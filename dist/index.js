var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// dist/build.js
var require_build = __commonJS({
  "dist/build.js"(exports, module) {
    "use strict";
    (function(root, factory2) {
      if (typeof define === "function" && define.amd) {
        define([], factory2);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory2();
      } else {
        root.mxgraph = factory2();
      }
    })(exports, function() {
      return function(opts) {
        for (var name in opts) {
          this[name] = opts[name];
        }
        var __mxOutput = {};
        var mxClient = {
          /**
           * Class: mxClient
           *
           * Bootstrapping mechanism for the mxGraph thin client. The production version
           * of this file contains all code required to run the mxGraph thin client, as
           * well as global constants to identify the browser and operating system in
           * use. You may have to load chrome://global/content/contentAreaUtils.js in
           * your page to disable certain security restrictions in Mozilla.
           * 
           * Variable: VERSION
           *
           * Contains the current version of the mxGraph library. The strings that
           * communicate versions of mxGraph use the following format.
           * 
           * versionMajor.versionMinor.buildNumber.revisionNumber
           * 
           * Current version is 4.2.2.
           */
          VERSION: "4.2.2",
          /**
           * Variable: IS_IE
           *
           * True if the current browser is Internet Explorer 10 or below. Use <mxClient.IS_IE11>
           * to detect IE 11.
           */
          IS_IE: navigator.userAgent != null && navigator.userAgent.indexOf("MSIE") >= 0,
          /**
           * Variable: IS_IE6
           *
           * True if the current browser is Internet Explorer 6.x.
           */
          IS_IE6: navigator.userAgent != null && navigator.userAgent.indexOf("MSIE 6") >= 0,
          /**
           * Variable: IS_IE11
           *
           * True if the current browser is Internet Explorer 11.x.
           */
          IS_IE11: navigator.userAgent != null && !!navigator.userAgent.match(/Trident\/7\./),
          /**
           * Variable: IS_EDGE
           *
           * True if the current browser is Microsoft Edge.
           */
          IS_EDGE: navigator.userAgent != null && !!navigator.userAgent.match(/Edge\//),
          /**
           * Variable: IS_QUIRKS
           *
           * True if the current browser is Internet Explorer and it is in quirks mode.
           */
          IS_QUIRKS: navigator.userAgent != null && navigator.userAgent.indexOf("MSIE") >= 0 && (document.documentMode == null || document.documentMode == 5),
          /**
           * Variable: IS_EM
           * 
           * True if the browser is IE11 in enterprise mode (IE8 standards mode).
           */
          IS_EM: "spellcheck" in document.createElement("textarea") && document.documentMode == 8,
          /**
           * Variable: VML_PREFIX
           * 
           * Prefix for VML namespace in node names. Default is 'v'.
           */
          VML_PREFIX: "v",
          /**
           * Variable: OFFICE_PREFIX
           * 
           * Prefix for VML office namespace in node names. Default is 'o'.
           */
          OFFICE_PREFIX: "o",
          /**
           * Variable: IS_NS
           *
           * True if the current browser is Netscape (including Firefox).
           */
          IS_NS: navigator.userAgent != null && navigator.userAgent.indexOf("Mozilla/") >= 0 && navigator.userAgent.indexOf("MSIE") < 0 && navigator.userAgent.indexOf("Edge/") < 0,
          /**
           * Variable: IS_OP
           *
           * True if the current browser is Opera.
           */
          IS_OP: navigator.userAgent != null && (navigator.userAgent.indexOf("Opera/") >= 0 || navigator.userAgent.indexOf("OPR/") >= 0),
          /**
           * Variable: IS_OT
           *
           * True if -o-transform is available as a CSS style, ie for Opera browsers
           * based on a Presto engine with version 2.5 or later.
           */
          IS_OT: navigator.userAgent != null && navigator.userAgent.indexOf("Presto/") >= 0 && navigator.userAgent.indexOf("Presto/2.4.") < 0 && navigator.userAgent.indexOf("Presto/2.3.") < 0 && navigator.userAgent.indexOf("Presto/2.2.") < 0 && navigator.userAgent.indexOf("Presto/2.1.") < 0 && navigator.userAgent.indexOf("Presto/2.0.") < 0 && navigator.userAgent.indexOf("Presto/1.") < 0,
          /**
           * Variable: IS_SF
           *
           * True if the current browser is Safari.
           */
          IS_SF: /Apple Computer, Inc/.test(navigator.vendor),
          /**
           * Variable: IS_ANDROID
           * 
           * Returns true if the user agent contains Android.
           */
          IS_ANDROID: navigator.appVersion.indexOf("Android") >= 0,
          /**
           * Variable: IS_IOS
           * 
           * Returns true if the user agent is an iPad, iPhone or iPod.
           */
          IS_IOS: /iP(hone|od|ad)/.test(navigator.platform),
          /**
           * Variable: IS_GC
           *
           * True if the current browser is Google Chrome.
           */
          IS_GC: /Google Inc/.test(navigator.vendor),
          /**
           * Variable: IS_CHROMEAPP
           *
           * True if the this is running inside a Chrome App.
           */
          IS_CHROMEAPP: window.chrome != null && chrome.app != null && chrome.app.runtime != null,
          /**
           * Variable: IS_FF
           *
           * True if the current browser is Firefox.
           */
          IS_FF: typeof InstallTrigger !== "undefined",
          /**
           * Variable: IS_MT
           *
           * True if -moz-transform is available as a CSS style. This is the case
           * for all Firefox-based browsers newer than or equal 3, such as Camino,
           * Iceweasel, Seamonkey and Iceape.
           */
          IS_MT: navigator.userAgent.indexOf("Firefox/") >= 0 && navigator.userAgent.indexOf("Firefox/1.") < 0 && navigator.userAgent.indexOf("Firefox/2.") < 0 || navigator.userAgent.indexOf("Iceweasel/") >= 0 && navigator.userAgent.indexOf("Iceweasel/1.") < 0 && navigator.userAgent.indexOf("Iceweasel/2.") < 0 || navigator.userAgent.indexOf("SeaMonkey/") >= 0 && navigator.userAgent.indexOf("SeaMonkey/1.") < 0 || navigator.userAgent.indexOf("Iceape/") >= 0 && navigator.userAgent.indexOf("Iceape/1.") < 0,
          /**
           * Variable: IS_VML
           *
           * True if the browser supports VML.
           */
          IS_VML: navigator.appName.toUpperCase() == "MICROSOFT INTERNET EXPLORER",
          /**
           * Variable: IS_SVG
           *
           * True if the browser supports SVG.
           */
          IS_SVG: navigator.appName.toUpperCase() != "MICROSOFT INTERNET EXPLORER",
          /**
           * Variable: NO_FO
           *
           * True if foreignObject support is not available. This is the case for
           * Opera, older SVG-based browsers and all versions of IE.
           */
          NO_FO: !document.createElementNS || document.createElementNS(
            "http://www.w3.org/2000/svg",
            "foreignObject"
          ) != "[object SVGForeignObjectElement]" || navigator.userAgent.indexOf("Opera/") >= 0,
          /**
           * Variable: IS_WIN
           *
           * True if the client is a Windows.
           */
          IS_WIN: navigator.appVersion.indexOf("Win") > 0,
          /**
           * Variable: IS_MAC
           *
           * True if the client is a Mac.
           */
          IS_MAC: navigator.appVersion.indexOf("Mac") > 0,
          /**
           * Variable: IS_CHROMEOS
           *
           * True if the client is a Chrome OS.
           */
          IS_CHROMEOS: /\bCrOS\b/.test(navigator.appVersion),
          /**
           * Variable: IS_TOUCH
           * 
           * True if this device supports touchstart/-move/-end events (Apple iOS,
           * Android, Chromebook and Chrome Browser on touch-enabled devices).
           */
          IS_TOUCH: "ontouchstart" in document.documentElement,
          /**
           * Variable: IS_POINTER
           * 
           * True if this device supports Microsoft pointer events (always false on Macs).
           */
          IS_POINTER: window.PointerEvent != null && !(navigator.appVersion.indexOf("Mac") > 0),
          /**
           * Variable: IS_LOCAL
           *
           * True if the documents location does not start with http:// or https://.
           */
          IS_LOCAL: document.location.href.indexOf("http://") < 0 && document.location.href.indexOf("https://") < 0,
          /**
           * Variable: defaultBundles
           * 
           * Contains the base names of the default bundles if mxLoadResources is false.
           */
          defaultBundles: [],
          /**
           * Function: isBrowserSupported
           *
           * Returns true if the current browser is supported, that is, if
           * <mxClient.IS_VML> or <mxClient.IS_SVG> is true.
           * 
           * Example:
           * 
           * (code)
           * if (!mxClient.isBrowserSupported())
           * {
           *   mxUtils.error('Browser is not supported!', 200, false);
           * }
           * (end)
           */
          isBrowserSupported: function() {
            return mxClient.IS_VML || mxClient.IS_SVG;
          },
          /**
           * Function: link
           *
           * Adds a link node to the head of the document. Use this
           * to add a stylesheet to the page as follows:
           *
           * (code)
           * mxClient.link('stylesheet', filename);
           * (end)
           *
           * where filename is the (relative) URL of the stylesheet. The charset
           * is hardcoded to ISO-8859-1 and the type is text/css.
           * 
           * Parameters:
           * 
           * rel - String that represents the rel attribute of the link node.
           * href - String that represents the href attribute of the link node.
           * doc - Optional parent document of the link node.
           * id - unique id for the link element to check if it already exists
           */
          link: function(rel, href, doc, id) {
            doc = doc || document;
            if (mxClient.IS_IE6) {
              doc.write('<link rel="' + rel + '" href="' + href + '" charset="UTF-8" type="text/css"/>');
            } else {
              var link = doc.createElement("link");
              link.setAttribute("rel", rel);
              link.setAttribute("href", href);
              link.setAttribute("charset", "UTF-8");
              link.setAttribute("type", "text/css");
              if (id) {
                link.setAttribute("id", id);
              }
              var head = doc.getElementsByTagName("head")[0];
              head.appendChild(link);
            }
          },
          /**
           * Function: loadResources
           * 
           * Helper method to load the default bundles if mxLoadResources is false.
           * 
           * Parameters:
           * 
           * fn - Function to call after all resources have been loaded.
           * lan - Optional string to pass to <mxResources.add>.
           */
          loadResources: function(fn, lan) {
            var pending = mxClient.defaultBundles.length;
            function callback() {
              if (--pending == 0) {
                fn();
              }
            }
            for (var i = 0; i < mxClient.defaultBundles.length; i++) {
              mxResources.add(mxClient.defaultBundles[i], lan, callback);
            }
          },
          /**
           * Function: include
           *
           * Dynamically adds a script node to the document header.
           * 
           * In production environments, the includes are resolved in the mxClient.js
           * file to reduce the number of requests required for client startup. This
           * function should only be used in development environments, but not in
           * production systems.
           */
          include: function(src) {
            document.write('<script src="' + src + '"><\/script>');
          }
        };
        if (typeof mxLoadResources == "undefined") {
          mxLoadResources = true;
        }
        if (typeof mxForceIncludes == "undefined") {
          mxForceIncludes = false;
        }
        if (typeof mxResourceExtension == "undefined") {
          mxResourceExtension = ".txt";
        }
        if (typeof mxLoadStylesheets == "undefined") {
          mxLoadStylesheets = true;
        }
        if (typeof mxBasePath != "undefined" && mxBasePath.length > 0) {
          if (mxBasePath.substring(mxBasePath.length - 1) == "/") {
            mxBasePath = mxBasePath.substring(0, mxBasePath.length - 1);
          }
          mxClient.basePath = mxBasePath;
        } else {
          mxClient.basePath = ".";
        }
        if (typeof mxImageBasePath != "undefined" && mxImageBasePath.length > 0) {
          if (mxImageBasePath.substring(mxImageBasePath.length - 1) == "/") {
            mxImageBasePath = mxImageBasePath.substring(0, mxImageBasePath.length - 1);
          }
          mxClient.imageBasePath = mxImageBasePath;
        } else {
          mxClient.imageBasePath = mxClient.basePath + "/images";
        }
        if (typeof mxLanguage != "undefined" && mxLanguage != null) {
          mxClient.language = mxLanguage;
        } else {
          mxClient.language = mxClient.IS_IE ? navigator.userLanguage : navigator.language;
        }
        if (typeof mxDefaultLanguage != "undefined" && mxDefaultLanguage != null) {
          mxClient.defaultLanguage = mxDefaultLanguage;
        } else {
          mxClient.defaultLanguage = "en";
        }
        if (mxLoadStylesheets) {
          mxClient.link("stylesheet", mxClient.basePath + "/css/common.css");
        }
        if (typeof mxLanguages != "undefined" && mxLanguages != null) {
          mxClient.languages = mxLanguages;
        }
        if (mxClient.IS_VML) {
          if (mxClient.IS_SVG) {
            mxClient.IS_VML = false;
          } else {
            if (document.namespaces != null) {
              if (document.documentMode == 8) {
                document.namespaces.add(mxClient.VML_PREFIX, "urn:schemas-microsoft-com:vml", "#default#VML");
                document.namespaces.add(mxClient.OFFICE_PREFIX, "urn:schemas-microsoft-com:office:office", "#default#VML");
              } else {
                document.namespaces.add(mxClient.VML_PREFIX, "urn:schemas-microsoft-com:vml");
                document.namespaces.add(mxClient.OFFICE_PREFIX, "urn:schemas-microsoft-com:office:office");
              }
            }
            if (mxClient.IS_QUIRKS && document.styleSheets.length >= 30) {
              (function() {
                var node = document.createElement("style");
                node.type = "text/css";
                node.styleSheet.cssText = mxClient.VML_PREFIX + "\\:*{behavior:url(#default#VML)}" + mxClient.OFFICE_PREFIX + "\\:*{behavior:url(#default#VML)}";
                document.getElementsByTagName("head")[0].appendChild(node);
              })();
            } else {
              document.createStyleSheet().cssText = mxClient.VML_PREFIX + "\\:*{behavior:url(#default#VML)}" + mxClient.OFFICE_PREFIX + "\\:*{behavior:url(#default#VML)}";
            }
            if (mxLoadStylesheets) {
              mxClient.link("stylesheet", mxClient.basePath + "/css/explorer.css");
            }
          }
        }
        if (mxForceIncludes) {
          mxClient.include(mxClient.basePath + "/js/util/mxLog.js");
          mxClient.include(mxClient.basePath + "/js/util/mxObjectIdentity.js");
          mxClient.include(mxClient.basePath + "/js/util/mxDictionary.js");
          mxClient.include(mxClient.basePath + "/js/util/mxResources.js");
          mxClient.include(mxClient.basePath + "/js/util/mxPoint.js");
          mxClient.include(mxClient.basePath + "/js/util/mxRectangle.js");
          mxClient.include(mxClient.basePath + "/js/util/mxEffects.js");
          mxClient.include(mxClient.basePath + "/js/util/mxUtils.js");
          mxClient.include(mxClient.basePath + "/js/util/mxConstants.js");
          mxClient.include(mxClient.basePath + "/js/util/mxEventObject.js");
          mxClient.include(mxClient.basePath + "/js/util/mxMouseEvent.js");
          mxClient.include(mxClient.basePath + "/js/util/mxEventSource.js");
          mxClient.include(mxClient.basePath + "/js/util/mxEvent.js");
          mxClient.include(mxClient.basePath + "/js/util/mxXmlRequest.js");
          mxClient.include(mxClient.basePath + "/js/util/mxClipboard.js");
          mxClient.include(mxClient.basePath + "/js/util/mxWindow.js");
          mxClient.include(mxClient.basePath + "/js/util/mxForm.js");
          mxClient.include(mxClient.basePath + "/js/util/mxImage.js");
          mxClient.include(mxClient.basePath + "/js/util/mxDivResizer.js");
          mxClient.include(mxClient.basePath + "/js/util/mxDragSource.js");
          mxClient.include(mxClient.basePath + "/js/util/mxToolbar.js");
          mxClient.include(mxClient.basePath + "/js/util/mxUndoableEdit.js");
          mxClient.include(mxClient.basePath + "/js/util/mxUndoManager.js");
          mxClient.include(mxClient.basePath + "/js/util/mxUrlConverter.js");
          mxClient.include(mxClient.basePath + "/js/util/mxPanningManager.js");
          mxClient.include(mxClient.basePath + "/js/util/mxPopupMenu.js");
          mxClient.include(mxClient.basePath + "/js/util/mxAutoSaveManager.js");
          mxClient.include(mxClient.basePath + "/js/util/mxAnimation.js");
          mxClient.include(mxClient.basePath + "/js/util/mxMorphing.js");
          mxClient.include(mxClient.basePath + "/js/util/mxImageBundle.js");
          mxClient.include(mxClient.basePath + "/js/util/mxImageExport.js");
          mxClient.include(mxClient.basePath + "/js/util/mxAbstractCanvas2D.js");
          mxClient.include(mxClient.basePath + "/js/util/mxXmlCanvas2D.js");
          mxClient.include(mxClient.basePath + "/js/util/mxSvgCanvas2D.js");
          mxClient.include(mxClient.basePath + "/js/util/mxVmlCanvas2D.js");
          mxClient.include(mxClient.basePath + "/js/util/mxGuide.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxShape.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxStencil.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxStencilRegistry.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxMarker.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxActor.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxCloud.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxRectangleShape.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxEllipse.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxDoubleEllipse.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxRhombus.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxPolyline.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxPolygon.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxArrow.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxArrowConnector.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxText.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxTriangle.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxHexagon.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxLine.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxImageShape.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxLabel.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxCylinder.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxConnector.js");
          mxClient.include(mxClient.basePath + "/js/shape/mxSwimlane.js");
          mxClient.include(mxClient.basePath + "/js/layout/mxGraphLayout.js");
          mxClient.include(mxClient.basePath + "/js/layout/mxStackLayout.js");
          mxClient.include(mxClient.basePath + "/js/layout/mxPartitionLayout.js");
          mxClient.include(mxClient.basePath + "/js/layout/mxCompactTreeLayout.js");
          mxClient.include(mxClient.basePath + "/js/layout/mxRadialTreeLayout.js");
          mxClient.include(mxClient.basePath + "/js/layout/mxFastOrganicLayout.js");
          mxClient.include(mxClient.basePath + "/js/layout/mxCircleLayout.js");
          mxClient.include(mxClient.basePath + "/js/layout/mxParallelEdgeLayout.js");
          mxClient.include(mxClient.basePath + "/js/layout/mxCompositeLayout.js");
          mxClient.include(mxClient.basePath + "/js/layout/mxEdgeLabelLayout.js");
          mxClient.include(mxClient.basePath + "/js/layout/hierarchical/model/mxGraphAbstractHierarchyCell.js");
          mxClient.include(mxClient.basePath + "/js/layout/hierarchical/model/mxGraphHierarchyNode.js");
          mxClient.include(mxClient.basePath + "/js/layout/hierarchical/model/mxGraphHierarchyEdge.js");
          mxClient.include(mxClient.basePath + "/js/layout/hierarchical/model/mxGraphHierarchyModel.js");
          mxClient.include(mxClient.basePath + "/js/layout/hierarchical/model/mxSwimlaneModel.js");
          mxClient.include(mxClient.basePath + "/js/layout/hierarchical/stage/mxHierarchicalLayoutStage.js");
          mxClient.include(mxClient.basePath + "/js/layout/hierarchical/stage/mxMedianHybridCrossingReduction.js");
          mxClient.include(mxClient.basePath + "/js/layout/hierarchical/stage/mxMinimumCycleRemover.js");
          mxClient.include(mxClient.basePath + "/js/layout/hierarchical/stage/mxCoordinateAssignment.js");
          mxClient.include(mxClient.basePath + "/js/layout/hierarchical/stage/mxSwimlaneOrdering.js");
          mxClient.include(mxClient.basePath + "/js/layout/hierarchical/mxHierarchicalLayout.js");
          mxClient.include(mxClient.basePath + "/js/layout/hierarchical/mxSwimlaneLayout.js");
          mxClient.include(mxClient.basePath + "/js/model/mxGraphModel.js");
          mxClient.include(mxClient.basePath + "/js/model/mxCell.js");
          mxClient.include(mxClient.basePath + "/js/model/mxGeometry.js");
          mxClient.include(mxClient.basePath + "/js/model/mxCellPath.js");
          mxClient.include(mxClient.basePath + "/js/view/mxPerimeter.js");
          mxClient.include(mxClient.basePath + "/js/view/mxPrintPreview.js");
          mxClient.include(mxClient.basePath + "/js/view/mxStylesheet.js");
          mxClient.include(mxClient.basePath + "/js/view/mxCellState.js");
          mxClient.include(mxClient.basePath + "/js/view/mxGraphSelectionModel.js");
          mxClient.include(mxClient.basePath + "/js/view/mxCellEditor.js");
          mxClient.include(mxClient.basePath + "/js/view/mxCellRenderer.js");
          mxClient.include(mxClient.basePath + "/js/view/mxEdgeStyle.js");
          mxClient.include(mxClient.basePath + "/js/view/mxStyleRegistry.js");
          mxClient.include(mxClient.basePath + "/js/view/mxGraphView.js");
          mxClient.include(mxClient.basePath + "/js/view/mxGraph.js");
          mxClient.include(mxClient.basePath + "/js/azdata/view/azDataGraph.js");
          mxClient.include(mxClient.basePath + "/js/view/mxCellOverlay.js");
          mxClient.include(mxClient.basePath + "/js/view/mxOutline.js");
          mxClient.include(mxClient.basePath + "/js/view/mxMultiplicity.js");
          mxClient.include(mxClient.basePath + "/js/view/mxLayoutManager.js");
          mxClient.include(mxClient.basePath + "/js/view/mxSwimlaneManager.js");
          mxClient.include(mxClient.basePath + "/js/view/mxTemporaryCellStates.js");
          mxClient.include(mxClient.basePath + "/js/view/mxCellStatePreview.js");
          mxClient.include(mxClient.basePath + "/js/view/mxConnectionConstraint.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxGraphHandler.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxPanningHandler.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxPopupMenuHandler.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxCellMarker.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxSelectionCellsHandler.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxConnectionHandler.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxConstraintHandler.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxRubberband.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxHandle.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxVertexHandler.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxEdgeHandler.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxElbowEdgeHandler.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxEdgeSegmentHandler.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxKeyHandler.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxTooltipHandler.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxCellTracker.js");
          mxClient.include(mxClient.basePath + "/js/handler/mxCellHighlight.js");
          mxClient.include(mxClient.basePath + "/js/editor/mxDefaultKeyHandler.js");
          mxClient.include(mxClient.basePath + "/js/editor/mxDefaultPopupMenu.js");
          mxClient.include(mxClient.basePath + "/js/editor/mxDefaultToolbar.js");
          mxClient.include(mxClient.basePath + "/js/editor/mxEditor.js");
          mxClient.include(mxClient.basePath + "/js/io/mxCodecRegistry.js");
          mxClient.include(mxClient.basePath + "/js/io/mxCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxObjectCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxCellCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxModelCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxRootChangeCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxChildChangeCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxTerminalChangeCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxGenericChangeCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxGraphCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxGraphViewCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxStylesheetCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxDefaultKeyHandlerCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxDefaultToolbarCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxDefaultPopupMenuCodec.js");
          mxClient.include(mxClient.basePath + "/js/io/mxEditorCodec.js");
          mxClient.include(mxClient.basePath + "/js/azdata/azdataQueryPlan.js");
        }
        __mxOutput.mxClient = typeof mxClient !== "undefined" ? mxClient : void 0;
        var mxLog = {
          /**
           * Class: mxLog
           * 
           * A singleton class that implements a simple console.
           * 
           * Variable: consoleName
           * 
           * Specifies the name of the console window. Default is 'Console'.
           */
          consoleName: "Console",
          /**
           * Variable: TRACE
           * 
           * Specified if the output for <enter> and <leave> should be visible in the
           * console. Default is false.
           */
          TRACE: false,
          /**
           * Variable: DEBUG
           * 
           * Specifies if the output for <debug> should be visible in the console.
           * Default is true.
           */
          DEBUG: true,
          /**
           * Variable: WARN
           * 
           * Specifies if the output for <warn> should be visible in the console.
           * Default is true.
           */
          WARN: true,
          /**
           * Variable: buffer
           * 
           * Buffer for pre-initialized content.
           */
          buffer: "",
          /**
           * Function: init
           *
           * Initializes the DOM node for the console. This requires document.body to
           * point to a non-null value. This is called from within <setVisible> if the
           * log has not yet been initialized.
           */
          init: function() {
            if (mxLog.window == null && document.body != null) {
              var title = mxLog.consoleName + " - mxGraph " + mxClient.VERSION;
              var table = document.createElement("table");
              table.setAttribute("width", "100%");
              table.setAttribute("height", "100%");
              var tbody = document.createElement("tbody");
              var tr = document.createElement("tr");
              var td2 = document.createElement("td");
              td2.style.verticalAlign = "top";
              mxLog.textarea = document.createElement("textarea");
              mxLog.textarea.setAttribute("wrap", "off");
              mxLog.textarea.setAttribute("readOnly", "true");
              mxLog.textarea.style.height = "100%";
              mxLog.textarea.style.resize = "none";
              mxLog.textarea.value = mxLog.buffer;
              if (mxClient.IS_NS && document.compatMode != "BackCompat") {
                mxLog.textarea.style.width = "99%";
              } else {
                mxLog.textarea.style.width = "100%";
              }
              td2.appendChild(mxLog.textarea);
              tr.appendChild(td2);
              tbody.appendChild(tr);
              tr = document.createElement("tr");
              mxLog.td = document.createElement("td");
              mxLog.td.style.verticalAlign = "top";
              mxLog.td.setAttribute("height", "30px");
              tr.appendChild(mxLog.td);
              tbody.appendChild(tr);
              table.appendChild(tbody);
              mxLog.addButton("Info", function(evt) {
                mxLog.info();
              });
              mxLog.addButton("DOM", function(evt) {
                var content = mxUtils.getInnerHtml(document.body);
                mxLog.debug(content);
              });
              mxLog.addButton("Trace", function(evt) {
                mxLog.TRACE = !mxLog.TRACE;
                if (mxLog.TRACE) {
                  mxLog.debug("Tracing enabled");
                } else {
                  mxLog.debug("Tracing disabled");
                }
              });
              mxLog.addButton("Copy", function(evt) {
                try {
                  mxUtils.copy(mxLog.textarea.value);
                } catch (err) {
                  mxUtils.alert(err);
                }
              });
              mxLog.addButton("Show", function(evt) {
                try {
                  mxUtils.popup(mxLog.textarea.value);
                } catch (err) {
                  mxUtils.alert(err);
                }
              });
              mxLog.addButton("Clear", function(evt) {
                mxLog.textarea.value = "";
              });
              var h2 = 0;
              var w2 = 0;
              if (typeof window.innerWidth === "number") {
                h2 = window.innerHeight;
                w2 = window.innerWidth;
              } else {
                h2 = document.documentElement.clientHeight || document.body.clientHeight;
                w2 = document.body.clientWidth;
              }
              mxLog.window = new mxWindow(title, table, Math.max(0, w2 - 320), Math.max(0, h2 - 210), 300, 160);
              mxLog.window.setMaximizable(true);
              mxLog.window.setScrollable(false);
              mxLog.window.setResizable(true);
              mxLog.window.setClosable(true);
              mxLog.window.destroyOnClose = false;
              if ((mxClient.IS_NS || mxClient.IS_IE) && !mxClient.IS_GC && !mxClient.IS_SF && document.compatMode != "BackCompat" || document.documentMode == 11) {
                var elt = mxLog.window.getElement();
                var resizeHandler = function(sender, evt) {
                  mxLog.textarea.style.height = Math.max(0, elt.offsetHeight - 70) + "px";
                };
                mxLog.window.addListener(mxEvent.RESIZE_END, resizeHandler);
                mxLog.window.addListener(mxEvent.MAXIMIZE, resizeHandler);
                mxLog.window.addListener(mxEvent.NORMALIZE, resizeHandler);
                mxLog.textarea.style.height = "92px";
              }
            }
          },
          /**
           * Function: info
           * 
           * Writes the current navigator information to the console.
           */
          info: function() {
            mxLog.writeln(mxUtils.toString(navigator));
          },
          /**
           * Function: addButton
           * 
           * Adds a button to the console using the given label and function.
           */
          addButton: function(lab, funct) {
            var button = document.createElement("button");
            mxUtils.write(button, lab);
            mxEvent.addListener(button, "click", funct);
            mxLog.td.appendChild(button);
          },
          /**
           * Function: isVisible
           * 
           * Returns true if the console is visible.
           */
          isVisible: function() {
            if (mxLog.window != null) {
              return mxLog.window.isVisible();
            }
            return false;
          },
          /**
           * Function: show
           * 
           * Shows the console.
           */
          show: function() {
            mxLog.setVisible(true);
          },
          /**
           * Function: setVisible
           * 
           * Shows or hides the console.
           */
          setVisible: function(visible) {
            if (mxLog.window == null) {
              mxLog.init();
            }
            if (mxLog.window != null) {
              mxLog.window.setVisible(visible);
            }
          },
          /**
           * Function: enter
           * 
           * Writes the specified string to the console
           * if <TRACE> is true and returns the current 
           * time in milliseconds.
           *
           * Example:
           * 
           * (code)
           * mxLog.show();
           * var t0 = mxLog.enter('Hello');
           * // Do something
           * mxLog.leave('World!', t0);
           * (end)
           */
          enter: function(string) {
            if (mxLog.TRACE) {
              mxLog.writeln("Entering " + string);
              return (/* @__PURE__ */ new Date()).getTime();
            }
          },
          /**
           * Function: leave
           * 
           * Writes the specified string to the console
           * if <TRACE> is true and computes the difference
           * between the current time and t0 in milliseconds.
           * See <enter> for an example.
           */
          leave: function(string, t0) {
            if (mxLog.TRACE) {
              var dt = t0 != 0 ? " (" + ((/* @__PURE__ */ new Date()).getTime() - t0) + " ms)" : "";
              mxLog.writeln("Leaving " + string + dt);
            }
          },
          /**
           * Function: debug
           * 
           * Adds all arguments to the console if <DEBUG> is enabled.
           *
           * Example:
           * 
           * (code)
           * mxLog.show();
           * mxLog.debug('Hello, World!');
           * (end)
           */
          debug: function() {
            if (mxLog.DEBUG) {
              mxLog.writeln.apply(this, arguments);
            }
          },
          /**
           * Function: warn
           * 
           * Adds all arguments to the console if <WARN> is enabled.
           *
           * Example:
           * 
           * (code)
           * mxLog.show();
           * mxLog.warn('Hello, World!');
           * (end)
           */
          warn: function() {
            if (mxLog.WARN) {
              mxLog.writeln.apply(this, arguments);
            }
          },
          /**
           * Function: write
           * 
           * Adds the specified strings to the console.
           */
          write: function() {
            var string = "";
            for (var i = 0; i < arguments.length; i++) {
              string += arguments[i];
              if (i < arguments.length - 1) {
                string += " ";
              }
            }
            if (mxLog.textarea != null) {
              mxLog.textarea.value = mxLog.textarea.value + string;
              if (navigator.userAgent != null && navigator.userAgent.indexOf("Presto/2.5") >= 0) {
                mxLog.textarea.style.visibility = "hidden";
                mxLog.textarea.style.visibility = "visible";
              }
              mxLog.textarea.scrollTop = mxLog.textarea.scrollHeight;
            } else {
              mxLog.buffer += string;
            }
          },
          /**
           * Function: writeln
           * 
           * Adds the specified strings to the console, appending a linefeed at the
           * end of each string.
           */
          writeln: function() {
            var string = "";
            for (var i = 0; i < arguments.length; i++) {
              string += arguments[i];
              if (i < arguments.length - 1) {
                string += " ";
              }
            }
            mxLog.write(string + "\n");
          }
        };
        __mxOutput.mxLog = typeof mxLog !== "undefined" ? mxLog : void 0;
        var mxObjectIdentity = {
          /**
           * Class: mxObjectIdentity
           * 
           * Identity for JavaScript objects and functions. This is implemented using
           * a simple incrementing counter which is stored in each object under
           * <FIELD_NAME>.
           * 
           * The identity for an object does not change during its lifecycle.
           * 
           * Variable: FIELD_NAME
           * 
           * Name of the field to be used to store the object ID. Default is
           * <code>mxObjectId</code>.
           */
          FIELD_NAME: "mxObjectId",
          /**
           * Variable: counter
           * 
           * Current counter.
           */
          counter: 0,
          /**
           * Function: get
           * 
           * Returns the ID for the given object or function or null if no object
           * is specified.
           */
          get: function(obj) {
            if (obj != null) {
              if (obj[mxObjectIdentity.FIELD_NAME] == null) {
                if (typeof obj === "object") {
                  var ctor = mxUtils.getFunctionName(obj.constructor);
                  obj[mxObjectIdentity.FIELD_NAME] = ctor + "#" + mxObjectIdentity.counter++;
                } else if (typeof obj === "function") {
                  obj[mxObjectIdentity.FIELD_NAME] = "Function#" + mxObjectIdentity.counter++;
                }
              }
              return obj[mxObjectIdentity.FIELD_NAME];
            }
            return null;
          },
          /**
           * Function: clear
           * 
           * Deletes the ID from the given object or function.
           */
          clear: function(obj) {
            if (typeof obj === "object" || typeof obj === "function") {
              delete obj[mxObjectIdentity.FIELD_NAME];
            }
          }
        };
        __mxOutput.mxObjectIdentity = typeof mxObjectIdentity !== "undefined" ? mxObjectIdentity : void 0;
        function mxDictionary() {
          this.clear();
        }
        ;
        mxDictionary.prototype.map = null;
        mxDictionary.prototype.clear = function() {
          this.map = {};
        };
        mxDictionary.prototype.get = function(key) {
          var id = mxObjectIdentity.get(key);
          return this.map[id];
        };
        mxDictionary.prototype.put = function(key, value) {
          var id = mxObjectIdentity.get(key);
          var previous = this.map[id];
          this.map[id] = value;
          return previous;
        };
        mxDictionary.prototype.remove = function(key) {
          var id = mxObjectIdentity.get(key);
          var previous = this.map[id];
          delete this.map[id];
          return previous;
        };
        mxDictionary.prototype.getKeys = function() {
          var result2 = [];
          for (var key in this.map) {
            result2.push(key);
          }
          return result2;
        };
        mxDictionary.prototype.getValues = function() {
          var result2 = [];
          for (var key in this.map) {
            result2.push(this.map[key]);
          }
          return result2;
        };
        mxDictionary.prototype.visit = function(visitor) {
          for (var key in this.map) {
            visitor(key, this.map[key]);
          }
        };
        __mxOutput.mxDictionary = typeof mxDictionary !== "undefined" ? mxDictionary : void 0;
        var mxResources = {
          /**
           * Class: mxResources
           * 
           * Implements internationalization. You can provide any number of 
           * resource files on the server using the following format for the 
           * filename: name[-en].properties. The en stands for any lowercase 
           * 2-character language shortcut (eg. de for german, fr for french).
           *
           * If the optional language extension is omitted, then the file is used as a 
           * default resource which is loaded in all cases. If a properties file for a 
           * specific language exists, then it is used to override the settings in the 
           * default resource. All entries in the file are of the form key=value. The
           * values may then be accessed in code via <get>. Lines without 
           * equal signs in the properties files are ignored.
           *
           * Resource files may either be added programmatically using
           * <add> or via a resource tag in the UI section of the 
           * editor configuration file, eg:
           * 
           * (code)
           * <mxEditor>
           *   <ui>
           *     <resource basename="examples/resources/mxWorkflow"/>
           * (end)
           * 
           * The above element will load examples/resources/mxWorkflow.properties as well
           * as the language specific file for the current language, if it exists.
           * 
           * Values may contain placeholders of the form {1}...{n} where each placeholder
           * is replaced with the value of the corresponding array element in the params
           * argument passed to <mxResources.get>. The placeholder {1} maps to the first
           * element in the array (at index 0).
           * 
           * See <mxClient.language> for more information on specifying the default
           * language or disabling all loading of resources.
           * 
           * Lines that start with a # sign will be ignored.
           * 
           * Special characters
           * 
           * To use unicode characters, use the standard notation (eg. \u8fd1) or %u as a
           * prefix (eg. %u20AC will display a Euro sign). For normal hex encoded strings,
           * use % as a prefix, eg. %F6 will display a "o umlaut" (&ouml;).
           * 
           * See <resourcesEncoded> to disable this. If you disable this, make sure that
           * your files are UTF-8 encoded.
           * 
           * Asynchronous loading
           * 
           * By default, the core adds two resource files synchronously at load time.
           * To load these files asynchronously, set <mxLoadResources> to false
           * before loading mxClient.js and use <mxResources.loadResources> instead.
           * 
           * Variable: resources
           * 
           * Object that maps from keys to values.
           */
          resources: {},
          /**
           * Variable: extension
           * 
           * Specifies the extension used for language files. Default is <mxResourceExtension>.
           */
          extension: mxResourceExtension,
          /**
           * Variable: resourcesEncoded
           * 
           * Specifies whether or not values in resource files are encoded with \u or
           * percentage. Default is false.
           */
          resourcesEncoded: false,
          /**
           * Variable: loadDefaultBundle
           * 
           * Specifies if the default file for a given basename should be loaded.
           * Default is true.
           */
          loadDefaultBundle: true,
          /**
           * Variable: loadDefaultBundle
           * 
           * Specifies if the specific language file file for a given basename should
           * be loaded. Default is true.
           */
          loadSpecialBundle: true,
          /**
           * Function: isLanguageSupported
           * 
           * Hook for subclassers to disable support for a given language. This
           * implementation returns true if lan is in <mxClient.languages>.
           * 
           * Parameters:
           *
           * lan - The current language.
           */
          isLanguageSupported: function(lan) {
            if (mxClient.languages != null) {
              return mxUtils.indexOf(mxClient.languages, lan) >= 0;
            }
            return true;
          },
          /**
           * Function: getDefaultBundle
           * 
           * Hook for subclassers to return the URL for the special bundle. This
           * implementation returns basename + <extension> or null if
           * <loadDefaultBundle> is false.
           * 
           * Parameters:
           * 
           * basename - The basename for which the file should be loaded.
           * lan - The current language.
           */
          getDefaultBundle: function(basename, lan) {
            if (mxResources.loadDefaultBundle || !mxResources.isLanguageSupported(lan)) {
              return basename + mxResources.extension;
            } else {
              return null;
            }
          },
          /**
           * Function: getSpecialBundle
           * 
           * Hook for subclassers to return the URL for the special bundle. This
           * implementation returns basename + '_' + lan + <extension> or null if
           * <loadSpecialBundle> is false or lan equals <mxClient.defaultLanguage>.
           * 
           * If <mxResources.languages> is not null and <mxClient.language> contains
           * a dash, then this method checks if <isLanguageSupported> returns true
           * for the full language (including the dash). If that returns false the
           * first part of the language (up to the dash) will be tried as an extension.
           * 
           * If <mxResources.language> is null then the first part of the language is
           * used to maintain backwards compatibility.
           * 
           * Parameters:
           * 
           * basename - The basename for which the file should be loaded.
           * lan - The language for which the file should be loaded.
           */
          getSpecialBundle: function(basename, lan) {
            if (mxClient.languages == null || !this.isLanguageSupported(lan)) {
              var dash = lan.indexOf("-");
              if (dash > 0) {
                lan = lan.substring(0, dash);
              }
            }
            if (mxResources.loadSpecialBundle && mxResources.isLanguageSupported(lan) && lan != mxClient.defaultLanguage) {
              return basename + "_" + lan + mxResources.extension;
            } else {
              return null;
            }
          },
          /**
           * Function: add
           * 
           * Adds the default and current language properties file for the specified
           * basename. Existing keys are overridden as new files are added. If no
           * callback is used then the request is synchronous.
           *
           * Example:
           * 
           * At application startup, additional resources may be 
           * added using the following code:
           * 
           * (code)
           * mxResources.add('resources/editor');
           * (end)
           * 
           * Parameters:
           * 
           * basename - The basename for which the file should be loaded.
           * lan - The language for which the file should be loaded.
           * callback - Optional callback for asynchronous loading.
           */
          add: function(basename, lan, callback) {
            lan = lan != null ? lan : mxClient.language != null ? mxClient.language.toLowerCase() : mxConstants.NONE;
            if (lan != mxConstants.NONE) {
              var defaultBundle = mxResources.getDefaultBundle(basename, lan);
              var specialBundle = mxResources.getSpecialBundle(basename, lan);
              var loadSpecialBundle = function() {
                if (specialBundle != null) {
                  if (callback) {
                    mxUtils.get(specialBundle, function(req3) {
                      mxResources.parse(req3.getText());
                      callback();
                    }, function() {
                      callback();
                    });
                  } else {
                    try {
                      var req2 = mxUtils.load(specialBundle);
                      if (req2.isReady()) {
                        mxResources.parse(req2.getText());
                      }
                    } catch (e) {
                    }
                  }
                } else if (callback != null) {
                  callback();
                }
              };
              if (defaultBundle != null) {
                if (callback) {
                  mxUtils.get(defaultBundle, function(req2) {
                    mxResources.parse(req2.getText());
                    loadSpecialBundle();
                  }, function() {
                    loadSpecialBundle();
                  });
                } else {
                  try {
                    var req = mxUtils.load(defaultBundle);
                    if (req.isReady()) {
                      mxResources.parse(req.getText());
                    }
                    loadSpecialBundle();
                  } catch (e) {
                  }
                }
              } else {
                loadSpecialBundle();
              }
            }
          },
          /**
           * Function: parse
           * 
           * Parses the key, value pairs in the specified
           * text and stores them as local resources.
           */
          parse: function(text) {
            if (text != null) {
              var lines = text.split("\n");
              for (var i = 0; i < lines.length; i++) {
                if (lines[i].charAt(0) != "#") {
                  var index = lines[i].indexOf("=");
                  if (index > 0) {
                    var key = lines[i].substring(0, index);
                    var idx = lines[i].length;
                    if (lines[i].charCodeAt(idx - 1) == 13) {
                      idx--;
                    }
                    var value = lines[i].substring(index + 1, idx);
                    if (this.resourcesEncoded) {
                      value = value.replace(/\\(?=u[a-fA-F\d]{4})/g, "%");
                      mxResources.resources[key] = unescape(value);
                    } else {
                      mxResources.resources[key] = value;
                    }
                  }
                }
              }
            }
          },
          /**
           * Function: get
           * 
           * Returns the value for the specified resource key.
           *
           * Example:
           * To read the value for 'welomeMessage', use the following:
           * (code)
           * var result = mxResources.get('welcomeMessage') || '';
           * (end)
           *
           * This would require an entry of the following form in
           * one of the English language resource files:
           * (code)
           * welcomeMessage=Welcome to mxGraph!
           * (end)
           * 
           * The part behind the || is the string value to be used if the given
           * resource is not available.
           * 
           * Parameters:
           * 
           * key - String that represents the key of the resource to be returned.
           * params - Array of the values for the placeholders of the form {1}...{n}
           * to be replaced with in the resulting string.
           * defaultValue - Optional string that specifies the default return value.
           */
          get: function(key, params, defaultValue) {
            var value = mxResources.resources[key];
            if (value == null) {
              value = defaultValue;
            }
            if (value != null && params != null) {
              value = mxResources.replacePlaceholders(value, params);
            }
            return value;
          },
          /**
           * Function: replacePlaceholders
           * 
           * Replaces the given placeholders with the given parameters.
           * 
           * Parameters:
           * 
           * value - String that contains the placeholders.
           * params - Array of the values for the placeholders of the form {1}...{n}
           * to be replaced with in the resulting string.
           */
          replacePlaceholders: function(value, params) {
            var result2 = [];
            var index = null;
            for (var i = 0; i < value.length; i++) {
              var c = value.charAt(i);
              if (c == "{") {
                index = "";
              } else if (index != null && c == "}") {
                index = parseInt(index) - 1;
                if (index >= 0 && index < params.length) {
                  result2.push(params[index]);
                }
                index = null;
              } else if (index != null) {
                index += c;
              } else {
                result2.push(c);
              }
            }
            return result2.join("");
          },
          /**
           * Function: loadResources
           * 
           * Loads all required resources asynchronously. Use this to load the graph and
           * editor resources if <mxLoadResources> is false.
           * 
           * Parameters:
           * 
           * callback - Callback function for asynchronous loading.
           */
          loadResources: function(callback) {
            mxResources.add(mxClient.basePath + "/resources/editor", null, function() {
              mxResources.add(mxClient.basePath + "/resources/graph", null, callback);
            });
          }
        };
        __mxOutput.mxResources = typeof mxResources !== "undefined" ? mxResources : void 0;
        function mxPoint(x, y) {
          this.x = x != null ? x : 0;
          this.y = y != null ? y : 0;
        }
        ;
        mxPoint.prototype.x = null;
        mxPoint.prototype.y = null;
        mxPoint.prototype.equals = function(obj) {
          return obj != null && obj.x == this.x && obj.y == this.y;
        };
        mxPoint.prototype.clone = function() {
          return mxUtils.clone(this);
        };
        __mxOutput.mxPoint = typeof mxPoint !== "undefined" ? mxPoint : void 0;
        function mxRectangle(x, y, width, height) {
          mxPoint.call(this, x, y);
          this.width = width != null ? width : 0;
          this.height = height != null ? height : 0;
        }
        ;
        mxRectangle.prototype = new mxPoint();
        mxRectangle.prototype.constructor = mxRectangle;
        mxRectangle.prototype.width = null;
        mxRectangle.prototype.height = null;
        mxRectangle.prototype.setRect = function(x, y, w2, h2) {
          this.x = x;
          this.y = y;
          this.width = w2;
          this.height = h2;
        };
        mxRectangle.prototype.getCenterX = function() {
          return this.x + this.width / 2;
        };
        mxRectangle.prototype.getCenterY = function() {
          return this.y + this.height / 2;
        };
        mxRectangle.prototype.add = function(rect) {
          if (rect != null) {
            var minX = Math.min(this.x, rect.x);
            var minY = Math.min(this.y, rect.y);
            var maxX = Math.max(this.x + this.width, rect.x + rect.width);
            var maxY = Math.max(this.y + this.height, rect.y + rect.height);
            this.x = minX;
            this.y = minY;
            this.width = maxX - minX;
            this.height = maxY - minY;
          }
        };
        mxRectangle.prototype.intersect = function(rect) {
          if (rect != null) {
            var r1 = this.x + this.width;
            var r2 = rect.x + rect.width;
            var b1 = this.y + this.height;
            var b2 = rect.y + rect.height;
            this.x = Math.max(this.x, rect.x);
            this.y = Math.max(this.y, rect.y);
            this.width = Math.min(r1, r2) - this.x;
            this.height = Math.min(b1, b2) - this.y;
          }
        };
        mxRectangle.prototype.grow = function(amount) {
          this.x -= amount;
          this.y -= amount;
          this.width += 2 * amount;
          this.height += 2 * amount;
          return this;
        };
        mxRectangle.prototype.getPoint = function() {
          return new mxPoint(this.x, this.y);
        };
        mxRectangle.prototype.rotate90 = function() {
          var t = (this.width - this.height) / 2;
          this.x += t;
          this.y -= t;
          var tmp = this.width;
          this.width = this.height;
          this.height = tmp;
        };
        mxRectangle.prototype.equals = function(obj) {
          return obj != null && obj.x == this.x && obj.y == this.y && obj.width == this.width && obj.height == this.height;
        };
        mxRectangle.fromRectangle = function(rect) {
          return new mxRectangle(rect.x, rect.y, rect.width, rect.height);
        };
        __mxOutput.mxRectangle = typeof mxRectangle !== "undefined" ? mxRectangle : void 0;
        var mxEffects = {
          /**
           * Class: mxEffects
           * 
           * Provides animation effects.
           */
          /**
           * Function: animateChanges
           * 
           * Asynchronous animated move operation. See also: <mxMorphing>.
           * 
           * Example:
           * 
           * (code)
           * graph.model.addListener(mxEvent.CHANGE, function(sender, evt)
           * {
           *   var changes = evt.getProperty('edit').changes;
           * 
           *   if (changes.length < 10)
           *   {
           *     mxEffects.animateChanges(graph, changes);
           *   }
           * });
           * (end)
           * 
           * Parameters:
           * 
           * graph - <mxGraph> that received the changes.
           * changes - Array of changes to be animated.
           * done - Optional function argument that is invoked after the
           * last step of the animation.
           */
          animateChanges: function(graph, changes, done) {
            var maxStep = 10;
            var step = 0;
            var animate = function() {
              var isRequired = false;
              for (var i = 0; i < changes.length; i++) {
                var change = changes[i];
                if (change instanceof mxGeometryChange || change instanceof mxTerminalChange || change instanceof mxValueChange || change instanceof mxChildChange || change instanceof mxStyleChange) {
                  var state = graph.getView().getState(change.cell || change.child, false);
                  if (state != null) {
                    isRequired = true;
                    if (change.constructor != mxGeometryChange || graph.model.isEdge(change.cell)) {
                      mxUtils.setOpacity(state.shape.node, 100 * step / maxStep);
                    } else {
                      var scale = graph.getView().scale;
                      var dx = (change.geometry.x - change.previous.x) * scale;
                      var dy = (change.geometry.y - change.previous.y) * scale;
                      var sx = (change.geometry.width - change.previous.width) * scale;
                      var sy = (change.geometry.height - change.previous.height) * scale;
                      if (step == 0) {
                        state.x -= dx;
                        state.y -= dy;
                        state.width -= sx;
                        state.height -= sy;
                      } else {
                        state.x += dx / maxStep;
                        state.y += dy / maxStep;
                        state.width += sx / maxStep;
                        state.height += sy / maxStep;
                      }
                      graph.cellRenderer.redraw(state);
                      mxEffects.cascadeOpacity(graph, change.cell, 100 * step / maxStep);
                    }
                  }
                }
              }
              if (step < maxStep && isRequired) {
                step++;
                window.setTimeout(animate, delay);
              } else if (done != null) {
                done();
              }
            };
            var delay = 30;
            animate();
          },
          /**
           * Function: cascadeOpacity
           * 
           * Sets the opacity on the given cell and its descendants.
           * 
           * Parameters:
           * 
           * graph - <mxGraph> that contains the cells.
           * cell - <mxCell> to set the opacity for.
           * opacity - New value for the opacity in %.
           */
          cascadeOpacity: function(graph, cell2, opacity) {
            var childCount = graph.model.getChildCount(cell2);
            for (var i = 0; i < childCount; i++) {
              var child = graph.model.getChildAt(cell2, i);
              var childState = graph.getView().getState(child);
              if (childState != null) {
                mxUtils.setOpacity(childState.shape.node, opacity);
                mxEffects.cascadeOpacity(graph, child, opacity);
              }
            }
            var edges = graph.model.getEdges(cell2);
            if (edges != null) {
              for (var i = 0; i < edges.length; i++) {
                var edgeState = graph.getView().getState(edges[i]);
                if (edgeState != null) {
                  mxUtils.setOpacity(edgeState.shape.node, opacity);
                }
              }
            }
          },
          /**
           * Function: fadeOut
           * 
           * Asynchronous fade-out operation.
           */
          fadeOut: function(node, from, remove, step, delay, isEnabled) {
            step = step || 40;
            delay = delay || 30;
            var opacity = from || 100;
            mxUtils.setOpacity(node, opacity);
            if (isEnabled || isEnabled == null) {
              var f = function() {
                opacity = Math.max(opacity - step, 0);
                mxUtils.setOpacity(node, opacity);
                if (opacity > 0) {
                  window.setTimeout(f, delay);
                } else {
                  node.style.visibility = "hidden";
                  if (remove && node.parentNode) {
                    node.parentNode.removeChild(node);
                  }
                }
              };
              window.setTimeout(f, delay);
            } else {
              node.style.visibility = "hidden";
              if (remove && node.parentNode) {
                node.parentNode.removeChild(node);
              }
            }
          }
        };
        __mxOutput.mxEffects = typeof mxEffects !== "undefined" ? mxEffects : void 0;
        var mxUtils = {
          /**
           * Class: mxUtils
           * 
           * A singleton class that provides cross-browser helper methods.
           * This is a global functionality. To access the functions in this
           * class, use the global classname appended by the functionname.
           * You may have to load chrome://global/content/contentAreaUtils.js
           * to disable certain security restrictions in Mozilla for the <open>,
           * <save>, <saveAs> and <copy> function.
           * 
           * For example, the following code displays an error message:
           * 
           * (code)
           * mxUtils.error('Browser is not supported!', 200, false);
           * (end)
           * 
           * Variable: errorResource
           * 
           * Specifies the resource key for the title of the error window. If the
           * resource for this key does not exist then the value is used as
           * the title. Default is 'error'.
           */
          errorResource: mxClient.language != "none" ? "error" : "",
          /**
           * Variable: closeResource
           * 
           * Specifies the resource key for the label of the close button. If the
           * resource for this key does not exist then the value is used as
           * the label. Default is 'close'.
           */
          closeResource: mxClient.language != "none" ? "close" : "",
          /**
           * Variable: errorImage
           * 
           * Defines the image used for error dialogs.
           */
          errorImage: mxClient.imageBasePath + "/error.gif",
          /**
           * Function: removeCursors
           * 
           * Removes the cursors from the style of the given DOM node and its
           * descendants.
           * 
           * Parameters:
           * 
           * element - DOM node to remove the cursor style from.
           */
          removeCursors: function(element) {
            if (element.style != null) {
              element.style.cursor = "";
            }
            var children = element.childNodes;
            if (children != null) {
              var childCount = children.length;
              for (var i = 0; i < childCount; i += 1) {
                mxUtils.removeCursors(children[i]);
              }
            }
          },
          /**
           * Function: getCurrentStyle
           * 
           * Returns the current style of the specified element.
           * 
           * Parameters:
           * 
           * element - DOM node whose current style should be returned.
           */
          getCurrentStyle: function() {
            if (mxClient.IS_IE && (document.documentMode == null || document.documentMode < 9)) {
              return function(element) {
                return element != null ? element.currentStyle : null;
              };
            } else {
              return function(element) {
                return element != null ? window.getComputedStyle(element, "") : null;
              };
            }
          }(),
          /**
           * Function: parseCssNumber
           * 
           * Parses the given CSS numeric value adding handling for the values thin,
           * medium and thick (2, 4 and 6).
           */
          parseCssNumber: function(value) {
            if (value == "thin") {
              value = "2";
            } else if (value == "medium") {
              value = "4";
            } else if (value == "thick") {
              value = "6";
            }
            value = parseFloat(value);
            if (isNaN(value)) {
              value = 0;
            }
            return value;
          },
          /**
           * Function: setPrefixedStyle
           * 
           * Adds the given style with the standard name and an optional vendor prefix for the current
           * browser.
           * 
           * (code)
           * mxUtils.setPrefixedStyle(node.style, 'transformOrigin', '0% 0%');
           * (end)
           */
          setPrefixedStyle: function() {
            var prefix = null;
            if (mxClient.IS_OT) {
              prefix = "O";
            } else if (mxClient.IS_SF || mxClient.IS_GC) {
              prefix = "Webkit";
            } else if (mxClient.IS_MT) {
              prefix = "Moz";
            } else if (mxClient.IS_IE && document.documentMode >= 9 && document.documentMode < 10) {
              prefix = "ms";
            }
            return function(style, name2, value) {
              style[name2] = value;
              if (prefix != null && name2.length > 0) {
                name2 = prefix + name2.substring(0, 1).toUpperCase() + name2.substring(1);
                style[name2] = value;
              }
            };
          }(),
          /**
           * Function: hasScrollbars
           * 
           * Returns true if the overflow CSS property of the given node is either
           * scroll or auto.
           * 
           * Parameters:
           * 
           * node - DOM node whose style should be checked for scrollbars.
           */
          hasScrollbars: function(node) {
            var style = mxUtils.getCurrentStyle(node);
            return style != null && (style.overflow == "scroll" || style.overflow == "auto");
          },
          /**
           * Function: bind
           * 
           * Returns a wrapper function that locks the execution scope of the given
           * function to the specified scope. Inside funct, the "this" keyword
           * becomes a reference to that scope.
           */
          bind: function(scope, funct) {
            return function() {
              return funct.apply(scope, arguments);
            };
          },
          /**
           * Function: eval
           * 
           * Evaluates the given expression using eval and returns the JavaScript
           * object that represents the expression result. Supports evaluation of
           * expressions that define functions and returns the function object for
           * these expressions.
           * 
           * Parameters:
           * 
           * expr - A string that represents a JavaScript expression.
           */
          eval: function(expr) {
            var result = null;
            if (expr.indexOf("function") >= 0) {
              try {
                eval("var _mxJavaScriptExpression=" + expr);
                result = _mxJavaScriptExpression;
                _mxJavaScriptExpression = null;
              } catch (e) {
                mxLog.warn(e.message + " while evaluating " + expr);
              }
            } else {
              try {
                result = eval(expr);
              } catch (e) {
                mxLog.warn(e.message + " while evaluating " + expr);
              }
            }
            return result;
          },
          /**
           * Function: findNode
           * 
           * Returns the first node where attr equals value.
           * This implementation does not use XPath.
           */
          findNode: function(node, attr, value) {
            if (node.nodeType == mxConstants.NODETYPE_ELEMENT) {
              var tmp = node.getAttribute(attr);
              if (tmp != null && tmp == value) {
                return node;
              }
            }
            node = node.firstChild;
            while (node != null) {
              var result2 = mxUtils.findNode(node, attr, value);
              if (result2 != null) {
                return result2;
              }
              node = node.nextSibling;
            }
            return null;
          },
          /**
           * Function: getFunctionName
           * 
           * Returns the name for the given function.
           * 
           * Parameters:
           * 
           * f - JavaScript object that represents a function.
           */
          getFunctionName: function(f) {
            var str = null;
            if (f != null) {
              if (f.name != null) {
                str = f.name;
              } else {
                str = mxUtils.trim(f.toString());
                if (/^function\s/.test(str)) {
                  str = mxUtils.ltrim(str.substring(9));
                  var idx2 = str.indexOf("(");
                  if (idx2 > 0) {
                    str = str.substring(0, idx2);
                  }
                }
              }
            }
            return str;
          },
          /**
           * Function: indexOf
           * 
           * Returns the index of obj in array or -1 if the array does not contain
           * the given object.
           * 
           * Parameters:
           * 
           * array - Array to check for the given obj.
           * obj - Object to find in the given array.
           */
          indexOf: function(array, obj) {
            if (array != null && obj != null) {
              for (var i = 0; i < array.length; i++) {
                if (array[i] == obj) {
                  return i;
                }
              }
            }
            return -1;
          },
          /**
           * Function: forEach
           * 
           * Calls the given function for each element of the given array and returns
           * the array.
           * 
           * Parameters:
           * 
           * array - Array that contains the elements.
           * fn - Function to be called for each object.
           */
          forEach: function(array, fn) {
            if (array != null && fn != null) {
              for (var i = 0; i < array.length; i++) {
                fn(array[i]);
              }
            }
            return array;
          },
          /**
           * Function: remove
           * 
           * Removes all occurrences of the given object in the given array or
           * object. If there are multiple occurrences of the object, be they
           * associative or as an array entry, all occurrences are removed from
           * the array or deleted from the object. By removing the object from
           * the array, all elements following the removed element are shifted
           * by one step towards the beginning of the array.
           * 
           * The length of arrays is not modified inside this function.
           * 
           * Parameters:
           * 
           * obj - Object to find in the given array.
           * array - Array to check for the given obj.
           */
          remove: function(obj, array) {
            var result2 = null;
            if (typeof array == "object") {
              var index = mxUtils.indexOf(array, obj);
              while (index >= 0) {
                array.splice(index, 1);
                result2 = obj;
                index = mxUtils.indexOf(array, obj);
              }
            }
            for (var key in array) {
              if (array[key] == obj) {
                delete array[key];
                result2 = obj;
              }
            }
            return result2;
          },
          /**
           * Function: isNode
           * 
           * Returns true if the given value is an XML node with the node name
           * and if the optional attribute has the specified value.
           * 
           * This implementation assumes that the given value is a DOM node if the
           * nodeType property is numeric, that is, if isNaN returns false for
           * value.nodeType.
           * 
           * Parameters:
           * 
           * value - Object that should be examined as a node.
           * nodeName - String that specifies the node name.
           * attributeName - Optional attribute name to check.
           * attributeValue - Optional attribute value to check.
           */
          isNode: function(value, nodeName, attributeName, attributeValue) {
            if (value != null && !isNaN(value.nodeType) && (nodeName == null || value.nodeName.toLowerCase() == nodeName.toLowerCase())) {
              return attributeName == null || value.getAttribute(attributeName) == attributeValue;
            }
            return false;
          },
          /**
           * Function: isAncestorNode
           * 
           * Returns true if the given ancestor is an ancestor of the
           * given DOM node in the DOM. This also returns true if the
           * child is the ancestor.
           * 
           * Parameters:
           * 
           * ancestor - DOM node that represents the ancestor.
           * child - DOM node that represents the child.
           */
          isAncestorNode: function(ancestor, child) {
            var parent = child;
            while (parent != null) {
              if (parent == ancestor) {
                return true;
              }
              parent = parent.parentNode;
            }
            return false;
          },
          /**
           * Function: getChildNodes
           * 
           * Returns an array of child nodes that are of the given node type.
           * 
           * Parameters:
           * 
           * node - Parent DOM node to return the children from.
           * nodeType - Optional node type to return. Default is
           * <mxConstants.NODETYPE_ELEMENT>.
           */
          getChildNodes: function(node, nodeType) {
            nodeType = nodeType || mxConstants.NODETYPE_ELEMENT;
            var children = [];
            var tmp = node.firstChild;
            while (tmp != null) {
              if (tmp.nodeType == nodeType) {
                children.push(tmp);
              }
              tmp = tmp.nextSibling;
            }
            return children;
          },
          /**
           * Function: importNode
           * 
           * Cross browser implementation for document.importNode. Uses document.importNode
           * in all browsers but IE, where the node is cloned by creating a new node and
           * copying all attributes and children into it using importNode, recursively.
           * 
           * Parameters:
           * 
           * doc - Document to import the node into.
           * node - Node to be imported.
           * allChildren - If all children should be imported.
           */
          importNode: function(doc, node, allChildren) {
            if (mxClient.IS_IE && (document.documentMode == null || document.documentMode < 10)) {
              return mxUtils.importNodeImplementation(doc, node, allChildren);
            } else {
              return doc.importNode(node, allChildren);
            }
          },
          /**
           * Function: importNodeImplementation
           * 
           * Full DOM API implementation for importNode without using importNode API call.
           * 
           * Parameters:
           * 
           * doc - Document to import the node into.
           * node - Node to be imported.
           * allChildren - If all children should be imported.
           */
          importNodeImplementation: function(doc, node, allChildren) {
            switch (node.nodeType) {
              case 1: {
                var newNode = doc.createElement(node.nodeName);
                if (node.attributes && node.attributes.length > 0) {
                  for (var i = 0; i < node.attributes.length; i++) {
                    newNode.setAttribute(
                      node.attributes[i].nodeName,
                      node.getAttribute(node.attributes[i].nodeName)
                    );
                  }
                }
                if (allChildren && node.childNodes && node.childNodes.length > 0) {
                  for (var i = 0; i < node.childNodes.length; i++) {
                    newNode.appendChild(mxUtils.importNodeImplementation(doc, node.childNodes[i], allChildren));
                  }
                }
                return newNode;
                break;
              }
              case 3:
              /* text */
              case 4:
              /* cdata-section */
              case 8: {
                return doc.createTextNode(node.nodeValue != null ? node.nodeValue : node.value);
                break;
              }
            }
            ;
          },
          /**
           * Function: createXmlDocument
           * 
           * Returns a new, empty XML document.
           */
          createXmlDocument: function() {
            var doc = null;
            if (document.implementation && document.implementation.createDocument) {
              doc = document.implementation.createDocument("", "", null);
            } else if ("ActiveXObject" in window) {
              doc = mxUtils.createMsXmlDocument();
            }
            return doc;
          },
          /**
           * Function: createMsXmlDocument
           * 
           * Returns a new, empty Microsoft.XMLDOM document using ActiveXObject.
           */
          createMsXmlDocument: function() {
            var doc = new ActiveXObject("Microsoft.XMLDOM");
            doc.async = false;
            doc.validateOnParse = false;
            doc.resolveExternals = false;
            return doc;
          },
          /**
           * Function: parseXml
           * 
           * Parses the specified XML string into a new XML document and returns the
           * new document.
           * 
           * Example:
           * 
           * (code)
           * var doc = mxUtils.parseXml(
           *   '<mxGraphModel><root><MyDiagram id="0"><mxCell/></MyDiagram>'+
           *   '<MyLayer id="1"><mxCell parent="0" /></MyLayer><MyObject id="2">'+
           *   '<mxCell style="strokeColor=blue;fillColor=red" parent="1" vertex="1">'+
           *   '<mxGeometry x="10" y="10" width="80" height="30" as="geometry"/>'+
           *   '</mxCell></MyObject></root></mxGraphModel>');
           * (end)
           * 
           * Parameters:
           * 
           * xml - String that contains the XML data.
           */
          parseXml: function() {
            if (window.DOMParser) {
              return function(xml) {
                var parser = new DOMParser();
                return parser.parseFromString(xml, "text/xml");
              };
            } else {
              return function(xml) {
                var doc = mxUtils.createMsXmlDocument();
                doc.loadXML(xml);
                return doc;
              };
            }
          }(),
          /**
           * Function: clearSelection
           * 
           * Clears the current selection in the page.
           */
          clearSelection: function() {
            if (document.selection) {
              return function() {
                document.selection.empty();
              };
            } else if (window.getSelection) {
              return function() {
                if (window.getSelection().empty) {
                  window.getSelection().empty();
                } else if (window.getSelection().removeAllRanges) {
                  window.getSelection().removeAllRanges();
                }
              };
            } else {
              return function() {
              };
            }
          }(),
          /**
           * Function: removeWhitespace
           * 
           * Removes the sibling text nodes for the given node that only consists
           * of tabs, newlines and spaces.
           * 
           * Parameters:
           * 
           * node - DOM node whose siblings should be removed.
           * before - Optional boolean that specifies the direction of the traversal.
           */
          removeWhitespace: function(node, before) {
            var tmp = before ? node.previousSibling : node.nextSibling;
            while (tmp != null && tmp.nodeType == mxConstants.NODETYPE_TEXT) {
              var next = before ? tmp.previousSibling : tmp.nextSibling;
              var text = mxUtils.getTextContent(tmp);
              if (mxUtils.trim(text).length == 0) {
                tmp.parentNode.removeChild(tmp);
              }
              tmp = next;
            }
          },
          /**
           * Function: htmlEntities
           * 
           * Replaces characters (less than, greater than, newlines and quotes) with
           * their HTML entities in the given string and returns the result.
           * 
           * Parameters:
           * 
           * s - String that contains the characters to be converted.
           * newline - If newlines should be replaced. Default is true.
           */
          htmlEntities: function(s, newline) {
            s = String(s || "");
            s = s.replace(/&/g, "&amp;");
            s = s.replace(/"/g, "&quot;");
            s = s.replace(/\'/g, "&#39;");
            s = s.replace(/</g, "&lt;");
            s = s.replace(/>/g, "&gt;");
            if (newline == null || newline) {
              s = s.replace(/\n/g, "&#xa;");
            }
            return s;
          },
          /**
           * Function: isVml
           * 
           * Returns true if the given node is in the VML namespace.
           * 
           * Parameters:
           * 
           * node - DOM node whose tag urn should be checked.
           */
          isVml: function(node) {
            return node != null && node.tagUrn == "urn:schemas-microsoft-com:vml";
          },
          /**
           * Function: getXml
           * 
           * Returns the XML content of the specified node. For Internet Explorer,
           * all \r\n\t[\t]* are removed from the XML string and the remaining \r\n
           * are replaced by \n. All \n are then replaced with linefeed, or &#xa; if
           * no linefeed is defined.
           * 
           * Parameters:
           * 
           * node - DOM node to return the XML for.
           * linefeed - Optional string that linefeeds are converted into. Default is
           * &#xa;
           */
          getXml: function(node, linefeed) {
            var xml = "";
            if (mxClient.IS_IE || mxClient.IS_IE11) {
              xml = mxUtils.getPrettyXml(node, "", "", "");
            } else if (window.XMLSerializer != null) {
              var xmlSerializer = new XMLSerializer();
              xml = xmlSerializer.serializeToString(node);
            } else if (node.xml != null) {
              xml = node.xml.replace(/\r\n\t[\t]*/g, "").replace(/>\r\n/g, ">").replace(/\r\n/g, "\n");
            }
            linefeed = linefeed || "&#xa;";
            xml = xml.replace(/\n/g, linefeed);
            return xml;
          },
          /**
           * Function: getPrettyXML
           * 
           * Returns a pretty printed string that represents the XML tree for the
           * given node. This method should only be used to print XML for reading,
           * use <getXml> instead to obtain a string for processing.
           * 
           * Parameters:
           * 
           * node - DOM node to return the XML for.
           * tab - Optional string that specifies the indentation for one level.
           * Default is two spaces.
           * indent - Optional string that represents the current indentation.
           * Default is an empty string.
           * newline - Option string that represents a linefeed. Default is '\n'.
           */
          getPrettyXml: function(node, tab, indent, newline, ns) {
            var result2 = [];
            if (node != null) {
              tab = tab != null ? tab : "  ";
              indent = indent != null ? indent : "";
              newline = newline != null ? newline : "\n";
              if (node.namespaceURI != null && node.namespaceURI != ns) {
                ns = node.namespaceURI;
                if (node.getAttribute("xmlns") == null) {
                  node.setAttribute("xmlns", node.namespaceURI);
                }
              }
              if (node.nodeType == mxConstants.NODETYPE_DOCUMENT) {
                result2.push(mxUtils.getPrettyXml(node.documentElement, tab, indent, newline, ns));
              } else if (node.nodeType == mxConstants.NODETYPE_DOCUMENT_FRAGMENT) {
                var tmp = node.firstChild;
                if (tmp != null) {
                  while (tmp != null) {
                    result2.push(mxUtils.getPrettyXml(tmp, tab, indent, newline, ns));
                    tmp = tmp.nextSibling;
                  }
                }
              } else if (node.nodeType == mxConstants.NODETYPE_COMMENT) {
                var value = mxUtils.getTextContent(node);
                if (value.length > 0) {
                  result2.push(indent + "<!--" + value + "-->" + newline);
                }
              } else if (node.nodeType == mxConstants.NODETYPE_TEXT) {
                var value = mxUtils.trim(mxUtils.getTextContent(node));
                if (value.length > 0) {
                  result2.push(indent + mxUtils.htmlEntities(value, false) + newline);
                }
              } else if (node.nodeType == mxConstants.NODETYPE_CDATA) {
                var value = mxUtils.getTextContent(node);
                if (value.length > 0) {
                  result2.push(indent + "<![CDATA[" + value + "]]" + newline);
                }
              } else {
                result2.push(indent + "<" + node.nodeName);
                var attrs = node.attributes;
                if (attrs != null) {
                  for (var i = 0; i < attrs.length; i++) {
                    var val = mxUtils.htmlEntities(attrs[i].value);
                    result2.push(" " + attrs[i].nodeName + '="' + val + '"');
                  }
                }
                var tmp = node.firstChild;
                if (tmp != null) {
                  result2.push(">" + newline);
                  while (tmp != null) {
                    result2.push(mxUtils.getPrettyXml(tmp, tab, indent + tab, newline, ns));
                    tmp = tmp.nextSibling;
                  }
                  result2.push(indent + "</" + node.nodeName + ">" + newline);
                } else {
                  result2.push(" />" + newline);
                }
              }
            }
            return result2.join("");
          },
          /**
           * Function: extractTextWithWhitespace
           * 
           * Returns the text content of the specified node.
           * 
           * Parameters:
           * 
           * elems - DOM nodes to return the text for.
           */
          extractTextWithWhitespace: function(elems) {
            var blocks = ["BLOCKQUOTE", "DIV", "H1", "H2", "H3", "H4", "H5", "H6", "OL", "P", "PRE", "TABLE", "UL"];
            var ret = [];
            function doExtract(elts) {
              if (elts.length == 1 && (elts[0].nodeName == "BR" || elts[0].innerHTML == "\n")) {
                return;
              }
              for (var i = 0; i < elts.length; i++) {
                var elem = elts[i];
                if (elem.nodeName == "BR" || elem.innerHTML == "\n" || (elts.length == 1 || i == 0) && (elem.nodeName == "DIV" && elem.innerHTML.toLowerCase() == "<br>")) {
                  ret.push("\n");
                } else {
                  if (elem.nodeType === 3 || elem.nodeType === 4) {
                    if (elem.nodeValue.length > 0) {
                      ret.push(elem.nodeValue);
                    }
                  } else if (elem.nodeType !== 8 && elem.childNodes.length > 0) {
                    doExtract(elem.childNodes);
                  }
                  if (i < elts.length - 1 && mxUtils.indexOf(blocks, elts[i + 1].nodeName) >= 0) {
                    ret.push("\n");
                  }
                }
              }
            }
            ;
            doExtract(elems);
            return ret.join("");
          },
          /**
           * Function: replaceTrailingNewlines
           * 
           * Replaces each trailing newline with the given pattern.
           */
          replaceTrailingNewlines: function(str, pattern) {
            var postfix = "";
            while (str.length > 0 && str.charAt(str.length - 1) == "\n") {
              str = str.substring(0, str.length - 1);
              postfix += pattern;
            }
            return str + postfix;
          },
          /**
           * Function: getTextContent
           * 
           * Returns the text content of the specified node.
           * 
           * Parameters:
           * 
           * node - DOM node to return the text content for.
           */
          getTextContent: function(node) {
            if (mxClient.IS_IE && node.innerText !== void 0) {
              return node.innerText;
            } else {
              return node != null ? node[node.textContent === void 0 ? "text" : "textContent"] : "";
            }
          },
          /**
           * Function: setTextContent
           * 
           * Sets the text content of the specified node.
           * 
           * Parameters:
           * 
           * node - DOM node to set the text content for.
           * text - String that represents the text content.
           */
          setTextContent: function(node, text) {
            if (node.innerText !== void 0) {
              node.innerText = text;
            } else {
              node[node.textContent === void 0 ? "text" : "textContent"] = text;
            }
          },
          /**
           * Function: getInnerHtml
           * 
           * Returns the inner HTML for the given node as a string or an empty string
           * if no node was specified. The inner HTML is the text representing all
           * children of the node, but not the node itself.
           * 
           * Parameters:
           * 
           * node - DOM node to return the inner HTML for.
           */
          getInnerHtml: function() {
            if (mxClient.IS_IE) {
              return function(node) {
                if (node != null) {
                  return node.innerHTML;
                }
                return "";
              };
            } else {
              return function(node) {
                if (node != null) {
                  var serializer = new XMLSerializer();
                  return serializer.serializeToString(node);
                }
                return "";
              };
            }
          }(),
          /**
           * Function: getOuterHtml
           * 
           * Returns the outer HTML for the given node as a string or an empty
           * string if no node was specified. The outer HTML is the text representing
           * all children of the node including the node itself.
           * 
           * Parameters:
           * 
           * node - DOM node to return the outer HTML for.
           */
          getOuterHtml: function() {
            if (mxClient.IS_IE) {
              return function(node) {
                if (node != null) {
                  if (node.outerHTML != null) {
                    return node.outerHTML;
                  } else {
                    var tmp = [];
                    tmp.push("<" + node.nodeName);
                    var attrs = node.attributes;
                    if (attrs != null) {
                      for (var i = 0; i < attrs.length; i++) {
                        var value = attrs[i].value;
                        if (value != null && value.length > 0) {
                          tmp.push(" ");
                          tmp.push(attrs[i].nodeName);
                          tmp.push('="');
                          tmp.push(value);
                          tmp.push('"');
                        }
                      }
                    }
                    if (node.innerHTML.length == 0) {
                      tmp.push("/>");
                    } else {
                      tmp.push(">");
                      tmp.push(node.innerHTML);
                      tmp.push("</" + node.nodeName + ">");
                    }
                    return tmp.join("");
                  }
                }
                return "";
              };
            } else {
              return function(node) {
                if (node != null) {
                  var serializer = new XMLSerializer();
                  return serializer.serializeToString(node);
                }
                return "";
              };
            }
          }(),
          /**
           * Function: write
           * 
           * Creates a text node for the given string and appends it to the given
           * parent. Returns the text node.
           * 
           * Parameters:
           * 
           * parent - DOM node to append the text node to.
           * text - String representing the text to be added.
           */
          write: function(parent, text) {
            var doc = parent.ownerDocument;
            var node = doc.createTextNode(text);
            if (parent != null) {
              parent.appendChild(node);
            }
            return node;
          },
          /**
           * Function: writeln
           * 
           * Creates a text node for the given string and appends it to the given
           * parent with an additional linefeed. Returns the text node.
           * 
           * Parameters:
           * 
           * parent - DOM node to append the text node to.
           * text - String representing the text to be added.
           */
          writeln: function(parent, text) {
            var doc = parent.ownerDocument;
            var node = doc.createTextNode(text);
            if (parent != null) {
              parent.appendChild(node);
              parent.appendChild(document.createElement("br"));
            }
            return node;
          },
          /**
           * Function: br
           * 
           * Appends a linebreak to the given parent and returns the linebreak.
           * 
           * Parameters:
           * 
           * parent - DOM node to append the linebreak to.
           */
          br: function(parent, count) {
            count = count || 1;
            var br = null;
            for (var i = 0; i < count; i++) {
              if (parent != null) {
                br = parent.ownerDocument.createElement("br");
                parent.appendChild(br);
              }
            }
            return br;
          },
          /**
           * Function: button
           * 
           * Returns a new button with the given level and function as an onclick
           * event handler.
           * 
           * (code)
           * document.body.appendChild(mxUtils.button('Test', function(evt)
           * {
           *   alert('Hello, World!');
           * }));
           * (end)
           * 
           * Parameters:
           * 
           * label - String that represents the label of the button.
           * funct - Function to be called if the button is pressed.
           * doc - Optional document to be used for creating the button. Default is the
           * current document.
           */
          button: function(label, funct, doc) {
            doc = doc != null ? doc : document;
            var button = doc.createElement("button");
            mxUtils.write(button, label);
            mxEvent.addListener(button, "click", function(evt) {
              funct(evt);
            });
            return button;
          },
          /**
           * Function: para
           * 
           * Appends a new paragraph with the given text to the specified parent and
           * returns the paragraph.
           * 
           * Parameters:
           * 
           * parent - DOM node to append the text node to.
           * text - String representing the text for the new paragraph.
           */
          para: function(parent, text) {
            var p = document.createElement("p");
            mxUtils.write(p, text);
            if (parent != null) {
              parent.appendChild(p);
            }
            return p;
          },
          /**
           * Function: addTransparentBackgroundFilter
           * 
           * Adds a transparent background to the filter of the given node. This
           * background can be used in IE8 standards mode (native IE8 only) to pass
           * events through the node.
           */
          addTransparentBackgroundFilter: function(node) {
            node.style.filter += "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + mxClient.imageBasePath + "/transparent.gif', sizingMethod='scale')";
          },
          /**
           * Function: linkAction
           * 
           * Adds a hyperlink to the specified parent that invokes action on the
           * specified editor.
           * 
           * Parameters:
           * 
           * parent - DOM node to contain the new link.
           * text - String that is used as the link label.
           * editor - <mxEditor> that will execute the action.
           * action - String that defines the name of the action to be executed.
           * pad - Optional left-padding for the link. Default is 0.
           */
          linkAction: function(parent, text, editor, action, pad) {
            return mxUtils.link(parent, text, function() {
              editor.execute(action);
            }, pad);
          },
          /**
           * Function: linkInvoke
           * 
           * Adds a hyperlink to the specified parent that invokes the specified
           * function on the editor passing along the specified argument. The
           * function name is the name of a function of the editor instance,
           * not an action name.
           * 
           * Parameters:
           * 
           * parent - DOM node to contain the new link.
           * text - String that is used as the link label.
           * editor - <mxEditor> instance to execute the function on.
           * functName - String that represents the name of the function.
           * arg - Object that represents the argument to the function.
           * pad - Optional left-padding for the link. Default is 0.
           */
          linkInvoke: function(parent, text, editor, functName, arg, pad) {
            return mxUtils.link(parent, text, function() {
              editor[functName](arg);
            }, pad);
          },
          /**
           * Function: link
           * 
           * Adds a hyperlink to the specified parent and invokes the given function
           * when the link is clicked.
           * 
           * Parameters:
           * 
           * parent - DOM node to contain the new link.
           * text - String that is used as the link label.
           * funct - Function to execute when the link is clicked.
           * pad - Optional left-padding for the link. Default is 0.
           */
          link: function(parent, text, funct, pad) {
            var a = document.createElement("span");
            a.style.color = "blue";
            a.style.textDecoration = "underline";
            a.style.cursor = "pointer";
            if (pad != null) {
              a.style.paddingLeft = pad + "px";
            }
            mxEvent.addListener(a, "click", funct);
            mxUtils.write(a, text);
            if (parent != null) {
              parent.appendChild(a);
            }
            return a;
          },
          /**
           * Function: getDocumentSize
           * 
           * Returns the client size for the current document as an <mxRectangle>.
           */
          getDocumentSize: function() {
            var b = document.body;
            var d = document.documentElement;
            try {
              return new mxRectangle(0, 0, b.clientWidth || d.clientWidth, Math.max(b.clientHeight || 0, d.clientHeight));
            } catch (e) {
              return new mxRectangle();
            }
          },
          /**
           * Function: fit
           * 
           * Makes sure the given node is inside the visible area of the window. This
           * is done by setting the left and top in the style. 
           */
          fit: function(node) {
            var ds = mxUtils.getDocumentSize();
            var left = parseInt(node.offsetLeft);
            var width = parseInt(node.offsetWidth);
            var offset = mxUtils.getDocumentScrollOrigin(node.ownerDocument);
            var sl = offset.x;
            var st = offset.y;
            var b = document.body;
            var d = document.documentElement;
            var right = sl + ds.width;
            if (left + width > right) {
              node.style.left = Math.max(sl, right - width) + "px";
            }
            var top = parseInt(node.offsetTop);
            var height = parseInt(node.offsetHeight);
            var bottom = st + ds.height;
            if (top + height > bottom) {
              node.style.top = Math.max(st, bottom - height) + "px";
            }
          },
          /**
           * Function: load
           * 
           * Loads the specified URL *synchronously* and returns the <mxXmlRequest>.
           * Throws an exception if the file cannot be loaded. See <mxUtils.get> for
           * an asynchronous implementation.
           *
           * Example:
           * 
           * (code)
           * try
           * {
           *   var req = mxUtils.load(filename);
           *   var root = req.getDocumentElement();
           *   // Process XML DOM...
           * }
           * catch (ex)
           * {
           *   mxUtils.alert('Cannot load '+filename+': '+ex);
           * }
           * (end)
           * 
           * Parameters:
           * 
           * url - URL to get the data from.
           */
          load: function(url) {
            var req = new mxXmlRequest(url, null, "GET", false);
            req.send();
            return req;
          },
          /**
           * Function: get
           * 
           * Loads the specified URL *asynchronously* and invokes the given functions
           * depending on the request status. Returns the <mxXmlRequest> in use. Both
           * functions take the <mxXmlRequest> as the only parameter. See
           * <mxUtils.load> for a synchronous implementation.
           *
           * Example:
           * 
           * (code)
           * mxUtils.get(url, function(req)
           * {
           *    var node = req.getDocumentElement();
           *    // Process XML DOM...
           * });
           * (end)
           * 
           * So for example, to load a diagram into an existing graph model, the
           * following code is used.
           * 
           * (code)
           * mxUtils.get(url, function(req)
           * {
           *   var node = req.getDocumentElement();
           *   var dec = new mxCodec(node.ownerDocument);
           *   dec.decode(node, graph.getModel());
           * });
           * (end)
           * 
           * Parameters:
           * 
           * url - URL to get the data from.
           * onload - Optional function to execute for a successful response.
           * onerror - Optional function to execute on error.
           * binary - Optional boolean parameter that specifies if the request is
           * binary.
           * timeout - Optional timeout in ms before calling ontimeout.
           * ontimeout - Optional function to execute on timeout.
           * headers - Optional with headers, eg. {'Authorization': 'token xyz'}
           */
          get: function(url, onload, onerror, binary, timeout, ontimeout, headers) {
            var req = new mxXmlRequest(url, null, "GET");
            var setRequestHeaders = req.setRequestHeaders;
            if (headers) {
              req.setRequestHeaders = function(request, params) {
                setRequestHeaders.apply(this, arguments);
                for (var key in headers) {
                  request.setRequestHeader(key, headers[key]);
                }
              };
            }
            if (binary != null) {
              req.setBinary(binary);
            }
            req.send(onload, onerror, timeout, ontimeout);
            return req;
          },
          /**
           * Function: getAll
           * 
           * Loads the URLs in the given array *asynchronously* and invokes the given function
           * if all requests returned with a valid 2xx status. The error handler is invoked
           * once on the first error or invalid response.
           *
           * Parameters:
           * 
           * urls - Array of URLs to be loaded.
           * onload - Callback with array of <mxXmlRequests>.
           * onerror - Optional function to execute on error.
           */
          getAll: function(urls, onload, onerror) {
            var remain = urls.length;
            var result2 = [];
            var errors = 0;
            var err = function() {
              if (errors == 0 && onerror != null) {
                onerror();
              }
              errors++;
            };
            for (var i = 0; i < urls.length; i++) {
              (function(url, index) {
                mxUtils.get(url, function(req) {
                  var status = req.getStatus();
                  if (status < 200 || status > 299) {
                    err();
                  } else {
                    result2[index] = req;
                    remain--;
                    if (remain == 0) {
                      onload(result2);
                    }
                  }
                }, err);
              })(urls[i], i);
            }
            if (remain == 0) {
              onload(result2);
            }
          },
          /**
           * Function: post
           * 
           * Posts the specified params to the given URL *asynchronously* and invokes
           * the given functions depending on the request status. Returns the
           * <mxXmlRequest> in use. Both functions take the <mxXmlRequest> as the
           * only parameter. Make sure to use encodeURIComponent for the parameter
           * values.
           *
           * Example:
           * 
           * (code)
           * mxUtils.post(url, 'key=value', function(req)
           * {
           * 	mxUtils.alert('Ready: '+req.isReady()+' Status: '+req.getStatus());
           *  // Process req.getDocumentElement() using DOM API if OK...
           * });
           * (end)
           * 
           * Parameters:
           * 
           * url - URL to get the data from.
           * params - Parameters for the post request.
           * onload - Optional function to execute for a successful response.
           * onerror - Optional function to execute on error.
           */
          post: function(url, params, onload, onerror) {
            return new mxXmlRequest(url, params).send(onload, onerror);
          },
          /**
           * Function: submit
           * 
           * Submits the given parameters to the specified URL using
           * <mxXmlRequest.simulate> and returns the <mxXmlRequest>.
           * Make sure to use encodeURIComponent for the parameter
           * values.
           * 
           * Parameters:
           * 
           * url - URL to get the data from.
           * params - Parameters for the form.
           * doc - Document to create the form in.
           * target - Target to send the form result to.
           */
          submit: function(url, params, doc, target) {
            return new mxXmlRequest(url, params).simulate(doc, target);
          },
          /**
           * Function: loadInto
           * 
           * Loads the specified URL *asynchronously* into the specified document,
           * invoking onload after the document has been loaded. This implementation
           * does not use <mxXmlRequest>, but the document.load method.
           * 
           * Parameters:
           * 
           * url - URL to get the data from.
           * doc - The document to load the URL into.
           * onload - Function to execute when the URL has been loaded.
           */
          loadInto: function(url, doc, onload) {
            if (mxClient.IS_IE) {
              doc.onreadystatechange = function() {
                if (doc.readyState == 4) {
                  onload();
                }
              };
            } else {
              doc.addEventListener("load", onload, false);
            }
            doc.load(url);
          },
          /**
           * Function: getValue
           * 
           * Returns the value for the given key in the given associative array or
           * the given default value if the value is null.
           * 
           * Parameters:
           * 
           * array - Associative array that contains the value for the key.
           * key - Key whose value should be returned.
           * defaultValue - Value to be returned if the value for the given
           * key is null.
           */
          getValue: function(array, key, defaultValue) {
            var value = array != null ? array[key] : null;
            if (value == null) {
              value = defaultValue;
            }
            return value;
          },
          /**
           * Function: getNumber
           * 
           * Returns the numeric value for the given key in the given associative
           * array or the given default value (or 0) if the value is null. The value
           * is converted to a numeric value using the Number function.
           * 
           * Parameters:
           * 
           * array - Associative array that contains the value for the key.
           * key - Key whose value should be returned.
           * defaultValue - Value to be returned if the value for the given
           * key is null. Default is 0.
           */
          getNumber: function(array, key, defaultValue) {
            var value = array != null ? array[key] : null;
            if (value == null) {
              value = defaultValue || 0;
            }
            return Number(value);
          },
          /**
           * Function: getColor
           * 
           * Returns the color value for the given key in the given associative
           * array or the given default value if the value is null. If the value
           * is <mxConstants.NONE> then null is returned.
           * 
           * Parameters:
           * 
           * array - Associative array that contains the value for the key.
           * key - Key whose value should be returned.
           * defaultValue - Value to be returned if the value for the given
           * key is null. Default is null.
           */
          getColor: function(array, key, defaultValue) {
            var value = array != null ? array[key] : null;
            if (value == null) {
              value = defaultValue;
            } else if (value == mxConstants.NONE) {
              value = null;
            }
            return value;
          },
          /**
           * Function: clone
           * 
           * Recursively clones the specified object ignoring all fieldnames in the
           * given array of transient fields. <mxObjectIdentity.FIELD_NAME> is always
           * ignored by this function.
           * 
           * Parameters:
           * 
           * obj - Object to be cloned.
           * transients - Optional array of strings representing the fieldname to be
           * ignored.
           * shallow - Optional boolean argument to specify if a shallow clone should
           * be created, that is, one where all object references are not cloned or,
           * in other words, one where only atomic (strings, numbers) values are
           * cloned. Default is false.
           */
          clone: function(obj, transients, shallow) {
            shallow = shallow != null ? shallow : false;
            var clone = null;
            if (obj != null && typeof obj.constructor == "function") {
              clone = new obj.constructor();
              for (var i in obj) {
                if (i != mxObjectIdentity.FIELD_NAME && (transients == null || mxUtils.indexOf(transients, i) < 0)) {
                  if (!shallow && typeof obj[i] == "object") {
                    clone[i] = mxUtils.clone(obj[i]);
                  } else {
                    clone[i] = obj[i];
                  }
                }
              }
            }
            return clone;
          },
          /**
           * Function: equalPoints
           * 
           * Compares all mxPoints in the given lists.
           * 
           * Parameters:
           * 
           * a - Array of <mxPoints> to be compared.
           * b - Array of <mxPoints> to be compared.
           */
          equalPoints: function(a, b) {
            if (a == null && b != null || a != null && b == null || a != null && b != null && a.length != b.length) {
              return false;
            } else if (a != null && b != null) {
              for (var i = 0; i < a.length; i++) {
                if (a[i] != null && b[i] == null || a[i] == null && b[i] != null || a[i] != null && b[i] != null && (a[i].x != b[i].x || a[i].y != b[i].y)) {
                  return false;
                }
              }
            }
            return true;
          },
          /**
           * Function: equalEntries
           * 
           * Returns true if all properties of the given objects are equal. Values
           * with NaN are equal to NaN and unequal to any other value.
           * 
           * Parameters:
           * 
           * a - First object to be compared.
           * b - Second object to be compared.
           */
          equalEntries: function(a, b) {
            var count = 0;
            if (a == null && b != null || a != null && b == null || a != null && b != null && a.length != b.length) {
              return false;
            } else if (a != null && b != null) {
              for (var key in b) {
                count++;
              }
              for (var key in a) {
                count--;
                if ((!mxUtils.isNaN(a[key]) || !mxUtils.isNaN(b[key])) && a[key] != b[key]) {
                  return false;
                }
              }
            }
            return count == 0;
          },
          /**
           * Function: removeDuplicates
           * 
           * Removes all duplicates from the given array.
           */
          removeDuplicates: function(arr) {
            var dict = new mxDictionary();
            var result2 = [];
            for (var i = 0; i < arr.length; i++) {
              if (!dict.get(arr[i])) {
                result2.push(arr[i]);
                dict.put(arr[i], true);
              }
            }
            return result2;
          },
          /**
           * Function: isNaN
           *
           * Returns true if the given value is of type number and isNaN returns true.
           */
          isNaN: function(value) {
            return typeof value == "number" && isNaN(value);
          },
          /**
           * Function: extend
           *
           * Assigns a copy of the superclass prototype to the subclass prototype.
           * Note that this does not call the constructor of the superclass at this
           * point, the superclass constructor should be called explicitely in the
           * subclass constructor. Below is an example.
           * 
           * (code)
           * MyGraph = function(container, model, renderHint, stylesheet)
           * {
           *   mxGraph.call(this, container, model, renderHint, stylesheet);
           * }
           * 
           * mxUtils.extend(MyGraph, mxGraph);
           * (end)
           * 
           * Parameters:
           * 
           * ctor - Constructor of the subclass.
           * superCtor - Constructor of the superclass.
           */
          extend: function(ctor, superCtor) {
            var f = function() {
            };
            f.prototype = superCtor.prototype;
            ctor.prototype = new f();
            ctor.prototype.constructor = ctor;
          },
          /**
           * Function: toString
           * 
           * Returns a textual representation of the specified object.
           * 
           * Parameters:
           * 
           * obj - Object to return the string representation for.
           */
          toString: function(obj) {
            var output = "";
            for (var i in obj) {
              try {
                if (obj[i] == null) {
                  output += i + " = [null]\n";
                } else if (typeof obj[i] == "function") {
                  output += i + " => [Function]\n";
                } else if (typeof obj[i] == "object") {
                  var ctor = mxUtils.getFunctionName(obj[i].constructor);
                  output += i + " => [" + ctor + "]\n";
                } else {
                  output += i + " = " + obj[i] + "\n";
                }
              } catch (e) {
                output += i + "=" + e.message;
              }
            }
            return output;
          },
          /**
           * Function: toRadians
           * 
           * Converts the given degree to radians.
           */
          toRadians: function(deg) {
            return Math.PI * deg / 180;
          },
          /**
           * Function: toDegree
           * 
           * Converts the given radians to degree.
           */
          toDegree: function(rad) {
            return rad * 180 / Math.PI;
          },
          /**
           * Function: arcToCurves
           * 
           * Converts the given arc to a series of curves.
           */
          arcToCurves: function(x0, y0, r1, r2, angle, largeArcFlag, sweepFlag, x, y) {
            x -= x0;
            y -= y0;
            if (r1 === 0 || r2 === 0) {
              return result2;
            }
            var fS = sweepFlag;
            var psai = angle;
            r1 = Math.abs(r1);
            r2 = Math.abs(r2);
            var ctx = -x / 2;
            var cty = -y / 2;
            var cpsi = Math.cos(psai * Math.PI / 180);
            var spsi = Math.sin(psai * Math.PI / 180);
            var rxd = cpsi * ctx + spsi * cty;
            var ryd = -1 * spsi * ctx + cpsi * cty;
            var rxdd = rxd * rxd;
            var rydd = ryd * ryd;
            var r1x = r1 * r1;
            var r2y = r2 * r2;
            var lamda = rxdd / r1x + rydd / r2y;
            var sds;
            if (lamda > 1) {
              r1 = Math.sqrt(lamda) * r1;
              r2 = Math.sqrt(lamda) * r2;
              sds = 0;
            } else {
              var seif = 1;
              if (largeArcFlag === fS) {
                seif = -1;
              }
              sds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));
            }
            var txd = sds * r1 * ryd / r2;
            var tyd = -1 * sds * r2 * rxd / r1;
            var tx = cpsi * txd - spsi * tyd + x / 2;
            var ty = spsi * txd + cpsi * tyd + y / 2;
            var rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);
            var s1 = rad >= 0 ? rad : 2 * Math.PI + rad;
            rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);
            var dr = rad >= 0 ? rad : 2 * Math.PI + rad;
            if (fS == 0 && dr > 0) {
              dr -= 2 * Math.PI;
            } else if (fS != 0 && dr < 0) {
              dr += 2 * Math.PI;
            }
            var sse = dr * 2 / Math.PI;
            var seg = Math.ceil(sse < 0 ? -1 * sse : sse);
            var segr = dr / seg;
            var t = 8 / 3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);
            var cpsir1 = cpsi * r1;
            var cpsir2 = cpsi * r2;
            var spsir1 = spsi * r1;
            var spsir2 = spsi * r2;
            var mc = Math.cos(s1);
            var ms = Math.sin(s1);
            var x2 = -t * (cpsir1 * ms + spsir2 * mc);
            var y2 = -t * (spsir1 * ms - cpsir2 * mc);
            var x3 = 0;
            var y3 = 0;
            var result2 = [];
            for (var n = 0; n < seg; ++n) {
              s1 += segr;
              mc = Math.cos(s1);
              ms = Math.sin(s1);
              x3 = cpsir1 * mc - spsir2 * ms + tx;
              y3 = spsir1 * mc + cpsir2 * ms + ty;
              var dx = -t * (cpsir1 * ms + spsir2 * mc);
              var dy = -t * (spsir1 * ms - cpsir2 * mc);
              var index = n * 6;
              result2[index] = Number(x2 + x0);
              result2[index + 1] = Number(y2 + y0);
              result2[index + 2] = Number(x3 - dx + x0);
              result2[index + 3] = Number(y3 - dy + y0);
              result2[index + 4] = Number(x3 + x0);
              result2[index + 5] = Number(y3 + y0);
              x2 = x3 + dx;
              y2 = y3 + dy;
            }
            return result2;
          },
          /**
           * Function: getBoundingBox
           * 
           * Returns the bounding box for the rotated rectangle.
           * 
           * Parameters:
           * 
           * rect - <mxRectangle> to be rotated.
           * angle - Number that represents the angle (in degrees).
           * cx - Optional <mxPoint> that represents the rotation center. If no
           * rotation center is given then the center of rect is used.
           */
          getBoundingBox: function(rect, rotation, cx) {
            var result2 = null;
            if (rect != null && rotation != null && rotation != 0) {
              var rad = mxUtils.toRadians(rotation);
              var cos = Math.cos(rad);
              var sin = Math.sin(rad);
              cx = cx != null ? cx : new mxPoint(rect.x + rect.width / 2, rect.y + rect.height / 2);
              var p1 = new mxPoint(rect.x, rect.y);
              var p2 = new mxPoint(rect.x + rect.width, rect.y);
              var p3 = new mxPoint(p2.x, rect.y + rect.height);
              var p4 = new mxPoint(rect.x, p3.y);
              p1 = mxUtils.getRotatedPoint(p1, cos, sin, cx);
              p2 = mxUtils.getRotatedPoint(p2, cos, sin, cx);
              p3 = mxUtils.getRotatedPoint(p3, cos, sin, cx);
              p4 = mxUtils.getRotatedPoint(p4, cos, sin, cx);
              result2 = new mxRectangle(p1.x, p1.y, 0, 0);
              result2.add(new mxRectangle(p2.x, p2.y, 0, 0));
              result2.add(new mxRectangle(p3.x, p3.y, 0, 0));
              result2.add(new mxRectangle(p4.x, p4.y, 0, 0));
            }
            return result2;
          },
          /**
           * Function: getRotatedPoint
           * 
           * Rotates the given point by the given cos and sin.
           */
          getRotatedPoint: function(pt, cos, sin, c) {
            c = c != null ? c : new mxPoint();
            var x = pt.x - c.x;
            var y = pt.y - c.y;
            var x1 = x * cos - y * sin;
            var y1 = y * cos + x * sin;
            return new mxPoint(x1 + c.x, y1 + c.y);
          },
          /**
           * Returns an integer mask of the port constraints of the given map
           * @param dict the style map to determine the port constraints for
           * @param defaultValue Default value to return if the key is undefined.
           * @return the mask of port constraint directions
           * 
           * Parameters:
           * 
           * terminal - <mxCelState> that represents the terminal.
           * edge - <mxCellState> that represents the edge.
           * source - Boolean that specifies if the terminal is the source terminal.
           * defaultValue - Default value to be returned.
           */
          getPortConstraints: function(terminal, edge, source, defaultValue) {
            var value = mxUtils.getValue(
              terminal.style,
              mxConstants.STYLE_PORT_CONSTRAINT,
              mxUtils.getValue(edge.style, source ? mxConstants.STYLE_SOURCE_PORT_CONSTRAINT : mxConstants.STYLE_TARGET_PORT_CONSTRAINT, null)
            );
            if (value == null) {
              return defaultValue;
            } else {
              var directions = value.toString();
              var returnValue = mxConstants.DIRECTION_MASK_NONE;
              var constraintRotationEnabled = mxUtils.getValue(terminal.style, mxConstants.STYLE_PORT_CONSTRAINT_ROTATION, 0);
              var rotation = 0;
              if (constraintRotationEnabled == 1) {
                rotation = mxUtils.getValue(terminal.style, mxConstants.STYLE_ROTATION, 0);
              }
              var quad = 0;
              if (rotation > 45) {
                quad = 1;
                if (rotation >= 135) {
                  quad = 2;
                }
              } else if (rotation < -45) {
                quad = 3;
                if (rotation <= -135) {
                  quad = 2;
                }
              }
              if (directions.indexOf(mxConstants.DIRECTION_NORTH) >= 0) {
                switch (quad) {
                  case 0:
                    returnValue |= mxConstants.DIRECTION_MASK_NORTH;
                    break;
                  case 1:
                    returnValue |= mxConstants.DIRECTION_MASK_EAST;
                    break;
                  case 2:
                    returnValue |= mxConstants.DIRECTION_MASK_SOUTH;
                    break;
                  case 3:
                    returnValue |= mxConstants.DIRECTION_MASK_WEST;
                    break;
                }
              }
              if (directions.indexOf(mxConstants.DIRECTION_WEST) >= 0) {
                switch (quad) {
                  case 0:
                    returnValue |= mxConstants.DIRECTION_MASK_WEST;
                    break;
                  case 1:
                    returnValue |= mxConstants.DIRECTION_MASK_NORTH;
                    break;
                  case 2:
                    returnValue |= mxConstants.DIRECTION_MASK_EAST;
                    break;
                  case 3:
                    returnValue |= mxConstants.DIRECTION_MASK_SOUTH;
                    break;
                }
              }
              if (directions.indexOf(mxConstants.DIRECTION_SOUTH) >= 0) {
                switch (quad) {
                  case 0:
                    returnValue |= mxConstants.DIRECTION_MASK_SOUTH;
                    break;
                  case 1:
                    returnValue |= mxConstants.DIRECTION_MASK_WEST;
                    break;
                  case 2:
                    returnValue |= mxConstants.DIRECTION_MASK_NORTH;
                    break;
                  case 3:
                    returnValue |= mxConstants.DIRECTION_MASK_EAST;
                    break;
                }
              }
              if (directions.indexOf(mxConstants.DIRECTION_EAST) >= 0) {
                switch (quad) {
                  case 0:
                    returnValue |= mxConstants.DIRECTION_MASK_EAST;
                    break;
                  case 1:
                    returnValue |= mxConstants.DIRECTION_MASK_SOUTH;
                    break;
                  case 2:
                    returnValue |= mxConstants.DIRECTION_MASK_WEST;
                    break;
                  case 3:
                    returnValue |= mxConstants.DIRECTION_MASK_NORTH;
                    break;
                }
              }
              return returnValue;
            }
          },
          /**
           * Function: reversePortConstraints
           * 
           * Reverse the port constraint bitmask. For example, north | east
           * becomes south | west
           */
          reversePortConstraints: function(constraint) {
            var result2 = 0;
            result2 = (constraint & mxConstants.DIRECTION_MASK_WEST) << 3;
            result2 |= (constraint & mxConstants.DIRECTION_MASK_NORTH) << 1;
            result2 |= (constraint & mxConstants.DIRECTION_MASK_SOUTH) >> 1;
            result2 |= (constraint & mxConstants.DIRECTION_MASK_EAST) >> 3;
            return result2;
          },
          /**
           * Function: findNearestSegment
           * 
           * Finds the index of the nearest segment on the given cell state for
           * the specified coordinate pair.
           */
          findNearestSegment: function(state, x, y) {
            var index = -1;
            if (state.absolutePoints.length > 0) {
              var last = state.absolutePoints[0];
              var min = null;
              for (var i = 1; i < state.absolutePoints.length; i++) {
                var current = state.absolutePoints[i];
                var dist = mxUtils.ptSegDistSq(
                  last.x,
                  last.y,
                  current.x,
                  current.y,
                  x,
                  y
                );
                if (min == null || dist < min) {
                  min = dist;
                  index = i - 1;
                }
                last = current;
              }
            }
            return index;
          },
          /**
           * Function: getDirectedBounds
           * 
           * Adds the given margins to the given rectangle and rotates and flips the
           * rectangle according to the respective styles in style.
           */
          getDirectedBounds: function(rect, m, style, flipH, flipV) {
            var d = mxUtils.getValue(style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
            flipH = flipH != null ? flipH : mxUtils.getValue(style, mxConstants.STYLE_FLIPH, false);
            flipV = flipV != null ? flipV : mxUtils.getValue(style, mxConstants.STYLE_FLIPV, false);
            m.x = Math.round(Math.max(0, Math.min(rect.width, m.x)));
            m.y = Math.round(Math.max(0, Math.min(rect.height, m.y)));
            m.width = Math.round(Math.max(0, Math.min(rect.width, m.width)));
            m.height = Math.round(Math.max(0, Math.min(rect.height, m.height)));
            if (flipV && (d == mxConstants.DIRECTION_SOUTH || d == mxConstants.DIRECTION_NORTH) || flipH && (d == mxConstants.DIRECTION_EAST || d == mxConstants.DIRECTION_WEST)) {
              var tmp = m.x;
              m.x = m.width;
              m.width = tmp;
            }
            if (flipH && (d == mxConstants.DIRECTION_SOUTH || d == mxConstants.DIRECTION_NORTH) || flipV && (d == mxConstants.DIRECTION_EAST || d == mxConstants.DIRECTION_WEST)) {
              var tmp = m.y;
              m.y = m.height;
              m.height = tmp;
            }
            var m2 = mxRectangle.fromRectangle(m);
            if (d == mxConstants.DIRECTION_SOUTH) {
              m2.y = m.x;
              m2.x = m.height;
              m2.width = m.y;
              m2.height = m.width;
            } else if (d == mxConstants.DIRECTION_WEST) {
              m2.y = m.height;
              m2.x = m.width;
              m2.width = m.x;
              m2.height = m.y;
            } else if (d == mxConstants.DIRECTION_NORTH) {
              m2.y = m.width;
              m2.x = m.y;
              m2.width = m.height;
              m2.height = m.x;
            }
            return new mxRectangle(rect.x + m2.x, rect.y + m2.y, rect.width - m2.width - m2.x, rect.height - m2.height - m2.y);
          },
          /**
           * Function: getPerimeterPoint
           * 
           * Returns the intersection between the polygon defined by the array of
           * points and the line between center and point.
           */
          getPerimeterPoint: function(pts, center, point) {
            var min = null;
            for (var i = 0; i < pts.length - 1; i++) {
              var pt = mxUtils.intersection(
                pts[i].x,
                pts[i].y,
                pts[i + 1].x,
                pts[i + 1].y,
                center.x,
                center.y,
                point.x,
                point.y
              );
              if (pt != null) {
                var dx = point.x - pt.x;
                var dy = point.y - pt.y;
                var ip = { p: pt, distSq: dy * dy + dx * dx };
                if (ip != null && (min == null || min.distSq > ip.distSq)) {
                  min = ip;
                }
              }
            }
            return min != null ? min.p : null;
          },
          /**
           * Function: rectangleIntersectsSegment
           * 
           * Returns true if the given rectangle intersects the given segment.
           * 
           * Parameters:
           * 
           * bounds - <mxRectangle> that represents the rectangle.
           * p1 - <mxPoint> that represents the first point of the segment.
           * p2 - <mxPoint> that represents the second point of the segment.
           */
          rectangleIntersectsSegment: function(bounds, p1, p2) {
            var top = bounds.y;
            var left = bounds.x;
            var bottom = top + bounds.height;
            var right = left + bounds.width;
            var minX = p1.x;
            var maxX = p2.x;
            if (p1.x > p2.x) {
              minX = p2.x;
              maxX = p1.x;
            }
            if (maxX > right) {
              maxX = right;
            }
            if (minX < left) {
              minX = left;
            }
            if (minX > maxX) {
              return false;
            }
            var minY = p1.y;
            var maxY = p2.y;
            var dx = p2.x - p1.x;
            if (Math.abs(dx) > 1e-7) {
              var a = (p2.y - p1.y) / dx;
              var b = p1.y - a * p1.x;
              minY = a * minX + b;
              maxY = a * maxX + b;
            }
            if (minY > maxY) {
              var tmp = maxY;
              maxY = minY;
              minY = tmp;
            }
            if (maxY > bottom) {
              maxY = bottom;
            }
            if (minY < top) {
              minY = top;
            }
            if (minY > maxY) {
              return false;
            }
            return true;
          },
          /**
           * Function: contains
           * 
           * Returns true if the specified point (x, y) is contained in the given rectangle.
           * 
           * Parameters:
           * 
           * bounds - <mxRectangle> that represents the area.
           * x - X-coordinate of the point.
           * y - Y-coordinate of the point.
           */
          contains: function(bounds, x, y) {
            return bounds.x <= x && bounds.x + bounds.width >= x && bounds.y <= y && bounds.y + bounds.height >= y;
          },
          /**
           * Function: intersects
           * 
           * Returns true if the two rectangles intersect.
           * 
           * Parameters:
           * 
           * a - <mxRectangle> to be checked for intersection.
           * b - <mxRectangle> to be checked for intersection.
           */
          intersects: function(a, b) {
            var tw = a.width;
            var th = a.height;
            var rw = b.width;
            var rh = b.height;
            if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {
              return false;
            }
            var tx = a.x;
            var ty = a.y;
            var rx = b.x;
            var ry = b.y;
            rw += rx;
            rh += ry;
            tw += tx;
            th += ty;
            return (rw < rx || rw > tx) && (rh < ry || rh > ty) && (tw < tx || tw > rx) && (th < ty || th > ry);
          },
          /**
           * Function: intersectsHotspot
           * 
           * Returns true if the state and the hotspot intersect.
           * 
           * Parameters:
           * 
           * state - <mxCellState>
           * x - X-coordinate.
           * y - Y-coordinate.
           * hotspot - Optional size of the hostpot.
           * min - Optional min size of the hostpot.
           * max - Optional max size of the hostpot.
           */
          intersectsHotspot: function(state, x, y, hotspot, min, max) {
            hotspot = hotspot != null ? hotspot : 1;
            min = min != null ? min : 0;
            max = max != null ? max : 0;
            if (hotspot > 0) {
              var cx = state.getCenterX();
              var cy = state.getCenterY();
              var w2 = state.width;
              var h2 = state.height;
              var start = mxUtils.getValue(state.style, mxConstants.STYLE_STARTSIZE) * state.view.scale;
              if (start > 0) {
                if (mxUtils.getValue(state.style, mxConstants.STYLE_HORIZONTAL, true)) {
                  cy = state.y + start / 2;
                  h2 = start;
                } else {
                  cx = state.x + start / 2;
                  w2 = start;
                }
              }
              w2 = Math.max(min, w2 * hotspot);
              h2 = Math.max(min, h2 * hotspot);
              if (max > 0) {
                w2 = Math.min(w2, max);
                h2 = Math.min(h2, max);
              }
              var rect = new mxRectangle(cx - w2 / 2, cy - h2 / 2, w2, h2);
              var alpha = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0);
              if (alpha != 0) {
                var cos = Math.cos(-alpha);
                var sin = Math.sin(-alpha);
                var cx = new mxPoint(state.getCenterX(), state.getCenterY());
                var pt = mxUtils.getRotatedPoint(new mxPoint(x, y), cos, sin, cx);
                x = pt.x;
                y = pt.y;
              }
              return mxUtils.contains(rect, x, y);
            }
            return true;
          },
          /**
           * Function: getOffset
           * 
           * Returns the offset for the specified container as an <mxPoint>. The
           * offset is the distance from the top left corner of the container to the
           * top left corner of the document.
           * 
           * Parameters:
           * 
           * container - DOM node to return the offset for.
           * scollOffset - Optional boolean to add the scroll offset of the document.
           * Default is false.
           */
          getOffset: function(container, scrollOffset) {
            var offsetLeft = 0;
            var offsetTop = 0;
            var fixed = false;
            var node = container;
            var b = document.body;
            var d = document.documentElement;
            while (node != null && node != b && node != d && !fixed) {
              var style = mxUtils.getCurrentStyle(node);
              if (style != null) {
                fixed = fixed || style.position == "fixed";
              }
              node = node.parentNode;
            }
            if (!scrollOffset && !fixed) {
              var offset = mxUtils.getDocumentScrollOrigin(container.ownerDocument);
              offsetLeft += offset.x;
              offsetTop += offset.y;
            }
            var r = container.getBoundingClientRect();
            if (r != null) {
              offsetLeft += r.left;
              offsetTop += r.top;
            }
            return new mxPoint(offsetLeft, offsetTop);
          },
          /**
           * Function: getDocumentScrollOrigin
           * 
           * Returns the scroll origin of the given document or the current document
           * if no document is given.
           */
          getDocumentScrollOrigin: function(doc) {
            if (mxClient.IS_QUIRKS) {
              return new mxPoint(doc.body.scrollLeft, doc.body.scrollTop);
            } else {
              var wnd = doc.defaultView || doc.parentWindow;
              var x = wnd != null && window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
              var y = wnd != null && window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
              return new mxPoint(x, y);
            }
          },
          /**
           * Function: getScrollOrigin
           * 
           * Returns the top, left corner of the viewrect as an <mxPoint>.
           * 
           * Parameters:
           * 
           * node - DOM node whose scroll origin should be returned.
           * includeAncestors - Whether the scroll origin of the ancestors should be
           * included. Default is false.
           * includeDocument - Whether the scroll origin of the document should be
           * included. Default is true.
           */
          getScrollOrigin: function(node, includeAncestors, includeDocument) {
            includeAncestors = includeAncestors != null ? includeAncestors : false;
            includeDocument = includeDocument != null ? includeDocument : true;
            var doc = node != null ? node.ownerDocument : document;
            var b = doc.body;
            var d = doc.documentElement;
            var result2 = new mxPoint();
            var fixed = false;
            while (node != null && node != b && node != d) {
              if (!isNaN(node.scrollLeft) && !isNaN(node.scrollTop)) {
                result2.x += node.scrollLeft;
                result2.y += node.scrollTop;
              }
              var style = mxUtils.getCurrentStyle(node);
              if (style != null) {
                fixed = fixed || style.position == "fixed";
              }
              node = includeAncestors ? node.parentNode : null;
            }
            if (!fixed && includeDocument) {
              var origin = mxUtils.getDocumentScrollOrigin(doc);
              result2.x += origin.x;
              result2.y += origin.y;
            }
            return result2;
          },
          /**
           * Function: convertPoint
           * 
           * Converts the specified point (x, y) using the offset of the specified
           * container and returns a new <mxPoint> with the result.
           * 
           * (code)
           * var pt = mxUtils.convertPoint(graph.container,
           *   mxEvent.getClientX(evt), mxEvent.getClientY(evt));
           * (end)
           * 
           * Parameters:
           * 
           * container - DOM node to use for the offset.
           * x - X-coordinate of the point to be converted.
           * y - Y-coordinate of the point to be converted.
           */
          convertPoint: function(container, x, y) {
            var origin = mxUtils.getScrollOrigin(container, false);
            var offset = mxUtils.getOffset(container);
            offset.x -= origin.x;
            offset.y -= origin.y;
            return new mxPoint(x - offset.x, y - offset.y);
          },
          /**
           * Function: ltrim
           * 
           * Strips all whitespaces from the beginning of the string. Without the
           * second parameter, this will trim these characters:
           * 
           * - " " (ASCII 32 (0x20)), an ordinary space
           * - "\t" (ASCII 9 (0x09)), a tab
           * - "\n" (ASCII 10 (0x0A)), a new line (line feed)
           * - "\r" (ASCII 13 (0x0D)), a carriage return
           * - "\0" (ASCII 0 (0x00)), the NUL-byte
           * - "\x0B" (ASCII 11 (0x0B)), a vertical tab
           */
          ltrim: function(str, chars) {
            chars = chars || "\\s";
            return str != null ? str.replace(new RegExp("^[" + chars + "]+", "g"), "") : null;
          },
          /**
           * Function: rtrim
           * 
           * Strips all whitespaces from the end of the string. Without the second
           * parameter, this will trim these characters:
           * 
           * - " " (ASCII 32 (0x20)), an ordinary space
           * - "\t" (ASCII 9 (0x09)), a tab
           * - "\n" (ASCII 10 (0x0A)), a new line (line feed)
           * - "\r" (ASCII 13 (0x0D)), a carriage return
           * - "\0" (ASCII 0 (0x00)), the NUL-byte
           * - "\x0B" (ASCII 11 (0x0B)), a vertical tab
           */
          rtrim: function(str, chars) {
            chars = chars || "\\s";
            return str != null ? str.replace(new RegExp("[" + chars + "]+$", "g"), "") : null;
          },
          /**
           * Function: trim
           * 
           * Strips all whitespaces from both end of the string.
           * Without the second parameter, Javascript function will trim these
           * characters:
           * 
           * - " " (ASCII 32 (0x20)), an ordinary space
           * - "\t" (ASCII 9 (0x09)), a tab
           * - "\n" (ASCII 10 (0x0A)), a new line (line feed)
           * - "\r" (ASCII 13 (0x0D)), a carriage return
           * - "\0" (ASCII 0 (0x00)), the NUL-byte
           * - "\x0B" (ASCII 11 (0x0B)), a vertical tab
           */
          trim: function(str, chars) {
            return mxUtils.ltrim(mxUtils.rtrim(str, chars), chars);
          },
          /**
           * Function: isNumeric
           * 
           * Returns true if the specified value is numeric, that is, if it is not
           * null, not an empty string, not a HEX number and isNaN returns false.
           * 
           * Parameters:
           * 
           * n - String representing the possibly numeric value.
           */
          isNumeric: function(n) {
            return !isNaN(parseFloat(n)) && isFinite(n) && (typeof n != "string" || n.toLowerCase().indexOf("0x") < 0);
          },
          /**
           * Function: isInteger
           * 
           * Returns true if the given value is an valid integer number.
           * 
           * Parameters:
           * 
           * n - String representing the possibly numeric value.
           */
          isInteger: function(n) {
            return String(parseInt(n)) === String(n);
          },
          /**
           * Function: mod
           * 
           * Returns the remainder of division of n by m. You should use this instead
           * of the built-in operation as the built-in operation does not properly
           * handle negative numbers.
           */
          mod: function(n, m) {
            return (n % m + m) % m;
          },
          /**
           * Function: intersection
           * 
           * Returns the intersection of two lines as an <mxPoint>.
           * 
           * Parameters:
           * 
           * x0 - X-coordinate of the first line's startpoint.
           * y0 - X-coordinate of the first line's startpoint.
           * x1 - X-coordinate of the first line's endpoint.
           * y1 - Y-coordinate of the first line's endpoint.
           * x2 - X-coordinate of the second line's startpoint.
           * y2 - Y-coordinate of the second line's startpoint.
           * x3 - X-coordinate of the second line's endpoint.
           * y3 - Y-coordinate of the second line's endpoint.
           */
          intersection: function(x0, y0, x1, y1, x2, y2, x3, y3) {
            var denom = (y3 - y2) * (x1 - x0) - (x3 - x2) * (y1 - y0);
            var nume_a = (x3 - x2) * (y0 - y2) - (y3 - y2) * (x0 - x2);
            var nume_b = (x1 - x0) * (y0 - y2) - (y1 - y0) * (x0 - x2);
            var ua = nume_a / denom;
            var ub = nume_b / denom;
            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
              var x = x0 + ua * (x1 - x0);
              var y = y0 + ua * (y1 - y0);
              return new mxPoint(x, y);
            }
            return null;
          },
          /**
           * Function: ptSegDistSq
           * 
           * Returns the square distance between a segment and a point. To get the
           * distance between a point and a line (with infinite length) use
           * <mxUtils.ptLineDist>.
           * 
           * Parameters:
           * 
           * x1 - X-coordinate of the startpoint of the segment.
           * y1 - Y-coordinate of the startpoint of the segment.
           * x2 - X-coordinate of the endpoint of the segment.
           * y2 - Y-coordinate of the endpoint of the segment.
           * px - X-coordinate of the point.
           * py - Y-coordinate of the point.
           */
          ptSegDistSq: function(x1, y1, x2, y2, px2, py) {
            x2 -= x1;
            y2 -= y1;
            px2 -= x1;
            py -= y1;
            var dotprod = px2 * x2 + py * y2;
            var projlenSq;
            if (dotprod <= 0) {
              projlenSq = 0;
            } else {
              px2 = x2 - px2;
              py = y2 - py;
              dotprod = px2 * x2 + py * y2;
              if (dotprod <= 0) {
                projlenSq = 0;
              } else {
                projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
              }
            }
            var lenSq = px2 * px2 + py * py - projlenSq;
            if (lenSq < 0) {
              lenSq = 0;
            }
            return lenSq;
          },
          /**
           * Function: ptLineDist
           * 
           * Returns the distance between a line defined by two points and a point.
           * To get the distance between a point and a segment (with a specific
           * length) use <mxUtils.ptSeqDistSq>.
           * 
           * Parameters:
           * 
           * x1 - X-coordinate of point 1 of the line.
           * y1 - Y-coordinate of point 1 of the line.
           * x2 - X-coordinate of point 1 of the line.
           * y2 - Y-coordinate of point 1 of the line.
           * px - X-coordinate of the point.
           * py - Y-coordinate of the point.
           */
          ptLineDist: function(x1, y1, x2, y2, px2, py) {
            return Math.abs((y2 - y1) * px2 - (x2 - x1) * py + x2 * y1 - y2 * x1) / Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
          },
          /**
           * Function: relativeCcw
           * 
           * Returns 1 if the given point on the right side of the segment, 0 if its
           * on the segment, and -1 if the point is on the left side of the segment.
           * 
           * Parameters:
           * 
           * x1 - X-coordinate of the startpoint of the segment.
           * y1 - Y-coordinate of the startpoint of the segment.
           * x2 - X-coordinate of the endpoint of the segment.
           * y2 - Y-coordinate of the endpoint of the segment.
           * px - X-coordinate of the point.
           * py - Y-coordinate of the point.
           */
          relativeCcw: function(x1, y1, x2, y2, px2, py) {
            x2 -= x1;
            y2 -= y1;
            px2 -= x1;
            py -= y1;
            var ccw = px2 * y2 - py * x2;
            if (ccw == 0) {
              ccw = px2 * x2 + py * y2;
              if (ccw > 0) {
                px2 -= x2;
                py -= y2;
                ccw = px2 * x2 + py * y2;
                if (ccw < 0) {
                  ccw = 0;
                }
              }
            }
            return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
          },
          /**
           * Function: animateChanges
           * 
           * See <mxEffects.animateChanges>. This is for backwards compatibility and
           * will be removed later.
           */
          animateChanges: function(graph, changes) {
            mxEffects.animateChanges.apply(this, arguments);
          },
          /**
           * Function: cascadeOpacity
           * 
           * See <mxEffects.cascadeOpacity>. This is for backwards compatibility and
           * will be removed later.
           */
          cascadeOpacity: function(graph, cell2, opacity) {
            mxEffects.cascadeOpacity.apply(this, arguments);
          },
          /**
           * Function: fadeOut
           * 
           * See <mxEffects.fadeOut>. This is for backwards compatibility and
           * will be removed later.
           */
          fadeOut: function(node, from, remove, step, delay, isEnabled) {
            mxEffects.fadeOut.apply(this, arguments);
          },
          /**
           * Function: setOpacity
           * 
           * Sets the opacity of the specified DOM node to the given value in %.
           * 
           * Parameters:
           * 
           * node - DOM node to set the opacity for.
           * value - Opacity in %. Possible values are between 0 and 100.
           */
          setOpacity: function(node, value) {
            if (mxUtils.isVml(node)) {
              if (value >= 100) {
                node.style.filter = "";
              } else {
                node.style.filter = "alpha(opacity=" + value / 5 + ")";
              }
            } else if (mxClient.IS_IE && (typeof document.documentMode === "undefined" || document.documentMode < 9)) {
              if (value >= 100) {
                node.style.filter = "";
              } else {
                node.style.filter = "alpha(opacity=" + value + ")";
              }
            } else {
              node.style.opacity = value / 100;
            }
          },
          /**
           * Function: createImage
           * 
           * Creates and returns an image (IMG node) or VML image (v:image) in IE6 in
           * quirks mode.
           * 
           * Parameters:
           * 
           * src - URL that points to the image to be displayed.
           */
          createImage: function(src) {
            var imageNode = null;
            if (mxClient.IS_IE6 && document.compatMode != "CSS1Compat") {
              imageNode = document.createElement(mxClient.VML_PREFIX + ":image");
              imageNode.setAttribute("src", src);
              imageNode.style.borderStyle = "none";
            } else {
              imageNode = document.createElement("img");
              imageNode.setAttribute("src", src);
              imageNode.setAttribute("border", "0");
            }
            return imageNode;
          },
          /**
           * Function: sortCells
           * 
           * Sorts the given cells according to the order in the cell hierarchy.
           * Ascending is optional and defaults to true.
           */
          sortCells: function(cells, ascending) {
            ascending = ascending != null ? ascending : true;
            var lookup = new mxDictionary();
            cells.sort(function(o1, o2) {
              var p1 = lookup.get(o1);
              if (p1 == null) {
                p1 = mxCellPath.create(o1).split(mxCellPath.PATH_SEPARATOR);
                lookup.put(o1, p1);
              }
              var p2 = lookup.get(o2);
              if (p2 == null) {
                p2 = mxCellPath.create(o2).split(mxCellPath.PATH_SEPARATOR);
                lookup.put(o2, p2);
              }
              var comp = mxCellPath.compare(p1, p2);
              return comp == 0 ? 0 : comp > 0 == ascending ? 1 : -1;
            });
            return cells;
          },
          /**
           * Function: getStylename
           * 
           * Returns the stylename in a style of the form [(stylename|key=value);] or
           * an empty string if the given style does not contain a stylename.
           * 
           * Parameters:
           * 
           * style - String of the form [(stylename|key=value);].
           */
          getStylename: function(style) {
            if (style != null) {
              var pairs = style.split(";");
              var stylename = pairs[0];
              if (stylename.indexOf("=") < 0) {
                return stylename;
              }
            }
            return "";
          },
          /**
           * Function: getStylenames
           * 
           * Returns the stylenames in a style of the form [(stylename|key=value);]
           * or an empty array if the given style does not contain any stylenames.
           * 
           * Parameters:
           * 
           * style - String of the form [(stylename|key=value);].
           */
          getStylenames: function(style) {
            var result2 = [];
            if (style != null) {
              var pairs = style.split(";");
              for (var i = 0; i < pairs.length; i++) {
                if (pairs[i].indexOf("=") < 0) {
                  result2.push(pairs[i]);
                }
              }
            }
            return result2;
          },
          /**
           * Function: indexOfStylename
           * 
           * Returns the index of the given stylename in the given style. This
           * returns -1 if the given stylename does not occur (as a stylename) in the
           * given style, otherwise it returns the index of the first character.
           */
          indexOfStylename: function(style, stylename) {
            if (style != null && stylename != null) {
              var tokens = style.split(";");
              var pos = 0;
              for (var i = 0; i < tokens.length; i++) {
                if (tokens[i] == stylename) {
                  return pos;
                }
                pos += tokens[i].length + 1;
              }
            }
            return -1;
          },
          /**
           * Function: addStylename
           * 
           * Adds the specified stylename to the given style if it does not already
           * contain the stylename.
           */
          addStylename: function(style, stylename) {
            if (mxUtils.indexOfStylename(style, stylename) < 0) {
              if (style == null) {
                style = "";
              } else if (style.length > 0 && style.charAt(style.length - 1) != ";") {
                style += ";";
              }
              style += stylename;
            }
            return style;
          },
          /**
           * Function: removeStylename
           * 
           * Removes all occurrences of the specified stylename in the given style
           * and returns the updated style. Trailing semicolons are not preserved.
           */
          removeStylename: function(style, stylename) {
            var result2 = [];
            if (style != null) {
              var tokens = style.split(";");
              for (var i = 0; i < tokens.length; i++) {
                if (tokens[i] != stylename) {
                  result2.push(tokens[i]);
                }
              }
            }
            return result2.join(";");
          },
          /**
           * Function: removeAllStylenames
           * 
           * Removes all stylenames from the given style and returns the updated
           * style.
           */
          removeAllStylenames: function(style) {
            var result2 = [];
            if (style != null) {
              var tokens = style.split(";");
              for (var i = 0; i < tokens.length; i++) {
                if (tokens[i].indexOf("=") >= 0) {
                  result2.push(tokens[i]);
                }
              }
            }
            return result2.join(";");
          },
          /**
           * Function: setCellStyles
           * 
           * Assigns the value for the given key in the styles of the given cells, or
           * removes the key from the styles if the value is null.
           * 
           * Parameters:
           * 
           * model - <mxGraphModel> to execute the transaction in.
           * cells - Array of <mxCells> to be updated.
           * key - Key of the style to be changed.
           * value - New value for the given key.
           */
          setCellStyles: function(model, cells, key, value) {
            if (cells != null && cells.length > 0) {
              model.beginUpdate();
              try {
                for (var i = 0; i < cells.length; i++) {
                  if (cells[i] != null) {
                    var style = mxUtils.setStyle(model.getStyle(cells[i]), key, value);
                    model.setStyle(cells[i], style);
                  }
                }
              } finally {
                model.endUpdate();
              }
            }
          },
          /**
           * Function: setStyle
           * 
           * Adds or removes the given key, value pair to the style and returns the
           * new style. If value is null or zero length then the key is removed from
           * the style. This is for cell styles, not for CSS styles.
           * 
           * Parameters:
           * 
           * style - String of the form [(stylename|key=value);].
           * key - Key of the style to be changed.
           * value - New value for the given key.
           */
          setStyle: function(style, key, value) {
            var isValue = value != null && (typeof value.length == "undefined" || value.length > 0);
            if (style == null || style.length == 0) {
              if (isValue) {
                style = key + "=" + value + ";";
              }
            } else {
              if (style.substring(0, key.length + 1) == key + "=") {
                var next = style.indexOf(";");
                if (isValue) {
                  style = key + "=" + value + (next < 0 ? ";" : style.substring(next));
                } else {
                  style = next < 0 || next == style.length - 1 ? "" : style.substring(next + 1);
                }
              } else {
                var index = style.indexOf(";" + key + "=");
                if (index < 0) {
                  if (isValue) {
                    var sep = style.charAt(style.length - 1) == ";" ? "" : ";";
                    style = style + sep + key + "=" + value + ";";
                  }
                } else {
                  var next = style.indexOf(";", index + 1);
                  if (isValue) {
                    style = style.substring(0, index + 1) + key + "=" + value + (next < 0 ? ";" : style.substring(next));
                  } else {
                    style = style.substring(0, index) + (next < 0 ? ";" : style.substring(next));
                  }
                }
              }
            }
            return style;
          },
          /**
           * Function: setCellStyleFlags
           * 
           * Sets or toggles the flag bit for the given key in the cell's styles.
           * If value is null then the flag is toggled.
           * 
           * Example:
           * 
           * (code)
           * var cells = graph.getSelectionCells();
           * mxUtils.setCellStyleFlags(graph.model,
           * 			cells,
           * 			mxConstants.STYLE_FONTSTYLE,
           * 			mxConstants.FONT_BOLD);
           * (end)
           * 
           * Toggles the bold font style.
           * 
           * Parameters:
           * 
           * model - <mxGraphModel> that contains the cells.
           * cells - Array of <mxCells> to change the style for.
           * key - Key of the style to be changed.
           * flag - Integer for the bit to be changed.
           * value - Optional boolean value for the flag.
           */
          setCellStyleFlags: function(model, cells, key, flag, value) {
            if (cells != null && cells.length > 0) {
              model.beginUpdate();
              try {
                for (var i = 0; i < cells.length; i++) {
                  if (cells[i] != null) {
                    var style = mxUtils.setStyleFlag(
                      model.getStyle(cells[i]),
                      key,
                      flag,
                      value
                    );
                    model.setStyle(cells[i], style);
                  }
                }
              } finally {
                model.endUpdate();
              }
            }
          },
          /**
           * Function: setStyleFlag
           * 
           * Sets or removes the given key from the specified style and returns the
           * new style. If value is null then the flag is toggled.
           * 
           * Parameters:
           * 
           * style - String of the form [(stylename|key=value);].
           * key - Key of the style to be changed.
           * flag - Integer for the bit to be changed.
           * value - Optional boolean value for the given flag.
           */
          setStyleFlag: function(style, key, flag, value) {
            if (style == null || style.length == 0) {
              if (value || value == null) {
                style = key + "=" + flag;
              } else {
                style = key + "=0";
              }
            } else {
              var index = style.indexOf(key + "=");
              if (index < 0) {
                var sep = style.charAt(style.length - 1) == ";" ? "" : ";";
                if (value || value == null) {
                  style = style + sep + key + "=" + flag;
                } else {
                  style = style + sep + key + "=0";
                }
              } else {
                var cont = style.indexOf(";", index);
                var tmp = "";
                if (cont < 0) {
                  tmp = style.substring(index + key.length + 1);
                } else {
                  tmp = style.substring(index + key.length + 1, cont);
                }
                if (value == null) {
                  tmp = parseInt(tmp) ^ flag;
                } else if (value) {
                  tmp = parseInt(tmp) | flag;
                } else {
                  tmp = parseInt(tmp) & ~flag;
                }
                style = style.substring(0, index) + key + "=" + tmp + (cont >= 0 ? style.substring(cont) : "");
              }
            }
            return style;
          },
          /**
           * Function: getAlignmentAsPoint
           * 
           * Returns an <mxPoint> that represents the horizontal and vertical alignment
           * for numeric computations. X is -0.5 for center, -1 for right and 0 for
           * left alignment. Y is -0.5 for middle, -1 for bottom and 0 for top
           * alignment. Default values for missing arguments is top, left.
           */
          getAlignmentAsPoint: function(align, valign) {
            var dx = -0.5;
            var dy = -0.5;
            if (align == mxConstants.ALIGN_LEFT) {
              dx = 0;
            } else if (align == mxConstants.ALIGN_RIGHT) {
              dx = -1;
            }
            if (valign == mxConstants.ALIGN_TOP) {
              dy = 0;
            } else if (valign == mxConstants.ALIGN_BOTTOM) {
              dy = -1;
            }
            return new mxPoint(dx, dy);
          },
          /**
           * Function: getSizeForString
           * 
           * Returns an <mxRectangle> with the size (width and height in pixels) of
           * the given string. The string may contain HTML markup. Newlines should be
           * converted to <br> before calling this method. The caller is responsible
           * for sanitizing the HTML markup.
           * 
           * Example:
           * 
           * (code)
           * var label = graph.getLabel(cell).replace(/\n/g, "<br>");
           * var size = graph.getSizeForString(label);
           * (end)
           * 
           * Parameters:
           * 
           * text - String whose size should be returned.
           * fontSize - Integer that specifies the font size in pixels. Default is
           * <mxConstants.DEFAULT_FONTSIZE>.
           * fontFamily - String that specifies the name of the font family. Default
           * is <mxConstants.DEFAULT_FONTFAMILY>.
           * textWidth - Optional width for text wrapping.
           * fontStyle - Optional font style.
           */
          getSizeForString: function(text, fontSize, fontFamily, textWidth, fontStyle) {
            fontSize = fontSize != null ? fontSize : mxConstants.DEFAULT_FONTSIZE;
            fontFamily = fontFamily != null ? fontFamily : mxConstants.DEFAULT_FONTFAMILY;
            var div = document.createElement("div");
            div.style.fontFamily = fontFamily;
            div.style.fontSize = Math.round(fontSize) + "px";
            div.style.lineHeight = Math.round(fontSize * mxConstants.LINE_HEIGHT) + "px";
            if (fontStyle != null) {
              if ((fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
                div.style.fontWeight = "bold";
              }
              if ((fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
                div.style.fontStyle = "italic";
              }
              var txtDecor = [];
              if ((fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
                txtDecor.push("underline");
              }
              if ((fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
                txtDecor.push("line-through");
              }
              if (txtDecor.length > 0) {
                div.style.textDecoration = txtDecor.join(" ");
              }
            }
            div.style.position = "absolute";
            div.style.visibility = "hidden";
            div.style.display = mxClient.IS_QUIRKS ? "inline" : "inline-block";
            div.style.zoom = "1";
            if (textWidth != null) {
              div.style.width = textWidth + "px";
              div.style.whiteSpace = "normal";
            } else {
              div.style.whiteSpace = "nowrap";
            }
            div.innerHTML = text;
            document.body.appendChild(div);
            var size = new mxRectangle(0, 0, div.offsetWidth, div.offsetHeight);
            document.body.removeChild(div);
            return size;
          },
          /**
           * Function: getViewXml
           */
          getViewXml: function(graph, scale, cells, x0, y0) {
            x0 = x0 != null ? x0 : 0;
            y0 = y0 != null ? y0 : 0;
            scale = scale != null ? scale : 1;
            if (cells == null) {
              var model = graph.getModel();
              cells = [model.getRoot()];
            }
            var view = graph.getView();
            var result2 = null;
            var eventsEnabled = view.isEventsEnabled();
            view.setEventsEnabled(false);
            var drawPane = view.drawPane;
            var overlayPane = view.overlayPane;
            if (graph.dialect == mxConstants.DIALECT_SVG) {
              view.drawPane = document.createElementNS(mxConstants.NS_SVG, "g");
              view.canvas.appendChild(view.drawPane);
              view.overlayPane = document.createElementNS(mxConstants.NS_SVG, "g");
              view.canvas.appendChild(view.overlayPane);
            } else {
              view.drawPane = view.drawPane.cloneNode(false);
              view.canvas.appendChild(view.drawPane);
              view.overlayPane = view.overlayPane.cloneNode(false);
              view.canvas.appendChild(view.overlayPane);
            }
            var translate = view.getTranslate();
            view.translate = new mxPoint(x0, y0);
            var temp = new mxTemporaryCellStates(graph.getView(), scale, cells);
            try {
              var enc = new mxCodec();
              result2 = enc.encode(graph.getView());
            } finally {
              temp.destroy();
              view.translate = translate;
              view.canvas.removeChild(view.drawPane);
              view.canvas.removeChild(view.overlayPane);
              view.drawPane = drawPane;
              view.overlayPane = overlayPane;
              view.setEventsEnabled(eventsEnabled);
            }
            return result2;
          },
          /**
           * Function: getScaleForPageCount
           * 
           * Returns the scale to be used for printing the graph with the given
           * bounds across the specifies number of pages with the given format. The
           * scale is always computed such that it given the given amount or fewer
           * pages in the print output. See <mxPrintPreview> for an example.
           * 
           * Parameters:
           * 
           * pageCount - Specifies the number of pages in the print output.
           * graph - <mxGraph> that should be printed.
           * pageFormat - Optional <mxRectangle> that specifies the page format.
           * Default is <mxConstants.PAGE_FORMAT_A4_PORTRAIT>.
           * border - The border along each side of every page.
           */
          getScaleForPageCount: function(pageCount, graph, pageFormat, border) {
            if (pageCount < 1) {
              return 1;
            }
            pageFormat = pageFormat != null ? pageFormat : mxConstants.PAGE_FORMAT_A4_PORTRAIT;
            border = border != null ? border : 0;
            var availablePageWidth = pageFormat.width - border * 2;
            var availablePageHeight = pageFormat.height - border * 2;
            var graphBounds = graph.getGraphBounds().clone();
            var sc = graph.getView().getScale();
            graphBounds.width /= sc;
            graphBounds.height /= sc;
            var graphWidth = graphBounds.width;
            var graphHeight = graphBounds.height;
            var scale = 1;
            var pageFormatAspectRatio = availablePageWidth / availablePageHeight;
            var graphAspectRatio = graphWidth / graphHeight;
            var pagesAspectRatio = graphAspectRatio / pageFormatAspectRatio;
            var pageRoot = Math.sqrt(pageCount);
            var pagesAspectRatioSqrt = Math.sqrt(pagesAspectRatio);
            var numRowPages = pageRoot * pagesAspectRatioSqrt;
            var numColumnPages = pageRoot / pagesAspectRatioSqrt;
            if (numRowPages < 1 && numColumnPages > pageCount) {
              var scaleChange = numColumnPages / pageCount;
              numColumnPages = pageCount;
              numRowPages /= scaleChange;
            }
            if (numColumnPages < 1 && numRowPages > pageCount) {
              var scaleChange = numRowPages / pageCount;
              numRowPages = pageCount;
              numColumnPages /= scaleChange;
            }
            var currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);
            var numLoops = 0;
            while (currentTotalPages > pageCount) {
              var roundRowDownProportion = Math.floor(numRowPages) / numRowPages;
              var roundColumnDownProportion = Math.floor(numColumnPages) / numColumnPages;
              if (roundRowDownProportion == 1) {
                roundRowDownProportion = Math.floor(numRowPages - 1) / numRowPages;
              }
              if (roundColumnDownProportion == 1) {
                roundColumnDownProportion = Math.floor(numColumnPages - 1) / numColumnPages;
              }
              var scaleChange = 1;
              if (roundRowDownProportion > roundColumnDownProportion) {
                scaleChange = roundRowDownProportion;
              } else {
                scaleChange = roundColumnDownProportion;
              }
              numRowPages = numRowPages * scaleChange;
              numColumnPages = numColumnPages * scaleChange;
              currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);
              numLoops++;
              if (numLoops > 10) {
                break;
              }
            }
            var posterWidth = availablePageWidth * numRowPages;
            scale = posterWidth / graphWidth;
            return scale * 0.99999;
          },
          /**
           * Function: show
           * 
           * Copies the styles and the markup from the graph's container into the
           * given document and removes all cursor styles. The document is returned.
           * 
           * This function should be called from within the document with the graph.
           * If you experience problems with missing stylesheets in IE then try adding
           * the domain to the trusted sites.
           * 
           * Parameters:
           * 
           * graph - <mxGraph> to be copied.
           * doc - Document where the new graph is created.
           * x0 - X-coordinate of the graph view origin. Default is 0.
           * y0 - Y-coordinate of the graph view origin. Default is 0.
           * w - Optional width of the graph view.
           * h - Optional height of the graph view.
           */
          show: function(graph, doc, x0, y0, w2, h2) {
            x0 = x0 != null ? x0 : 0;
            y0 = y0 != null ? y0 : 0;
            if (doc == null) {
              var wnd = window.open();
              doc = wnd.document;
            } else {
              doc.open();
            }
            if (document.documentMode == 9) {
              doc.writeln('<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=9"><![endif]-->');
            }
            var bounds = graph.getGraphBounds();
            var dx = Math.ceil(x0 - bounds.x);
            var dy = Math.ceil(y0 - bounds.y);
            if (w2 == null) {
              w2 = Math.ceil(bounds.width + x0) + Math.ceil(Math.ceil(bounds.x) - bounds.x);
            }
            if (h2 == null) {
              h2 = Math.ceil(bounds.height + y0) + Math.ceil(Math.ceil(bounds.y) - bounds.y);
            }
            if (mxClient.IS_IE || document.documentMode == 11) {
              var html = "<html><head>";
              var base = document.getElementsByTagName("base");
              for (var i = 0; i < base.length; i++) {
                html += base[i].outerHTML;
              }
              html += "<style>";
              for (var i = 0; i < document.styleSheets.length; i++) {
                try {
                  html += document.styleSheets[i].cssText;
                } catch (e) {
                }
              }
              html += '</style></head><body style="margin:0px;">';
              html += '<div style="position:absolute;overflow:hidden;width:' + w2 + "px;height:" + h2 + 'px;"><div style="position:relative;left:' + dx + "px;top:" + dy + 'px;">';
              html += graph.container.innerHTML;
              html += "</div></div></body><html>";
              doc.writeln(html);
              doc.close();
            } else {
              doc.writeln("<html><head>");
              var base = document.getElementsByTagName("base");
              for (var i = 0; i < base.length; i++) {
                doc.writeln(mxUtils.getOuterHtml(base[i]));
              }
              var links = document.getElementsByTagName("link");
              for (var i = 0; i < links.length; i++) {
                doc.writeln(mxUtils.getOuterHtml(links[i]));
              }
              var styles = document.getElementsByTagName("style");
              for (var i = 0; i < styles.length; i++) {
                doc.writeln(mxUtils.getOuterHtml(styles[i]));
              }
              doc.writeln('</head><body style="margin:0px;"></body></html>');
              doc.close();
              var outer = doc.createElement("div");
              outer.position = "absolute";
              outer.overflow = "hidden";
              outer.style.width = w2 + "px";
              outer.style.height = h2 + "px";
              var div = doc.createElement("div");
              div.style.position = "absolute";
              div.style.left = dx + "px";
              div.style.top = dy + "px";
              var node = graph.container.firstChild;
              var svg = null;
              while (node != null) {
                var clone = node.cloneNode(true);
                if (node == graph.view.drawPane.ownerSVGElement) {
                  outer.appendChild(clone);
                  svg = clone;
                } else {
                  div.appendChild(clone);
                }
                node = node.nextSibling;
              }
              doc.body.appendChild(outer);
              if (div.firstChild != null) {
                doc.body.appendChild(div);
              }
              if (svg != null) {
                svg.style.minWidth = "";
                svg.style.minHeight = "";
                svg.firstChild.setAttribute("transform", "translate(" + dx + "," + dy + ")");
              }
            }
            mxUtils.removeCursors(doc.body);
            return doc;
          },
          /**
           * Function: printScreen
           * 
           * Prints the specified graph using a new window and the built-in print
           * dialog.
           * 
           * This function should be called from within the document with the graph.
           * 
           * Parameters:
           * 
           * graph - <mxGraph> to be printed.
           */
          printScreen: function(graph) {
            var wnd = window.open();
            var bounds = graph.getGraphBounds();
            mxUtils.show(graph, wnd.document);
            var print = function() {
              wnd.focus();
              wnd.print();
              wnd.close();
            };
            if (mxClient.IS_GC) {
              wnd.setTimeout(print, 500);
            } else {
              print();
            }
          },
          /**
           * Function: popup
           * 
           * Shows the specified text content in a new <mxWindow> or a new browser
           * window if isInternalWindow is false.
           * 
           * Parameters:
           * 
           * content - String that specifies the text to be displayed.
           * isInternalWindow - Optional boolean indicating if an mxWindow should be
           * used instead of a new browser window. Default is false.
           */
          popup: function(content, isInternalWindow) {
            if (isInternalWindow) {
              var div = document.createElement("div");
              div.style.overflow = "scroll";
              div.style.width = "636px";
              div.style.height = "460px";
              var pre = document.createElement("pre");
              pre.innerHTML = mxUtils.htmlEntities(content, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
              div.appendChild(pre);
              var w2 = document.body.clientWidth;
              var h2 = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight);
              var wnd = new mxWindow(
                "Popup Window",
                div,
                w2 / 2 - 320,
                h2 / 2 - 240,
                640,
                480,
                false,
                true
              );
              wnd.setClosable(true);
              wnd.setVisible(true);
            } else {
              if (mxClient.IS_NS) {
                var wnd = window.open();
                wnd.document.writeln("<pre>" + mxUtils.htmlEntities(content) + "</pre");
                wnd.document.close();
              } else {
                var wnd = window.open();
                var pre = wnd.document.createElement("pre");
                pre.innerHTML = mxUtils.htmlEntities(content, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
                wnd.document.body.appendChild(pre);
              }
            }
          },
          /**
           * Function: alert
           * 
           * Displayss the given alert in a new dialog. This implementation uses the
           * built-in alert function. This is used to display validation errors when
           * connections cannot be changed or created.
           * 
           * Parameters:
           * 
           * message - String specifying the message to be displayed.
           */
          alert: function(message) {
            alert(message);
          },
          /**
           * Function: prompt
           * 
           * Displays the given message in a prompt dialog. This implementation uses
           * the built-in prompt function.
           * 
           * Parameters:
           * 
           * message - String specifying the message to be displayed.
           * defaultValue - Optional string specifying the default value.
           */
          prompt: function(message, defaultValue) {
            return prompt(message, defaultValue != null ? defaultValue : "");
          },
          /**
           * Function: confirm
           * 
           * Displays the given message in a confirm dialog. This implementation uses
           * the built-in confirm function.
           * 
           * Parameters:
           * 
           * message - String specifying the message to be displayed.
           */
          confirm: function(message) {
            return confirm(message);
          },
          /**
           * Function: error
           * 
           * Displays the given error message in a new <mxWindow> of the given width.
           * If close is true then an additional close button is added to the window.
           * The optional icon specifies the icon to be used for the window. Default
           * is <mxUtils.errorImage>.
           * 
           * Parameters:
           * 
           * message - String specifying the message to be displayed.
           * width - Integer specifying the width of the window.
           * close - Optional boolean indicating whether to add a close button.
           * icon - Optional icon for the window decoration.
           */
          error: function(message, width, close, icon) {
            var div = document.createElement("div");
            div.style.padding = "20px";
            var img = document.createElement("img");
            img.setAttribute("src", icon || mxUtils.errorImage);
            img.setAttribute("valign", "bottom");
            img.style.verticalAlign = "middle";
            div.appendChild(img);
            div.appendChild(document.createTextNode("\xA0"));
            div.appendChild(document.createTextNode("\xA0"));
            div.appendChild(document.createTextNode("\xA0"));
            mxUtils.write(div, message);
            var w2 = document.body.clientWidth;
            var h2 = document.body.clientHeight || document.documentElement.clientHeight;
            var warn = new mxWindow(
              mxResources.get(mxUtils.errorResource) || mxUtils.errorResource,
              div,
              (w2 - width) / 2,
              h2 / 4,
              width,
              null,
              false,
              true
            );
            if (close) {
              mxUtils.br(div);
              var tmp = document.createElement("p");
              var button = document.createElement("button");
              if (mxClient.IS_IE) {
                button.style.cssText = "float:right";
              } else {
                button.setAttribute("style", "float:right");
              }
              mxEvent.addListener(button, "click", function(evt) {
                warn.destroy();
              });
              mxUtils.write(button, mxResources.get(mxUtils.closeResource) || mxUtils.closeResource);
              tmp.appendChild(button);
              div.appendChild(tmp);
              mxUtils.br(div);
              warn.setClosable(true);
            }
            warn.setVisible(true);
            return warn;
          },
          /**
           * Function: makeDraggable
           * 
           * Configures the given DOM element to act as a drag source for the
           * specified graph. Returns a a new <mxDragSource>. If
           * <mxDragSource.guideEnabled> is enabled then the x and y arguments must
           * be used in funct to match the preview location.
           * 
           * Example:
           * 
           * (code)
           * var funct = function(graph, evt, cell, x, y)
           * {
           *   if (graph.canImportCell(cell))
           *   {
           *     var parent = graph.getDefaultParent();
           *     var vertex = null;
           *     
           *     graph.getModel().beginUpdate();
           *     try
           *     {
           * 	     vertex = graph.insertVertex(parent, null, 'Hello', x, y, 80, 30);
           *     }
           *     finally
           *     {
           *       graph.getModel().endUpdate();
           *     }
           *
           *     graph.setSelectionCell(vertex);
           *   }
           * }
           * 
           * var img = document.createElement('img');
           * img.setAttribute('src', 'editors/images/rectangle.gif');
           * img.style.position = 'absolute';
           * img.style.left = '0px';
           * img.style.top = '0px';
           * img.style.width = '16px';
           * img.style.height = '16px';
           * 
           * var dragImage = img.cloneNode(true);
           * dragImage.style.width = '32px';
           * dragImage.style.height = '32px';
           * mxUtils.makeDraggable(img, graph, funct, dragImage);
           * document.body.appendChild(img);
           * (end)
           * 
           * Parameters:
           * 
           * element - DOM element to make draggable.
           * graphF - <mxGraph> that acts as the drop target or a function that takes a
           * mouse event and returns the current <mxGraph>.
           * funct - Function to execute on a successful drop.
           * dragElement - Optional DOM node to be used for the drag preview.
           * dx - Optional horizontal offset between the cursor and the drag
           * preview.
           * dy - Optional vertical offset between the cursor and the drag
           * preview.
           * autoscroll - Optional boolean that specifies if autoscroll should be
           * used. Default is mxGraph.autoscroll.
           * scalePreview - Optional boolean that specifies if the preview element
           * should be scaled according to the graph scale. If this is true, then
           * the offsets will also be scaled. Default is false.
           * highlightDropTargets - Optional boolean that specifies if dropTargets
           * should be highlighted. Default is true.
           * getDropTarget - Optional function to return the drop target for a given
           * location (x, y). Default is mxGraph.getCellAt.
           */
          makeDraggable: function(element, graphF, funct, dragElement, dx, dy, autoscroll, scalePreview, highlightDropTargets, getDropTarget) {
            var dragSource = new mxDragSource(element, funct);
            dragSource.dragOffset = new mxPoint(
              dx != null ? dx : 0,
              dy != null ? dy : mxConstants.TOOLTIP_VERTICAL_OFFSET
            );
            dragSource.autoscroll = autoscroll;
            dragSource.setGuidesEnabled(false);
            if (highlightDropTargets != null) {
              dragSource.highlightDropTargets = highlightDropTargets;
            }
            if (getDropTarget != null) {
              dragSource.getDropTarget = getDropTarget;
            }
            dragSource.getGraphForEvent = function(evt) {
              return typeof graphF == "function" ? graphF(evt) : graphF;
            };
            if (dragElement != null) {
              dragSource.createDragElement = function() {
                return dragElement.cloneNode(true);
              };
              if (scalePreview) {
                dragSource.createPreviewElement = function(graph) {
                  var elt = dragElement.cloneNode(true);
                  var w2 = parseInt(elt.style.width);
                  var h2 = parseInt(elt.style.height);
                  elt.style.width = Math.round(w2 * graph.view.scale) + "px";
                  elt.style.height = Math.round(h2 * graph.view.scale) + "px";
                  return elt;
                };
              }
            }
            return dragSource;
          }
        };
        __mxOutput.mxUtils = typeof mxUtils !== "undefined" ? mxUtils : void 0;
        var mxConstants = {
          /**
           * Class: mxConstants
           * 
           * Defines various global constants.
           * 
           * Variable: DEFAULT_HOTSPOT
           * 
           * Defines the portion of the cell which is to be used as a connectable
           * region. Default is 0.3. Possible values are 0 < x <= 1. 
           */
          DEFAULT_HOTSPOT: 0.3,
          /**
           * Variable: MIN_HOTSPOT_SIZE
           * 
           * Defines the minimum size in pixels of the portion of the cell which is
           * to be used as a connectable region. Default is 8.
           */
          MIN_HOTSPOT_SIZE: 8,
          /**
           * Variable: MAX_HOTSPOT_SIZE
           * 
           * Defines the maximum size in pixels of the portion of the cell which is
           * to be used as a connectable region. Use 0 for no maximum. Default is 0.
           */
          MAX_HOTSPOT_SIZE: 0,
          /**
           * Variable: RENDERING_HINT_EXACT
           * 
           * Defines the exact rendering hint.
           */
          RENDERING_HINT_EXACT: "exact",
          /**
           * Variable: RENDERING_HINT_FASTER
           * 
           * Defines the faster rendering hint.
           */
          RENDERING_HINT_FASTER: "faster",
          /**
           * Variable: RENDERING_HINT_FASTEST
           * 
           * Defines the fastest rendering hint.
           */
          RENDERING_HINT_FASTEST: "fastest",
          /**
           * Variable: DIALECT_SVG
           * 
           * Defines the SVG display dialect name.
           */
          DIALECT_SVG: "svg",
          /**
           * Variable: DIALECT_VML
           * 
           * Defines the VML display dialect name.
           */
          DIALECT_VML: "vml",
          /**
           * Variable: DIALECT_MIXEDHTML
           * 
           * Defines the mixed HTML display dialect name.
           */
          DIALECT_MIXEDHTML: "mixedHtml",
          /**
           * Variable: DIALECT_PREFERHTML
           * 
           * Defines the preferred HTML display dialect name.
           */
          DIALECT_PREFERHTML: "preferHtml",
          /**
           * Variable: DIALECT_STRICTHTML
           * 
           * Defines the strict HTML display dialect.
           */
          DIALECT_STRICTHTML: "strictHtml",
          /**
           * Variable: NS_SVG
           * 
           * Defines the SVG namespace.
           */
          NS_SVG: "http://www.w3.org/2000/svg",
          /**
           * Variable: NS_XHTML
           * 
           * Defines the XHTML namespace.
           */
          NS_XHTML: "http://www.w3.org/1999/xhtml",
          /**
           * Variable: NS_XLINK
           * 
           * Defines the XLink namespace.
           */
          NS_XLINK: "http://www.w3.org/1999/xlink",
          /**
           * Variable: SHADOWCOLOR
           * 
           * Defines the color to be used to draw shadows in shapes and windows.
           * Default is gray.
           */
          SHADOWCOLOR: "gray",
          /**
           * Variable: VML_SHADOWCOLOR
           * 
           * Used for shadow color in filters where transparency is not supported
           * (Microsoft Internet Explorer). Default is gray.
           */
          VML_SHADOWCOLOR: "gray",
          /**
           * Variable: SHADOW_OFFSET_X
           * 
           * Specifies the x-offset of the shadow. Default is 2.
           */
          SHADOW_OFFSET_X: 2,
          /**
           * Variable: SHADOW_OFFSET_Y
           * 
           * Specifies the y-offset of the shadow. Default is 3.
           */
          SHADOW_OFFSET_Y: 3,
          /**
           * Variable: SHADOW_OPACITY
           * 
           * Defines the opacity for shadows. Default is 1.
           */
          SHADOW_OPACITY: 1,
          /**
           * Variable: NODETYPE_ELEMENT
           * 
           * DOM node of type ELEMENT.
           */
          NODETYPE_ELEMENT: 1,
          /**
           * Variable: NODETYPE_ATTRIBUTE
           * 
           * DOM node of type ATTRIBUTE.
           */
          NODETYPE_ATTRIBUTE: 2,
          /**
           * Variable: NODETYPE_TEXT
           * 
           * DOM node of type TEXT.
           */
          NODETYPE_TEXT: 3,
          /**
           * Variable: NODETYPE_CDATA
           * 
           * DOM node of type CDATA.
           */
          NODETYPE_CDATA: 4,
          /**
           * Variable: NODETYPE_ENTITY_REFERENCE
           * 
           * DOM node of type ENTITY_REFERENCE.
           */
          NODETYPE_ENTITY_REFERENCE: 5,
          /**
           * Variable: NODETYPE_ENTITY
           * 
           * DOM node of type ENTITY.
           */
          NODETYPE_ENTITY: 6,
          /**
           * Variable: NODETYPE_PROCESSING_INSTRUCTION
           * 
           * DOM node of type PROCESSING_INSTRUCTION.
           */
          NODETYPE_PROCESSING_INSTRUCTION: 7,
          /**
           * Variable: NODETYPE_COMMENT
           * 
           * DOM node of type COMMENT.
           */
          NODETYPE_COMMENT: 8,
          /**
           * Variable: NODETYPE_DOCUMENT
           * 
           * DOM node of type DOCUMENT.
           */
          NODETYPE_DOCUMENT: 9,
          /**
           * Variable: NODETYPE_DOCUMENTTYPE
           * 
           * DOM node of type DOCUMENTTYPE.
           */
          NODETYPE_DOCUMENTTYPE: 10,
          /**
           * Variable: NODETYPE_DOCUMENT_FRAGMENT
           * 
           * DOM node of type DOCUMENT_FRAGMENT.
           */
          NODETYPE_DOCUMENT_FRAGMENT: 11,
          /**
           * Variable: NODETYPE_NOTATION
           * 
           * DOM node of type NOTATION.
           */
          NODETYPE_NOTATION: 12,
          /**
           * Variable: TOOLTIP_VERTICAL_OFFSET
           * 
           * Defines the vertical offset for the tooltip.
           * Default is 16.
           */
          TOOLTIP_VERTICAL_OFFSET: 16,
          /**
           * Variable: DEFAULT_VALID_COLOR
           * 
           * Specifies the default valid color. Default is #0000FF.
           */
          DEFAULT_VALID_COLOR: "#00FF00",
          /**
           * Variable: DEFAULT_INVALID_COLOR
           * 
           * Specifies the default invalid color. Default is #FF0000.
           */
          DEFAULT_INVALID_COLOR: "#FF0000",
          /**
           * Variable: OUTLINE_HIGHLIGHT_COLOR
           * 
           * Specifies the default highlight color for shape outlines.
           * Default is #0000FF. This is used in <mxEdgeHandler>.
           */
          OUTLINE_HIGHLIGHT_COLOR: "#00FF00",
          /**
           * Variable: OUTLINE_HIGHLIGHT_COLOR
           * 
           * Defines the strokewidth to be used for shape outlines.
           * Default is 5. This is used in <mxEdgeHandler>.
           */
          OUTLINE_HIGHLIGHT_STROKEWIDTH: 5,
          /**
           * Variable: HIGHLIGHT_STROKEWIDTH
           * 
           * Defines the strokewidth to be used for the highlights.
           * Default is 3.
           */
          HIGHLIGHT_STROKEWIDTH: 3,
          /**
           * Variable: CONSTRAINT_HIGHLIGHT_SIZE
           * 
           * Size of the constraint highlight (in px). Default is 2.
           */
          HIGHLIGHT_SIZE: 2,
          /**
           * Variable: HIGHLIGHT_OPACITY
           * 
           * Opacity (in %) used for the highlights (including outline).
           * Default is 100.
           */
          HIGHLIGHT_OPACITY: 100,
          /**
           * Variable: CURSOR_MOVABLE_VERTEX
           * 
           * Defines the cursor for a movable vertex. Default is 'move'.
           */
          CURSOR_MOVABLE_VERTEX: "move",
          /**
           * Variable: CURSOR_MOVABLE_EDGE
           * 
           * Defines the cursor for a movable edge. Default is 'move'.
           */
          CURSOR_MOVABLE_EDGE: "move",
          /**
           * Variable: CURSOR_LABEL_HANDLE
           * 
           * Defines the cursor for a movable label. Default is 'default'.
           */
          CURSOR_LABEL_HANDLE: "default",
          /**
           * Variable: CURSOR_TERMINAL_HANDLE
           * 
           * Defines the cursor for a terminal handle. Default is 'pointer'.
           */
          CURSOR_TERMINAL_HANDLE: "pointer",
          /**
           * Variable: CURSOR_BEND_HANDLE
           * 
           * Defines the cursor for a movable bend. Default is 'crosshair'.
           */
          CURSOR_BEND_HANDLE: "crosshair",
          /**
           * Variable: CURSOR_VIRTUAL_BEND_HANDLE
           * 
           * Defines the cursor for a movable bend. Default is 'crosshair'.
           */
          CURSOR_VIRTUAL_BEND_HANDLE: "crosshair",
          /**
           * Variable: CURSOR_CONNECT
           * 
           * Defines the cursor for a connectable state. Default is 'pointer'.
           */
          CURSOR_CONNECT: "pointer",
          /**
           * Variable: HIGHLIGHT_COLOR
           * 
           * Defines the color to be used for the cell highlighting.
           * Use 'none' for no color. Default is #00FF00.
           */
          HIGHLIGHT_COLOR: "#00FF00",
          /**
           * Variable: TARGET_HIGHLIGHT_COLOR
           * 
           * Defines the color to be used for highlighting a target cell for a new
           * or changed connection. Note that this may be either a source or
           * target terminal in the graph. Use 'none' for no color.
           * Default is #0000FF.
           */
          CONNECT_TARGET_COLOR: "#0000FF",
          /**
           * Variable: INVALID_CONNECT_TARGET_COLOR
           * 
           * Defines the color to be used for highlighting a invalid target cells
           * for a new or changed connections. Note that this may be either a source
           * or target terminal in the graph. Use 'none' for no color. Default is
           * #FF0000.
           */
          INVALID_CONNECT_TARGET_COLOR: "#FF0000",
          /**
           * Variable: DROP_TARGET_COLOR
           * 
           * Defines the color to be used for the highlighting target parent cells
           * (for drag and drop). Use 'none' for no color. Default is #0000FF.
           */
          DROP_TARGET_COLOR: "#0000FF",
          /**
           * Variable: VALID_COLOR
           * 
           * Defines the color to be used for the coloring valid connection
           * previews. Use 'none' for no color. Default is #FF0000.
           */
          VALID_COLOR: "#00FF00",
          /**
           * Variable: INVALID_COLOR
           * 
           * Defines the color to be used for the coloring invalid connection
           * previews. Use 'none' for no color. Default is #FF0000.
           */
          INVALID_COLOR: "#FF0000",
          /**
           * Variable: EDGE_SELECTION_COLOR
           * 
           * Defines the color to be used for the selection border of edges. Use
           * 'none' for no color. Default is #00FF00.
           */
          EDGE_SELECTION_COLOR: "#00FF00",
          /**
           * Variable: VERTEX_SELECTION_COLOR
           * 
           * Defines the color to be used for the selection border of vertices. Use
           * 'none' for no color. Default is #00FF00.
           */
          VERTEX_SELECTION_COLOR: "#00FF00",
          /**
           * Variable: VERTEX_SELECTION_STROKEWIDTH
           * 
           * Defines the strokewidth to be used for vertex selections.
           * Default is 1.
           */
          VERTEX_SELECTION_STROKEWIDTH: 1,
          /**
           * Variable: EDGE_SELECTION_STROKEWIDTH
           * 
           * Defines the strokewidth to be used for edge selections.
           * Default is 1.
           */
          EDGE_SELECTION_STROKEWIDTH: 1,
          /**
           * Variable: SELECTION_DASHED
           * 
           * Defines the dashed state to be used for the vertex selection
           * border. Default is true.
           */
          VERTEX_SELECTION_DASHED: true,
          /**
           * Variable: SELECTION_DASHED
           * 
           * Defines the dashed state to be used for the edge selection
           * border. Default is true.
           */
          EDGE_SELECTION_DASHED: true,
          /**
           * Variable: GUIDE_COLOR
           * 
           * Defines the color to be used for the guidelines in mxGraphHandler.
           * Default is #FF0000.
           */
          GUIDE_COLOR: "#FF0000",
          /**
           * Variable: GUIDE_STROKEWIDTH
           * 
           * Defines the strokewidth to be used for the guidelines in mxGraphHandler.
           * Default is 1.
           */
          GUIDE_STROKEWIDTH: 1,
          /**
           * Variable: OUTLINE_COLOR
           * 
           * Defines the color to be used for the outline rectangle
           * border.  Use 'none' for no color. Default is #0099FF.
           */
          OUTLINE_COLOR: "#0099FF",
          /**
           * Variable: OUTLINE_STROKEWIDTH
           * 
           * Defines the strokewidth to be used for the outline rectangle
           * stroke width. Default is 3.
           */
          OUTLINE_STROKEWIDTH: mxClient.IS_IE ? 2 : 3,
          /**
           * Variable: HANDLE_SIZE
           * 
           * Defines the default size for handles. Default is 6.
           */
          HANDLE_SIZE: 6,
          /**
           * Variable: LABEL_HANDLE_SIZE
           * 
           * Defines the default size for label handles. Default is 4.
           */
          LABEL_HANDLE_SIZE: 4,
          /**
           * Variable: HANDLE_FILLCOLOR
           * 
           * Defines the color to be used for the handle fill color. Use 'none' for
           * no color. Default is #00FF00 (green).
           */
          HANDLE_FILLCOLOR: "#00FF00",
          /**
           * Variable: HANDLE_STROKECOLOR
           * 
           * Defines the color to be used for the handle stroke color. Use 'none' for
           * no color. Default is black.
           */
          HANDLE_STROKECOLOR: "black",
          /**
           * Variable: LABEL_HANDLE_FILLCOLOR
           * 
           * Defines the color to be used for the label handle fill color. Use 'none'
           * for no color. Default is yellow.
           */
          LABEL_HANDLE_FILLCOLOR: "yellow",
          /**
           * Variable: CONNECT_HANDLE_FILLCOLOR
           * 
           * Defines the color to be used for the connect handle fill color. Use
           * 'none' for no color. Default is #0000FF (blue).
           */
          CONNECT_HANDLE_FILLCOLOR: "#0000FF",
          /**
           * Variable: LOCKED_HANDLE_FILLCOLOR
           * 
           * Defines the color to be used for the locked handle fill color. Use
           * 'none' for no color. Default is #FF0000 (red).
           */
          LOCKED_HANDLE_FILLCOLOR: "#FF0000",
          /**
           * Variable: OUTLINE_HANDLE_FILLCOLOR
           * 
           * Defines the color to be used for the outline sizer fill color. Use
           * 'none' for no color. Default is #00FFFF.
           */
          OUTLINE_HANDLE_FILLCOLOR: "#00FFFF",
          /**
           * Variable: OUTLINE_HANDLE_STROKECOLOR
           * 
           * Defines the color to be used for the outline sizer stroke color. Use
           * 'none' for no color. Default is #0033FF.
           */
          OUTLINE_HANDLE_STROKECOLOR: "#0033FF",
          /**
           * Variable: DEFAULT_FONTFAMILY
           * 
           * Defines the default family for all fonts. Default is Arial,Helvetica.
           */
          DEFAULT_FONTFAMILY: "Arial,Helvetica",
          /**
           * Variable: DEFAULT_FONTSIZE
           * 
           * Defines the default size (in px). Default is 11.
           */
          DEFAULT_FONTSIZE: 11,
          /**
           * Variable: DEFAULT_TEXT_DIRECTION
           * 
           * Defines the default value for the <STYLE_TEXT_DIRECTION> if no value is
           * defined for it in the style. Default value is an empty string which means
           * the default system setting is used and no direction is set.
           */
          DEFAULT_TEXT_DIRECTION: "",
          /**
           * Variable: LINE_HEIGHT
           * 
           * Defines the default line height for text labels. Default is 1.2.
           */
          LINE_HEIGHT: 1.2,
          /**
           * Variable: WORD_WRAP
           * 
           * Defines the CSS value for the word-wrap property. Default is "normal".
           * Change this to "break-word" to allow long words to be able to be broken
           * and wrap onto the next line.
           */
          WORD_WRAP: "normal",
          /**
           * Variable: ABSOLUTE_LINE_HEIGHT
           * 
           * Specifies if absolute line heights should be used (px) in CSS. Default
           * is false. Set this to true for backwards compatibility.
           */
          ABSOLUTE_LINE_HEIGHT: false,
          /**
           * Variable: DEFAULT_FONTSTYLE
           * 
           * Defines the default style for all fonts. Default is 0. This can be set
           * to any combination of font styles as follows.
           * 
           * (code)
           * mxConstants.DEFAULT_FONTSTYLE = mxConstants.FONT_BOLD | mxConstants.FONT_ITALIC;
           * (end)
           */
          DEFAULT_FONTSTYLE: 0,
          /**
           * Variable: DEFAULT_STARTSIZE
           * 
           * Defines the default start size for swimlanes. Default is 40.
           */
          DEFAULT_STARTSIZE: 40,
          /**
           * Variable: DEFAULT_MARKERSIZE
           * 
           * Defines the default size for all markers. Default is 6.
           */
          DEFAULT_MARKERSIZE: 6,
          /**
           * Variable: DEFAULT_IMAGESIZE
           * 
           * Defines the default width and height for images used in the
           * label shape. Default is 24.
           */
          DEFAULT_IMAGESIZE: 24,
          /**
           * Variable: ENTITY_SEGMENT
           * 
           * Defines the length of the horizontal segment of an Entity Relation.
           * This can be overridden using <mxConstants.STYLE_SEGMENT> style.
           * Default is 30.
           */
          ENTITY_SEGMENT: 30,
          /**
           * Variable: RECTANGLE_ROUNDING_FACTOR
           * 
           * Defines the rounding factor for rounded rectangles in percent between
           * 0 and 1. Values should be smaller than 0.5. Default is 0.15.
           */
          RECTANGLE_ROUNDING_FACTOR: 0.15,
          /**
           * Variable: LINE_ARCSIZE
           * 
           * Defines the size of the arcs for rounded edges. Default is 20.
           */
          LINE_ARCSIZE: 20,
          /**
           * Variable: ARROW_SPACING
           * 
           * Defines the spacing between the arrow shape and its terminals. Default is 0.
           */
          ARROW_SPACING: 0,
          /**
           * Variable: ARROW_WIDTH
           * 
           * Defines the width of the arrow shape. Default is 30.
           */
          ARROW_WIDTH: 30,
          /**
           * Variable: ARROW_SIZE
           * 
           * Defines the size of the arrowhead in the arrow shape. Default is 30.
           */
          ARROW_SIZE: 30,
          /**
           * Variable: PAGE_FORMAT_A4_PORTRAIT
           * 
           * Defines the rectangle for the A4 portrait page format. The dimensions
           * of this page format are 826x1169 pixels.
           */
          PAGE_FORMAT_A4_PORTRAIT: new mxRectangle(0, 0, 827, 1169),
          /**
           * Variable: PAGE_FORMAT_A4_PORTRAIT
           * 
           * Defines the rectangle for the A4 portrait page format. The dimensions
           * of this page format are 826x1169 pixels.
           */
          PAGE_FORMAT_A4_LANDSCAPE: new mxRectangle(0, 0, 1169, 827),
          /**
           * Variable: PAGE_FORMAT_LETTER_PORTRAIT
           * 
           * Defines the rectangle for the Letter portrait page format. The
           * dimensions of this page format are 850x1100 pixels.
           */
          PAGE_FORMAT_LETTER_PORTRAIT: new mxRectangle(0, 0, 850, 1100),
          /**
           * Variable: PAGE_FORMAT_LETTER_PORTRAIT
           * 
           * Defines the rectangle for the Letter portrait page format. The dimensions
           * of this page format are 850x1100 pixels.
           */
          PAGE_FORMAT_LETTER_LANDSCAPE: new mxRectangle(0, 0, 1100, 850),
          /**
           * Variable: NONE
           * 
           * Defines the value for none. Default is "none".
           */
          NONE: "none",
          /**
           * Variable: STYLE_PERIMETER
           * 
           * Defines the key for the perimeter style. This is a function that defines
           * the perimeter around a particular shape. Possible values are the
           * functions defined in <mxPerimeter>. Alternatively, the constants in this
           * class that start with "PERIMETER_" may be used to access
           * perimeter styles in <mxStyleRegistry>. Value is "perimeter".
           */
          STYLE_PERIMETER: "perimeter",
          /**
           * Variable: STYLE_SOURCE_PORT
           * 
           * Defines the ID of the cell that should be used for computing the
           * perimeter point of the source for an edge. This allows for graphically
           * connecting to a cell while keeping the actual terminal of the edge.
           * Value is "sourcePort".
           */
          STYLE_SOURCE_PORT: "sourcePort",
          /**
           * Variable: STYLE_TARGET_PORT
           * 
           * Defines the ID of the cell that should be used for computing the
           * perimeter point of the target for an edge. This allows for graphically
           * connecting to a cell while keeping the actual terminal of the edge.
           * Value is "targetPort".
           */
          STYLE_TARGET_PORT: "targetPort",
          /**
           * Variable: STYLE_PORT_CONSTRAINT
           * 
           * Defines the direction(s) that edges are allowed to connect to cells in.
           * Possible values are "DIRECTION_NORTH, DIRECTION_SOUTH, 
           * DIRECTION_EAST" and "DIRECTION_WEST". Value is
           * "portConstraint".
           */
          STYLE_PORT_CONSTRAINT: "portConstraint",
          /**
           * Variable: STYLE_PORT_CONSTRAINT_ROTATION
           * 
           * Define whether port constraint directions are rotated with vertex
           * rotation. 0 (default) causes port constraints to remain absolute, 
           * relative to the graph, 1 causes the constraints to rotate with
           * the vertex. Value is "portConstraintRotation".
           */
          STYLE_PORT_CONSTRAINT_ROTATION: "portConstraintRotation",
          /**
           * Variable: STYLE_SOURCE_PORT_CONSTRAINT
           * 
           * Defines the direction(s) that edges are allowed to connect to sources in.
           * Possible values are "DIRECTION_NORTH, DIRECTION_SOUTH, DIRECTION_EAST"
           * and "DIRECTION_WEST". Value is "sourcePortConstraint".
           */
          STYLE_SOURCE_PORT_CONSTRAINT: "sourcePortConstraint",
          /**
           * Variable: STYLE_TARGET_PORT_CONSTRAINT
           * 
           * Defines the direction(s) that edges are allowed to connect to targets in.
           * Possible values are "DIRECTION_NORTH, DIRECTION_SOUTH, DIRECTION_EAST"
           * and "DIRECTION_WEST". Value is "targetPortConstraint".
           */
          STYLE_TARGET_PORT_CONSTRAINT: "targetPortConstraint",
          /**
           * Variable: STYLE_OPACITY
           * 
           * Defines the key for the opacity style. The type of the value is 
           * numeric and the possible range is 0-100. Value is "opacity".
           */
          STYLE_OPACITY: "opacity",
          /**
           * Variable: STYLE_FILL_OPACITY
           * 
           * Defines the key for the fill opacity style. The type of the value is 
           * numeric and the possible range is 0-100. Value is "fillOpacity".
           */
          STYLE_FILL_OPACITY: "fillOpacity",
          /**
           * Variable: STYLE_STROKE_OPACITY
           * 
           * Defines the key for the stroke opacity style. The type of the value is 
           * numeric and the possible range is 0-100. Value is "strokeOpacity".
           */
          STYLE_STROKE_OPACITY: "strokeOpacity",
          /**
           * Variable: STYLE_TEXT_OPACITY
           * 
           * Defines the key for the text opacity style. The type of the value is 
           * numeric and the possible range is 0-100. Value is "textOpacity".
           */
          STYLE_TEXT_OPACITY: "textOpacity",
          /**
           * Variable: STYLE_TEXT_DIRECTION
           * 
           * Defines the key for the text direction style. Possible values are
           * "TEXT_DIRECTION_DEFAULT, TEXT_DIRECTION_AUTO, TEXT_DIRECTION_LTR"
           * and "TEXT_DIRECTION_RTL". Value is "textDirection".
           * The default value for the style is defined in <DEFAULT_TEXT_DIRECTION>.
           * It is used is no value is defined for this key in a given style. This is
           * an experimental style that is currently ignored in the backends.
           */
          STYLE_TEXT_DIRECTION: "textDirection",
          /**
           * Variable: STYLE_OVERFLOW
           * 
           * Defines the key for the overflow style. Possible values are 'visible',
           * 'hidden', 'fill' and 'width'. The default value is 'visible'. This value
           * specifies how overlapping vertex labels are handled. A value of
           * 'visible' will show the complete label. A value of 'hidden' will clip
           * the label so that it does not overlap the vertex bounds. A value of
           * 'fill' will use the vertex bounds and a value of 'width' will use the
           * vertex width for the label. See <mxGraph.isLabelClipped>. Note that
           * the vertical alignment is ignored for overflow fill and for horizontal
           * alignment, left should be used to avoid pixel offsets in Internet Explorer
           * 11 and earlier or if foreignObjects are disabled. Value is "overflow".
           */
          STYLE_OVERFLOW: "overflow",
          /**
           * Variable: STYLE_ORTHOGONAL
           * 
           * Defines if the connection points on either end of the edge should be
           * computed so that the edge is vertical or horizontal if possible and
           * if the point is not at a fixed location. Default is false. This is
           * used in <mxGraph.isOrthogonal>, which also returns true if the edgeStyle
           * of the edge is an elbow or entity. Value is "orthogonal".
           */
          STYLE_ORTHOGONAL: "orthogonal",
          /**
           * Variable: STYLE_EXIT_X
           * 
           * Defines the key for the horizontal relative coordinate connection point
           * of an edge with its source terminal. Value is "exitX".
           */
          STYLE_EXIT_X: "exitX",
          /**
           * Variable: STYLE_EXIT_Y
           * 
           * Defines the key for the vertical relative coordinate connection point
           * of an edge with its source terminal. Value is "exitY".
           */
          STYLE_EXIT_Y: "exitY",
          /**
          * Variable: STYLE_EXIT_DX
          * 
          * Defines the key for the horizontal offset of the connection point
          * of an edge with its source terminal. Value is "exitDx".
          */
          STYLE_EXIT_DX: "exitDx",
          /**
          * Variable: STYLE_EXIT_DY
          * 
          * Defines the key for the vertical offset of the connection point
          * of an edge with its source terminal. Value is "exitDy".
          */
          STYLE_EXIT_DY: "exitDy",
          /**
           * Variable: STYLE_EXIT_PERIMETER
           * 
           * Defines if the perimeter should be used to find the exact entry point
           * along the perimeter of the source. Possible values are 0 (false) and
           * 1 (true). Default is 1 (true). Value is "exitPerimeter".
           */
          STYLE_EXIT_PERIMETER: "exitPerimeter",
          /**
           * Variable: STYLE_ENTRY_X
           * 
           * Defines the key for the horizontal relative coordinate connection point
           * of an edge with its target terminal. Value is "entryX".
           */
          STYLE_ENTRY_X: "entryX",
          /**
           * Variable: STYLE_ENTRY_Y
           * 
           * Defines the key for the vertical relative coordinate connection point
           * of an edge with its target terminal. Value is "entryY".
           */
          STYLE_ENTRY_Y: "entryY",
          /**
           * Variable: STYLE_ENTRY_DX
           * 
          * Defines the key for the horizontal offset of the connection point
          * of an edge with its target terminal. Value is "entryDx".
          */
          STYLE_ENTRY_DX: "entryDx",
          /**
           * Variable: STYLE_ENTRY_DY
           * 
          * Defines the key for the vertical offset of the connection point
          * of an edge with its target terminal. Value is "entryDy".
          */
          STYLE_ENTRY_DY: "entryDy",
          /**
           * Variable: STYLE_ENTRY_PERIMETER
           * 
           * Defines if the perimeter should be used to find the exact entry point
           * along the perimeter of the target. Possible values are 0 (false) and
           * 1 (true). Default is 1 (true). Value is "entryPerimeter".
           */
          STYLE_ENTRY_PERIMETER: "entryPerimeter",
          /**
           * Variable: STYLE_WHITE_SPACE
           * 
           * Defines the key for the white-space style. Possible values are 'nowrap'
           * and 'wrap'. The default value is 'nowrap'. This value specifies how
           * white-space inside a HTML vertex label should be handled. A value of
           * 'nowrap' means the text will never wrap to the next line until a
           * linefeed is encountered. A value of 'wrap' means text will wrap when
           * necessary. This style is only used for HTML labels.
           * See <mxGraph.isWrapping>. Value is "whiteSpace".
           */
          STYLE_WHITE_SPACE: "whiteSpace",
          /**
           * Variable: STYLE_ROTATION
           * 
           * Defines the key for the rotation style. The type of the value is 
           * numeric and the possible range is 0-360. Value is "rotation".
           */
          STYLE_ROTATION: "rotation",
          /**
           * Variable: STYLE_FILLCOLOR
           * 
           * Defines the key for the fill color. Possible values are all HTML color
           * names or HEX codes, as well as special keywords such as 'swimlane,
           * 'inherit' or 'indicated' to use the color code of a related cell or the
           * indicator shape. Value is "fillColor".
           */
          STYLE_FILLCOLOR: "fillColor",
          /**
           * Variable: STYLE_POINTER_EVENTS
           * 
           * Specifies if pointer events should be fired on transparent backgrounds.
           * This style is currently only supported in <mxRectangleShape>. Default
           * is true. Value is "pointerEvents". This is typically set to
           * false in groups where the transparent part should allow any underlying
           * cells to be clickable.
           */
          STYLE_POINTER_EVENTS: "pointerEvents",
          /**
           * Variable: STYLE_SWIMLANE_FILLCOLOR
           * 
           * Defines the key for the fill color of the swimlane background. Possible
           * values are all HTML color names or HEX codes. Default is no background.
           * Value is "swimlaneFillColor".
           */
          STYLE_SWIMLANE_FILLCOLOR: "swimlaneFillColor",
          /**
           * Variable: STYLE_MARGIN
           * 
           * Defines the key for the margin between the ellipses in the double ellipse shape.
           * Possible values are all positive numbers. Value is "margin".
           */
          STYLE_MARGIN: "margin",
          /**
           * Variable: STYLE_GRADIENTCOLOR
           * 
           * Defines the key for the gradient color. Possible values are all HTML color
           * names or HEX codes, as well as special keywords such as 'swimlane,
           * 'inherit' or 'indicated' to use the color code of a related cell or the
           * indicator shape. This is ignored if no fill color is defined. Value is
           * "gradientColor".
           */
          STYLE_GRADIENTCOLOR: "gradientColor",
          /**
           * Variable: STYLE_GRADIENT_DIRECTION
           * 
           * Defines the key for the gradient direction. Possible values are
           * <DIRECTION_EAST>, <DIRECTION_WEST>, <DIRECTION_NORTH> and
           * <DIRECTION_SOUTH>. Default is <DIRECTION_SOUTH>. Generally, and by
           * default in mxGraph, gradient painting is done from the value of
           * <STYLE_FILLCOLOR> to the value of <STYLE_GRADIENTCOLOR>. Taking the
           * example of <DIRECTION_NORTH>, this means <STYLE_FILLCOLOR> color at the 
           * bottom of paint pattern and <STYLE_GRADIENTCOLOR> at top, with a
           * gradient in-between. Value is "gradientDirection".
           */
          STYLE_GRADIENT_DIRECTION: "gradientDirection",
          /**
           * Variable: STYLE_STROKECOLOR
           * 
           * Defines the key for the strokeColor style. Possible values are all HTML
           * color names or HEX codes, as well as special keywords such as 'swimlane,
           * 'inherit', 'indicated' to use the color code of a related cell or the
           * indicator shape or 'none' for no color. Value is "strokeColor".
           */
          STYLE_STROKECOLOR: "strokeColor",
          /**
           * Variable: STYLE_SEPARATORCOLOR
           * 
           * Defines the key for the separatorColor style. Possible values are all
           * HTML color names or HEX codes. This style is only used for
           * <SHAPE_SWIMLANE> shapes. Value is "separatorColor".
           */
          STYLE_SEPARATORCOLOR: "separatorColor",
          /**
           * Variable: STYLE_STROKEWIDTH
           * 
           * Defines the key for the strokeWidth style. The type of the value is 
           * numeric and the possible range is any non-negative value larger or equal
           * to 1. The value defines the stroke width in pixels. Note: To hide a
           * stroke use strokeColor none. Value is "strokeWidth".
           */
          STYLE_STROKEWIDTH: "strokeWidth",
          /**
           * Variable: STYLE_ALIGN
           * 
           * Defines the key for the align style. Possible values are <ALIGN_LEFT>,
           * <ALIGN_CENTER> and <ALIGN_RIGHT>. This value defines how the lines of
           * the label are horizontally aligned. <ALIGN_LEFT> mean label text lines
           * are aligned to left of the label bounds, <ALIGN_RIGHT> to the right of
           * the label bounds and <ALIGN_CENTER> means the center of the text lines
           * are aligned in the center of the label bounds. Note this value doesn't
           * affect the positioning of the overall label bounds relative to the
           * vertex, to move the label bounds horizontally, use
           * <STYLE_LABEL_POSITION>. Value is "align".
           */
          STYLE_ALIGN: "align",
          /**
           * Variable: STYLE_VERTICAL_ALIGN
           * 
           * Defines the key for the verticalAlign style. Possible values are
           * <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>. This value defines how
           * the lines of the label are vertically aligned. <ALIGN_TOP> means the
           * topmost label text line is aligned against the top of the label bounds,
           * <ALIGN_BOTTOM> means the bottom-most label text line is aligned against
           * the bottom of the label bounds and <ALIGN_MIDDLE> means there is equal
           * spacing between the topmost text label line and the top of the label
           * bounds and the bottom-most text label line and the bottom of the label
           * bounds. Note this value doesn't affect the positioning of the overall
           * label bounds relative to the vertex, to move the label bounds
           * vertically, use <STYLE_VERTICAL_LABEL_POSITION>. Value is "verticalAlign".
           */
          STYLE_VERTICAL_ALIGN: "verticalAlign",
          /**
           * Variable: STYLE_LABEL_WIDTH
           * 
           * Defines the key for the width of the label if the label position is not
           * center. Value is "labelWidth".
           */
          STYLE_LABEL_WIDTH: "labelWidth",
          /**
           * Variable: STYLE_LABEL_POSITION
           * 
           * Defines the key for the horizontal label position of vertices. Possible
           * values are <ALIGN_LEFT>, <ALIGN_CENTER> and <ALIGN_RIGHT>. Default is
           * <ALIGN_CENTER>. The label align defines the position of the label
           * relative to the cell. <ALIGN_LEFT> means the entire label bounds is
           * placed completely just to the left of the vertex, <ALIGN_RIGHT> means
           * adjust to the right and <ALIGN_CENTER> means the label bounds are
           * vertically aligned with the bounds of the vertex. Note this value
           * doesn't affect the positioning of label within the label bounds, to move
           * the label horizontally within the label bounds, use <STYLE_ALIGN>.
           * Value is "labelPosition".
           */
          STYLE_LABEL_POSITION: "labelPosition",
          /**
           * Variable: STYLE_VERTICAL_LABEL_POSITION
           * 
           * Defines the key for the vertical label position of vertices. Possible
           * values are <ALIGN_TOP>, <ALIGN_BOTTOM> and <ALIGN_MIDDLE>. Default is
           * <ALIGN_MIDDLE>. The label align defines the position of the label
           * relative to the cell. <ALIGN_TOP> means the entire label bounds is
           * placed completely just on the top of the vertex, <ALIGN_BOTTOM> means
           * adjust on the bottom and <ALIGN_MIDDLE> means the label bounds are
           * horizontally aligned with the bounds of the vertex. Note this value
           * doesn't affect the positioning of label within the label bounds, to move
           * the label vertically within the label bounds, use
           * <STYLE_VERTICAL_ALIGN>. Value is "verticalLabelPosition".
           */
          STYLE_VERTICAL_LABEL_POSITION: "verticalLabelPosition",
          /**
           * Variable: STYLE_IMAGE_ASPECT
           * 
           * Defines the key for the image aspect style. Possible values are 0 (do
           * not preserve aspect) or 1 (keep aspect). This is only used in
           * <mxImageShape>. Default is 1. Value is "imageAspect".
           */
          STYLE_IMAGE_ASPECT: "imageAspect",
          /**
           * Variable: STYLE_IMAGE_ALIGN
           * 
           * Defines the key for the align style. Possible values are <ALIGN_LEFT>,
           * <ALIGN_CENTER> and <ALIGN_RIGHT>. The value defines how any image in the
           * vertex label is aligned horizontally within the label bounds of a
           * <SHAPE_LABEL> shape. Value is "imageAlign".
           */
          STYLE_IMAGE_ALIGN: "imageAlign",
          /**
           * Variable: STYLE_IMAGE_VERTICAL_ALIGN
           * 
           * Defines the key for the verticalAlign style. Possible values are
           * <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>. The value defines how
           * any image in the vertex label is aligned vertically within the label
           * bounds of a <SHAPE_LABEL> shape. Value is "imageVerticalAlign".
           */
          STYLE_IMAGE_VERTICAL_ALIGN: "imageVerticalAlign",
          /**
           * Variable: STYLE_GLASS
           * 
           * Defines the key for the glass style. Possible values are 0 (disabled) and
           * 1(enabled). The default value is 0. This is used in <mxLabel>. Value is
           * "glass".
           */
          STYLE_GLASS: "glass",
          /**
           * Variable: STYLE_IMAGE
           * 
           * Defines the key for the image style. Possible values are any image URL,
           * the type of the value is String. This is the path to the image that is
           * to be displayed within the label of a vertex. Data URLs should use the
           * following format: data:image/png,xyz where xyz is the base64 encoded
           * data (without the "base64"-prefix). Note that Data URLs are only
           * supported in modern browsers. Value is "image".
           */
          STYLE_IMAGE: "image",
          /**
           * Variable: STYLE_IMAGE_WIDTH
           * 
           * Defines the key for the imageWidth style. The type of this value is
           * int, the value is the image width in pixels and must be greater than 0.
           * Value is "imageWidth".
           */
          STYLE_IMAGE_WIDTH: "imageWidth",
          /**
           * Variable: STYLE_IMAGE_HEIGHT
           * 
           * Defines the key for the imageHeight style. The type of this value is
           * int, the value is the image height in pixels and must be greater than 0.
           * Value is "imageHeight".
           */
          STYLE_IMAGE_HEIGHT: "imageHeight",
          /**
           * Variable: STYLE_IMAGE_BACKGROUND
           * 
           * Defines the key for the image background color. This style is only used
           * in <mxImageShape>. Possible values are all HTML color names or HEX
           * codes. Value is "imageBackground".
           */
          STYLE_IMAGE_BACKGROUND: "imageBackground",
          /**
           * Variable: STYLE_IMAGE_BORDER
           * 
           * Defines the key for the image border color. This style is only used in
           * <mxImageShape>. Possible values are all HTML color names or HEX codes.
           * Value is "imageBorder".
           */
          STYLE_IMAGE_BORDER: "imageBorder",
          /**
           * Variable: STYLE_FLIPH
           * 
           * Defines the key for the horizontal image flip. This style is only used
           * in <mxImageShape>. Possible values are 0 and 1. Default is 0. Value is
           * "flipH".
           */
          STYLE_FLIPH: "flipH",
          /**
           * Variable: STYLE_FLIPV
           * 
           * Defines the key for the vertical flip. Possible values are 0 and 1.
           * Default is 0. Value is "flipV".
           */
          STYLE_FLIPV: "flipV",
          /**
           * Variable: STYLE_NOLABEL
           * 
           * Defines the key for the noLabel style. If this is true then no label is
           * visible for a given cell. Possible values are true or false (1 or 0).
           * Default is false. Value is "noLabel".
           */
          STYLE_NOLABEL: "noLabel",
          /**
           * Variable: STYLE_NOEDGESTYLE
           * 
           * Defines the key for the noEdgeStyle style. If this is true then no edge
           * style is applied for a given edge. Possible values are true or false
           * (1 or 0). Default is false. Value is "noEdgeStyle".
           */
          STYLE_NOEDGESTYLE: "noEdgeStyle",
          /**
           * Variable: STYLE_LABEL_BACKGROUNDCOLOR
           * 
           * Defines the key for the label background color. Possible values are all
           * HTML color names or HEX codes. Value is "labelBackgroundColor".
           */
          STYLE_LABEL_BACKGROUNDCOLOR: "labelBackgroundColor",
          /**
           * Variable: STYLE_LABEL_BORDERCOLOR
           * 
           * Defines the key for the label border color. Possible values are all
           * HTML color names or HEX codes. Value is "labelBorderColor".
           */
          STYLE_LABEL_BORDERCOLOR: "labelBorderColor",
          /**
           * Variable: STYLE_LABEL_PADDING
           * 
           * Defines the key for the label padding, ie. the space between the label
           * border and the label. Value is "labelPadding".
           */
          STYLE_LABEL_PADDING: "labelPadding",
          /**
           * Variable: STYLE_INDICATOR_SHAPE
           * 
           * Defines the key for the indicator shape used within an <mxLabel>.
           * Possible values are all SHAPE_* constants or the names of any new
           * shapes. The indicatorShape has precedence over the indicatorImage.
           * Value is "indicatorShape".
           */
          STYLE_INDICATOR_SHAPE: "indicatorShape",
          /**
           * Variable: STYLE_INDICATOR_IMAGE
           * 
           * Defines the key for the indicator image used within an <mxLabel>.
           * Possible values are all image URLs. The indicatorShape has
           * precedence over the indicatorImage. Value is "indicatorImage".
           */
          STYLE_INDICATOR_IMAGE: "indicatorImage",
          /**
           * Variable: STYLE_INDICATOR_COLOR
           * 
           * Defines the key for the indicatorColor style. Possible values are all
           * HTML color names or HEX codes, as well as the special 'swimlane' keyword
           * to refer to the color of the parent swimlane if one exists. Value is
           * "indicatorColor".
           */
          STYLE_INDICATOR_COLOR: "indicatorColor",
          /**
           * Variable: STYLE_INDICATOR_STROKECOLOR
           * 
           * Defines the key for the indicator stroke color in <mxLabel>.
           * Possible values are all color codes. Value is "indicatorStrokeColor".
           */
          STYLE_INDICATOR_STROKECOLOR: "indicatorStrokeColor",
          /**
           * Variable: STYLE_INDICATOR_GRADIENTCOLOR
           * 
           * Defines the key for the indicatorGradientColor style. Possible values
           * are all HTML color names or HEX codes. This style is only supported in
           * <SHAPE_LABEL> shapes. Value is "indicatorGradientColor".
           */
          STYLE_INDICATOR_GRADIENTCOLOR: "indicatorGradientColor",
          /**
           * Variable: STYLE_INDICATOR_SPACING
           * 
           * The defines the key for the spacing between the label and the
           * indicator in <mxLabel>. Possible values are in pixels. Value is
           * "indicatorSpacing".
           */
          STYLE_INDICATOR_SPACING: "indicatorSpacing",
          /**
           * Variable: STYLE_INDICATOR_WIDTH
           * 
           * Defines the key for the indicator width. Possible values start at 0 (in
           * pixels). Value is "indicatorWidth".
           */
          STYLE_INDICATOR_WIDTH: "indicatorWidth",
          /**
           * Variable: STYLE_INDICATOR_HEIGHT
           * 
           * Defines the key for the indicator height. Possible values start at 0 (in
           * pixels). Value is "indicatorHeight".
           */
          STYLE_INDICATOR_HEIGHT: "indicatorHeight",
          /**
           * Variable: STYLE_INDICATOR_DIRECTION
           * 
           * Defines the key for the indicatorDirection style. The direction style is
           * used to specify the direction of certain shapes (eg. <mxTriangle>).
           * Possible values are <DIRECTION_EAST> (default), <DIRECTION_WEST>,
           * <DIRECTION_NORTH> and <DIRECTION_SOUTH>. Value is "indicatorDirection".
           */
          STYLE_INDICATOR_DIRECTION: "indicatorDirection",
          /**
           * Variable: STYLE_SHADOW
           * 
           * Defines the key for the shadow style. The type of the value is Boolean.
           * Value is "shadow".
           */
          STYLE_SHADOW: "shadow",
          /**
           * Variable: STYLE_SEGMENT
           * 
           * Defines the key for the segment style. The type of this value is float
           * and the value represents the size of the horizontal segment of the
           * entity relation style. Default is ENTITY_SEGMENT. Value is "segment".
           */
          STYLE_SEGMENT: "segment",
          /**
           * Variable: STYLE_ENDARROW
           *
           * Defines the key for the end arrow marker. Possible values are all
           * constants with an ARROW-prefix. This is only used in <mxConnector>.
           * Value is "endArrow".
           *
           * Example:
           * (code)
           * style[mxConstants.STYLE_ENDARROW] = mxConstants.ARROW_CLASSIC;
           * (end)
           */
          STYLE_ENDARROW: "endArrow",
          /**
           * Variable: STYLE_STARTARROW
           * 
           * Defines the key for the start arrow marker. Possible values are all
           * constants with an ARROW-prefix. This is only used in <mxConnector>.
           * See <STYLE_ENDARROW>. Value is "startArrow".
           */
          STYLE_STARTARROW: "startArrow",
          /**
           * Variable: STYLE_ENDSIZE
           * 
           * Defines the key for the endSize style. The type of this value is numeric
           * and the value represents the size of the end marker in pixels. Value is
           * "endSize".
           */
          STYLE_ENDSIZE: "endSize",
          /**
           * Variable: STYLE_STARTSIZE
           * 
           * Defines the key for the startSize style. The type of this value is
           * numeric and the value represents the size of the start marker or the
           * size of the swimlane title region depending on the shape it is used for.
           * Value is "startSize".
           */
          STYLE_STARTSIZE: "startSize",
          /**
           * Variable: STYLE_SWIMLANE_LINE
           * 
           * Defines the key for the swimlaneLine style. This style specifies whether
           * the line between the title regio of a swimlane should be visible. Use 0
           * for hidden or 1 (default) for visible. Value is "swimlaneLine".
           */
          STYLE_SWIMLANE_LINE: "swimlaneLine",
          /**
           * Variable: STYLE_ENDFILL
           * 
           * Defines the key for the endFill style. Use 0 for no fill or 1 (default)
           * for fill. (This style is only exported via <mxImageExport>.) Value is
           * "endFill".
           */
          STYLE_ENDFILL: "endFill",
          /**
           * Variable: STYLE_STARTFILL
           * 
           * Defines the key for the startFill style. Use 0 for no fill or 1 (default)
           * for fill. (This style is only exported via <mxImageExport>.) Value is
           * "startFill".
           */
          STYLE_STARTFILL: "startFill",
          /**
           * Variable: STYLE_DASHED
           * 
           * Defines the key for the dashed style. Use 0 (default) for non-dashed or 1
           * for dashed. Value is "dashed".
           */
          STYLE_DASHED: "dashed",
          /**
           * Variable: STYLE_DASH_PATTERN
           * 
           * Defines the key for the dashed pattern style in SVG and image exports.
           * The type of this value is a space separated list of numbers that specify
           * a custom-defined dash pattern. Dash styles are defined in terms of the
           * length of the dash (the drawn part of the stroke) and the length of the
           * space between the dashes. The lengths are relative to the line width: a
           * length of "1" is equal to the line width. VML ignores this style and
           * uses dashStyle instead as defined in the VML specification. This style
           * is only used in the <mxConnector> shape. Value is "dashPattern".
           */
          STYLE_DASH_PATTERN: "dashPattern",
          /**
           * Variable: STYLE_FIX_DASH
           * 
           * Defines the key for the fixDash style. Use 0 (default) for dash patterns
           * that depend on the linewidth and 1 for dash patterns that ignore the
           * line width. Value is "fixDash".
           */
          STYLE_FIX_DASH: "fixDash",
          /**
           * Variable: STYLE_ROUNDED
           * 
           * Defines the key for the rounded style. The type of this value is
           * Boolean. For edges this determines whether or not joins between edges
           * segments are smoothed to a rounded finish. For vertices that have the
           * rectangle shape, this determines whether or not the rectangle is
           * rounded. Use 0 (default) for non-rounded or 1 for rounded. Value is
           * "rounded".
           */
          STYLE_ROUNDED: "rounded",
          /**
           * Variable: STYLE_CURVED
           * 
           * Defines the key for the curved style. The type of this value is
           * Boolean. It is only applicable for connector shapes. Use 0 (default)
           * for non-curved or 1 for curved. Value is "curved".
           */
          STYLE_CURVED: "curved",
          /**
           * Variable: STYLE_ARCSIZE
           * 
           * Defines the rounding factor for a rounded rectangle in percent (without
           * the percent sign). Possible values are between 0 and 100. If this value
           * is not specified then RECTANGLE_ROUNDING_FACTOR * 100 is used. For
           * edges, this defines the absolute size of rounded corners in pixels. If
           * this values is not specified then LINE_ARCSIZE is used.
           * (This style is only exported via <mxImageExport>.) Value is "arcSize".
           */
          STYLE_ARCSIZE: "arcSize",
          /**
           * Variable: STYLE_ABSOLUTE_ARCSIZE
           * 
           * Defines the key for the absolute arc size style. This specifies if
           * arcSize for rectangles is abolute or relative. Possible values are 1
           * and 0 (default). Value is "absoluteArcSize".
           */
          STYLE_ABSOLUTE_ARCSIZE: "absoluteArcSize",
          /**
           * Variable: STYLE_SOURCE_PERIMETER_SPACING
           * 
           * Defines the key for the source perimeter spacing. The type of this value
           * is numeric. This is the distance between the source connection point of
           * an edge and the perimeter of the source vertex in pixels. This style
           * only applies to edges. Value is "sourcePerimeterSpacing".
           */
          STYLE_SOURCE_PERIMETER_SPACING: "sourcePerimeterSpacing",
          /**
           * Variable: STYLE_TARGET_PERIMETER_SPACING
           * 
           * Defines the key for the target perimeter spacing. The type of this value
           * is numeric. This is the distance between the target connection point of
           * an edge and the perimeter of the target vertex in pixels. This style
           * only applies to edges. Value is "targetPerimeterSpacing".
           */
          STYLE_TARGET_PERIMETER_SPACING: "targetPerimeterSpacing",
          /**
           * Variable: STYLE_PERIMETER_SPACING
           * 
           * Defines the key for the perimeter spacing. This is the distance between
           * the connection point and the perimeter in pixels. When used in a vertex
           * style, this applies to all incoming edges to floating ports (edges that
           * terminate on the perimeter of the vertex). When used in an edge style,
           * this spacing applies to the source and target separately, if they
           * terminate in floating ports (on the perimeter of the vertex). Value is
           * "perimeterSpacing".
           */
          STYLE_PERIMETER_SPACING: "perimeterSpacing",
          /**
           * Variable: STYLE_SPACING
           * 
           * Defines the key for the spacing. The value represents the spacing, in
           * pixels, added to each side of a label in a vertex (style applies to
           * vertices only). Value is "spacing".
           */
          STYLE_SPACING: "spacing",
          /**
           * Variable: STYLE_SPACING_TOP
           * 
           * Defines the key for the spacingTop style. The value represents the
           * spacing, in pixels, added to the top side of a label in a vertex (style
           * applies to vertices only). Value is "spacingTop".
           */
          STYLE_SPACING_TOP: "spacingTop",
          /**
           * Variable: STYLE_SPACING_LEFT
           * 
           * Defines the key for the spacingLeft style. The value represents the
           * spacing, in pixels, added to the left side of a label in a vertex (style
           * applies to vertices only). Value is "spacingLeft".
           */
          STYLE_SPACING_LEFT: "spacingLeft",
          /**
           * Variable: STYLE_SPACING_BOTTOM
           * 
           * Defines the key for the spacingBottom style The value represents the
           * spacing, in pixels, added to the bottom side of a label in a vertex
           * (style applies to vertices only). Value is "spacingBottom".
           */
          STYLE_SPACING_BOTTOM: "spacingBottom",
          /**
           * Variable: STYLE_SPACING_RIGHT
           * 
           * Defines the key for the spacingRight style The value represents the
           * spacing, in pixels, added to the right side of a label in a vertex (style
           * applies to vertices only). Value is "spacingRight".
           */
          STYLE_SPACING_RIGHT: "spacingRight",
          /**
           * Variable: STYLE_HORIZONTAL
           * 
           * Defines the key for the horizontal style. Possible values are
           * true or false. This value only applies to vertices. If the <STYLE_SHAPE>
           * is "SHAPE_SWIMLANE" a value of false indicates that the
           * swimlane should be drawn vertically, true indicates to draw it
           * horizontally. If the shape style does not indicate that this vertex is a
           * swimlane, this value affects only whether the label is drawn
           * horizontally or vertically. Value is "horizontal".
           */
          STYLE_HORIZONTAL: "horizontal",
          /**
           * Variable: STYLE_DIRECTION
           * 
           * Defines the key for the direction style. The direction style is used
           * to specify the direction of certain shapes (eg. <mxTriangle>).
           * Possible values are <DIRECTION_EAST> (default), <DIRECTION_WEST>,
           * <DIRECTION_NORTH> and <DIRECTION_SOUTH>. Value is "direction".
           */
          STYLE_DIRECTION: "direction",
          /**
           * Variable: STYLE_ANCHOR_POINT_DIRECTION
           * 
           * Defines the key for the anchorPointDirection style. The defines if the
           * direction style should be taken into account when computing the fixed
           * point location for connected edges. Default is 1 (yes). Set this to 0
           * to ignore the direction style for fixed connection points. Value is
           * "anchorPointDirection".
           */
          STYLE_ANCHOR_POINT_DIRECTION: "anchorPointDirection",
          /**
           * Variable: STYLE_ELBOW
           * 
           * Defines the key for the elbow style. Possible values are
           * <ELBOW_HORIZONTAL> and <ELBOW_VERTICAL>. Default is <ELBOW_HORIZONTAL>.
           * This defines how the three segment orthogonal edge style leaves its
           * terminal vertices. The vertical style leaves the terminal vertices at
           * the top and bottom sides. Value is "elbow".
           */
          STYLE_ELBOW: "elbow",
          /**
           * Variable: STYLE_FONTCOLOR
           * 
           * Defines the key for the fontColor style. Possible values are all HTML
           * color names or HEX codes. Value is "fontColor".
           */
          STYLE_FONTCOLOR: "fontColor",
          /**
           * Variable: STYLE_FONTFAMILY
           * 
           * Defines the key for the fontFamily style. Possible values are names such
           * as Arial; Dialog; Verdana; Times New Roman. The value is of type String.
           * Value is fontFamily.
           */
          STYLE_FONTFAMILY: "fontFamily",
          /**
           * Variable: STYLE_FONTSIZE
           * 
           * Defines the key for the fontSize style (in px). The type of the value
           * is int. Value is "fontSize".
           */
          STYLE_FONTSIZE: "fontSize",
          /**
           * Variable: STYLE_FONTSTYLE
           * 
           * Defines the key for the fontStyle style. Values may be any logical AND
           * (sum) of <FONT_BOLD>, <FONT_ITALIC> and <FONT_UNDERLINE>.
           * The type of the value is int. Value is "fontStyle".
           */
          STYLE_FONTSTYLE: "fontStyle",
          /**
           * Variable: STYLE_ASPECT
           * 
           * Defines the key for the aspect style. Possible values are empty or fixed.
           * If fixed is used then the aspect ratio of the cell will be maintained
           * when resizing. Default is empty. Value is "aspect".
           */
          STYLE_ASPECT: "aspect",
          /**
           * Variable: STYLE_AUTOSIZE
           * 
           * Defines the key for the autosize style. This specifies if a cell should be
           * resized automatically if the value has changed. Possible values are 0 or 1.
           * Default is 0. See <mxGraph.isAutoSizeCell>. This is normally combined with
           * <STYLE_RESIZABLE> to disable manual sizing. Value is "autosize".
           */
          STYLE_AUTOSIZE: "autosize",
          /**
           * Variable: STYLE_FOLDABLE
           * 
           * Defines the key for the foldable style. This specifies if a cell is foldable
           * using a folding icon. Possible values are 0 or 1. Default is 1. See
           * <mxGraph.isCellFoldable>. Value is "foldable".
           */
          STYLE_FOLDABLE: "foldable",
          /**
           * Variable: STYLE_EDITABLE
           * 
           * Defines the key for the editable style. This specifies if the value of
           * a cell can be edited using the in-place editor. Possible values are 0 or
           * 1. Default is 1. See <mxGraph.isCellEditable>. Value is "editable".
           */
          STYLE_EDITABLE: "editable",
          /**
           * Variable: STYLE_BACKGROUND_OUTLINE
           * 
           * Defines the key for the backgroundOutline style. This specifies if a
           * only the background of a cell should be painted when it is highlighted.
           * Possible values are 0 or 1. Default is 0. Value is "backgroundOutline".
           */
          STYLE_BACKGROUND_OUTLINE: "backgroundOutline",
          /**
           * Variable: STYLE_BENDABLE
           * 
           * Defines the key for the bendable style. This specifies if the control
           * points of an edge can be moved. Possible values are 0 or 1. Default is
           * 1. See <mxGraph.isCellBendable>. Value is "bendable".
           */
          STYLE_BENDABLE: "bendable",
          /**
           * Variable: STYLE_MOVABLE
           * 
           * Defines the key for the movable style. This specifies if a cell can
           * be moved. Possible values are 0 or 1. Default is 1. See
           * <mxGraph.isCellMovable>. Value is "movable".
           */
          STYLE_MOVABLE: "movable",
          /**
           * Variable: STYLE_RESIZABLE
           * 
           * Defines the key for the resizable style. This specifies if a cell can
           * be resized. Possible values are 0 or 1. Default is 1. See
           * <mxGraph.isCellResizable>. Value is "resizable".
           */
          STYLE_RESIZABLE: "resizable",
          /**
           * Variable: STYLE_RESIZE_WIDTH
           * 
           * Defines the key for the resizeWidth style. This specifies if a cell's
           * width is resized if the parent is resized. If this is 1 then the width
           * will be resized even if the cell's geometry is relative. If this is 0
           * then the cell's width will not be resized. Default is not defined. Value
           * is "resizeWidth".
           */
          STYLE_RESIZE_WIDTH: "resizeWidth",
          /**
           * Variable: STYLE_RESIZE_WIDTH
           * 
           * Defines the key for the resizeHeight style. This specifies if a cell's
           * height if resize if the parent is resized. If this is 1 then the height
           * will be resized even if the cell's geometry is relative. If this is 0
           * then the cell's height will not be resized. Default is not defined. Value
           * is "resizeHeight".
           */
          STYLE_RESIZE_HEIGHT: "resizeHeight",
          /**
           * Variable: STYLE_ROTATABLE
           * 
           * Defines the key for the rotatable style. This specifies if a cell can
           * be rotated. Possible values are 0 or 1. Default is 1. See
           * <mxGraph.isCellRotatable>. Value is "rotatable".
           */
          STYLE_ROTATABLE: "rotatable",
          /**
           * Variable: STYLE_CLONEABLE
           * 
           * Defines the key for the cloneable style. This specifies if a cell can
           * be cloned. Possible values are 0 or 1. Default is 1. See
           * <mxGraph.isCellCloneable>. Value is "cloneable".
           */
          STYLE_CLONEABLE: "cloneable",
          /**
           * Variable: STYLE_DELETABLE
           * 
           * Defines the key for the deletable style. This specifies if a cell can be
           * deleted. Possible values are 0 or 1. Default is 1. See
           * <mxGraph.isCellDeletable>. Value is "deletable".
           */
          STYLE_DELETABLE: "deletable",
          /**
           * Variable: STYLE_SHAPE
           * 
           * Defines the key for the shape. Possible values are all constants with
           * a SHAPE-prefix or any newly defined shape names. Value is "shape".
           */
          STYLE_SHAPE: "shape",
          /**
           * Variable: STYLE_EDGE
           * 
           * Defines the key for the edge style. Possible values are the functions
           * defined in <mxEdgeStyle>. Value is "edgeStyle".
           */
          STYLE_EDGE: "edgeStyle",
          /**
           * Variable: STYLE_JETTY_SIZE
           * 
           * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.
           * Default is 10. Possible values are all numeric values or "auto".
           * Jetty size is the minimum length of the orthogonal segment before
           * it attaches to a shape.
           * Value is "jettySize".
           */
          STYLE_JETTY_SIZE: "jettySize",
          /**
           * Variable: STYLE_SOURCE_JETTY_SIZE
           * 
           * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.
           * Default is 10. Possible values are numeric values or "auto". This has
           * precedence over <STYLE_JETTY_SIZE>. Value is "sourceJettySize".
           */
          STYLE_SOURCE_JETTY_SIZE: "sourceJettySize",
          /**
           * Variable: targetJettySize
           * 
           * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.
           * Default is 10. Possible values are numeric values or "auto". This has
           * precedence over <STYLE_JETTY_SIZE>. Value is "targetJettySize".
           */
          STYLE_TARGET_JETTY_SIZE: "targetJettySize",
          /**
           * Variable: STYLE_LOOP
           * 
           * Defines the key for the loop style. Possible values are the functions
           * defined in <mxEdgeStyle>. Value is "loopStyle". Default is
           * <mxGraph.defaultLoopStylean>.
           */
          STYLE_LOOP: "loopStyle",
          /**
           * Variable: STYLE_ORTHOGONAL_LOOP
           * 
           * Defines the key for the orthogonal loop style. Possible values are 0 and
           * 1. Default is 0. Value is "orthogonalLoop". Use this style to specify
           * if loops with no waypoints and defined anchor points should be routed
           * using <STYLE_LOOP> or not routed.
           */
          STYLE_ORTHOGONAL_LOOP: "orthogonalLoop",
          /**
           * Variable: STYLE_ROUTING_CENTER_X
           * 
           * Defines the key for the horizontal routing center. Possible values are
           * between -0.5 and 0.5. This is the relative offset from the center used
           * for connecting edges. The type of this value is numeric. Value is
           * "routingCenterX".
           */
          STYLE_ROUTING_CENTER_X: "routingCenterX",
          /**
           * Variable: STYLE_ROUTING_CENTER_Y
           * 
           * Defines the key for the vertical routing center. Possible values are
           * between -0.5 and 0.5. This is the relative offset from the center used
           * for connecting edges. The type of this value is numeric. Value is
           * "routingCenterY".
           */
          STYLE_ROUTING_CENTER_Y: "routingCenterY",
          /**
           * Variable: STYLE_CELL_HIGHLIGHT_COLOR
           */
          STYLE_CELL_HIGHLIGHT_COLOR: "cellHighlightColor",
          /**
           * Variable: STYLE_CELL_HIGHLIGHT_STROKE_WIDTH
           */
          STYLE_CELL_HIGHLIGHT_STROKE_WIDTH: "cellHighlightStrokeWidth",
          /**
           * Variable: STYLE_CELL_HIGHLIGHT_DASHED
           */
          STYLE_CELL_HIGHLIGHT_DASHED: "cellHighlightDashed",
          /**
           * Variable: FONT_BOLD
           * 
           * Constant for bold fonts. Default is 1.
           */
          FONT_BOLD: 1,
          /**
           * Variable: FONT_ITALIC
           * 
           * Constant for italic fonts. Default is 2.
           */
          FONT_ITALIC: 2,
          /**
           * Variable: FONT_UNDERLINE
           * 
           * Constant for underlined fonts. Default is 4.
           */
          FONT_UNDERLINE: 4,
          /**
           * Variable: FONT_STRIKETHROUGH
           * 
           * Constant for strikthrough fonts. Default is 8.
           */
          FONT_STRIKETHROUGH: 8,
          /**
           * Variable: SHAPE_RECTANGLE
           * 
           * Name under which <mxRectangleShape> is registered in <mxCellRenderer>.
           * Default is rectangle.
           */
          SHAPE_RECTANGLE: "rectangle",
          /**
           * Variable: SHAPE_ELLIPSE
           * 
           * Name under which <mxEllipse> is registered in <mxCellRenderer>.
           * Default is ellipse.
           */
          SHAPE_ELLIPSE: "ellipse",
          /**
           * Variable: SHAPE_DOUBLE_ELLIPSE
           * 
           * Name under which <mxDoubleEllipse> is registered in <mxCellRenderer>.
           * Default is doubleEllipse.
           */
          SHAPE_DOUBLE_ELLIPSE: "doubleEllipse",
          /**
           * Variable: SHAPE_RHOMBUS
           * 
           * Name under which <mxRhombus> is registered in <mxCellRenderer>.
           * Default is rhombus.
           */
          SHAPE_RHOMBUS: "rhombus",
          /**
           * Variable: SHAPE_LINE
           * 
           * Name under which <mxLine> is registered in <mxCellRenderer>.
           * Default is line.
           */
          SHAPE_LINE: "line",
          /**
           * Variable: SHAPE_IMAGE
           * 
           * Name under which <mxImageShape> is registered in <mxCellRenderer>.
           * Default is image.
           */
          SHAPE_IMAGE: "image",
          /**
           * Variable: SHAPE_ARROW
           * 
           * Name under which <mxArrow> is registered in <mxCellRenderer>.
           * Default is arrow.
           */
          SHAPE_ARROW: "arrow",
          /**
           * Variable: SHAPE_ARROW_CONNECTOR
           * 
           * Name under which <mxArrowConnector> is registered in <mxCellRenderer>.
           * Default is arrowConnector.
           */
          SHAPE_ARROW_CONNECTOR: "arrowConnector",
          /**
           * Variable: SHAPE_LABEL
           * 
           * Name under which <mxLabel> is registered in <mxCellRenderer>.
           * Default is label.
           */
          SHAPE_LABEL: "label",
          /**
           * Variable: SHAPE_CYLINDER
           * 
           * Name under which <mxCylinder> is registered in <mxCellRenderer>.
           * Default is cylinder.
           */
          SHAPE_CYLINDER: "cylinder",
          /**
           * Variable: SHAPE_SWIMLANE
           * 
           * Name under which <mxSwimlane> is registered in <mxCellRenderer>.
           * Default is swimlane.
           */
          SHAPE_SWIMLANE: "swimlane",
          /**
           * Variable: SHAPE_CONNECTOR
           * 
           * Name under which <mxConnector> is registered in <mxCellRenderer>.
           * Default is connector.
           */
          SHAPE_CONNECTOR: "connector",
          /**
           * Variable: SHAPE_ACTOR
           * 
           * Name under which <mxActor> is registered in <mxCellRenderer>.
           * Default is actor.
           */
          SHAPE_ACTOR: "actor",
          /**
           * Variable: SHAPE_CLOUD
           * 
           * Name under which <mxCloud> is registered in <mxCellRenderer>.
           * Default is cloud.
           */
          SHAPE_CLOUD: "cloud",
          /**
           * Variable: SHAPE_TRIANGLE
           * 
           * Name under which <mxTriangle> is registered in <mxCellRenderer>.
           * Default is triangle.
           */
          SHAPE_TRIANGLE: "triangle",
          /**
           * Variable: SHAPE_HEXAGON
           * 
           * Name under which <mxHexagon> is registered in <mxCellRenderer>.
           * Default is hexagon.
           */
          SHAPE_HEXAGON: "hexagon",
          /**
           * Variable: ARROW_CLASSIC
           * 
           * Constant for classic arrow markers.
           */
          ARROW_CLASSIC: "classic",
          /**
           * Variable: ARROW_CLASSIC_THIN
           * 
           * Constant for thin classic arrow markers.
           */
          ARROW_CLASSIC_THIN: "classicThin",
          /**
           * Variable: ARROW_BLOCK
           * 
           * Constant for block arrow markers.
           */
          ARROW_BLOCK: "block",
          /**
           * Variable: ARROW_BLOCK_THIN
           * 
           * Constant for thin block arrow markers.
           */
          ARROW_BLOCK_THIN: "blockThin",
          /**
           * Variable: ARROW_OPEN
           * 
           * Constant for open arrow markers.
           */
          ARROW_OPEN: "open",
          /**
           * Variable: ARROW_OPEN_THIN
           * 
           * Constant for thin open arrow markers.
           */
          ARROW_OPEN_THIN: "openThin",
          /**
           * Variable: ARROW_OVAL
           * 
           * Constant for oval arrow markers.
           */
          ARROW_OVAL: "oval",
          /**
           * Variable: ARROW_DIAMOND
           * 
           * Constant for diamond arrow markers.
           */
          ARROW_DIAMOND: "diamond",
          /**
           * Variable: ARROW_DIAMOND_THIN
           * 
           * Constant for thin diamond arrow markers.
           */
          ARROW_DIAMOND_THIN: "diamondThin",
          /**
           * Variable: ALIGN_LEFT
           * 
           * Constant for left horizontal alignment. Default is left.
           */
          ALIGN_LEFT: "left",
          /**
           * Variable: ALIGN_CENTER
           * 
           * Constant for center horizontal alignment. Default is center.
           */
          ALIGN_CENTER: "center",
          /**
           * Variable: ALIGN_RIGHT
           * 
           * Constant for right horizontal alignment. Default is right.
           */
          ALIGN_RIGHT: "right",
          /**
           * Variable: ALIGN_TOP
           * 
           * Constant for top vertical alignment. Default is top.
           */
          ALIGN_TOP: "top",
          /**
           * Variable: ALIGN_MIDDLE
           * 
           * Constant for middle vertical alignment. Default is middle.
           */
          ALIGN_MIDDLE: "middle",
          /**
           * Variable: ALIGN_BOTTOM
           * 
           * Constant for bottom vertical alignment. Default is bottom.
           */
          ALIGN_BOTTOM: "bottom",
          /**
           * Variable: DIRECTION_NORTH
           * 
           * Constant for direction north. Default is north.
           */
          DIRECTION_NORTH: "north",
          /**
           * Variable: DIRECTION_SOUTH
           * 
           * Constant for direction south. Default is south.
           */
          DIRECTION_SOUTH: "south",
          /**
           * Variable: DIRECTION_EAST
           * 
           * Constant for direction east. Default is east.
           */
          DIRECTION_EAST: "east",
          /**
           * Variable: DIRECTION_WEST
           * 
           * Constant for direction west. Default is west.
           */
          DIRECTION_WEST: "west",
          /**
           * Variable: TEXT_DIRECTION_DEFAULT
           * 
           * Constant for text direction default. Default is an empty string. Use
           * this value to use the default text direction of the operating system. 
           */
          TEXT_DIRECTION_DEFAULT: "",
          /**
           * Variable: TEXT_DIRECTION_AUTO
           * 
           * Constant for text direction automatic. Default is auto. Use this value
           * to find the direction for a given text with <mxText.getAutoDirection>. 
           */
          TEXT_DIRECTION_AUTO: "auto",
          /**
           * Variable: TEXT_DIRECTION_LTR
           * 
           * Constant for text direction left to right. Default is ltr. Use this
           * value for left to right text direction.
           */
          TEXT_DIRECTION_LTR: "ltr",
          /**
           * Variable: TEXT_DIRECTION_RTL
           * 
           * Constant for text direction right to left. Default is rtl. Use this
           * value for right to left text direction.
           */
          TEXT_DIRECTION_RTL: "rtl",
          /**
           * Variable: DIRECTION_MASK_NONE
           * 
           * Constant for no direction.
           */
          DIRECTION_MASK_NONE: 0,
          /**
           * Variable: DIRECTION_MASK_WEST
           * 
           * Bitwise mask for west direction.
           */
          DIRECTION_MASK_WEST: 1,
          /**
           * Variable: DIRECTION_MASK_NORTH
           * 
           * Bitwise mask for north direction.
           */
          DIRECTION_MASK_NORTH: 2,
          /**
           * Variable: DIRECTION_MASK_SOUTH
           * 
           * Bitwise mask for south direction.
           */
          DIRECTION_MASK_SOUTH: 4,
          /**
           * Variable: DIRECTION_MASK_EAST
           * 
           * Bitwise mask for east direction.
           */
          DIRECTION_MASK_EAST: 8,
          /**
           * Variable: DIRECTION_MASK_ALL
           * 
           * Bitwise mask for all directions.
           */
          DIRECTION_MASK_ALL: 15,
          /**
           * Variable: ELBOW_VERTICAL
           * 
           * Constant for elbow vertical. Default is horizontal.
           */
          ELBOW_VERTICAL: "vertical",
          /**
           * Variable: ELBOW_HORIZONTAL
           * 
           * Constant for elbow horizontal. Default is horizontal.
           */
          ELBOW_HORIZONTAL: "horizontal",
          /**
           * Variable: EDGESTYLE_ELBOW
           * 
           * Name of the elbow edge style. Can be used as a string value
           * for the STYLE_EDGE style.
           */
          EDGESTYLE_ELBOW: "elbowEdgeStyle",
          /**
           * Variable: EDGESTYLE_ENTITY_RELATION
           * 
           * Name of the entity relation edge style. Can be used as a string value
           * for the STYLE_EDGE style.
           */
          EDGESTYLE_ENTITY_RELATION: "entityRelationEdgeStyle",
          /**
           * Variable: EDGESTYLE_LOOP
           * 
           * Name of the loop edge style. Can be used as a string value
           * for the STYLE_EDGE style.
           */
          EDGESTYLE_LOOP: "loopEdgeStyle",
          /**
           * Variable: EDGESTYLE_SIDETOSIDE
           * 
           * Name of the side to side edge style. Can be used as a string value
           * for the STYLE_EDGE style.
           */
          EDGESTYLE_SIDETOSIDE: "sideToSideEdgeStyle",
          /**
           * Variable: EDGESTYLE_TOPTOBOTTOM
           * 
           * Name of the top to bottom edge style. Can be used as a string value
           * for the STYLE_EDGE style.
           */
          EDGESTYLE_TOPTOBOTTOM: "topToBottomEdgeStyle",
          /**
           * Variable: EDGESTYLE_ORTHOGONAL
           * 
           * Name of the generic orthogonal edge style. Can be used as a string value
           * for the STYLE_EDGE style.
           */
          EDGESTYLE_ORTHOGONAL: "orthogonalEdgeStyle",
          /**
           * Variable: EDGESTYLE_SEGMENT
           * 
           * Name of the generic segment edge style. Can be used as a string value
           * for the STYLE_EDGE style.
           */
          EDGESTYLE_SEGMENT: "segmentEdgeStyle",
          /**
           * Variable: PERIMETER_ELLIPSE
           * 
           * Name of the ellipse perimeter. Can be used as a string value
           * for the STYLE_PERIMETER style.
           */
          PERIMETER_ELLIPSE: "ellipsePerimeter",
          /**
           * Variable: PERIMETER_RECTANGLE
           *
           * Name of the rectangle perimeter. Can be used as a string value
           * for the STYLE_PERIMETER style.
           */
          PERIMETER_RECTANGLE: "rectanglePerimeter",
          /**
           * Variable: PERIMETER_RHOMBUS
           * 
           * Name of the rhombus perimeter. Can be used as a string value
           * for the STYLE_PERIMETER style.
           */
          PERIMETER_RHOMBUS: "rhombusPerimeter",
          /**
           * Variable: PERIMETER_HEXAGON
           * 
           * Name of the hexagon perimeter. Can be used as a string value 
           * for the STYLE_PERIMETER style.
           */
          PERIMETER_HEXAGON: "hexagonPerimeter",
          /**
           * Variable: PERIMETER_TRIANGLE
           * 
           * Name of the triangle perimeter. Can be used as a string value
           * for the STYLE_PERIMETER style.
           */
          PERIMETER_TRIANGLE: "trianglePerimeter"
        };
        __mxOutput.mxConstants = typeof mxConstants !== "undefined" ? mxConstants : void 0;
        function mxEventObject(name2) {
          this.name = name2;
          this.properties = [];
          for (var i = 1; i < arguments.length; i += 2) {
            if (arguments[i + 1] != null) {
              this.properties[arguments[i]] = arguments[i + 1];
            }
          }
        }
        ;
        mxEventObject.prototype.name = null;
        mxEventObject.prototype.properties = null;
        mxEventObject.prototype.consumed = false;
        mxEventObject.prototype.getName = function() {
          return this.name;
        };
        mxEventObject.prototype.getProperties = function() {
          return this.properties;
        };
        mxEventObject.prototype.getProperty = function(key) {
          return this.properties[key];
        };
        mxEventObject.prototype.isConsumed = function() {
          return this.consumed;
        };
        mxEventObject.prototype.consume = function() {
          this.consumed = true;
        };
        __mxOutput.mxEventObject = typeof mxEventObject !== "undefined" ? mxEventObject : void 0;
        function mxMouseEvent(evt, state) {
          this.evt = evt;
          this.state = state;
          this.sourceState = state;
        }
        ;
        mxMouseEvent.prototype.consumed = false;
        mxMouseEvent.prototype.evt = null;
        mxMouseEvent.prototype.graphX = null;
        mxMouseEvent.prototype.graphY = null;
        mxMouseEvent.prototype.state = null;
        mxMouseEvent.prototype.sourceState = null;
        mxMouseEvent.prototype.getEvent = function() {
          return this.evt;
        };
        mxMouseEvent.prototype.getSource = function() {
          return mxEvent.getSource(this.evt);
        };
        mxMouseEvent.prototype.isSource = function(shape2) {
          if (shape2 != null) {
            return mxUtils.isAncestorNode(shape2.node, this.getSource());
          }
          return false;
        };
        mxMouseEvent.prototype.getX = function() {
          return mxEvent.getClientX(this.getEvent());
        };
        mxMouseEvent.prototype.getY = function() {
          return mxEvent.getClientY(this.getEvent());
        };
        mxMouseEvent.prototype.getGraphX = function() {
          return this.graphX;
        };
        mxMouseEvent.prototype.getGraphY = function() {
          return this.graphY;
        };
        mxMouseEvent.prototype.getState = function() {
          return this.state;
        };
        mxMouseEvent.prototype.getCell = function() {
          var state = this.getState();
          if (state != null) {
            return state.cell;
          }
          return null;
        };
        mxMouseEvent.prototype.isPopupTrigger = function() {
          return mxEvent.isPopupTrigger(this.getEvent());
        };
        mxMouseEvent.prototype.isConsumed = function() {
          return this.consumed;
        };
        mxMouseEvent.prototype.consume = function(preventDefault) {
          preventDefault = preventDefault != null ? preventDefault : this.evt.touches != null || mxEvent.isMouseEvent(this.evt);
          if (preventDefault && this.evt.preventDefault) {
            this.evt.preventDefault();
          }
          if (mxClient.IS_IE) {
            this.evt.returnValue = true;
          }
          this.consumed = true;
        };
        __mxOutput.mxMouseEvent = typeof mxMouseEvent !== "undefined" ? mxMouseEvent : void 0;
        function mxEventSource(eventSource) {
          this.setEventSource(eventSource);
        }
        ;
        mxEventSource.prototype.eventListeners = null;
        mxEventSource.prototype.eventsEnabled = true;
        mxEventSource.prototype.eventSource = null;
        mxEventSource.prototype.isEventsEnabled = function() {
          return this.eventsEnabled;
        };
        mxEventSource.prototype.setEventsEnabled = function(value) {
          this.eventsEnabled = value;
        };
        mxEventSource.prototype.getEventSource = function() {
          return this.eventSource;
        };
        mxEventSource.prototype.setEventSource = function(value) {
          this.eventSource = value;
        };
        mxEventSource.prototype.addListener = function(name2, funct) {
          if (this.eventListeners == null) {
            this.eventListeners = [];
          }
          this.eventListeners.push(name2);
          this.eventListeners.push(funct);
        };
        mxEventSource.prototype.removeListener = function(funct) {
          if (this.eventListeners != null) {
            var i = 0;
            while (i < this.eventListeners.length) {
              if (this.eventListeners[i + 1] == funct) {
                this.eventListeners.splice(i, 2);
              } else {
                i += 2;
              }
            }
          }
        };
        mxEventSource.prototype.fireEvent = function(evt, sender) {
          if (this.eventListeners != null && this.isEventsEnabled()) {
            if (evt == null) {
              evt = new mxEventObject();
            }
            if (sender == null) {
              sender = this.getEventSource();
            }
            if (sender == null) {
              sender = this;
            }
            var args = [sender, evt];
            for (var i = 0; i < this.eventListeners.length; i += 2) {
              var listen = this.eventListeners[i];
              if (listen == null || listen == evt.getName()) {
                this.eventListeners[i + 1].apply(this, args);
              }
            }
          }
        };
        __mxOutput.mxEventSource = typeof mxEventSource !== "undefined" ? mxEventSource : void 0;
        var mxEvent = {
          /**
           * Class: mxEvent
           * 
           * Cross-browser DOM event support. For internal event handling,
           * <mxEventSource> and the graph event dispatch loop in <mxGraph> are used.
           * 
           * Memory Leaks:
           * 
           * Use this class for adding and removing listeners to/from DOM nodes. The
           * <removeAllListeners> function is provided to remove all listeners that
           * have been added using <addListener>. The function should be invoked when
           * the last reference is removed in the JavaScript code, typically when the
           * referenced DOM node is removed from the DOM.
           *
           * Function: addListener
           * 
           * Binds the function to the specified event on the given element. Use
           * <mxUtils.bind> in order to bind the "this" keyword inside the function
           * to a given execution scope.
           */
          addListener: function() {
            var updateListenerList = function(element, eventName, funct) {
              if (element.mxListenerList == null) {
                element.mxListenerList = [];
              }
              var entry = { name: eventName, f: funct };
              element.mxListenerList.push(entry);
            };
            if (window.addEventListener) {
              var supportsPassive = false;
              try {
                document.addEventListener("test", function() {
                }, Object.defineProperty && Object.defineProperty({}, "passive", { get: function() {
                  supportsPassive = true;
                } }));
              } catch (e) {
              }
              return function(element, eventName, funct) {
                element.addEventListener(
                  eventName,
                  funct,
                  supportsPassive ? { passive: false } : false
                );
                updateListenerList(element, eventName, funct);
              };
            } else {
              return function(element, eventName, funct) {
                element.attachEvent("on" + eventName, funct);
                updateListenerList(element, eventName, funct);
              };
            }
          }(),
          /**
           * Function: removeListener
           *
           * Removes the specified listener from the given element.
           */
          removeListener: function() {
            var updateListener = function(element, eventName, funct) {
              if (element.mxListenerList != null) {
                var listenerCount = element.mxListenerList.length;
                for (var i = 0; i < listenerCount; i++) {
                  var entry = element.mxListenerList[i];
                  if (entry.f == funct) {
                    element.mxListenerList.splice(i, 1);
                    break;
                  }
                }
                if (element.mxListenerList.length == 0) {
                  element.mxListenerList = null;
                }
              }
            };
            if (window.removeEventListener) {
              return function(element, eventName, funct) {
                element.removeEventListener(eventName, funct, false);
                updateListener(element, eventName, funct);
              };
            } else {
              return function(element, eventName, funct) {
                element.detachEvent("on" + eventName, funct);
                updateListener(element, eventName, funct);
              };
            }
          }(),
          /**
           * Function: removeAllListeners
           * 
           * Removes all listeners from the given element.
           */
          removeAllListeners: function(element) {
            var list = element.mxListenerList;
            if (list != null) {
              while (list.length > 0) {
                var entry = list[0];
                mxEvent.removeListener(element, entry.name, entry.f);
              }
            }
          },
          /**
           * Function: addGestureListeners
           * 
           * Adds the given listeners for touch, mouse and/or pointer events. If
           * <mxClient.IS_POINTER> is true then pointer events will be registered,
           * else the respective mouse events will be registered. If <mxClient.IS_POINTER>
           * is false and <mxClient.IS_TOUCH> is true then the respective touch events
           * will be registered as well as the mouse events.
           */
          addGestureListeners: function(node, startListener, moveListener, endListener) {
            if (startListener != null) {
              mxEvent.addListener(node, mxClient.IS_POINTER ? "pointerdown" : "mousedown", startListener);
            }
            if (moveListener != null) {
              mxEvent.addListener(node, mxClient.IS_POINTER ? "pointermove" : "mousemove", moveListener);
            }
            if (endListener != null) {
              mxEvent.addListener(node, mxClient.IS_POINTER ? "pointerup" : "mouseup", endListener);
            }
            if (!mxClient.IS_POINTER && mxClient.IS_TOUCH) {
              if (startListener != null) {
                mxEvent.addListener(node, "touchstart", startListener);
              }
              if (moveListener != null) {
                mxEvent.addListener(node, "touchmove", moveListener);
              }
              if (endListener != null) {
                mxEvent.addListener(node, "touchend", endListener);
              }
            }
          },
          /**
           * Function: removeGestureListeners
           * 
           * Removes the given listeners from mousedown, mousemove, mouseup and the
           * respective touch events if <mxClient.IS_TOUCH> is true.
           */
          removeGestureListeners: function(node, startListener, moveListener, endListener) {
            if (startListener != null) {
              mxEvent.removeListener(node, mxClient.IS_POINTER ? "pointerdown" : "mousedown", startListener);
            }
            if (moveListener != null) {
              mxEvent.removeListener(node, mxClient.IS_POINTER ? "pointermove" : "mousemove", moveListener);
            }
            if (endListener != null) {
              mxEvent.removeListener(node, mxClient.IS_POINTER ? "pointerup" : "mouseup", endListener);
            }
            if (!mxClient.IS_POINTER && mxClient.IS_TOUCH) {
              if (startListener != null) {
                mxEvent.removeListener(node, "touchstart", startListener);
              }
              if (moveListener != null) {
                mxEvent.removeListener(node, "touchmove", moveListener);
              }
              if (endListener != null) {
                mxEvent.removeListener(node, "touchend", endListener);
              }
            }
          },
          /**
           * Function: redirectMouseEvents
           *
           * Redirects the mouse events from the given DOM node to the graph dispatch
           * loop using the event and given state as event arguments. State can
           * either be an instance of <mxCellState> or a function that returns an
           * <mxCellState>. The down, move, up and dblClick arguments are optional
           * functions that take the trigger event as arguments and replace the
           * default behaviour.
           */
          redirectMouseEvents: function(node, graph, state, down, move, up, dblClick) {
            var getState = function(evt) {
              return typeof state == "function" ? state(evt) : state;
            };
            mxEvent.addGestureListeners(
              node,
              function(evt) {
                if (down != null) {
                  down(evt);
                } else if (!mxEvent.isConsumed(evt)) {
                  graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, getState(evt)));
                }
              },
              function(evt) {
                if (move != null) {
                  move(evt);
                } else if (!mxEvent.isConsumed(evt)) {
                  graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));
                }
              },
              function(evt) {
                if (up != null) {
                  up(evt);
                } else if (!mxEvent.isConsumed(evt)) {
                  graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, getState(evt)));
                }
              }
            );
            mxEvent.addListener(node, "dblclick", function(evt) {
              if (dblClick != null) {
                dblClick(evt);
              } else if (!mxEvent.isConsumed(evt)) {
                var tmp = getState(evt);
                graph.dblClick(evt, tmp != null ? tmp.cell : null);
              }
            });
          },
          /**
           * Function: release
           * 
           * Removes the known listeners from the given DOM node and its descendants.
           * 
           * Parameters:
           * 
           * element - DOM node to remove the listeners from.
           */
          release: function(element) {
            try {
              if (element != null) {
                mxEvent.removeAllListeners(element);
                var children = element.childNodes;
                if (children != null) {
                  var childCount = children.length;
                  for (var i = 0; i < childCount; i += 1) {
                    mxEvent.release(children[i]);
                  }
                }
              }
            } catch (e) {
            }
          },
          /**
           * Function: addMouseWheelListener
           * 
           * Installs the given function as a handler for mouse wheel events. The
           * function has two arguments: the mouse event and a boolean that specifies
           * if the wheel was moved up or down.
           * 
           * This has been tested with IE 6 and 7, Firefox (all versions), Opera and
           * Safari. It does currently not work on Safari for Mac.
           * 
           * Example:
           * 
           * (code)
           * mxEvent.addMouseWheelListener(function (evt, up, pinch)
           * {
           *   mxLog.show();
           *   mxLog.debug('mouseWheel: up='+up);
           * });
           *(end)
           * 
           * Parameters:
           * 
           * funct - Handler function that takes the event argument, a boolean argument
           * for the mousewheel direction and a boolean to specify if the underlying
           * event was a pinch gesture on a touch device.
           * target - Target for installing the listener in Google Chrome. See 
           * https://www.chromestatus.com/features/6662647093133312.
           */
          addMouseWheelListener: function(funct, target) {
            if (funct != null) {
              var wheelHandler = function(evt) {
                if (evt == null) {
                  evt = window.event;
                }
                if (evt.ctrlKey) {
                  evt.preventDefault();
                }
                if (Math.abs(evt.deltaX) > 0.5 || Math.abs(evt.deltaY) > 0.5) {
                  funct(evt, evt.deltaY == 0 ? -evt.deltaX > 0 : -evt.deltaY > 0);
                }
              };
              target = target != null ? target : window;
              if (mxClient.IS_SF && !mxClient.IS_TOUCH) {
                var scale = 1;
                mxEvent.addListener(target, "gesturestart", function(evt) {
                  mxEvent.consume(evt);
                  scale = 1;
                });
                mxEvent.addListener(target, "gesturechange", function(evt) {
                  mxEvent.consume(evt);
                  var diff = scale - evt.scale;
                  if (Math.abs(diff) > 0.2) {
                    funct(evt, diff < 0, true);
                    scale = evt.scale;
                  }
                });
                mxEvent.addListener(target, "gestureend", function(evt) {
                  mxEvent.consume(evt);
                });
              } else {
                var evtCache = [];
                var dx0 = 0;
                var dy0 = 0;
                mxEvent.addGestureListeners(
                  target,
                  mxUtils.bind(this, function(evt) {
                    if (!mxEvent.isMouseEvent(evt) && evt.pointerId != null) {
                      evtCache.push(evt);
                    }
                  }),
                  mxUtils.bind(this, function(evt) {
                    if (!mxEvent.isMouseEvent(evt) && evtCache.length == 2) {
                      for (var i = 0; i < evtCache.length; i++) {
                        if (evt.pointerId == evtCache[i].pointerId) {
                          evtCache[i] = evt;
                          break;
                        }
                      }
                      var dx = Math.abs(evtCache[0].clientX - evtCache[1].clientX);
                      var dy = Math.abs(evtCache[0].clientY - evtCache[1].clientY);
                      var tx = Math.abs(dx - dx0);
                      var ty = Math.abs(dy - dy0);
                      if (tx > mxEvent.PINCH_THRESHOLD || ty > mxEvent.PINCH_THRESHOLD) {
                        var cx = evtCache[0].clientX + (evtCache[1].clientX - evtCache[0].clientX) / 2;
                        var cy = evtCache[0].clientY + (evtCache[1].clientY - evtCache[0].clientY) / 2;
                        funct(evtCache[0], tx > ty ? dx > dx0 : dy > dy0, true, cx, cy);
                        dx0 = dx;
                        dy0 = dy;
                      }
                    }
                  }),
                  mxUtils.bind(this, function(evt) {
                    evtCache = [];
                    dx0 = 0;
                    dy0 = 0;
                  })
                );
              }
              mxEvent.addListener(target, "wheel", wheelHandler);
            }
          },
          /**
           * Function: disableContextMenu
           *
           * Disables the context menu for the given element.
           */
          disableContextMenu: function(element) {
            mxEvent.addListener(element, "contextmenu", function(evt) {
              if (evt.preventDefault) {
                evt.preventDefault();
              }
              return false;
            });
          },
          /**
           * Function: getSource
           * 
           * Returns the event's target or srcElement depending on the browser.
           */
          getSource: function(evt) {
            return evt.srcElement != null ? evt.srcElement : evt.target;
          },
          /**
           * Function: isConsumed
           * 
           * Returns true if the event has been consumed using <consume>.
           */
          isConsumed: function(evt) {
            return evt.isConsumed != null && evt.isConsumed;
          },
          /**
           * Function: isTouchEvent
           * 
           * Returns true if the event was generated using a touch device (not a pen or mouse).
           */
          isTouchEvent: function(evt) {
            return evt.pointerType != null ? evt.pointerType == "touch" || evt.pointerType === evt.MSPOINTER_TYPE_TOUCH : evt.mozInputSource != null ? evt.mozInputSource == 5 : evt.type.indexOf("touch") == 0;
          },
          /**
           * Function: isPenEvent
           * 
           * Returns true if the event was generated using a pen (not a touch device or mouse).
           */
          isPenEvent: function(evt) {
            return evt.pointerType != null ? evt.pointerType == "pen" || evt.pointerType === evt.MSPOINTER_TYPE_PEN : evt.mozInputSource != null ? evt.mozInputSource == 2 : evt.type.indexOf("pen") == 0;
          },
          /**
           * Function: isMultiTouchEvent
           * 
           * Returns true if the event was generated using a touch device (not a pen or mouse).
           */
          isMultiTouchEvent: function(evt) {
            return evt.type != null && evt.type.indexOf("touch") == 0 && evt.touches != null && evt.touches.length > 1;
          },
          /**
           * Function: isMouseEvent
           * 
           * Returns true if the event was generated using a mouse (not a pen or touch device).
           */
          isMouseEvent: function(evt) {
            return evt.pointerType != null ? evt.pointerType == "mouse" || evt.pointerType === evt.MSPOINTER_TYPE_MOUSE : evt.mozInputSource != null ? evt.mozInputSource == 1 : evt.type.indexOf("mouse") == 0;
          },
          /**
           * Function: isLeftMouseButton
           * 
           * Returns true if the left mouse button is pressed for the given event.
           * To check if a button is pressed during a mouseMove you should use the
           * <mxGraph.isMouseDown> property. Note that this returns true in Firefox
           * for control+left-click on the Mac.
           */
          isLeftMouseButton: function(evt) {
            if ("buttons" in evt && (evt.type == "mousedown" || evt.type == "mousemove")) {
              return evt.buttons == 1;
            } else if ("which" in evt) {
              return evt.which === 1;
            } else {
              return evt.button === 1;
            }
          },
          /**
           * Function: isMiddleMouseButton
           * 
           * Returns true if the middle mouse button is pressed for the given event.
           * To check if a button is pressed during a mouseMove you should use the
           * <mxGraph.isMouseDown> property.
           */
          isMiddleMouseButton: function(evt) {
            if ("which" in evt) {
              return evt.which === 2;
            } else {
              return evt.button === 4;
            }
          },
          /**
           * Function: isRightMouseButton
           * 
           * Returns true if the right mouse button was pressed. Note that this
           * button might not be available on some systems. For handling a popup
           * trigger <isPopupTrigger> should be used.
           */
          isRightMouseButton: function(evt) {
            if ("which" in evt) {
              return evt.which === 3;
            } else {
              return evt.button === 2;
            }
          },
          /**
           * Function: isPopupTrigger
           * 
           * Returns true if the event is a popup trigger. This implementation
           * returns true if the right button or the left button and control was
           * pressed on a Mac.
           */
          isPopupTrigger: function(evt) {
            return mxEvent.isRightMouseButton(evt) || mxClient.IS_MAC && mxEvent.isControlDown(evt) && !mxEvent.isShiftDown(evt) && !mxEvent.isMetaDown(evt) && !mxEvent.isAltDown(evt);
          },
          /**
           * Function: isShiftDown
           * 
           * Returns true if the shift key is pressed for the given event.
           */
          isShiftDown: function(evt) {
            return evt != null ? evt.shiftKey : false;
          },
          /**
           * Function: isAltDown
           * 
           * Returns true if the alt key is pressed for the given event.
           */
          isAltDown: function(evt) {
            return evt != null ? evt.altKey : false;
          },
          /**
           * Function: isControlDown
           * 
           * Returns true if the control key is pressed for the given event.
           */
          isControlDown: function(evt) {
            return evt != null ? evt.ctrlKey : false;
          },
          /**
           * Function: isMetaDown
           * 
           * Returns true if the meta key is pressed for the given event.
           */
          isMetaDown: function(evt) {
            return evt != null ? evt.metaKey : false;
          },
          /**
           * Function: getMainEvent
           * 
           * Returns the touch or mouse event that contains the mouse coordinates.
           */
          getMainEvent: function(e) {
            if ((e.type == "touchstart" || e.type == "touchmove") && e.touches != null && e.touches[0] != null) {
              e = e.touches[0];
            } else if (e.type == "touchend" && e.changedTouches != null && e.changedTouches[0] != null) {
              e = e.changedTouches[0];
            }
            return e;
          },
          /**
           * Function: getClientX
           * 
           * Returns true if the meta key is pressed for the given event.
           */
          getClientX: function(e) {
            return mxEvent.getMainEvent(e).clientX;
          },
          /**
           * Function: getClientY
           * 
           * Returns true if the meta key is pressed for the given event.
           */
          getClientY: function(e) {
            return mxEvent.getMainEvent(e).clientY;
          },
          /**
           * Function: consume
           * 
           * Consumes the given event.
           * 
           * Parameters:
           * 
           * evt - Native event to be consumed.
           * preventDefault - Optional boolean to prevent the default for the event.
           * Default is true.
           * stopPropagation - Option boolean to stop event propagation. Default is
           * true.
           */
          consume: function(evt, preventDefault, stopPropagation) {
            preventDefault = preventDefault != null ? preventDefault : true;
            stopPropagation = stopPropagation != null ? stopPropagation : true;
            if (preventDefault) {
              if (evt.preventDefault) {
                if (stopPropagation) {
                  evt.stopPropagation();
                }
                evt.preventDefault();
              } else if (stopPropagation) {
                evt.cancelBubble = true;
              }
            }
            evt.isConsumed = true;
            if (!evt.preventDefault) {
              evt.returnValue = false;
            }
          },
          //
          // Special handles in mouse events
          //
          /**
           * Variable: LABEL_HANDLE
           * 
           * Index for the label handle in an mxMouseEvent. This should be a negative
           * value that does not interfere with any possible handle indices. Default
           * is -1.
           */
          LABEL_HANDLE: -1,
          /**
           * Variable: ROTATION_HANDLE
           * 
           * Index for the rotation handle in an mxMouseEvent. This should be a
           * negative value that does not interfere with any possible handle indices.
           * Default is -2.
           */
          ROTATION_HANDLE: -2,
          /**
           * Variable: CUSTOM_HANDLE
           * 
           * Start index for the custom handles in an mxMouseEvent. This should be a
           * negative value and is the start index which is decremented for each
           * custom handle. Default is -100.
           */
          CUSTOM_HANDLE: -100,
          /**
           * Variable: VIRTUAL_HANDLE
           * 
           * Start index for the virtual handles in an mxMouseEvent. This should be a
           * negative value and is the start index which is decremented for each
           * virtual handle. Default is -100000. This assumes that there are no more
           * than VIRTUAL_HANDLE - CUSTOM_HANDLE custom handles.
           * 
           */
          VIRTUAL_HANDLE: -1e5,
          //
          // Event names
          //
          /**
           * Variable: MOUSE_DOWN
           *
           * Specifies the event name for mouseDown.
           */
          MOUSE_DOWN: "mouseDown",
          /**
           * Variable: MOUSE_MOVE
           *
           * Specifies the event name for mouseMove. 
           */
          MOUSE_MOVE: "mouseMove",
          /**
           * Variable: MOUSE_UP
           *
           * Specifies the event name for mouseUp. 
           */
          MOUSE_UP: "mouseUp",
          /**
           * Variable: ACTIVATE
           *
           * Specifies the event name for activate.
           */
          ACTIVATE: "activate",
          /**
           * Variable: RESIZE_START
           *
           * Specifies the event name for resizeStart.
           */
          RESIZE_START: "resizeStart",
          /**
           * Variable: RESIZE
           *
           * Specifies the event name for resize.
           */
          RESIZE: "resize",
          /**
           * Variable: RESIZE_END
           *
           * Specifies the event name for resizeEnd.
           */
          RESIZE_END: "resizeEnd",
          /**
           * Variable: MOVE_START
           *
           * Specifies the event name for moveStart.
           */
          MOVE_START: "moveStart",
          /**
           * Variable: MOVE
           *
           * Specifies the event name for move.
           */
          MOVE: "move",
          /**
           * Variable: MOVE_END
           *
           * Specifies the event name for moveEnd.
           */
          MOVE_END: "moveEnd",
          /**
           * Variable: PAN_START
           *
           * Specifies the event name for panStart.
           */
          PAN_START: "panStart",
          /**
           * Variable: PAN
           *
           * Specifies the event name for pan.
           */
          PAN: "pan",
          /**
           * Variable: PAN_END
           *
           * Specifies the event name for panEnd.
           */
          PAN_END: "panEnd",
          /**
           * Variable: MINIMIZE
           *
           * Specifies the event name for minimize.
           */
          MINIMIZE: "minimize",
          /**
           * Variable: NORMALIZE
           *
           * Specifies the event name for normalize.
           */
          NORMALIZE: "normalize",
          /**
           * Variable: MAXIMIZE
           *
           * Specifies the event name for maximize.
           */
          MAXIMIZE: "maximize",
          /**
           * Variable: HIDE
           *
           * Specifies the event name for hide.
           */
          HIDE: "hide",
          /**
           * Variable: SHOW
           *
           * Specifies the event name for show.
           */
          SHOW: "show",
          /**
           * Variable: CLOSE
           *
           * Specifies the event name for close.
           */
          CLOSE: "close",
          /**
           * Variable: DESTROY
           *
           * Specifies the event name for destroy.
           */
          DESTROY: "destroy",
          /**
           * Variable: REFRESH
           *
           * Specifies the event name for refresh.
           */
          REFRESH: "refresh",
          /**
           * Variable: SIZE
           *
           * Specifies the event name for size.
           */
          SIZE: "size",
          /**
           * Variable: SELECT
           *
           * Specifies the event name for select.
           */
          SELECT: "select",
          /**
           * Variable: FIRED
           *
           * Specifies the event name for fired.
           */
          FIRED: "fired",
          /**
           * Variable: FIRE_MOUSE_EVENT
           *
           * Specifies the event name for fireMouseEvent.
           */
          FIRE_MOUSE_EVENT: "fireMouseEvent",
          /**
           * Variable: GESTURE
           *
           * Specifies the event name for gesture.
           */
          GESTURE: "gesture",
          /**
           * Variable: TAP_AND_HOLD
           *
           * Specifies the event name for tapAndHold.
           */
          TAP_AND_HOLD: "tapAndHold",
          /**
           * Variable: GET
           *
           * Specifies the event name for get.
           */
          GET: "get",
          /**
           * Variable: RECEIVE
           *
           * Specifies the event name for receive.
           */
          RECEIVE: "receive",
          /**
           * Variable: CONNECT
           *
           * Specifies the event name for connect.
           */
          CONNECT: "connect",
          /**
           * Variable: DISCONNECT
           *
           * Specifies the event name for disconnect.
           */
          DISCONNECT: "disconnect",
          /**
           * Variable: SUSPEND
           *
           * Specifies the event name for suspend.
           */
          SUSPEND: "suspend",
          /**
           * Variable: RESUME
           *
           * Specifies the event name for suspend.
           */
          RESUME: "resume",
          /**
           * Variable: MARK
           *
           * Specifies the event name for mark.
           */
          MARK: "mark",
          /**
           * Variable: ROOT
           *
           * Specifies the event name for root.
           */
          ROOT: "root",
          /**
           * Variable: POST
           *
           * Specifies the event name for post.
           */
          POST: "post",
          /**
           * Variable: OPEN
           *
           * Specifies the event name for open.
           */
          OPEN: "open",
          /**
           * Variable: SAVE
           *
           * Specifies the event name for open.
           */
          SAVE: "save",
          /**
           * Variable: BEFORE_ADD_VERTEX
           *
           * Specifies the event name for beforeAddVertex.
           */
          BEFORE_ADD_VERTEX: "beforeAddVertex",
          /**
           * Variable: ADD_VERTEX
           *
           * Specifies the event name for addVertex.
           */
          ADD_VERTEX: "addVertex",
          /**
           * Variable: AFTER_ADD_VERTEX
           *
           * Specifies the event name for afterAddVertex.
           */
          AFTER_ADD_VERTEX: "afterAddVertex",
          /**
           * Variable: DONE
           *
           * Specifies the event name for done.
           */
          DONE: "done",
          /**
           * Variable: EXECUTE
           *
           * Specifies the event name for execute.
           */
          EXECUTE: "execute",
          /**
           * Variable: EXECUTED
           *
           * Specifies the event name for executed.
           */
          EXECUTED: "executed",
          /**
           * Variable: BEGIN_UPDATE
           *
           * Specifies the event name for beginUpdate.
           */
          BEGIN_UPDATE: "beginUpdate",
          /**
           * Variable: START_EDIT
           *
           * Specifies the event name for startEdit.
           */
          START_EDIT: "startEdit",
          /**
           * Variable: END_UPDATE
           *
           * Specifies the event name for endUpdate.
           */
          END_UPDATE: "endUpdate",
          /**
           * Variable: END_EDIT
           *
           * Specifies the event name for endEdit.
           */
          END_EDIT: "endEdit",
          /**
           * Variable: BEFORE_UNDO
           *
           * Specifies the event name for beforeUndo.
           */
          BEFORE_UNDO: "beforeUndo",
          /**
           * Variable: UNDO
           *
           * Specifies the event name for undo.
           */
          UNDO: "undo",
          /**
           * Variable: REDO
           *
           * Specifies the event name for redo.
           */
          REDO: "redo",
          /**
           * Variable: CHANGE
           *
           * Specifies the event name for change.
           */
          CHANGE: "change",
          /**
           * Variable: NOTIFY
           *
           * Specifies the event name for notify.
           */
          NOTIFY: "notify",
          /**
           * Variable: LAYOUT_CELLS
           *
           * Specifies the event name for layoutCells.
           */
          LAYOUT_CELLS: "layoutCells",
          /**
           * Variable: CLICK
           *
           * Specifies the event name for click.
           */
          CLICK: "click",
          /**
           * Variable: SCALE
           *
           * Specifies the event name for scale.
           */
          SCALE: "scale",
          /**
           * Variable: TRANSLATE
           *
           * Specifies the event name for translate.
           */
          TRANSLATE: "translate",
          /**
           * Variable: SCALE_AND_TRANSLATE
           *
           * Specifies the event name for scaleAndTranslate.
           */
          SCALE_AND_TRANSLATE: "scaleAndTranslate",
          /**
           * Variable: UP
           *
           * Specifies the event name for up.
           */
          UP: "up",
          /**
           * Variable: DOWN
           *
           * Specifies the event name for down.
           */
          DOWN: "down",
          /**
           * Variable: ADD
           *
           * Specifies the event name for add.
           */
          ADD: "add",
          /**
           * Variable: REMOVE
           *
           * Specifies the event name for remove.
           */
          REMOVE: "remove",
          /**
           * Variable: CLEAR
           *
           * Specifies the event name for clear.
           */
          CLEAR: "clear",
          /**
           * Variable: ADD_CELLS
           *
           * Specifies the event name for addCells.
           */
          ADD_CELLS: "addCells",
          /**
           * Variable: CELLS_ADDED
           *
           * Specifies the event name for cellsAdded.
           */
          CELLS_ADDED: "cellsAdded",
          /**
           * Variable: MOVE_CELLS
           *
           * Specifies the event name for moveCells.
           */
          MOVE_CELLS: "moveCells",
          /**
           * Variable: CELLS_MOVED
           *
           * Specifies the event name for cellsMoved.
           */
          CELLS_MOVED: "cellsMoved",
          /**
           * Variable: RESIZE_CELLS
           *
           * Specifies the event name for resizeCells.
           */
          RESIZE_CELLS: "resizeCells",
          /**
           * Variable: CELLS_RESIZED
           *
           * Specifies the event name for cellsResized.
           */
          CELLS_RESIZED: "cellsResized",
          /**
           * Variable: TOGGLE_CELLS
           *
           * Specifies the event name for toggleCells.
           */
          TOGGLE_CELLS: "toggleCells",
          /**
           * Variable: CELLS_TOGGLED
           *
           * Specifies the event name for cellsToggled.
           */
          CELLS_TOGGLED: "cellsToggled",
          /**
           * Variable: ORDER_CELLS
           *
           * Specifies the event name for orderCells.
           */
          ORDER_CELLS: "orderCells",
          /**
           * Variable: CELLS_ORDERED
           *
           * Specifies the event name for cellsOrdered.
           */
          CELLS_ORDERED: "cellsOrdered",
          /**
           * Variable: REMOVE_CELLS
           *
           * Specifies the event name for removeCells.
           */
          REMOVE_CELLS: "removeCells",
          /**
           * Variable: CELLS_REMOVED
           *
           * Specifies the event name for cellsRemoved.
           */
          CELLS_REMOVED: "cellsRemoved",
          /**
           * Variable: GROUP_CELLS
           *
           * Specifies the event name for groupCells.
           */
          GROUP_CELLS: "groupCells",
          /**
           * Variable: UNGROUP_CELLS
           *
           * Specifies the event name for ungroupCells.
           */
          UNGROUP_CELLS: "ungroupCells",
          /**
           * Variable: REMOVE_CELLS_FROM_PARENT
           *
           * Specifies the event name for removeCellsFromParent.
           */
          REMOVE_CELLS_FROM_PARENT: "removeCellsFromParent",
          /**
           * Variable: FOLD_CELLS
           *
           * Specifies the event name for foldCells.
           */
          FOLD_CELLS: "foldCells",
          /**
           * Variable: CELLS_FOLDED
           *
           * Specifies the event name for cellsFolded.
           */
          CELLS_FOLDED: "cellsFolded",
          /**
           * Variable: ALIGN_CELLS
           *
           * Specifies the event name for alignCells.
           */
          ALIGN_CELLS: "alignCells",
          /**
           * Variable: LABEL_CHANGED
           *
           * Specifies the event name for labelChanged.
           */
          LABEL_CHANGED: "labelChanged",
          /**
           * Variable: CONNECT_CELL
           *
           * Specifies the event name for connectCell.
           */
          CONNECT_CELL: "connectCell",
          /**
           * Variable: CELL_CONNECTED
           *
           * Specifies the event name for cellConnected.
           */
          CELL_CONNECTED: "cellConnected",
          /**
           * Variable: SPLIT_EDGE
           *
           * Specifies the event name for splitEdge.
           */
          SPLIT_EDGE: "splitEdge",
          /**
           * Variable: FLIP_EDGE
           *
           * Specifies the event name for flipEdge.
           */
          FLIP_EDGE: "flipEdge",
          /**
           * Variable: START_EDITING
           *
           * Specifies the event name for startEditing.
           */
          START_EDITING: "startEditing",
          /**
           * Variable: EDITING_STARTED
           *
           * Specifies the event name for editingStarted.
           */
          EDITING_STARTED: "editingStarted",
          /**
           * Variable: EDITING_STOPPED
           *
           * Specifies the event name for editingStopped.
           */
          EDITING_STOPPED: "editingStopped",
          /**
           * Variable: ADD_OVERLAY
           *
           * Specifies the event name for addOverlay.
           */
          ADD_OVERLAY: "addOverlay",
          /**
           * Variable: REMOVE_OVERLAY
           *
           * Specifies the event name for removeOverlay.
           */
          REMOVE_OVERLAY: "removeOverlay",
          /**
           * Variable: UPDATE_CELL_SIZE
           *
           * Specifies the event name for updateCellSize.
           */
          UPDATE_CELL_SIZE: "updateCellSize",
          /**
           * Variable: ESCAPE
           *
           * Specifies the event name for escape.
           */
          ESCAPE: "escape",
          /**
           * Variable: DOUBLE_CLICK
           *
           * Specifies the event name for doubleClick.
           */
          DOUBLE_CLICK: "doubleClick",
          /**
           * Variable: START
           *
           * Specifies the event name for start.
           */
          START: "start",
          /**
           * Variable: RESET
           *
           * Specifies the event name for reset.
           */
          RESET: "reset",
          /**
           * Variable: TOOLTIP_SHOWN
           * 
           * Specified the event name for tooltip shown
           */
          TOOLTIP_SHOWN: "tooltipShown",
          /**
           * Variable: PINCH_THRESHOLD
           *
           * Threshold for pinch gestures to fire a mouse wheel event.
           * Default value is 10.
           */
          PINCH_THRESHOLD: 10
        };
        __mxOutput.mxEvent = typeof mxEvent !== "undefined" ? mxEvent : void 0;
        function mxXmlRequest(url, params, method, async, username, password) {
          this.url = url;
          this.params = params;
          this.method = method || "POST";
          this.async = async != null ? async : true;
          this.username = username;
          this.password = password;
        }
        ;
        mxXmlRequest.prototype.url = null;
        mxXmlRequest.prototype.params = null;
        mxXmlRequest.prototype.method = null;
        mxXmlRequest.prototype.async = null;
        mxXmlRequest.prototype.binary = false;
        mxXmlRequest.prototype.withCredentials = false;
        mxXmlRequest.prototype.username = null;
        mxXmlRequest.prototype.password = null;
        mxXmlRequest.prototype.request = null;
        mxXmlRequest.prototype.decodeSimulateValues = false;
        mxXmlRequest.prototype.isBinary = function() {
          return this.binary;
        };
        mxXmlRequest.prototype.setBinary = function(value) {
          this.binary = value;
        };
        mxXmlRequest.prototype.getText = function() {
          return this.request.responseText;
        };
        mxXmlRequest.prototype.isReady = function() {
          return this.request.readyState == 4;
        };
        mxXmlRequest.prototype.getDocumentElement = function() {
          var doc = this.getXml();
          if (doc != null) {
            return doc.documentElement;
          }
          return null;
        };
        mxXmlRequest.prototype.getXml = function() {
          var xml = this.request.responseXML;
          if (document.documentMode >= 9 || xml == null || xml.documentElement == null) {
            xml = mxUtils.parseXml(this.request.responseText);
          }
          return xml;
        };
        mxXmlRequest.prototype.getStatus = function() {
          return this.request != null ? this.request.status : null;
        };
        mxXmlRequest.prototype.create = function() {
          if (window.XMLHttpRequest) {
            return function() {
              var req = new XMLHttpRequest();
              if (this.isBinary() && req.overrideMimeType) {
                req.overrideMimeType("text/plain; charset=x-user-defined");
              }
              return req;
            };
          } else if (typeof ActiveXObject != "undefined") {
            return function() {
              return new ActiveXObject("Microsoft.XMLHTTP");
            };
          }
        }();
        mxXmlRequest.prototype.send = function(onload, onerror, timeout, ontimeout) {
          this.request = this.create();
          if (this.request != null) {
            if (onload != null) {
              this.request.onreadystatechange = mxUtils.bind(this, function() {
                if (this.isReady()) {
                  onload(this);
                  this.request.onreadystatechange = null;
                }
              });
            }
            this.request.open(
              this.method,
              this.url,
              this.async,
              this.username,
              this.password
            );
            this.setRequestHeaders(this.request, this.params);
            if (window.XMLHttpRequest && this.withCredentials) {
              this.request.withCredentials = "true";
            }
            if (!mxClient.IS_QUIRKS && (document.documentMode == null || document.documentMode > 9) && window.XMLHttpRequest && timeout != null && ontimeout != null) {
              this.request.timeout = timeout;
              this.request.ontimeout = ontimeout;
            }
            this.request.send(this.params);
          }
        };
        mxXmlRequest.prototype.setRequestHeaders = function(request, params) {
          if (params != null) {
            request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
          }
        };
        mxXmlRequest.prototype.simulate = function(doc, target) {
          doc = doc || document;
          var old = null;
          if (doc == document) {
            old = window.onbeforeunload;
            window.onbeforeunload = null;
          }
          var form = doc.createElement("form");
          form.setAttribute("method", this.method);
          form.setAttribute("action", this.url);
          if (target != null) {
            form.setAttribute("target", target);
          }
          form.style.display = "none";
          form.style.visibility = "hidden";
          var pars = this.params.indexOf("&") > 0 ? this.params.split("&") : this.params.split();
          for (var i = 0; i < pars.length; i++) {
            var pos = pars[i].indexOf("=");
            if (pos > 0) {
              var name2 = pars[i].substring(0, pos);
              var value = pars[i].substring(pos + 1);
              if (this.decodeSimulateValues) {
                value = decodeURIComponent(value);
              }
              var textarea = doc.createElement("textarea");
              textarea.setAttribute("wrap", "off");
              textarea.setAttribute("name", name2);
              mxUtils.write(textarea, value);
              form.appendChild(textarea);
            }
          }
          doc.body.appendChild(form);
          form.submit();
          if (form.parentNode != null) {
            form.parentNode.removeChild(form);
          }
          if (old != null) {
            window.onbeforeunload = old;
          }
        };
        __mxOutput.mxXmlRequest = typeof mxXmlRequest !== "undefined" ? mxXmlRequest : void 0;
        var mxClipboard = {
          /**
           * Class: mxClipboard
           * 
           * Singleton that implements a clipboard for graph cells.
           *
           * Example:
           * 
           * (code)
           * mxClipboard.copy(graph);
           * mxClipboard.paste(graph2);
           * (end)
           *
           * This copies the selection cells from the graph to the clipboard and
           * pastes them into graph2.
           * 
           * For fine-grained control of the clipboard data the <mxGraph.canExportCell>
           * and <mxGraph.canImportCell> functions can be overridden.
           * 
           * To restore previous parents for pasted cells, the implementation for
           * <copy> and <paste> can be changed as follows.
           * 
           * (code)
           * mxClipboard.copy = function(graph, cells)
           * {
           *   cells = cells || graph.getSelectionCells();
           *   var result = graph.getExportableCells(cells);
           *   
           *   mxClipboard.parents = new Object();
           *   
           *   for (var i = 0; i < result.length; i++)
           *   {
           *     mxClipboard.parents[i] = graph.model.getParent(cells[i]);
           *   }
           *   
           *   mxClipboard.insertCount = 1;
           *   mxClipboard.setCells(graph.cloneCells(result));
           *   
           *   return result;
           * };
           * 
           * mxClipboard.paste = function(graph)
           * {
           *   if (!mxClipboard.isEmpty())
           *   {
           *     var cells = graph.getImportableCells(mxClipboard.getCells());
           *     var delta = mxClipboard.insertCount * mxClipboard.STEPSIZE;
           *     var parent = graph.getDefaultParent();
           *     
           *     graph.model.beginUpdate();
           *     try
           *     {
           *       for (var i = 0; i < cells.length; i++)
           *       {
           *         var tmp = (mxClipboard.parents != null && graph.model.contains(mxClipboard.parents[i])) ?
           *              mxClipboard.parents[i] : parent;
           *         cells[i] = graph.importCells([cells[i]], delta, delta, tmp)[0];
           *       }
           *     }
           *     finally
           *     {
           *       graph.model.endUpdate();
           *     }
           *     
           *     // Increments the counter and selects the inserted cells
           *     mxClipboard.insertCount++;
           *     graph.setSelectionCells(cells);
           *   }
           * };
           * (end)
           * 
           * Variable: STEPSIZE
           * 
           * Defines the step size to offset the cells after each paste operation.
           * Default is 10.
           */
          STEPSIZE: 10,
          /**
           * Variable: insertCount
           * 
           * Counts the number of times the clipboard data has been inserted.
           */
          insertCount: 1,
          /**
           * Variable: cells
           * 
           * Holds the array of <mxCells> currently in the clipboard.
           */
          cells: null,
          /**
           * Function: setCells
           * 
           * Sets the cells in the clipboard. Fires a <mxEvent.CHANGE> event.
           */
          setCells: function(cells) {
            mxClipboard.cells = cells;
          },
          /**
           * Function: getCells
           * 
           * Returns  the cells in the clipboard.
           */
          getCells: function() {
            return mxClipboard.cells;
          },
          /**
           * Function: isEmpty
           * 
           * Returns true if the clipboard currently has not data stored.
           */
          isEmpty: function() {
            return mxClipboard.getCells() == null;
          },
          /**
           * Function: cut
           * 
           * Cuts the given array of <mxCells> from the specified graph.
           * If cells is null then the selection cells of the graph will
           * be used. Returns the cells that have been cut from the graph.
           *
           * Parameters:
           * 
           * graph - <mxGraph> that contains the cells to be cut.
           * cells - Optional array of <mxCells> to be cut.
           */
          cut: function(graph, cells) {
            cells = mxClipboard.copy(graph, cells);
            mxClipboard.insertCount = 0;
            mxClipboard.removeCells(graph, cells);
            return cells;
          },
          /**
           * Function: removeCells
           * 
           * Hook to remove the given cells from the given graph after
           * a cut operation.
           *
           * Parameters:
           * 
           * graph - <mxGraph> that contains the cells to be cut.
           * cells - Array of <mxCells> to be cut.
           */
          removeCells: function(graph, cells) {
            graph.removeCells(cells);
          },
          /**
           * Function: copy
           * 
           * Copies the given array of <mxCells> from the specified
           * graph to <cells>. Returns the original array of cells that has
           * been cloned. Descendants of cells in the array are ignored.
           * 
           * Parameters:
           * 
           * graph - <mxGraph> that contains the cells to be copied.
           * cells - Optional array of <mxCells> to be copied.
           */
          copy: function(graph, cells) {
            cells = cells || graph.getSelectionCells();
            var result2 = graph.getExportableCells(graph.model.getTopmostCells(cells));
            mxClipboard.insertCount = 1;
            mxClipboard.setCells(graph.cloneCells(result2));
            return result2;
          },
          /**
           * Function: paste
           * 
           * Pastes the <cells> into the specified graph restoring
           * the relation to <parents>, if possible. If the parents
           * are no longer in the graph or invisible then the
           * cells are added to the graph's default or into the
           * swimlane under the cell's new location if one exists.
           * The cells are added to the graph using <mxGraph.importCells>
           * and returned.
           * 
           * Parameters:
           * 
           * graph - <mxGraph> to paste the <cells> into.
           */
          paste: function(graph) {
            var cells = null;
            if (!mxClipboard.isEmpty()) {
              cells = graph.getImportableCells(mxClipboard.getCells());
              var delta = mxClipboard.insertCount * mxClipboard.STEPSIZE;
              var parent = graph.getDefaultParent();
              cells = graph.importCells(cells, delta, delta, parent);
              mxClipboard.insertCount++;
              graph.setSelectionCells(cells);
            }
            return cells;
          }
        };
        __mxOutput.mxClipboard = typeof mxClipboard !== "undefined" ? mxClipboard : void 0;
        function mxWindow(title, content, x, y, width, height, minimizable, movable, replaceNode, style) {
          if (content != null) {
            minimizable = minimizable != null ? minimizable : true;
            this.content = content;
            this.init(x, y, width, height, style);
            this.installMaximizeHandler();
            this.installMinimizeHandler();
            this.installCloseHandler();
            this.setMinimizable(minimizable);
            this.setTitle(title);
            if (movable == null || movable) {
              this.installMoveHandler();
            }
            if (replaceNode != null && replaceNode.parentNode != null) {
              replaceNode.parentNode.replaceChild(this.div, replaceNode);
            } else {
              document.body.appendChild(this.div);
            }
          }
        }
        ;
        mxWindow.prototype = new mxEventSource();
        mxWindow.prototype.constructor = mxWindow;
        mxWindow.prototype.closeImage = mxClient.imageBasePath + "/close.gif";
        mxWindow.prototype.minimizeImage = mxClient.imageBasePath + "/minimize.gif";
        mxWindow.prototype.normalizeImage = mxClient.imageBasePath + "/normalize.gif";
        mxWindow.prototype.maximizeImage = mxClient.imageBasePath + "/maximize.gif";
        mxWindow.prototype.resizeImage = mxClient.imageBasePath + "/resize.gif";
        mxWindow.prototype.visible = false;
        mxWindow.prototype.minimumSize = new mxRectangle(0, 0, 50, 40);
        mxWindow.prototype.destroyOnClose = true;
        mxWindow.prototype.contentHeightCorrection = document.documentMode == 8 || document.documentMode == 7 ? 6 : 2;
        mxWindow.prototype.title = null;
        mxWindow.prototype.content = null;
        mxWindow.prototype.init = function(x, y, width, height, style) {
          style = style != null ? style : "mxWindow";
          this.div = document.createElement("div");
          this.div.className = style;
          this.div.style.left = x + "px";
          this.div.style.top = y + "px";
          this.table = document.createElement("table");
          this.table.className = style;
          if (mxClient.IS_POINTER) {
            this.div.style.touchAction = "none";
          }
          if (width != null) {
            if (!mxClient.IS_QUIRKS) {
              this.div.style.width = width + "px";
            }
            this.table.style.width = width + "px";
          }
          if (height != null) {
            if (!mxClient.IS_QUIRKS) {
              this.div.style.height = height + "px";
            }
            this.table.style.height = height + "px";
          }
          var tbody = document.createElement("tbody");
          var tr = document.createElement("tr");
          this.title = document.createElement("td");
          this.title.className = style + "Title";
          this.buttons = document.createElement("div");
          this.buttons.style.position = "absolute";
          this.buttons.style.display = "inline-block";
          this.buttons.style.right = "4px";
          this.buttons.style.top = "5px";
          this.title.appendChild(this.buttons);
          tr.appendChild(this.title);
          tbody.appendChild(tr);
          tr = document.createElement("tr");
          this.td = document.createElement("td");
          this.td.className = style + "Pane";
          if (document.documentMode == 7) {
            this.td.style.height = "100%";
          }
          this.contentWrapper = document.createElement("div");
          this.contentWrapper.className = style + "Pane";
          this.contentWrapper.style.width = "100%";
          this.contentWrapper.appendChild(this.content);
          if (mxClient.IS_QUIRKS || this.content.nodeName.toUpperCase() != "DIV") {
            this.contentWrapper.style.height = "100%";
          }
          this.td.appendChild(this.contentWrapper);
          tr.appendChild(this.td);
          tbody.appendChild(tr);
          this.table.appendChild(tbody);
          this.div.appendChild(this.table);
          var activator = mxUtils.bind(this, function(evt) {
            this.activate();
          });
          mxEvent.addGestureListeners(this.title, activator);
          mxEvent.addGestureListeners(this.table, activator);
          this.hide();
        };
        mxWindow.prototype.setTitle = function(title) {
          var child = this.title.firstChild;
          while (child != null) {
            var next = child.nextSibling;
            if (child.nodeType == mxConstants.NODETYPE_TEXT) {
              child.parentNode.removeChild(child);
            }
            child = next;
          }
          mxUtils.write(this.title, title || "");
          this.title.appendChild(this.buttons);
        };
        mxWindow.prototype.setScrollable = function(scrollable) {
          if (navigator.userAgent == null || navigator.userAgent.indexOf("Presto/2.5") < 0) {
            if (scrollable) {
              this.contentWrapper.style.overflow = "auto";
            } else {
              this.contentWrapper.style.overflow = "hidden";
            }
          }
        };
        mxWindow.prototype.activate = function() {
          if (mxWindow.activeWindow != this) {
            var style = mxUtils.getCurrentStyle(this.getElement());
            var index = style != null ? style.zIndex : 3;
            if (mxWindow.activeWindow) {
              var elt = mxWindow.activeWindow.getElement();
              if (elt != null && elt.style != null) {
                elt.style.zIndex = index;
              }
            }
            var previousWindow = mxWindow.activeWindow;
            this.getElement().style.zIndex = parseInt(index) + 1;
            mxWindow.activeWindow = this;
            this.fireEvent(new mxEventObject(mxEvent.ACTIVATE, "previousWindow", previousWindow));
          }
        };
        mxWindow.prototype.getElement = function() {
          return this.div;
        };
        mxWindow.prototype.fit = function() {
          mxUtils.fit(this.div);
        };
        mxWindow.prototype.isResizable = function() {
          if (this.resize != null) {
            return this.resize.style.display != "none";
          }
          return false;
        };
        mxWindow.prototype.setResizable = function(resizable) {
          if (resizable) {
            if (this.resize == null) {
              this.resize = document.createElement("img");
              this.resize.style.position = "absolute";
              this.resize.style.bottom = "2px";
              this.resize.style.right = "2px";
              this.resize.setAttribute("src", this.resizeImage);
              this.resize.style.cursor = "nw-resize";
              var startX = null;
              var startY = null;
              var width = null;
              var height = null;
              var start = mxUtils.bind(this, function(evt) {
                this.activate();
                startX = mxEvent.getClientX(evt);
                startY = mxEvent.getClientY(evt);
                width = this.div.offsetWidth;
                height = this.div.offsetHeight;
                mxEvent.addGestureListeners(document, null, dragHandler, dropHandler);
                this.fireEvent(new mxEventObject(mxEvent.RESIZE_START, "event", evt));
                mxEvent.consume(evt);
              });
              var dragHandler = mxUtils.bind(this, function(evt) {
                if (startX != null && startY != null) {
                  var dx = mxEvent.getClientX(evt) - startX;
                  var dy = mxEvent.getClientY(evt) - startY;
                  this.setSize(width + dx, height + dy);
                  this.fireEvent(new mxEventObject(mxEvent.RESIZE, "event", evt));
                  mxEvent.consume(evt);
                }
              });
              var dropHandler = mxUtils.bind(this, function(evt) {
                if (startX != null && startY != null) {
                  startX = null;
                  startY = null;
                  mxEvent.removeGestureListeners(document, null, dragHandler, dropHandler);
                  this.fireEvent(new mxEventObject(mxEvent.RESIZE_END, "event", evt));
                  mxEvent.consume(evt);
                }
              });
              mxEvent.addGestureListeners(this.resize, start, dragHandler, dropHandler);
              this.div.appendChild(this.resize);
            } else {
              this.resize.style.display = "inline";
            }
          } else if (this.resize != null) {
            this.resize.style.display = "none";
          }
        };
        mxWindow.prototype.setSize = function(width, height) {
          width = Math.max(this.minimumSize.width, width);
          height = Math.max(this.minimumSize.height, height);
          if (!mxClient.IS_QUIRKS) {
            this.div.style.width = width + "px";
            this.div.style.height = height + "px";
          }
          this.table.style.width = width + "px";
          this.table.style.height = height + "px";
          if (!mxClient.IS_QUIRKS) {
            this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
          }
        };
        mxWindow.prototype.setMinimizable = function(minimizable) {
          this.minimize.style.display = minimizable ? "" : "none";
        };
        mxWindow.prototype.getMinimumSize = function() {
          return new mxRectangle(0, 0, 0, this.title.offsetHeight);
        };
        mxWindow.prototype.installMinimizeHandler = function() {
          this.minimize = document.createElement("img");
          this.minimize.setAttribute("src", this.minimizeImage);
          this.minimize.setAttribute("title", "Minimize");
          this.minimize.style.cursor = "pointer";
          this.minimize.style.marginLeft = "2px";
          this.minimize.style.display = "none";
          this.buttons.appendChild(this.minimize);
          var minimized = false;
          var maxDisplay = null;
          var height = null;
          var funct = mxUtils.bind(this, function(evt) {
            this.activate();
            if (!minimized) {
              minimized = true;
              this.minimize.setAttribute("src", this.normalizeImage);
              this.minimize.setAttribute("title", "Normalize");
              this.contentWrapper.style.display = "none";
              maxDisplay = this.maximize.style.display;
              this.maximize.style.display = "none";
              height = this.table.style.height;
              var minSize = this.getMinimumSize();
              if (minSize.height > 0) {
                if (!mxClient.IS_QUIRKS) {
                  this.div.style.height = minSize.height + "px";
                }
                this.table.style.height = minSize.height + "px";
              }
              if (minSize.width > 0) {
                if (!mxClient.IS_QUIRKS) {
                  this.div.style.width = minSize.width + "px";
                }
                this.table.style.width = minSize.width + "px";
              }
              if (this.resize != null) {
                this.resize.style.visibility = "hidden";
              }
              this.fireEvent(new mxEventObject(mxEvent.MINIMIZE, "event", evt));
            } else {
              minimized = false;
              this.minimize.setAttribute("src", this.minimizeImage);
              this.minimize.setAttribute("title", "Minimize");
              this.contentWrapper.style.display = "";
              this.maximize.style.display = maxDisplay;
              if (!mxClient.IS_QUIRKS) {
                this.div.style.height = height;
              }
              this.table.style.height = height;
              if (this.resize != null) {
                this.resize.style.visibility = "";
              }
              this.fireEvent(new mxEventObject(mxEvent.NORMALIZE, "event", evt));
            }
            mxEvent.consume(evt);
          });
          mxEvent.addGestureListeners(this.minimize, funct);
        };
        mxWindow.prototype.setMaximizable = function(maximizable) {
          this.maximize.style.display = maximizable ? "" : "none";
        };
        mxWindow.prototype.installMaximizeHandler = function() {
          this.maximize = document.createElement("img");
          this.maximize.setAttribute("src", this.maximizeImage);
          this.maximize.setAttribute("title", "Maximize");
          this.maximize.style.cursor = "default";
          this.maximize.style.marginLeft = "2px";
          this.maximize.style.cursor = "pointer";
          this.maximize.style.display = "none";
          this.buttons.appendChild(this.maximize);
          var maximized = false;
          var x = null;
          var y = null;
          var height = null;
          var width = null;
          var minDisplay = null;
          var funct = mxUtils.bind(this, function(evt) {
            this.activate();
            if (this.maximize.style.display != "none") {
              if (!maximized) {
                maximized = true;
                this.maximize.setAttribute("src", this.normalizeImage);
                this.maximize.setAttribute("title", "Normalize");
                this.contentWrapper.style.display = "";
                minDisplay = this.minimize.style.display;
                this.minimize.style.display = "none";
                x = parseInt(this.div.style.left);
                y = parseInt(this.div.style.top);
                height = this.table.style.height;
                width = this.table.style.width;
                this.div.style.left = "0px";
                this.div.style.top = "0px";
                var docHeight = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight || 0);
                if (!mxClient.IS_QUIRKS) {
                  this.div.style.width = document.body.clientWidth - 2 + "px";
                  this.div.style.height = docHeight - 2 + "px";
                }
                this.table.style.width = document.body.clientWidth - 2 + "px";
                this.table.style.height = docHeight - 2 + "px";
                if (this.resize != null) {
                  this.resize.style.visibility = "hidden";
                }
                if (!mxClient.IS_QUIRKS) {
                  var style = mxUtils.getCurrentStyle(this.contentWrapper);
                  if (style.overflow == "auto" || this.resize != null) {
                    this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
                  }
                }
                this.fireEvent(new mxEventObject(mxEvent.MAXIMIZE, "event", evt));
              } else {
                maximized = false;
                this.maximize.setAttribute("src", this.maximizeImage);
                this.maximize.setAttribute("title", "Maximize");
                this.contentWrapper.style.display = "";
                this.minimize.style.display = minDisplay;
                this.div.style.left = x + "px";
                this.div.style.top = y + "px";
                if (!mxClient.IS_QUIRKS) {
                  this.div.style.height = height;
                  this.div.style.width = width;
                  var style = mxUtils.getCurrentStyle(this.contentWrapper);
                  if (style.overflow == "auto" || this.resize != null) {
                    this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
                  }
                }
                this.table.style.height = height;
                this.table.style.width = width;
                if (this.resize != null) {
                  this.resize.style.visibility = "";
                }
                this.fireEvent(new mxEventObject(mxEvent.NORMALIZE, "event", evt));
              }
              mxEvent.consume(evt);
            }
          });
          mxEvent.addGestureListeners(this.maximize, funct);
          mxEvent.addListener(this.title, "dblclick", funct);
        };
        mxWindow.prototype.installMoveHandler = function() {
          this.title.style.cursor = "move";
          mxEvent.addGestureListeners(
            this.title,
            mxUtils.bind(this, function(evt) {
              var startX = mxEvent.getClientX(evt);
              var startY = mxEvent.getClientY(evt);
              var x = this.getX();
              var y = this.getY();
              var dragHandler = mxUtils.bind(this, function(evt2) {
                var dx = mxEvent.getClientX(evt2) - startX;
                var dy = mxEvent.getClientY(evt2) - startY;
                this.setLocation(x + dx, y + dy);
                this.fireEvent(new mxEventObject(mxEvent.MOVE, "event", evt2));
                mxEvent.consume(evt2);
              });
              var dropHandler = mxUtils.bind(this, function(evt2) {
                mxEvent.removeGestureListeners(document, null, dragHandler, dropHandler);
                this.fireEvent(new mxEventObject(mxEvent.MOVE_END, "event", evt2));
                mxEvent.consume(evt2);
              });
              mxEvent.addGestureListeners(document, null, dragHandler, dropHandler);
              this.fireEvent(new mxEventObject(mxEvent.MOVE_START, "event", evt));
              mxEvent.consume(evt);
            })
          );
          if (mxClient.IS_POINTER) {
            this.title.style.touchAction = "none";
          }
        };
        mxWindow.prototype.setLocation = function(x, y) {
          this.div.style.left = x + "px";
          this.div.style.top = y + "px";
        };
        mxWindow.prototype.getX = function() {
          return parseInt(this.div.style.left);
        };
        mxWindow.prototype.getY = function() {
          return parseInt(this.div.style.top);
        };
        mxWindow.prototype.installCloseHandler = function() {
          this.closeImg = document.createElement("img");
          this.closeImg.setAttribute("src", this.closeImage);
          this.closeImg.setAttribute("title", "Close");
          this.closeImg.style.marginLeft = "2px";
          this.closeImg.style.cursor = "pointer";
          this.closeImg.style.display = "none";
          this.buttons.appendChild(this.closeImg);
          mxEvent.addGestureListeners(
            this.closeImg,
            mxUtils.bind(this, function(evt) {
              this.fireEvent(new mxEventObject(mxEvent.CLOSE, "event", evt));
              if (this.destroyOnClose) {
                this.destroy();
              } else {
                this.setVisible(false);
              }
              mxEvent.consume(evt);
            })
          );
        };
        mxWindow.prototype.setImage = function(image) {
          this.image = document.createElement("img");
          this.image.setAttribute("src", image);
          this.image.setAttribute("align", "left");
          this.image.style.marginRight = "4px";
          this.image.style.marginLeft = "0px";
          this.image.style.marginTop = "-2px";
          this.title.insertBefore(this.image, this.title.firstChild);
        };
        mxWindow.prototype.setClosable = function(closable) {
          this.closeImg.style.display = closable ? "" : "none";
        };
        mxWindow.prototype.isVisible = function() {
          if (this.div != null) {
            return this.div.style.display != "none";
          }
          return false;
        };
        mxWindow.prototype.setVisible = function(visible) {
          if (this.div != null && this.isVisible() != visible) {
            if (visible) {
              this.show();
            } else {
              this.hide();
            }
          }
        };
        mxWindow.prototype.show = function() {
          this.div.style.display = "";
          this.activate();
          var style = mxUtils.getCurrentStyle(this.contentWrapper);
          if (!mxClient.IS_QUIRKS && (style.overflow == "auto" || this.resize != null) && this.contentWrapper.style.display != "none") {
            this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + "px";
          }
          this.fireEvent(new mxEventObject(mxEvent.SHOW));
        };
        mxWindow.prototype.hide = function() {
          this.div.style.display = "none";
          this.fireEvent(new mxEventObject(mxEvent.HIDE));
        };
        mxWindow.prototype.destroy = function() {
          this.fireEvent(new mxEventObject(mxEvent.DESTROY));
          if (this.div != null) {
            mxEvent.release(this.div);
            this.div.parentNode.removeChild(this.div);
            this.div = null;
          }
          this.title = null;
          this.content = null;
          this.contentWrapper = null;
        };
        __mxOutput.mxWindow = typeof mxWindow !== "undefined" ? mxWindow : void 0;
        function mxForm(className) {
          this.table = document.createElement("table");
          this.table.className = className;
          this.body = document.createElement("tbody");
          this.table.appendChild(this.body);
        }
        ;
        mxForm.prototype.table = null;
        mxForm.prototype.body = false;
        mxForm.prototype.getTable = function() {
          return this.table;
        };
        mxForm.prototype.addButtons = function(okFunct, cancelFunct) {
          var tr = document.createElement("tr");
          var td2 = document.createElement("td");
          tr.appendChild(td2);
          td2 = document.createElement("td");
          var button = document.createElement("button");
          mxUtils.write(button, mxResources.get("ok") || "OK");
          td2.appendChild(button);
          mxEvent.addListener(button, "click", function() {
            okFunct();
          });
          button = document.createElement("button");
          mxUtils.write(button, mxResources.get("cancel") || "Cancel");
          td2.appendChild(button);
          mxEvent.addListener(button, "click", function() {
            cancelFunct();
          });
          tr.appendChild(td2);
          this.body.appendChild(tr);
        };
        mxForm.prototype.addText = function(name2, value, type) {
          var input = document.createElement("input");
          input.setAttribute("type", type || "text");
          input.value = value;
          return this.addField(name2, input);
        };
        mxForm.prototype.addCheckbox = function(name2, value) {
          var input = document.createElement("input");
          input.setAttribute("type", "checkbox");
          this.addField(name2, input);
          if (value) {
            input.checked = true;
          }
          return input;
        };
        mxForm.prototype.addTextarea = function(name2, value, rows) {
          var input = document.createElement("textarea");
          if (mxClient.IS_NS) {
            rows--;
          }
          input.setAttribute("rows", rows || 2);
          input.value = value;
          return this.addField(name2, input);
        };
        mxForm.prototype.addCombo = function(name2, isMultiSelect, size) {
          var select = document.createElement("select");
          if (size != null) {
            select.setAttribute("size", size);
          }
          if (isMultiSelect) {
            select.setAttribute("multiple", "true");
          }
          return this.addField(name2, select);
        };
        mxForm.prototype.addOption = function(combo, label, value, isSelected) {
          var option = document.createElement("option");
          mxUtils.writeln(option, label);
          option.setAttribute("value", value);
          if (isSelected) {
            option.setAttribute("selected", isSelected);
          }
          combo.appendChild(option);
        };
        mxForm.prototype.addField = function(name2, input) {
          var tr = document.createElement("tr");
          var td2 = document.createElement("td");
          mxUtils.write(td2, name2);
          tr.appendChild(td2);
          td2 = document.createElement("td");
          td2.appendChild(input);
          tr.appendChild(td2);
          this.body.appendChild(tr);
          return input;
        };
        __mxOutput.mxForm = typeof mxForm !== "undefined" ? mxForm : void 0;
        function mxImage(src, width, height) {
          this.src = src;
          this.width = width;
          this.height = height;
        }
        ;
        mxImage.prototype.src = null;
        mxImage.prototype.width = null;
        mxImage.prototype.height = null;
        __mxOutput.mxImage = typeof mxImage !== "undefined" ? mxImage : void 0;
        function mxDivResizer(div, container) {
          if (div.nodeName.toLowerCase() == "div") {
            if (container == null) {
              container = window;
            }
            this.div = div;
            var style = mxUtils.getCurrentStyle(div);
            if (style != null) {
              this.resizeWidth = style.width == "auto";
              this.resizeHeight = style.height == "auto";
            }
            mxEvent.addListener(
              container,
              "resize",
              mxUtils.bind(this, function(evt) {
                if (!this.handlingResize) {
                  this.handlingResize = true;
                  this.resize();
                  this.handlingResize = false;
                }
              })
            );
            this.resize();
          }
        }
        ;
        mxDivResizer.prototype.resizeWidth = true;
        mxDivResizer.prototype.resizeHeight = true;
        mxDivResizer.prototype.handlingResize = false;
        mxDivResizer.prototype.resize = function() {
          var w2 = this.getDocumentWidth();
          var h2 = this.getDocumentHeight();
          var l = parseInt(this.div.style.left);
          var r = parseInt(this.div.style.right);
          var t = parseInt(this.div.style.top);
          var b = parseInt(this.div.style.bottom);
          if (this.resizeWidth && !isNaN(l) && !isNaN(r) && l >= 0 && r >= 0 && w2 - r - l > 0) {
            this.div.style.width = w2 - r - l + "px";
          }
          if (this.resizeHeight && !isNaN(t) && !isNaN(b) && t >= 0 && b >= 0 && h2 - t - b > 0) {
            this.div.style.height = h2 - t - b + "px";
          }
        };
        mxDivResizer.prototype.getDocumentWidth = function() {
          return document.body.clientWidth;
        };
        mxDivResizer.prototype.getDocumentHeight = function() {
          return document.body.clientHeight;
        };
        __mxOutput.mxDivResizer = typeof mxDivResizer !== "undefined" ? mxDivResizer : void 0;
        function mxDragSource(element, dropHandler) {
          this.element = element;
          this.dropHandler = dropHandler;
          mxEvent.addGestureListeners(element, mxUtils.bind(this, function(evt) {
            this.mouseDown(evt);
          }));
          mxEvent.addListener(element, "dragstart", function(evt) {
            mxEvent.consume(evt);
          });
          this.eventConsumer = function(sender, evt) {
            var evtName = evt.getProperty("eventName");
            var me = evt.getProperty("event");
            if (evtName != mxEvent.MOUSE_DOWN) {
              me.consume();
            }
          };
        }
        ;
        mxDragSource.prototype.element = null;
        mxDragSource.prototype.dropHandler = null;
        mxDragSource.prototype.dragOffset = null;
        mxDragSource.prototype.dragElement = null;
        mxDragSource.prototype.previewElement = null;
        mxDragSource.prototype.previewOffset = null;
        mxDragSource.prototype.enabled = true;
        mxDragSource.prototype.currentGraph = null;
        mxDragSource.prototype.currentDropTarget = null;
        mxDragSource.prototype.currentPoint = null;
        mxDragSource.prototype.currentGuide = null;
        mxDragSource.prototype.currentHighlight = null;
        mxDragSource.prototype.autoscroll = true;
        mxDragSource.prototype.guidesEnabled = true;
        mxDragSource.prototype.gridEnabled = true;
        mxDragSource.prototype.highlightDropTargets = true;
        mxDragSource.prototype.dragElementZIndex = 100;
        mxDragSource.prototype.dragElementOpacity = 70;
        mxDragSource.prototype.checkEventSource = true;
        mxDragSource.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxDragSource.prototype.setEnabled = function(value) {
          this.enabled = value;
        };
        mxDragSource.prototype.isGuidesEnabled = function() {
          return this.guidesEnabled;
        };
        mxDragSource.prototype.setGuidesEnabled = function(value) {
          this.guidesEnabled = value;
        };
        mxDragSource.prototype.isGridEnabled = function() {
          return this.gridEnabled;
        };
        mxDragSource.prototype.setGridEnabled = function(value) {
          this.gridEnabled = value;
        };
        mxDragSource.prototype.getGraphForEvent = function(evt) {
          return null;
        };
        mxDragSource.prototype.getDropTarget = function(graph, x, y, evt) {
          return graph.getCellAt(x, y);
        };
        mxDragSource.prototype.createDragElement = function(evt) {
          return this.element.cloneNode(true);
        };
        mxDragSource.prototype.createPreviewElement = function(graph) {
          return null;
        };
        mxDragSource.prototype.isActive = function() {
          return this.mouseMoveHandler != null;
        };
        mxDragSource.prototype.reset = function() {
          if (this.currentGraph != null) {
            this.dragExit(this.currentGraph);
            this.currentGraph = null;
          }
          this.removeDragElement();
          this.removeListeners();
          this.stopDrag();
        };
        mxDragSource.prototype.mouseDown = function(evt) {
          if (this.enabled && !mxEvent.isConsumed(evt) && this.mouseMoveHandler == null) {
            this.startDrag(evt);
            this.mouseMoveHandler = mxUtils.bind(this, this.mouseMove);
            this.mouseUpHandler = mxUtils.bind(this, this.mouseUp);
            mxEvent.addGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
            if (mxClient.IS_TOUCH && !mxEvent.isMouseEvent(evt)) {
              this.eventSource = mxEvent.getSource(evt);
              mxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
            }
          }
        };
        mxDragSource.prototype.startDrag = function(evt) {
          this.dragElement = this.createDragElement(evt);
          this.dragElement.style.position = "absolute";
          this.dragElement.style.zIndex = this.dragElementZIndex;
          mxUtils.setOpacity(this.dragElement, this.dragElementOpacity);
          if (this.checkEventSource && mxClient.IS_SVG) {
            this.dragElement.style.pointerEvents = "none";
          }
        };
        mxDragSource.prototype.stopDrag = function() {
          this.removeDragElement();
        };
        mxDragSource.prototype.removeDragElement = function() {
          if (this.dragElement != null) {
            if (this.dragElement.parentNode != null) {
              this.dragElement.parentNode.removeChild(this.dragElement);
            }
            this.dragElement = null;
          }
        };
        mxDragSource.prototype.getElementForEvent = function(evt) {
          return mxEvent.isTouchEvent(evt) || mxEvent.isPenEvent(evt) ? document.elementFromPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt)) : mxEvent.getSource(evt);
        };
        mxDragSource.prototype.graphContainsEvent = function(graph, evt) {
          var x = mxEvent.getClientX(evt);
          var y = mxEvent.getClientY(evt);
          var offset = mxUtils.getOffset(graph.container);
          var origin = mxUtils.getScrollOrigin();
          var elt = this.getElementForEvent(evt);
          if (this.checkEventSource) {
            while (elt != null && elt != graph.container) {
              elt = elt.parentNode;
            }
          }
          return elt != null && x >= offset.x - origin.x && y >= offset.y - origin.y && x <= offset.x - origin.x + graph.container.offsetWidth && y <= offset.y - origin.y + graph.container.offsetHeight;
        };
        mxDragSource.prototype.mouseMove = function(evt) {
          var graph = this.getGraphForEvent(evt);
          if (graph != null && !this.graphContainsEvent(graph, evt)) {
            graph = null;
          }
          if (graph != this.currentGraph) {
            if (this.currentGraph != null) {
              this.dragExit(this.currentGraph, evt);
            }
            this.currentGraph = graph;
            if (this.currentGraph != null) {
              this.dragEnter(this.currentGraph, evt);
            }
          }
          if (this.currentGraph != null) {
            this.dragOver(this.currentGraph, evt);
          }
          if (this.dragElement != null && (this.previewElement == null || this.previewElement.style.visibility != "visible")) {
            var x = mxEvent.getClientX(evt);
            var y = mxEvent.getClientY(evt);
            if (this.dragElement.parentNode == null) {
              document.body.appendChild(this.dragElement);
            }
            this.dragElement.style.visibility = "visible";
            if (this.dragOffset != null) {
              x += this.dragOffset.x;
              y += this.dragOffset.y;
            }
            var offset = mxUtils.getDocumentScrollOrigin(document);
            this.dragElement.style.left = x + offset.x + "px";
            this.dragElement.style.top = y + offset.y + "px";
          } else if (this.dragElement != null) {
            this.dragElement.style.visibility = "hidden";
          }
          mxEvent.consume(evt);
        };
        mxDragSource.prototype.mouseUp = function(evt) {
          if (this.currentGraph != null) {
            if (this.currentPoint != null && (this.previewElement == null || this.previewElement.style.visibility != "hidden")) {
              var scale = this.currentGraph.view.scale;
              var tr = this.currentGraph.view.translate;
              var x = this.currentPoint.x / scale - tr.x;
              var y = this.currentPoint.y / scale - tr.y;
              this.drop(this.currentGraph, evt, this.currentDropTarget, x, y);
            }
            this.dragExit(this.currentGraph);
            this.currentGraph = null;
          }
          this.stopDrag();
          this.removeListeners();
          mxEvent.consume(evt);
        };
        mxDragSource.prototype.removeListeners = function() {
          if (this.eventSource != null) {
            mxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
            this.eventSource = null;
          }
          mxEvent.removeGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
          this.mouseMoveHandler = null;
          this.mouseUpHandler = null;
        };
        mxDragSource.prototype.dragEnter = function(graph, evt) {
          graph.isMouseDown = true;
          graph.isMouseTrigger = mxEvent.isMouseEvent(evt);
          this.previewElement = this.createPreviewElement(graph);
          if (this.previewElement != null && this.checkEventSource && mxClient.IS_SVG) {
            this.previewElement.style.pointerEvents = "none";
          }
          if (this.isGuidesEnabled() && this.previewElement != null) {
            this.currentGuide = new mxGuide(graph, graph.graphHandler.getGuideStates());
          }
          if (this.highlightDropTargets) {
            this.currentHighlight = new mxCellHighlight(graph, mxConstants.DROP_TARGET_COLOR);
          }
          graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.eventConsumer);
        };
        mxDragSource.prototype.dragExit = function(graph, evt) {
          this.currentDropTarget = null;
          this.currentPoint = null;
          graph.isMouseDown = false;
          graph.removeListener(this.eventConsumer);
          if (this.previewElement != null) {
            if (this.previewElement.parentNode != null) {
              this.previewElement.parentNode.removeChild(this.previewElement);
            }
            this.previewElement = null;
          }
          if (this.currentGuide != null) {
            this.currentGuide.destroy();
            this.currentGuide = null;
          }
          if (this.currentHighlight != null) {
            this.currentHighlight.destroy();
            this.currentHighlight = null;
          }
        };
        mxDragSource.prototype.dragOver = function(graph, evt) {
          var offset = mxUtils.getOffset(graph.container);
          var origin = mxUtils.getScrollOrigin(graph.container);
          var x = mxEvent.getClientX(evt) - offset.x + origin.x - graph.panDx;
          var y = mxEvent.getClientY(evt) - offset.y + origin.y - graph.panDy;
          if (graph.autoScroll && (this.autoscroll == null || this.autoscroll)) {
            graph.scrollPointToVisible(x, y, graph.autoExtend);
          }
          if (this.currentHighlight != null && graph.isDropEnabled()) {
            this.currentDropTarget = this.getDropTarget(graph, x, y, evt);
            var state = graph.getView().getState(this.currentDropTarget);
            this.currentHighlight.highlight(state);
          }
          if (this.previewElement != null) {
            if (this.previewElement.parentNode == null) {
              graph.container.appendChild(this.previewElement);
              this.previewElement.style.zIndex = "3";
              this.previewElement.style.position = "absolute";
            }
            var gridEnabled = this.isGridEnabled() && graph.isGridEnabledEvent(evt);
            var hideGuide = true;
            if (this.currentGuide != null && this.currentGuide.isEnabledForEvent(evt)) {
              var w2 = parseInt(this.previewElement.style.width);
              var h2 = parseInt(this.previewElement.style.height);
              var bounds = new mxRectangle(0, 0, w2, h2);
              var delta = new mxPoint(x, y);
              delta = this.currentGuide.move(bounds, delta, gridEnabled, true);
              hideGuide = false;
              x = delta.x;
              y = delta.y;
            } else if (gridEnabled) {
              var scale = graph.view.scale;
              var tr = graph.view.translate;
              var off = graph.gridSize / 2;
              x = (graph.snap(x / scale - tr.x - off) + tr.x) * scale;
              y = (graph.snap(y / scale - tr.y - off) + tr.y) * scale;
            }
            if (this.currentGuide != null && hideGuide) {
              this.currentGuide.hide();
            }
            if (this.previewOffset != null) {
              x += this.previewOffset.x;
              y += this.previewOffset.y;
            }
            this.previewElement.style.left = Math.round(x) + "px";
            this.previewElement.style.top = Math.round(y) + "px";
            this.previewElement.style.visibility = "visible";
          }
          this.currentPoint = new mxPoint(x, y);
        };
        mxDragSource.prototype.drop = function(graph, evt, dropTarget, x, y) {
          this.dropHandler.apply(this, arguments);
          if (graph.container.style.visibility != "hidden") {
            graph.container.focus();
          }
        };
        __mxOutput.mxDragSource = typeof mxDragSource !== "undefined" ? mxDragSource : void 0;
        function mxToolbar(container) {
          this.container = container;
        }
        ;
        mxToolbar.prototype = new mxEventSource();
        mxToolbar.prototype.constructor = mxToolbar;
        mxToolbar.prototype.container = null;
        mxToolbar.prototype.enabled = true;
        mxToolbar.prototype.noReset = false;
        mxToolbar.prototype.updateDefaultMode = true;
        mxToolbar.prototype.addItem = function(title, icon, funct, pressedIcon, style, factoryMethod) {
          var img = document.createElement(icon != null ? "img" : "button");
          var initialClassName = style || (factoryMethod != null ? "mxToolbarMode" : "mxToolbarItem");
          img.className = initialClassName;
          img.setAttribute("src", icon);
          if (title != null) {
            if (icon != null) {
              img.setAttribute("title", title);
            } else {
              mxUtils.write(img, title);
            }
          }
          this.container.appendChild(img);
          if (funct != null) {
            mxEvent.addListener(img, "click", funct);
            if (mxClient.IS_TOUCH) {
              mxEvent.addListener(img, "touchend", funct);
            }
          }
          var mouseHandler = mxUtils.bind(this, function(evt) {
            if (pressedIcon != null) {
              img.setAttribute("src", icon);
            } else {
              img.style.backgroundColor = "";
            }
          });
          mxEvent.addGestureListeners(img, mxUtils.bind(this, function(evt) {
            if (pressedIcon != null) {
              img.setAttribute("src", pressedIcon);
            } else {
              img.style.backgroundColor = "gray";
            }
            if (factoryMethod != null) {
              if (this.menu == null) {
                this.menu = new mxPopupMenu();
                this.menu.init();
              }
              var last = this.currentImg;
              if (this.menu.isMenuShowing()) {
                this.menu.hideMenu();
              }
              if (last != img) {
                this.currentImg = img;
                this.menu.factoryMethod = factoryMethod;
                var point = new mxPoint(
                  img.offsetLeft,
                  img.offsetTop + img.offsetHeight
                );
                this.menu.popup(point.x, point.y, null, evt);
                if (this.menu.isMenuShowing()) {
                  img.className = initialClassName + "Selected";
                  this.menu.hideMenu = function() {
                    mxPopupMenu.prototype.hideMenu.apply(this);
                    img.className = initialClassName;
                    this.currentImg = null;
                  };
                }
              }
            }
          }), null, mouseHandler);
          mxEvent.addListener(img, "mouseout", mouseHandler);
          return img;
        };
        mxToolbar.prototype.addCombo = function(style) {
          var div = document.createElement("div");
          div.style.display = "inline";
          div.className = "mxToolbarComboContainer";
          var select = document.createElement("select");
          select.className = style || "mxToolbarCombo";
          div.appendChild(select);
          this.container.appendChild(div);
          return select;
        };
        mxToolbar.prototype.addActionCombo = function(title, style) {
          var select = document.createElement("select");
          select.className = style || "mxToolbarCombo";
          this.addOption(select, title, null);
          mxEvent.addListener(select, "change", function(evt) {
            var value = select.options[select.selectedIndex];
            select.selectedIndex = 0;
            if (value.funct != null) {
              value.funct(evt);
            }
          });
          this.container.appendChild(select);
          return select;
        };
        mxToolbar.prototype.addOption = function(combo, title, value) {
          var option = document.createElement("option");
          mxUtils.writeln(option, title);
          if (typeof value == "function") {
            option.funct = value;
          } else {
            option.setAttribute("value", value);
          }
          combo.appendChild(option);
          return option;
        };
        mxToolbar.prototype.addSwitchMode = function(title, icon, funct, pressedIcon, style) {
          var img = document.createElement("img");
          img.initialClassName = style || "mxToolbarMode";
          img.className = img.initialClassName;
          img.setAttribute("src", icon);
          img.altIcon = pressedIcon;
          if (title != null) {
            img.setAttribute("title", title);
          }
          mxEvent.addListener(img, "click", mxUtils.bind(this, function(evt) {
            var tmp = this.selectedMode.altIcon;
            if (tmp != null) {
              this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
              this.selectedMode.setAttribute("src", tmp);
            } else {
              this.selectedMode.className = this.selectedMode.initialClassName;
            }
            if (this.updateDefaultMode) {
              this.defaultMode = img;
            }
            this.selectedMode = img;
            var tmp = img.altIcon;
            if (tmp != null) {
              img.altIcon = img.getAttribute("src");
              img.setAttribute("src", tmp);
            } else {
              img.className = img.initialClassName + "Selected";
            }
            this.fireEvent(new mxEventObject(mxEvent.SELECT));
            funct();
          }));
          this.container.appendChild(img);
          if (this.defaultMode == null) {
            this.defaultMode = img;
            this.selectMode(img);
            funct();
          }
          return img;
        };
        mxToolbar.prototype.addMode = function(title, icon, funct, pressedIcon, style, toggle) {
          toggle = toggle != null ? toggle : true;
          var img = document.createElement(icon != null ? "img" : "button");
          img.initialClassName = style || "mxToolbarMode";
          img.className = img.initialClassName;
          img.setAttribute("src", icon);
          img.altIcon = pressedIcon;
          if (title != null) {
            img.setAttribute("title", title);
          }
          if (this.enabled && toggle) {
            mxEvent.addListener(img, "click", mxUtils.bind(this, function(evt) {
              this.selectMode(img, funct);
              this.noReset = false;
            }));
            mxEvent.addListener(img, "dblclick", mxUtils.bind(this, function(evt) {
              this.selectMode(img, funct);
              this.noReset = true;
            }));
            if (this.defaultMode == null) {
              this.defaultMode = img;
              this.defaultFunction = funct;
              this.selectMode(img, funct);
            }
          }
          this.container.appendChild(img);
          return img;
        };
        mxToolbar.prototype.selectMode = function(domNode, funct) {
          if (this.selectedMode != domNode) {
            if (this.selectedMode != null) {
              var tmp = this.selectedMode.altIcon;
              if (tmp != null) {
                this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
                this.selectedMode.setAttribute("src", tmp);
              } else {
                this.selectedMode.className = this.selectedMode.initialClassName;
              }
            }
            this.selectedMode = domNode;
            var tmp = this.selectedMode.altIcon;
            if (tmp != null) {
              this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
              this.selectedMode.setAttribute("src", tmp);
            } else {
              this.selectedMode.className = this.selectedMode.initialClassName + "Selected";
            }
            this.fireEvent(new mxEventObject(mxEvent.SELECT, "function", funct));
          }
        };
        mxToolbar.prototype.resetMode = function(forced) {
          if ((forced || !this.noReset) && this.selectedMode != this.defaultMode) {
            this.selectMode(this.defaultMode, this.defaultFunction);
          }
        };
        mxToolbar.prototype.addSeparator = function(icon) {
          return this.addItem(null, icon, null);
        };
        mxToolbar.prototype.addBreak = function() {
          mxUtils.br(this.container);
        };
        mxToolbar.prototype.addLine = function() {
          var hr = document.createElement("hr");
          hr.style.marginRight = "6px";
          hr.setAttribute("size", "1");
          this.container.appendChild(hr);
        };
        mxToolbar.prototype.destroy = function() {
          mxEvent.release(this.container);
          this.container = null;
          this.defaultMode = null;
          this.defaultFunction = null;
          this.selectedMode = null;
          if (this.menu != null) {
            this.menu.destroy();
          }
        };
        __mxOutput.mxToolbar = typeof mxToolbar !== "undefined" ? mxToolbar : void 0;
        function mxUndoableEdit(source, significant) {
          this.source = source;
          this.changes = [];
          this.significant = significant != null ? significant : true;
        }
        ;
        mxUndoableEdit.prototype.source = null;
        mxUndoableEdit.prototype.changes = null;
        mxUndoableEdit.prototype.significant = null;
        mxUndoableEdit.prototype.undone = false;
        mxUndoableEdit.prototype.redone = false;
        mxUndoableEdit.prototype.isEmpty = function() {
          return this.changes.length == 0;
        };
        mxUndoableEdit.prototype.isSignificant = function() {
          return this.significant;
        };
        mxUndoableEdit.prototype.add = function(change) {
          this.changes.push(change);
        };
        mxUndoableEdit.prototype.notify = function() {
        };
        mxUndoableEdit.prototype.die = function() {
        };
        mxUndoableEdit.prototype.undo = function() {
          if (!this.undone) {
            this.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));
            var count = this.changes.length;
            for (var i = count - 1; i >= 0; i--) {
              var change = this.changes[i];
              if (change.execute != null) {
                change.execute();
              } else if (change.undo != null) {
                change.undo();
              }
              this.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", change));
            }
            this.undone = true;
            this.redone = false;
            this.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));
          }
          this.notify();
        };
        mxUndoableEdit.prototype.redo = function() {
          if (!this.redone) {
            this.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));
            var count = this.changes.length;
            for (var i = 0; i < count; i++) {
              var change = this.changes[i];
              if (change.execute != null) {
                change.execute();
              } else if (change.redo != null) {
                change.redo();
              }
              this.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", change));
            }
            this.undone = false;
            this.redone = true;
            this.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));
          }
          this.notify();
        };
        __mxOutput.mxUndoableEdit = typeof mxUndoableEdit !== "undefined" ? mxUndoableEdit : void 0;
        function mxUndoManager(size) {
          this.size = size != null ? size : 100;
          this.clear();
        }
        ;
        mxUndoManager.prototype = new mxEventSource();
        mxUndoManager.prototype.constructor = mxUndoManager;
        mxUndoManager.prototype.size = null;
        mxUndoManager.prototype.history = null;
        mxUndoManager.prototype.indexOfNextAdd = 0;
        mxUndoManager.prototype.isEmpty = function() {
          return this.history.length == 0;
        };
        mxUndoManager.prototype.clear = function() {
          this.history = [];
          this.indexOfNextAdd = 0;
          this.fireEvent(new mxEventObject(mxEvent.CLEAR));
        };
        mxUndoManager.prototype.canUndo = function() {
          return this.indexOfNextAdd > 0;
        };
        mxUndoManager.prototype.undo = function() {
          while (this.indexOfNextAdd > 0) {
            var edit = this.history[--this.indexOfNextAdd];
            edit.undo();
            if (edit.isSignificant()) {
              this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", edit));
              break;
            }
          }
        };
        mxUndoManager.prototype.canRedo = function() {
          return this.indexOfNextAdd < this.history.length;
        };
        mxUndoManager.prototype.redo = function() {
          var n = this.history.length;
          while (this.indexOfNextAdd < n) {
            var edit = this.history[this.indexOfNextAdd++];
            edit.redo();
            if (edit.isSignificant()) {
              this.fireEvent(new mxEventObject(mxEvent.REDO, "edit", edit));
              break;
            }
          }
        };
        mxUndoManager.prototype.undoableEditHappened = function(undoableEdit) {
          this.trim();
          if (this.size > 0 && this.size == this.history.length) {
            this.history.shift();
          }
          this.history.push(undoableEdit);
          this.indexOfNextAdd = this.history.length;
          this.fireEvent(new mxEventObject(mxEvent.ADD, "edit", undoableEdit));
        };
        mxUndoManager.prototype.trim = function() {
          if (this.history.length > this.indexOfNextAdd) {
            var edits = this.history.splice(
              this.indexOfNextAdd,
              this.history.length - this.indexOfNextAdd
            );
            for (var i = 0; i < edits.length; i++) {
              edits[i].die();
            }
          }
        };
        __mxOutput.mxUndoManager = typeof mxUndoManager !== "undefined" ? mxUndoManager : void 0;
        var mxUrlConverter = function() {
        };
        mxUrlConverter.prototype.enabled = true;
        mxUrlConverter.prototype.baseUrl = null;
        mxUrlConverter.prototype.baseDomain = null;
        mxUrlConverter.prototype.updateBaseUrl = function() {
          this.baseDomain = location.protocol + "//" + location.host;
          this.baseUrl = this.baseDomain + location.pathname;
          var tmp = this.baseUrl.lastIndexOf("/");
          if (tmp > 0) {
            this.baseUrl = this.baseUrl.substring(0, tmp + 1);
          }
        };
        mxUrlConverter.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxUrlConverter.prototype.setEnabled = function(value) {
          this.enabled = value;
        };
        mxUrlConverter.prototype.getBaseUrl = function() {
          return this.baseUrl;
        };
        mxUrlConverter.prototype.setBaseUrl = function(value) {
          this.baseUrl = value;
        };
        mxUrlConverter.prototype.getBaseDomain = function() {
          return this.baseDomain;
        };
        mxUrlConverter.prototype.setBaseDomain = function(value) {
          this.baseDomain = value;
        };
        mxUrlConverter.prototype.isRelativeUrl = function(url) {
          return url != null && url.substring(0, 2) != "//" && url.substring(0, 7) != "http://" && url.substring(0, 8) != "https://" && url.substring(0, 10) != "data:image" && url.substring(0, 7) != "file://" && url.substring(0, 14) != "vscode-file://";
        };
        mxUrlConverter.prototype.convert = function(url) {
          if (this.isEnabled() && this.isRelativeUrl(url)) {
            if (this.getBaseUrl() == null) {
              this.updateBaseUrl();
            }
            if (url.charAt(0) == "/") {
              url = this.getBaseDomain() + url;
            } else {
              url = this.getBaseUrl() + url;
            }
          }
          return url;
        };
        __mxOutput.mxUrlConverter = typeof mxUrlConverter !== "undefined" ? mxUrlConverter : void 0;
        function mxPanningManager(graph) {
          this.thread = null;
          this.active = false;
          this.tdx = 0;
          this.tdy = 0;
          this.t0x = 0;
          this.t0y = 0;
          this.dx = 0;
          this.dy = 0;
          this.scrollbars = false;
          this.scrollLeft = 0;
          this.scrollTop = 0;
          this.mouseListener = {
            mouseDown: function(sender, me) {
            },
            mouseMove: function(sender, me) {
            },
            mouseUp: mxUtils.bind(this, function(sender, me) {
              if (this.active) {
                this.stop();
              }
            })
          };
          graph.addMouseListener(this.mouseListener);
          this.mouseUpListener = mxUtils.bind(this, function() {
            if (this.active) {
              this.stop();
            }
          });
          mxEvent.addListener(document, "mouseup", this.mouseUpListener);
          var createThread = mxUtils.bind(this, function() {
            this.scrollbars = mxUtils.hasScrollbars(graph.container);
            this.scrollLeft = graph.container.scrollLeft;
            this.scrollTop = graph.container.scrollTop;
            return window.setInterval(mxUtils.bind(this, function() {
              this.tdx -= this.dx;
              this.tdy -= this.dy;
              if (this.scrollbars) {
                var left = -graph.container.scrollLeft - Math.ceil(this.dx);
                var top = -graph.container.scrollTop - Math.ceil(this.dy);
                graph.panGraph(left, top);
                graph.panDx = this.scrollLeft - graph.container.scrollLeft;
                graph.panDy = this.scrollTop - graph.container.scrollTop;
                graph.fireEvent(new mxEventObject(mxEvent.PAN));
              } else {
                graph.panGraph(this.getDx(), this.getDy());
              }
            }), this.delay);
          });
          this.isActive = function() {
            return active;
          };
          this.getDx = function() {
            return Math.round(this.tdx);
          };
          this.getDy = function() {
            return Math.round(this.tdy);
          };
          this.start = function() {
            this.t0x = graph.view.translate.x;
            this.t0y = graph.view.translate.y;
            this.active = true;
          };
          this.panTo = function(x, y, w2, h2) {
            if (!this.active) {
              this.start();
            }
            this.scrollLeft = graph.container.scrollLeft;
            this.scrollTop = graph.container.scrollTop;
            w2 = w2 != null ? w2 : 0;
            h2 = h2 != null ? h2 : 0;
            var c = graph.container;
            this.dx = x + w2 - c.scrollLeft - c.clientWidth;
            if (this.dx < 0 && Math.abs(this.dx) < this.border) {
              this.dx = this.border + this.dx;
            } else if (this.handleMouseOut) {
              this.dx = Math.max(this.dx, 0);
            } else {
              this.dx = 0;
            }
            if (this.dx == 0) {
              this.dx = x - c.scrollLeft;
              if (this.dx > 0 && this.dx < this.border) {
                this.dx = this.dx - this.border;
              } else if (this.handleMouseOut) {
                this.dx = Math.min(0, this.dx);
              } else {
                this.dx = 0;
              }
            }
            this.dy = y + h2 - c.scrollTop - c.clientHeight;
            if (this.dy < 0 && Math.abs(this.dy) < this.border) {
              this.dy = this.border + this.dy;
            } else if (this.handleMouseOut) {
              this.dy = Math.max(this.dy, 0);
            } else {
              this.dy = 0;
            }
            if (this.dy == 0) {
              this.dy = y - c.scrollTop;
              if (this.dy > 0 && this.dy < this.border) {
                this.dy = this.dy - this.border;
              } else if (this.handleMouseOut) {
                this.dy = Math.min(0, this.dy);
              } else {
                this.dy = 0;
              }
            }
            if (this.dx != 0 || this.dy != 0) {
              this.dx *= this.damper;
              this.dy *= this.damper;
              if (this.thread == null) {
                this.thread = createThread();
              }
            } else if (this.thread != null) {
              window.clearInterval(this.thread);
              this.thread = null;
            }
          };
          this.stop = function() {
            if (this.active) {
              this.active = false;
              if (this.thread != null) {
                window.clearInterval(this.thread);
                this.thread = null;
              }
              this.tdx = 0;
              this.tdy = 0;
              if (!this.scrollbars) {
                var px2 = graph.panDx;
                var py = graph.panDy;
                if (px2 != 0 || py != 0) {
                  graph.panGraph(0, 0);
                  graph.view.setTranslate(this.t0x + px2 / graph.view.scale, this.t0y + py / graph.view.scale);
                }
              } else {
                graph.panDx = 0;
                graph.panDy = 0;
                graph.fireEvent(new mxEventObject(mxEvent.PAN));
              }
            }
          };
          this.destroy = function() {
            graph.removeMouseListener(this.mouseListener);
            mxEvent.removeListener(document, "mouseup", this.mouseUpListener);
          };
        }
        ;
        mxPanningManager.prototype.damper = 1 / 6;
        mxPanningManager.prototype.delay = 10;
        mxPanningManager.prototype.handleMouseOut = true;
        mxPanningManager.prototype.border = 0;
        __mxOutput.mxPanningManager = typeof mxPanningManager !== "undefined" ? mxPanningManager : void 0;
        function mxPopupMenu(factoryMethod) {
          this.factoryMethod = factoryMethod;
          if (factoryMethod != null) {
            this.init();
          }
        }
        ;
        mxPopupMenu.prototype = new mxEventSource();
        mxPopupMenu.prototype.constructor = mxPopupMenu;
        mxPopupMenu.prototype.submenuImage = mxClient.imageBasePath + "/submenu.gif";
        mxPopupMenu.prototype.zIndex = 10006;
        mxPopupMenu.prototype.factoryMethod = null;
        mxPopupMenu.prototype.useLeftButtonForPopup = false;
        mxPopupMenu.prototype.enabled = true;
        mxPopupMenu.prototype.itemCount = 0;
        mxPopupMenu.prototype.autoExpand = false;
        mxPopupMenu.prototype.smartSeparators = false;
        mxPopupMenu.prototype.labels = true;
        mxPopupMenu.prototype.init = function() {
          this.table = document.createElement("table");
          this.table.className = "mxPopupMenu";
          this.tbody = document.createElement("tbody");
          this.table.appendChild(this.tbody);
          this.div = document.createElement("div");
          this.div.className = "mxPopupMenu";
          this.div.style.display = "inline";
          this.div.style.zIndex = this.zIndex;
          this.div.appendChild(this.table);
          mxEvent.disableContextMenu(this.div);
        };
        mxPopupMenu.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxPopupMenu.prototype.setEnabled = function(enabled) {
          this.enabled = enabled;
        };
        mxPopupMenu.prototype.isPopupTrigger = function(me) {
          return me.isPopupTrigger() || this.useLeftButtonForPopup && mxEvent.isLeftMouseButton(me.getEvent());
        };
        mxPopupMenu.prototype.addItem = function(title, image, funct, parent, iconCls, enabled, active2, noHover) {
          parent = parent || this;
          this.itemCount++;
          if (parent.willAddSeparator) {
            if (parent.containsItems) {
              this.addSeparator(parent, true);
            }
            parent.willAddSeparator = false;
          }
          parent.containsItems = true;
          var tr = document.createElement("tr");
          tr.className = "mxPopupMenuItem";
          var col1 = document.createElement("td");
          col1.className = "mxPopupMenuIcon";
          if (image != null) {
            var img = document.createElement("img");
            img.src = image;
            col1.appendChild(img);
          } else if (iconCls != null) {
            var div = document.createElement("div");
            div.className = iconCls;
            col1.appendChild(div);
          }
          tr.appendChild(col1);
          if (this.labels) {
            var col2 = document.createElement("td");
            col2.className = "mxPopupMenuItem" + (enabled != null && !enabled ? " mxDisabled" : "");
            mxUtils.write(col2, title);
            col2.align = "left";
            tr.appendChild(col2);
            var col3 = document.createElement("td");
            col3.className = "mxPopupMenuItem" + (enabled != null && !enabled ? " mxDisabled" : "");
            col3.style.paddingRight = "6px";
            col3.style.textAlign = "right";
            tr.appendChild(col3);
            if (parent.div == null) {
              this.createSubmenu(parent);
            }
          }
          parent.tbody.appendChild(tr);
          if (active2 != false && enabled != false) {
            var currentSelection = null;
            mxEvent.addGestureListeners(
              tr,
              mxUtils.bind(this, function(evt) {
                this.eventReceiver = tr;
                if (parent.activeRow != tr && parent.activeRow != parent) {
                  if (parent.activeRow != null && parent.activeRow.div.parentNode != null) {
                    this.hideSubmenu(parent);
                  }
                  if (tr.div != null) {
                    this.showSubmenu(parent, tr);
                    parent.activeRow = tr;
                  }
                }
                if (document.selection != null && (mxClient.IS_QUIRKS || document.documentMode == 8)) {
                  currentSelection = document.selection.createRange();
                }
                mxEvent.consume(evt);
              }),
              mxUtils.bind(this, function(evt) {
                if (parent.activeRow != tr && parent.activeRow != parent) {
                  if (parent.activeRow != null && parent.activeRow.div.parentNode != null) {
                    this.hideSubmenu(parent);
                  }
                  if (this.autoExpand && tr.div != null) {
                    this.showSubmenu(parent, tr);
                    parent.activeRow = tr;
                  }
                }
                if (!noHover) {
                  tr.className = "mxPopupMenuItemHover";
                }
              }),
              mxUtils.bind(this, function(evt) {
                if (this.eventReceiver == tr) {
                  if (parent.activeRow != tr) {
                    this.hideMenu();
                  }
                  if (currentSelection != null) {
                    try {
                      currentSelection.select();
                    } catch (e) {
                    }
                    currentSelection = null;
                  }
                  if (funct != null) {
                    funct(evt);
                  }
                }
                this.eventReceiver = null;
                mxEvent.consume(evt);
              })
            );
            if (!noHover) {
              mxEvent.addListener(
                tr,
                "mouseout",
                mxUtils.bind(this, function(evt) {
                  tr.className = "mxPopupMenuItem";
                })
              );
            }
          }
          return tr;
        };
        mxPopupMenu.prototype.addCheckmark = function(item, img) {
          var td2 = item.firstChild.nextSibling;
          td2.style.backgroundImage = "url('" + img + "')";
          td2.style.backgroundRepeat = "no-repeat";
          td2.style.backgroundPosition = "2px 50%";
        };
        mxPopupMenu.prototype.createSubmenu = function(parent) {
          parent.table = document.createElement("table");
          parent.table.className = "mxPopupMenu";
          parent.tbody = document.createElement("tbody");
          parent.table.appendChild(parent.tbody);
          parent.div = document.createElement("div");
          parent.div.className = "mxPopupMenu";
          parent.div.style.position = "absolute";
          parent.div.style.display = "inline";
          parent.div.style.zIndex = this.zIndex;
          parent.div.appendChild(parent.table);
          var img = document.createElement("img");
          img.setAttribute("src", this.submenuImage);
          td = parent.firstChild.nextSibling.nextSibling;
          td.appendChild(img);
        };
        mxPopupMenu.prototype.showSubmenu = function(parent, row) {
          if (row.div != null) {
            row.div.style.left = parent.div.offsetLeft + row.offsetLeft + row.offsetWidth - 1 + "px";
            row.div.style.top = parent.div.offsetTop + row.offsetTop + "px";
            document.body.appendChild(row.div);
            var left = parseInt(row.div.offsetLeft);
            var width = parseInt(row.div.offsetWidth);
            var offset = mxUtils.getDocumentScrollOrigin(document);
            var b = document.body;
            var d = document.documentElement;
            var right = offset.x + (b.clientWidth || d.clientWidth);
            if (left + width > right) {
              row.div.style.left = Math.max(0, parent.div.offsetLeft - width + (mxClient.IS_IE ? 6 : -6)) + "px";
            }
            mxUtils.fit(row.div);
          }
        };
        mxPopupMenu.prototype.addSeparator = function(parent, force) {
          parent = parent || this;
          if (this.smartSeparators && !force) {
            parent.willAddSeparator = true;
          } else if (parent.tbody != null) {
            parent.willAddSeparator = false;
            var tr = document.createElement("tr");
            var col1 = document.createElement("td");
            col1.className = "mxPopupMenuIcon";
            col1.style.padding = "0 0 0 0px";
            tr.appendChild(col1);
            var col2 = document.createElement("td");
            col2.style.padding = "0 0 0 0px";
            col2.setAttribute("colSpan", "2");
            var hr = document.createElement("hr");
            hr.setAttribute("size", "1");
            col2.appendChild(hr);
            tr.appendChild(col2);
            parent.tbody.appendChild(tr);
          }
        };
        mxPopupMenu.prototype.popup = function(x, y, cell2, evt) {
          if (this.div != null && this.tbody != null && this.factoryMethod != null) {
            this.div.style.left = x + "px";
            this.div.style.top = y + "px";
            while (this.tbody.firstChild != null) {
              mxEvent.release(this.tbody.firstChild);
              this.tbody.removeChild(this.tbody.firstChild);
            }
            this.itemCount = 0;
            this.factoryMethod(this, cell2, evt);
            if (this.itemCount > 0) {
              this.showMenu();
              this.fireEvent(new mxEventObject(mxEvent.SHOW));
            }
          }
        };
        mxPopupMenu.prototype.isMenuShowing = function() {
          return this.div != null && this.div.parentNode == document.body;
        };
        mxPopupMenu.prototype.showMenu = function() {
          if (document.documentMode >= 9) {
            this.div.style.filter = "none";
          }
          document.body.appendChild(this.div);
          mxUtils.fit(this.div);
        };
        mxPopupMenu.prototype.hideMenu = function() {
          if (this.div != null) {
            if (this.div.parentNode != null) {
              this.div.parentNode.removeChild(this.div);
            }
            this.hideSubmenu(this);
            this.containsItems = false;
            this.fireEvent(new mxEventObject(mxEvent.HIDE));
          }
        };
        mxPopupMenu.prototype.hideSubmenu = function(parent) {
          if (parent.activeRow != null) {
            this.hideSubmenu(parent.activeRow);
            if (parent.activeRow.div.parentNode != null) {
              parent.activeRow.div.parentNode.removeChild(parent.activeRow.div);
            }
            parent.activeRow = null;
          }
        };
        mxPopupMenu.prototype.destroy = function() {
          if (this.div != null) {
            mxEvent.release(this.div);
            if (this.div.parentNode != null) {
              this.div.parentNode.removeChild(this.div);
            }
            this.div = null;
          }
        };
        __mxOutput.mxPopupMenu = typeof mxPopupMenu !== "undefined" ? mxPopupMenu : void 0;
        function mxAutoSaveManager(graph) {
          this.changeHandler = mxUtils.bind(this, function(sender, evt) {
            if (this.isEnabled()) {
              this.graphModelChanged(evt.getProperty("edit").changes);
            }
          });
          this.setGraph(graph);
        }
        ;
        mxAutoSaveManager.prototype = new mxEventSource();
        mxAutoSaveManager.prototype.constructor = mxAutoSaveManager;
        mxAutoSaveManager.prototype.graph = null;
        mxAutoSaveManager.prototype.autoSaveDelay = 10;
        mxAutoSaveManager.prototype.autoSaveThrottle = 2;
        mxAutoSaveManager.prototype.autoSaveThreshold = 5;
        mxAutoSaveManager.prototype.ignoredChanges = 0;
        mxAutoSaveManager.prototype.lastSnapshot = 0;
        mxAutoSaveManager.prototype.enabled = true;
        mxAutoSaveManager.prototype.changeHandler = null;
        mxAutoSaveManager.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxAutoSaveManager.prototype.setEnabled = function(value) {
          this.enabled = value;
        };
        mxAutoSaveManager.prototype.setGraph = function(graph) {
          if (this.graph != null) {
            this.graph.getModel().removeListener(this.changeHandler);
          }
          this.graph = graph;
          if (this.graph != null) {
            this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
          }
        };
        mxAutoSaveManager.prototype.save = function() {
        };
        mxAutoSaveManager.prototype.graphModelChanged = function(changes) {
          var now = (/* @__PURE__ */ new Date()).getTime();
          var dt = (now - this.lastSnapshot) / 1e3;
          if (dt > this.autoSaveDelay || this.ignoredChanges >= this.autoSaveThreshold && dt > this.autoSaveThrottle) {
            this.save();
            this.reset();
          } else {
            this.ignoredChanges++;
          }
        };
        mxAutoSaveManager.prototype.reset = function() {
          this.lastSnapshot = (/* @__PURE__ */ new Date()).getTime();
          this.ignoredChanges = 0;
        };
        mxAutoSaveManager.prototype.destroy = function() {
          this.setGraph(null);
        };
        __mxOutput.mxAutoSaveManager = typeof mxAutoSaveManager !== "undefined" ? mxAutoSaveManager : void 0;
        function mxAnimation(delay) {
          this.delay = delay != null ? delay : 20;
        }
        ;
        mxAnimation.prototype = new mxEventSource();
        mxAnimation.prototype.constructor = mxAnimation;
        mxAnimation.prototype.delay = null;
        mxAnimation.prototype.thread = null;
        mxAnimation.prototype.isRunning = function() {
          return this.thread != null;
        };
        mxAnimation.prototype.startAnimation = function() {
          if (this.thread == null) {
            this.thread = window.setInterval(mxUtils.bind(this, this.updateAnimation), this.delay);
          }
        };
        mxAnimation.prototype.updateAnimation = function() {
          this.fireEvent(new mxEventObject(mxEvent.EXECUTE));
        };
        mxAnimation.prototype.stopAnimation = function() {
          if (this.thread != null) {
            window.clearInterval(this.thread);
            this.thread = null;
            this.fireEvent(new mxEventObject(mxEvent.DONE));
          }
        };
        __mxOutput.mxAnimation = typeof mxAnimation !== "undefined" ? mxAnimation : void 0;
        function mxMorphing(graph, steps, ease, delay) {
          mxAnimation.call(this, delay);
          this.graph = graph;
          this.steps = steps != null ? steps : 6;
          this.ease = ease != null ? ease : 1.5;
        }
        ;
        mxMorphing.prototype = new mxAnimation();
        mxMorphing.prototype.constructor = mxMorphing;
        mxMorphing.prototype.graph = null;
        mxMorphing.prototype.steps = null;
        mxMorphing.prototype.step = 0;
        mxMorphing.prototype.ease = null;
        mxMorphing.prototype.cells = null;
        mxMorphing.prototype.updateAnimation = function() {
          mxAnimation.prototype.updateAnimation.apply(this, arguments);
          var move = new mxCellStatePreview(this.graph);
          if (this.cells != null) {
            for (var i = 0; i < this.cells.length; i++) {
              this.animateCell(this.cells[i], move, false);
            }
          } else {
            this.animateCell(this.graph.getModel().getRoot(), move, true);
          }
          this.show(move);
          if (move.isEmpty() || this.step++ >= this.steps) {
            this.stopAnimation();
          }
        };
        mxMorphing.prototype.show = function(move) {
          move.show();
        };
        mxMorphing.prototype.animateCell = function(cell2, move, recurse) {
          var state = this.graph.getView().getState(cell2);
          var delta = null;
          if (state != null) {
            delta = this.getDelta(state);
            if (this.graph.getModel().isVertex(cell2) && (delta.x != 0 || delta.y != 0)) {
              var translate = this.graph.view.getTranslate();
              var scale = this.graph.view.getScale();
              delta.x += translate.x * scale;
              delta.y += translate.y * scale;
              move.moveState(state, -delta.x / this.ease, -delta.y / this.ease);
            }
          }
          if (recurse && !this.stopRecursion(state, delta)) {
            var childCount = this.graph.getModel().getChildCount(cell2);
            for (var i = 0; i < childCount; i++) {
              this.animateCell(this.graph.getModel().getChildAt(cell2, i), move, recurse);
            }
          }
        };
        mxMorphing.prototype.stopRecursion = function(state, delta) {
          return delta != null && (delta.x != 0 || delta.y != 0);
        };
        mxMorphing.prototype.getDelta = function(state) {
          var origin = this.getOriginForCell(state.cell);
          var translate = this.graph.getView().getTranslate();
          var scale = this.graph.getView().getScale();
          var x = state.x / scale - translate.x;
          var y = state.y / scale - translate.y;
          return new mxPoint((origin.x - x) * scale, (origin.y - y) * scale);
        };
        mxMorphing.prototype.getOriginForCell = function(cell2) {
          var result2 = null;
          if (cell2 != null) {
            var parent = this.graph.getModel().getParent(cell2);
            var geo = this.graph.getCellGeometry(cell2);
            result2 = this.getOriginForCell(parent);
            if (geo != null) {
              if (geo.relative) {
                var pgeo = this.graph.getCellGeometry(parent);
                if (pgeo != null) {
                  result2.x += geo.x * pgeo.width;
                  result2.y += geo.y * pgeo.height;
                }
              } else {
                result2.x += geo.x;
                result2.y += geo.y;
              }
            }
          }
          if (result2 == null) {
            var t = this.graph.view.getTranslate();
            result2 = new mxPoint(-t.x, -t.y);
          }
          return result2;
        };
        __mxOutput.mxMorphing = typeof mxMorphing !== "undefined" ? mxMorphing : void 0;
        function mxImageBundle(alt) {
          this.images = [];
          this.alt = alt != null ? alt : false;
        }
        ;
        mxImageBundle.prototype.images = null;
        mxImageBundle.prototype.alt = null;
        mxImageBundle.prototype.putImage = function(key, value, fallback) {
          this.images[key] = { value, fallback };
        };
        mxImageBundle.prototype.getImage = function(key) {
          var result2 = null;
          if (key != null) {
            var img = this.images[key];
            if (img != null) {
              result2 = this.alt ? img.fallback : img.value;
            }
          }
          return result2;
        };
        __mxOutput.mxImageBundle = typeof mxImageBundle !== "undefined" ? mxImageBundle : void 0;
        function mxImageExport() {
        }
        ;
        mxImageExport.prototype.includeOverlays = false;
        mxImageExport.prototype.drawState = function(state, canvas) {
          if (state != null) {
            this.visitStatesRecursive(state, canvas, mxUtils.bind(this, function() {
              this.drawCellState.apply(this, arguments);
            }));
            if (this.includeOverlays) {
              this.visitStatesRecursive(state, canvas, mxUtils.bind(this, function() {
                this.drawOverlays.apply(this, arguments);
              }));
            }
          }
        };
        mxImageExport.prototype.visitStatesRecursive = function(state, canvas, visitor) {
          if (state != null) {
            visitor(state, canvas);
            var graph = state.view.graph;
            var childCount = graph.model.getChildCount(state.cell);
            for (var i = 0; i < childCount; i++) {
              var childState = graph.view.getState(graph.model.getChildAt(state.cell, i));
              this.visitStatesRecursive(childState, canvas, visitor);
            }
          }
        };
        mxImageExport.prototype.getLinkForCellState = function(state, canvas) {
          return null;
        };
        mxImageExport.prototype.drawCellState = function(state, canvas) {
          var link = this.getLinkForCellState(state, canvas);
          if (link != null) {
            canvas.setLink(link);
          }
          this.drawShape(state, canvas);
          this.drawText(state, canvas);
          if (link != null) {
            canvas.setLink(null);
          }
        };
        mxImageExport.prototype.drawShape = function(state, canvas) {
          if (state.shape instanceof mxShape && state.shape.checkBounds()) {
            canvas.save();
            state.shape.beforePaint(canvas);
            state.shape.paint(canvas);
            state.shape.afterPaint(canvas);
            canvas.restore();
          }
        };
        mxImageExport.prototype.drawText = function(state, canvas) {
          if (state.text != null && state.text.checkBounds()) {
            canvas.save();
            state.text.beforePaint(canvas);
            state.text.paint(canvas);
            state.text.afterPaint(canvas);
            canvas.restore();
          }
        };
        mxImageExport.prototype.drawOverlays = function(state, canvas) {
          if (state.overlays != null) {
            state.overlays.visit(function(id, shape2) {
              if (shape2 instanceof mxShape) {
                shape2.paint(canvas);
              }
            });
          }
        };
        __mxOutput.mxImageExport = typeof mxImageExport !== "undefined" ? mxImageExport : void 0;
        function mxAbstractCanvas2D() {
          this.converter = this.createUrlConverter();
          this.reset();
        }
        ;
        mxAbstractCanvas2D.prototype.state = null;
        mxAbstractCanvas2D.prototype.states = null;
        mxAbstractCanvas2D.prototype.path = null;
        mxAbstractCanvas2D.prototype.rotateHtml = true;
        mxAbstractCanvas2D.prototype.lastX = 0;
        mxAbstractCanvas2D.prototype.lastY = 0;
        mxAbstractCanvas2D.prototype.moveOp = "M";
        mxAbstractCanvas2D.prototype.lineOp = "L";
        mxAbstractCanvas2D.prototype.quadOp = "Q";
        mxAbstractCanvas2D.prototype.curveOp = "C";
        mxAbstractCanvas2D.prototype.closeOp = "Z";
        mxAbstractCanvas2D.prototype.pointerEvents = false;
        mxAbstractCanvas2D.prototype.createUrlConverter = function() {
          return new mxUrlConverter();
        };
        mxAbstractCanvas2D.prototype.reset = function() {
          this.state = this.createState();
          this.states = [];
        };
        mxAbstractCanvas2D.prototype.createState = function() {
          return {
            dx: 0,
            dy: 0,
            scale: 1,
            alpha: 1,
            fillAlpha: 1,
            strokeAlpha: 1,
            fillColor: null,
            gradientFillAlpha: 1,
            gradientColor: null,
            gradientAlpha: 1,
            gradientDirection: null,
            strokeColor: null,
            strokeWidth: 1,
            dashed: false,
            dashPattern: "3 3",
            fixDash: false,
            lineCap: "flat",
            lineJoin: "miter",
            miterLimit: 10,
            fontColor: "#000000",
            fontBackgroundColor: null,
            fontBorderColor: null,
            fontSize: mxConstants.DEFAULT_FONTSIZE,
            fontFamily: mxConstants.DEFAULT_FONTFAMILY,
            fontStyle: 0,
            shadow: false,
            shadowColor: mxConstants.SHADOWCOLOR,
            shadowAlpha: mxConstants.SHADOW_OPACITY,
            shadowDx: mxConstants.SHADOW_OFFSET_X,
            shadowDy: mxConstants.SHADOW_OFFSET_Y,
            rotation: 0,
            rotationCx: 0,
            rotationCy: 0
          };
        };
        mxAbstractCanvas2D.prototype.format = function(value) {
          return Math.round(parseFloat(value));
        };
        mxAbstractCanvas2D.prototype.addOp = function() {
          if (this.path != null) {
            this.path.push(arguments[0]);
            if (arguments.length > 2) {
              var s = this.state;
              for (var i = 2; i < arguments.length; i += 2) {
                this.lastX = arguments[i - 1];
                this.lastY = arguments[i];
                this.path.push(this.format((this.lastX + s.dx) * s.scale));
                this.path.push(this.format((this.lastY + s.dy) * s.scale));
              }
            }
          }
        };
        mxAbstractCanvas2D.prototype.rotatePoint = function(x, y, theta, cx, cy) {
          var rad = theta * (Math.PI / 180);
          return mxUtils.getRotatedPoint(
            new mxPoint(x, y),
            Math.cos(rad),
            Math.sin(rad),
            new mxPoint(cx, cy)
          );
        };
        mxAbstractCanvas2D.prototype.save = function() {
          this.states.push(this.state);
          this.state = mxUtils.clone(this.state);
        };
        mxAbstractCanvas2D.prototype.restore = function() {
          if (this.states.length > 0) {
            this.state = this.states.pop();
          }
        };
        mxAbstractCanvas2D.prototype.setLink = function(link) {
        };
        mxAbstractCanvas2D.prototype.scale = function(value) {
          this.state.scale *= value;
          this.state.strokeWidth *= value;
        };
        mxAbstractCanvas2D.prototype.translate = function(dx, dy) {
          this.state.dx += dx;
          this.state.dy += dy;
        };
        mxAbstractCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy) {
        };
        mxAbstractCanvas2D.prototype.setAlpha = function(value) {
          this.state.alpha = value;
        };
        mxAbstractCanvas2D.prototype.setFillAlpha = function(value) {
          this.state.fillAlpha = value;
        };
        mxAbstractCanvas2D.prototype.setStrokeAlpha = function(value) {
          this.state.strokeAlpha = value;
        };
        mxAbstractCanvas2D.prototype.setFillColor = function(value) {
          if (value == mxConstants.NONE) {
            value = null;
          }
          this.state.fillColor = value;
          this.state.gradientColor = null;
        };
        mxAbstractCanvas2D.prototype.setGradient = function(color1, color2, x, y, w2, h2, direction, alpha1, alpha2) {
          var s = this.state;
          s.fillColor = color1;
          s.gradientFillAlpha = alpha1 != null ? alpha1 : 1;
          s.gradientColor = color2;
          s.gradientAlpha = alpha2 != null ? alpha2 : 1;
          s.gradientDirection = direction;
        };
        mxAbstractCanvas2D.prototype.setStrokeColor = function(value) {
          if (value == mxConstants.NONE) {
            value = null;
          }
          this.state.strokeColor = value;
        };
        mxAbstractCanvas2D.prototype.setStrokeWidth = function(value) {
          this.state.strokeWidth = value;
        };
        mxAbstractCanvas2D.prototype.setDashed = function(value, fixDash) {
          this.state.dashed = value;
          this.state.fixDash = fixDash;
        };
        mxAbstractCanvas2D.prototype.setDashPattern = function(value) {
          this.state.dashPattern = value;
        };
        mxAbstractCanvas2D.prototype.setLineCap = function(value) {
          this.state.lineCap = value;
        };
        mxAbstractCanvas2D.prototype.setLineJoin = function(value) {
          this.state.lineJoin = value;
        };
        mxAbstractCanvas2D.prototype.setMiterLimit = function(value) {
          this.state.miterLimit = value;
        };
        mxAbstractCanvas2D.prototype.setFontColor = function(value) {
          if (value == mxConstants.NONE) {
            value = null;
          }
          this.state.fontColor = value;
        };
        mxAbstractCanvas2D.prototype.setFontBackgroundColor = function(value) {
          if (value == mxConstants.NONE) {
            value = null;
          }
          this.state.fontBackgroundColor = value;
        };
        mxAbstractCanvas2D.prototype.setFontBorderColor = function(value) {
          if (value == mxConstants.NONE) {
            value = null;
          }
          this.state.fontBorderColor = value;
        };
        mxAbstractCanvas2D.prototype.setFontSize = function(value) {
          this.state.fontSize = parseFloat(value);
        };
        mxAbstractCanvas2D.prototype.setFontFamily = function(value) {
          this.state.fontFamily = value;
        };
        mxAbstractCanvas2D.prototype.setFontStyle = function(value) {
          if (value == null) {
            value = 0;
          }
          this.state.fontStyle = value;
        };
        mxAbstractCanvas2D.prototype.setShadow = function(enabled) {
          this.state.shadow = enabled;
        };
        mxAbstractCanvas2D.prototype.setShadowColor = function(value) {
          if (value == mxConstants.NONE) {
            value = null;
          }
          this.state.shadowColor = value;
        };
        mxAbstractCanvas2D.prototype.setShadowAlpha = function(value) {
          this.state.shadowAlpha = value;
        };
        mxAbstractCanvas2D.prototype.setShadowOffset = function(dx, dy) {
          this.state.shadowDx = dx;
          this.state.shadowDy = dy;
        };
        mxAbstractCanvas2D.prototype.begin = function() {
          this.lastX = 0;
          this.lastY = 0;
          this.path = [];
        };
        mxAbstractCanvas2D.prototype.moveTo = function(x, y) {
          this.addOp(this.moveOp, x, y);
        };
        mxAbstractCanvas2D.prototype.lineTo = function(x, y) {
          this.addOp(this.lineOp, x, y);
        };
        mxAbstractCanvas2D.prototype.quadTo = function(x1, y1, x2, y2) {
          this.addOp(this.quadOp, x1, y1, x2, y2);
        };
        mxAbstractCanvas2D.prototype.curveTo = function(x1, y1, x2, y2, x3, y3) {
          this.addOp(this.curveOp, x1, y1, x2, y2, x3, y3);
        };
        mxAbstractCanvas2D.prototype.arcTo = function(rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
          var curves = mxUtils.arcToCurves(this.lastX, this.lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y);
          if (curves != null) {
            for (var i = 0; i < curves.length; i += 6) {
              this.curveTo(
                curves[i],
                curves[i + 1],
                curves[i + 2],
                curves[i + 3],
                curves[i + 4],
                curves[i + 5]
              );
            }
          }
        };
        mxAbstractCanvas2D.prototype.close = function(x1, y1, x2, y2, x3, y3) {
          this.addOp(this.closeOp);
        };
        mxAbstractCanvas2D.prototype.end = function() {
        };
        __mxOutput.mxAbstractCanvas2D = typeof mxAbstractCanvas2D !== "undefined" ? mxAbstractCanvas2D : void 0;
        function mxXmlCanvas2D(root) {
          mxAbstractCanvas2D.call(this);
          this.root = root;
          this.writeDefaults();
        }
        ;
        mxUtils.extend(mxXmlCanvas2D, mxAbstractCanvas2D);
        mxXmlCanvas2D.prototype.textEnabled = true;
        mxXmlCanvas2D.prototype.compressed = true;
        mxXmlCanvas2D.prototype.writeDefaults = function() {
          var elem;
          elem = this.createElement("fontfamily");
          elem.setAttribute("family", mxConstants.DEFAULT_FONTFAMILY);
          this.root.appendChild(elem);
          elem = this.createElement("fontsize");
          elem.setAttribute("size", mxConstants.DEFAULT_FONTSIZE);
          this.root.appendChild(elem);
          elem = this.createElement("shadowcolor");
          elem.setAttribute("color", mxConstants.SHADOWCOLOR);
          this.root.appendChild(elem);
          elem = this.createElement("shadowalpha");
          elem.setAttribute("alpha", mxConstants.SHADOW_OPACITY);
          this.root.appendChild(elem);
          elem = this.createElement("shadowoffset");
          elem.setAttribute("dx", mxConstants.SHADOW_OFFSET_X);
          elem.setAttribute("dy", mxConstants.SHADOW_OFFSET_Y);
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.format = function(value) {
          return parseFloat(parseFloat(value).toFixed(2));
        };
        mxXmlCanvas2D.prototype.createElement = function(name2) {
          return this.root.ownerDocument.createElement(name2);
        };
        mxXmlCanvas2D.prototype.save = function() {
          if (this.compressed) {
            mxAbstractCanvas2D.prototype.save.apply(this, arguments);
          }
          this.root.appendChild(this.createElement("save"));
        };
        mxXmlCanvas2D.prototype.restore = function() {
          if (this.compressed) {
            mxAbstractCanvas2D.prototype.restore.apply(this, arguments);
          }
          this.root.appendChild(this.createElement("restore"));
        };
        mxXmlCanvas2D.prototype.scale = function(value) {
          var elem = this.createElement("scale");
          elem.setAttribute("scale", value);
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.translate = function(dx, dy) {
          var elem = this.createElement("translate");
          elem.setAttribute("dx", this.format(dx));
          elem.setAttribute("dy", this.format(dy));
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy) {
          var elem = this.createElement("rotate");
          if (theta != 0 || flipH || flipV) {
            elem.setAttribute("theta", this.format(theta));
            elem.setAttribute("flipH", flipH ? "1" : "0");
            elem.setAttribute("flipV", flipV ? "1" : "0");
            elem.setAttribute("cx", this.format(cx));
            elem.setAttribute("cy", this.format(cy));
            this.root.appendChild(elem);
          }
        };
        mxXmlCanvas2D.prototype.setAlpha = function(value) {
          if (this.compressed) {
            if (this.state.alpha == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setAlpha.apply(this, arguments);
          }
          var elem = this.createElement("alpha");
          elem.setAttribute("alpha", this.format(value));
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setFillAlpha = function(value) {
          if (this.compressed) {
            if (this.state.fillAlpha == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setFillAlpha.apply(this, arguments);
          }
          var elem = this.createElement("fillalpha");
          elem.setAttribute("alpha", this.format(value));
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setStrokeAlpha = function(value) {
          if (this.compressed) {
            if (this.state.strokeAlpha == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setStrokeAlpha.apply(this, arguments);
          }
          var elem = this.createElement("strokealpha");
          elem.setAttribute("alpha", this.format(value));
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setFillColor = function(value) {
          if (value == mxConstants.NONE) {
            value = null;
          }
          if (this.compressed) {
            if (this.state.fillColor == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setFillColor.apply(this, arguments);
          }
          var elem = this.createElement("fillcolor");
          elem.setAttribute("color", value != null ? value : mxConstants.NONE);
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setGradient = function(color1, color2, x, y, w2, h2, direction, alpha1, alpha2) {
          if (color1 != null && color2 != null) {
            mxAbstractCanvas2D.prototype.setGradient.apply(this, arguments);
            var elem = this.createElement("gradient");
            elem.setAttribute("c1", color1);
            elem.setAttribute("c2", color2);
            elem.setAttribute("x", this.format(x));
            elem.setAttribute("y", this.format(y));
            elem.setAttribute("w", this.format(w2));
            elem.setAttribute("h", this.format(h2));
            if (direction != null) {
              elem.setAttribute("direction", direction);
            }
            if (alpha1 != null) {
              elem.setAttribute("alpha1", alpha1);
            }
            if (alpha2 != null) {
              elem.setAttribute("alpha2", alpha2);
            }
            this.root.appendChild(elem);
          }
        };
        mxXmlCanvas2D.prototype.setStrokeColor = function(value) {
          if (value == mxConstants.NONE) {
            value = null;
          }
          if (this.compressed) {
            if (this.state.strokeColor == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setStrokeColor.apply(this, arguments);
          }
          var elem = this.createElement("strokecolor");
          elem.setAttribute("color", value != null ? value : mxConstants.NONE);
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setStrokeWidth = function(value) {
          if (this.compressed) {
            if (this.state.strokeWidth == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setStrokeWidth.apply(this, arguments);
          }
          var elem = this.createElement("strokewidth");
          elem.setAttribute("width", this.format(value));
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setDashed = function(value, fixDash) {
          if (this.compressed) {
            if (this.state.dashed == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setDashed.apply(this, arguments);
          }
          var elem = this.createElement("dashed");
          elem.setAttribute("dashed", value ? "1" : "0");
          if (fixDash != null) {
            elem.setAttribute("fixDash", fixDash ? "1" : "0");
          }
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setDashPattern = function(value) {
          if (this.compressed) {
            if (this.state.dashPattern == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setDashPattern.apply(this, arguments);
          }
          var elem = this.createElement("dashpattern");
          elem.setAttribute("pattern", value);
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setLineCap = function(value) {
          if (this.compressed) {
            if (this.state.lineCap == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setLineCap.apply(this, arguments);
          }
          var elem = this.createElement("linecap");
          elem.setAttribute("cap", value);
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setLineJoin = function(value) {
          if (this.compressed) {
            if (this.state.lineJoin == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setLineJoin.apply(this, arguments);
          }
          var elem = this.createElement("linejoin");
          elem.setAttribute("join", value);
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setMiterLimit = function(value) {
          if (this.compressed) {
            if (this.state.miterLimit == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setMiterLimit.apply(this, arguments);
          }
          var elem = this.createElement("miterlimit");
          elem.setAttribute("limit", value);
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setFontColor = function(value) {
          if (this.textEnabled) {
            if (value == mxConstants.NONE) {
              value = null;
            }
            if (this.compressed) {
              if (this.state.fontColor == value) {
                return;
              }
              mxAbstractCanvas2D.prototype.setFontColor.apply(this, arguments);
            }
            var elem = this.createElement("fontcolor");
            elem.setAttribute("color", value != null ? value : mxConstants.NONE);
            this.root.appendChild(elem);
          }
        };
        mxXmlCanvas2D.prototype.setFontBackgroundColor = function(value) {
          if (this.textEnabled) {
            if (value == mxConstants.NONE) {
              value = null;
            }
            if (this.compressed) {
              if (this.state.fontBackgroundColor == value) {
                return;
              }
              mxAbstractCanvas2D.prototype.setFontBackgroundColor.apply(this, arguments);
            }
            var elem = this.createElement("fontbackgroundcolor");
            elem.setAttribute("color", value != null ? value : mxConstants.NONE);
            this.root.appendChild(elem);
          }
        };
        mxXmlCanvas2D.prototype.setFontBorderColor = function(value) {
          if (this.textEnabled) {
            if (value == mxConstants.NONE) {
              value = null;
            }
            if (this.compressed) {
              if (this.state.fontBorderColor == value) {
                return;
              }
              mxAbstractCanvas2D.prototype.setFontBorderColor.apply(this, arguments);
            }
            var elem = this.createElement("fontbordercolor");
            elem.setAttribute("color", value != null ? value : mxConstants.NONE);
            this.root.appendChild(elem);
          }
        };
        mxXmlCanvas2D.prototype.setFontSize = function(value) {
          if (this.textEnabled) {
            if (this.compressed) {
              if (this.state.fontSize == value) {
                return;
              }
              mxAbstractCanvas2D.prototype.setFontSize.apply(this, arguments);
            }
            var elem = this.createElement("fontsize");
            elem.setAttribute("size", value);
            this.root.appendChild(elem);
          }
        };
        mxXmlCanvas2D.prototype.setFontFamily = function(value) {
          if (this.textEnabled) {
            if (this.compressed) {
              if (this.state.fontFamily == value) {
                return;
              }
              mxAbstractCanvas2D.prototype.setFontFamily.apply(this, arguments);
            }
            var elem = this.createElement("fontfamily");
            elem.setAttribute("family", value);
            this.root.appendChild(elem);
          }
        };
        mxXmlCanvas2D.prototype.setFontStyle = function(value) {
          if (this.textEnabled) {
            if (value == null) {
              value = 0;
            }
            if (this.compressed) {
              if (this.state.fontStyle == value) {
                return;
              }
              mxAbstractCanvas2D.prototype.setFontStyle.apply(this, arguments);
            }
            var elem = this.createElement("fontstyle");
            elem.setAttribute("style", value);
            this.root.appendChild(elem);
          }
        };
        mxXmlCanvas2D.prototype.setShadow = function(value) {
          if (this.compressed) {
            if (this.state.shadow == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setShadow.apply(this, arguments);
          }
          var elem = this.createElement("shadow");
          elem.setAttribute("enabled", value ? "1" : "0");
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setShadowColor = function(value) {
          if (this.compressed) {
            if (value == mxConstants.NONE) {
              value = null;
            }
            if (this.state.shadowColor == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setShadowColor.apply(this, arguments);
          }
          var elem = this.createElement("shadowcolor");
          elem.setAttribute("color", value != null ? value : mxConstants.NONE);
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setShadowAlpha = function(value) {
          if (this.compressed) {
            if (this.state.shadowAlpha == value) {
              return;
            }
            mxAbstractCanvas2D.prototype.setShadowAlpha.apply(this, arguments);
          }
          var elem = this.createElement("shadowalpha");
          elem.setAttribute("alpha", value);
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.setShadowOffset = function(dx, dy) {
          if (this.compressed) {
            if (this.state.shadowDx == dx && this.state.shadowDy == dy) {
              return;
            }
            mxAbstractCanvas2D.prototype.setShadowOffset.apply(this, arguments);
          }
          var elem = this.createElement("shadowoffset");
          elem.setAttribute("dx", dx);
          elem.setAttribute("dy", dy);
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.rect = function(x, y, w2, h2) {
          var elem = this.createElement("rect");
          elem.setAttribute("x", this.format(x));
          elem.setAttribute("y", this.format(y));
          elem.setAttribute("w", this.format(w2));
          elem.setAttribute("h", this.format(h2));
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.roundrect = function(x, y, w2, h2, dx, dy) {
          var elem = this.createElement("roundrect");
          elem.setAttribute("x", this.format(x));
          elem.setAttribute("y", this.format(y));
          elem.setAttribute("w", this.format(w2));
          elem.setAttribute("h", this.format(h2));
          elem.setAttribute("dx", this.format(dx));
          elem.setAttribute("dy", this.format(dy));
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.ellipse = function(x, y, w2, h2) {
          var elem = this.createElement("ellipse");
          elem.setAttribute("x", this.format(x));
          elem.setAttribute("y", this.format(y));
          elem.setAttribute("w", this.format(w2));
          elem.setAttribute("h", this.format(h2));
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.image = function(x, y, w2, h2, src, aspect, flipH, flipV) {
          src = this.converter.convert(src);
          var elem = this.createElement("image");
          elem.setAttribute("x", this.format(x));
          elem.setAttribute("y", this.format(y));
          elem.setAttribute("w", this.format(w2));
          elem.setAttribute("h", this.format(h2));
          elem.setAttribute("src", src);
          elem.setAttribute("aspect", aspect ? "1" : "0");
          elem.setAttribute("flipH", flipH ? "1" : "0");
          elem.setAttribute("flipV", flipV ? "1" : "0");
          this.root.appendChild(elem);
        };
        mxXmlCanvas2D.prototype.begin = function() {
          this.root.appendChild(this.createElement("begin"));
          this.lastX = 0;
          this.lastY = 0;
        };
        mxXmlCanvas2D.prototype.moveTo = function(x, y) {
          var elem = this.createElement("move");
          elem.setAttribute("x", this.format(x));
          elem.setAttribute("y", this.format(y));
          this.root.appendChild(elem);
          this.lastX = x;
          this.lastY = y;
        };
        mxXmlCanvas2D.prototype.lineTo = function(x, y) {
          var elem = this.createElement("line");
          elem.setAttribute("x", this.format(x));
          elem.setAttribute("y", this.format(y));
          this.root.appendChild(elem);
          this.lastX = x;
          this.lastY = y;
        };
        mxXmlCanvas2D.prototype.quadTo = function(x1, y1, x2, y2) {
          var elem = this.createElement("quad");
          elem.setAttribute("x1", this.format(x1));
          elem.setAttribute("y1", this.format(y1));
          elem.setAttribute("x2", this.format(x2));
          elem.setAttribute("y2", this.format(y2));
          this.root.appendChild(elem);
          this.lastX = x2;
          this.lastY = y2;
        };
        mxXmlCanvas2D.prototype.curveTo = function(x1, y1, x2, y2, x3, y3) {
          var elem = this.createElement("curve");
          elem.setAttribute("x1", this.format(x1));
          elem.setAttribute("y1", this.format(y1));
          elem.setAttribute("x2", this.format(x2));
          elem.setAttribute("y2", this.format(y2));
          elem.setAttribute("x3", this.format(x3));
          elem.setAttribute("y3", this.format(y3));
          this.root.appendChild(elem);
          this.lastX = x3;
          this.lastY = y3;
        };
        mxXmlCanvas2D.prototype.close = function() {
          this.root.appendChild(this.createElement("close"));
        };
        mxXmlCanvas2D.prototype.text = function(x, y, w2, h2, str, align, valign, wrap, format, overflow, clip2, rotation, dir) {
          if (this.textEnabled && str != null) {
            if (mxUtils.isNode(str)) {
              str = mxUtils.getOuterHtml(str);
            }
            var elem = this.createElement("text");
            elem.setAttribute("x", this.format(x));
            elem.setAttribute("y", this.format(y));
            elem.setAttribute("w", this.format(w2));
            elem.setAttribute("h", this.format(h2));
            elem.setAttribute("str", str);
            if (align != null) {
              elem.setAttribute("align", align);
            }
            if (valign != null) {
              elem.setAttribute("valign", valign);
            }
            elem.setAttribute("wrap", wrap ? "1" : "0");
            if (format == null) {
              format = "";
            }
            elem.setAttribute("format", format);
            if (overflow != null) {
              elem.setAttribute("overflow", overflow);
            }
            if (clip2 != null) {
              elem.setAttribute("clip", clip2 ? "1" : "0");
            }
            if (rotation != null) {
              elem.setAttribute("rotation", rotation);
            }
            if (dir != null) {
              elem.setAttribute("dir", dir);
            }
            this.root.appendChild(elem);
          }
        };
        mxXmlCanvas2D.prototype.stroke = function() {
          this.root.appendChild(this.createElement("stroke"));
        };
        mxXmlCanvas2D.prototype.fill = function() {
          this.root.appendChild(this.createElement("fill"));
        };
        mxXmlCanvas2D.prototype.fillAndStroke = function() {
          this.root.appendChild(this.createElement("fillstroke"));
        };
        __mxOutput.mxXmlCanvas2D = typeof mxXmlCanvas2D !== "undefined" ? mxXmlCanvas2D : void 0;
        function mxSvgCanvas2D(root, styleEnabled) {
          mxAbstractCanvas2D.call(this);
          this.root = root;
          this.gradients = [];
          this.defs = null;
          this.styleEnabled = styleEnabled != null ? styleEnabled : false;
          var svg = null;
          if (root.ownerDocument != document) {
            var node = root;
            while (node != null && node.nodeName != "svg") {
              node = node.parentNode;
            }
            svg = node;
          }
          if (svg != null) {
            var tmp = svg.getElementsByTagName("defs");
            if (tmp.length > 0) {
              this.defs = svg.getElementsByTagName("defs")[0];
            }
            if (this.defs == null) {
              this.defs = this.createElement("defs");
              if (svg.firstChild != null) {
                svg.insertBefore(this.defs, svg.firstChild);
              } else {
                svg.appendChild(this.defs);
              }
            }
            if (this.styleEnabled) {
              this.defs.appendChild(this.createStyle());
            }
          }
        }
        ;
        mxUtils.extend(mxSvgCanvas2D, mxAbstractCanvas2D);
        (function() {
          mxSvgCanvas2D.prototype.useDomParser = !mxClient.IS_IE && typeof DOMParser === "function" && typeof XMLSerializer === "function";
          if (mxSvgCanvas2D.prototype.useDomParser) {
            try {
              var doc = new DOMParser().parseFromString("test text", "text/html");
              mxSvgCanvas2D.prototype.useDomParser = doc != null;
            } catch (e) {
              mxSvgCanvas2D.prototype.useDomParser = false;
            }
          }
          mxSvgCanvas2D.prototype.useAbsoluteIds = !mxClient.IS_CHROMEAPP && !mxClient.IS_IE && !mxClient.IS_IE11 && !mxClient.IS_EDGE && document.getElementsByTagName("base").length > 0;
        })();
        mxSvgCanvas2D.prototype.node = null;
        mxSvgCanvas2D.prototype.matchHtmlAlignment = true;
        mxSvgCanvas2D.prototype.textEnabled = true;
        mxSvgCanvas2D.prototype.foEnabled = true;
        mxSvgCanvas2D.prototype.foAltText = "[Object]";
        mxSvgCanvas2D.prototype.foOffset = 0;
        mxSvgCanvas2D.prototype.textOffset = 0;
        mxSvgCanvas2D.prototype.imageOffset = 0;
        mxSvgCanvas2D.prototype.strokeTolerance = 0;
        mxSvgCanvas2D.prototype.minStrokeWidth = 1;
        mxSvgCanvas2D.prototype.refCount = 0;
        mxSvgCanvas2D.prototype.lineHeightCorrection = 1;
        mxSvgCanvas2D.prototype.pointerEventsValue = "all";
        mxSvgCanvas2D.prototype.fontMetricsPadding = 10;
        mxSvgCanvas2D.prototype.cacheOffsetSize = true;
        mxSvgCanvas2D.prototype.format = function(value) {
          return parseFloat(parseFloat(value).toFixed(2));
        };
        mxSvgCanvas2D.prototype.getBaseUrl = function() {
          var href = window.location.href;
          var hash = href.lastIndexOf("#");
          if (hash > 0) {
            href = href.substring(0, hash);
          }
          return href;
        };
        mxSvgCanvas2D.prototype.reset = function() {
          mxAbstractCanvas2D.prototype.reset.apply(this, arguments);
          this.gradients = [];
        };
        mxSvgCanvas2D.prototype.createStyle = function(x) {
          var style = this.createElement("style");
          style.setAttribute("type", "text/css");
          mxUtils.write(style, "svg{font-family:" + mxConstants.DEFAULT_FONTFAMILY + ";font-size:" + mxConstants.DEFAULT_FONTSIZE + ";fill:none;stroke-miterlimit:10}");
          return style;
        };
        mxSvgCanvas2D.prototype.createElement = function(tagName, namespace) {
          if (this.root.ownerDocument.createElementNS != null) {
            return this.root.ownerDocument.createElementNS(namespace || mxConstants.NS_SVG, tagName);
          } else {
            var elt = this.root.ownerDocument.createElement(tagName);
            if (namespace != null) {
              elt.setAttribute("xmlns", namespace);
            }
            return elt;
          }
        };
        mxSvgCanvas2D.prototype.getAlternateText = function(fo, x, y, w2, h2, str, align, valign, wrap, format, overflow, clip2, rotation) {
          return str != null ? this.foAltText : null;
        };
        mxSvgCanvas2D.prototype.createAlternateContent = function(fo, x, y, w2, h2, str, align, valign, wrap, format, overflow, clip2, rotation) {
          var text = this.getAlternateText(fo, x, y, w2, h2, str, align, valign, wrap, format, overflow, clip2, rotation);
          var s = this.state;
          if (text != null && s.fontSize > 0) {
            var dy = valign == mxConstants.ALIGN_TOP ? 1 : valign == mxConstants.ALIGN_BOTTOM ? 0 : 0.3;
            var anchor = align == mxConstants.ALIGN_RIGHT ? "end" : align == mxConstants.ALIGN_LEFT ? "start" : "middle";
            var alt = this.createElement("text");
            alt.setAttribute("x", Math.round(x + s.dx));
            alt.setAttribute("y", Math.round(y + s.dy + dy * s.fontSize));
            alt.setAttribute("fill", s.fontColor || "black");
            alt.setAttribute("font-family", s.fontFamily);
            alt.setAttribute("font-size", Math.round(s.fontSize) + "px");
            if (anchor != "start") {
              alt.setAttribute("text-anchor", anchor);
            }
            if ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
              alt.setAttribute("font-weight", "bold");
            }
            if ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
              alt.setAttribute("font-style", "italic");
            }
            var txtDecor = [];
            if ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
              txtDecor.push("underline");
            }
            if ((s.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
              txtDecor.push("line-through");
            }
            if (txtDecor.length > 0) {
              alt.setAttribute("text-decoration", txtDecor.join(" "));
            }
            mxUtils.write(alt, text);
            return alt;
          } else {
            return null;
          }
        };
        mxSvgCanvas2D.prototype.createGradientId = function(start, end, alpha1, alpha2, direction) {
          if (start.charAt(0) == "#") {
            start = start.substring(1);
          }
          if (end.charAt(0) == "#") {
            end = end.substring(1);
          }
          start = start.toLowerCase() + "-" + alpha1;
          end = end.toLowerCase() + "-" + alpha2;
          var dir = null;
          if (direction == null || direction == mxConstants.DIRECTION_SOUTH) {
            dir = "s";
          } else if (direction == mxConstants.DIRECTION_EAST) {
            dir = "e";
          } else {
            var tmp = start;
            start = end;
            end = tmp;
            if (direction == mxConstants.DIRECTION_NORTH) {
              dir = "s";
            } else if (direction == mxConstants.DIRECTION_WEST) {
              dir = "e";
            }
          }
          return "mx-gradient-" + start + "-" + end + "-" + dir;
        };
        mxSvgCanvas2D.prototype.getSvgGradient = function(start, end, alpha1, alpha2, direction) {
          var id = this.createGradientId(start, end, alpha1, alpha2, direction);
          var gradient = this.gradients[id];
          if (gradient == null) {
            var svg = this.root.ownerSVGElement;
            var counter = 0;
            var tmpId = id + "-" + counter;
            if (svg != null) {
              gradient = svg.ownerDocument.getElementById(tmpId);
              while (gradient != null && gradient.ownerSVGElement != svg) {
                tmpId = id + "-" + counter++;
                gradient = svg.ownerDocument.getElementById(tmpId);
              }
            } else {
              tmpId = "id" + ++this.refCount;
            }
            if (gradient == null) {
              gradient = this.createSvgGradient(start, end, alpha1, alpha2, direction);
              gradient.setAttribute("id", tmpId);
              if (this.defs != null) {
                this.defs.appendChild(gradient);
              } else {
                svg.appendChild(gradient);
              }
            }
            this.gradients[id] = gradient;
          }
          return gradient.getAttribute("id");
        };
        mxSvgCanvas2D.prototype.createSvgGradient = function(start, end, alpha1, alpha2, direction) {
          var gradient = this.createElement("linearGradient");
          gradient.setAttribute("x1", "0%");
          gradient.setAttribute("y1", "0%");
          gradient.setAttribute("x2", "0%");
          gradient.setAttribute("y2", "0%");
          if (direction == null || direction == mxConstants.DIRECTION_SOUTH) {
            gradient.setAttribute("y2", "100%");
          } else if (direction == mxConstants.DIRECTION_EAST) {
            gradient.setAttribute("x2", "100%");
          } else if (direction == mxConstants.DIRECTION_NORTH) {
            gradient.setAttribute("y1", "100%");
          } else if (direction == mxConstants.DIRECTION_WEST) {
            gradient.setAttribute("x1", "100%");
          }
          var op = alpha1 < 1 ? ";stop-opacity:" + alpha1 : "";
          var stop = this.createElement("stop");
          stop.setAttribute("offset", "0%");
          stop.setAttribute("style", "stop-color:" + start + op);
          gradient.appendChild(stop);
          op = alpha2 < 1 ? ";stop-opacity:" + alpha2 : "";
          stop = this.createElement("stop");
          stop.setAttribute("offset", "100%");
          stop.setAttribute("style", "stop-color:" + end + op);
          gradient.appendChild(stop);
          return gradient;
        };
        mxSvgCanvas2D.prototype.addNode = function(filled, stroked) {
          var node = this.node;
          var s = this.state;
          if (node != null) {
            if (node.nodeName == "path") {
              if (this.path != null && this.path.length > 0) {
                node.setAttribute("d", this.path.join(" "));
              } else {
                return;
              }
            }
            if (filled && s.fillColor != null) {
              this.updateFill();
            } else if (!this.styleEnabled) {
              if (node.nodeName == "ellipse" && mxClient.IS_FF) {
                node.setAttribute("fill", "transparent");
              } else {
                node.setAttribute("fill", "none");
              }
              filled = false;
            }
            if (stroked && s.strokeColor != null) {
              this.updateStroke();
            } else if (!this.styleEnabled) {
              node.setAttribute("stroke", "none");
            }
            if (s.transform != null && s.transform.length > 0) {
              node.setAttribute("transform", s.transform);
            }
            if (s.shadow) {
              this.root.appendChild(this.createShadow(node));
            }
            if (this.strokeTolerance > 0 && !filled) {
              this.root.appendChild(this.createTolerance(node));
            }
            if (this.pointerEvents) {
              node.setAttribute("pointer-events", this.pointerEventsValue);
            } else if (!this.pointerEvents && this.originalRoot == null) {
              node.setAttribute("pointer-events", "none");
            }
            if (node.nodeName != "rect" && node.nodeName != "path" && node.nodeName != "ellipse" || node.getAttribute("fill") != "none" && node.getAttribute("fill") != "transparent" || node.getAttribute("stroke") != "none" || node.getAttribute("pointer-events") != "none") {
              this.root.appendChild(node);
            }
            this.node = null;
          }
        };
        mxSvgCanvas2D.prototype.updateFill = function() {
          var s = this.state;
          if (s.alpha < 1 || s.fillAlpha < 1) {
            this.node.setAttribute("fill-opacity", s.alpha * s.fillAlpha);
          }
          if (s.fillColor != null) {
            if (s.gradientColor != null) {
              var id = this.getSvgGradient(
                String(s.fillColor),
                String(s.gradientColor),
                s.gradientFillAlpha,
                s.gradientAlpha,
                s.gradientDirection
              );
              if (this.root.ownerDocument == document && this.useAbsoluteIds) {
                var base = this.getBaseUrl().replace(/([\(\)])/g, "\\$1");
                this.node.setAttribute("fill", "url(" + base + "#" + id + ")");
              } else {
                this.node.setAttribute("fill", "url(#" + id + ")");
              }
            } else {
              this.node.setAttribute("fill", String(s.fillColor).toLowerCase());
            }
          }
        };
        mxSvgCanvas2D.prototype.getCurrentStrokeWidth = function() {
          return Math.max(this.minStrokeWidth, Math.max(0.01, this.format(this.state.strokeWidth * this.state.scale)));
        };
        mxSvgCanvas2D.prototype.updateStroke = function() {
          var s = this.state;
          this.node.setAttribute("stroke", String(s.strokeColor).toLowerCase());
          if (s.alpha < 1 || s.strokeAlpha < 1) {
            this.node.setAttribute("stroke-opacity", s.alpha * s.strokeAlpha);
          }
          var sw = this.getCurrentStrokeWidth();
          if (sw != 1) {
            this.node.setAttribute("stroke-width", sw);
          }
          if (this.node.nodeName == "path") {
            this.updateStrokeAttributes();
          }
          if (s.dashed) {
            this.node.setAttribute("stroke-dasharray", this.createDashPattern(
              (s.fixDash ? 1 : s.strokeWidth) * s.scale
            ));
          }
        };
        mxSvgCanvas2D.prototype.updateStrokeAttributes = function() {
          var s = this.state;
          if (s.lineJoin != null && s.lineJoin != "miter") {
            this.node.setAttribute("stroke-linejoin", s.lineJoin);
          }
          if (s.lineCap != null) {
            var value = s.lineCap;
            if (value == "flat") {
              value = "butt";
            }
            if (value != "butt") {
              this.node.setAttribute("stroke-linecap", value);
            }
          }
          if (s.miterLimit != null && (!this.styleEnabled || s.miterLimit != 10)) {
            this.node.setAttribute("stroke-miterlimit", s.miterLimit);
          }
        };
        mxSvgCanvas2D.prototype.createDashPattern = function(scale) {
          var pat = [];
          if (typeof this.state.dashPattern === "string") {
            var dash = this.state.dashPattern.split(" ");
            if (dash.length > 0) {
              for (var i = 0; i < dash.length; i++) {
                pat[i] = Number(dash[i]) * scale;
              }
            }
          }
          return pat.join(" ");
        };
        mxSvgCanvas2D.prototype.createTolerance = function(node) {
          var tol = node.cloneNode(true);
          var sw = parseFloat(tol.getAttribute("stroke-width") || 1) + this.strokeTolerance;
          tol.setAttribute("pointer-events", "stroke");
          tol.setAttribute("visibility", "hidden");
          tol.removeAttribute("stroke-dasharray");
          tol.setAttribute("stroke-width", sw);
          tol.setAttribute("fill", "none");
          tol.setAttribute("stroke", mxClient.IS_OT ? "none" : "white");
          return tol;
        };
        mxSvgCanvas2D.prototype.createShadow = function(node) {
          var shadow = node.cloneNode(true);
          var s = this.state;
          if (shadow.getAttribute("fill") != "none" && (!mxClient.IS_FF || shadow.getAttribute("fill") != "transparent")) {
            shadow.setAttribute("fill", s.shadowColor);
          }
          if (shadow.getAttribute("stroke") != "none") {
            shadow.setAttribute("stroke", s.shadowColor);
          }
          shadow.setAttribute("transform", "translate(" + this.format(s.shadowDx * s.scale) + "," + this.format(s.shadowDy * s.scale) + ")" + (s.transform || ""));
          shadow.setAttribute("opacity", s.shadowAlpha);
          return shadow;
        };
        mxSvgCanvas2D.prototype.setLink = function(link) {
          if (link == null) {
            this.root = this.originalRoot;
          } else {
            this.originalRoot = this.root;
            var node = this.createElement("a");
            if (node.setAttributeNS == null || this.root.ownerDocument != document && document.documentMode == null) {
              node.setAttribute("xlink:href", link);
            } else {
              node.setAttributeNS(mxConstants.NS_XLINK, "xlink:href", link);
            }
            this.root.appendChild(node);
            this.root = node;
          }
        };
        mxSvgCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy) {
          if (theta != 0 || flipH || flipV) {
            var s = this.state;
            cx += s.dx;
            cy += s.dy;
            cx *= s.scale;
            cy *= s.scale;
            s.transform = s.transform || "";
            if (flipH && flipV) {
              theta += 180;
            } else if (flipH != flipV) {
              var tx = flipH ? cx : 0;
              var sx = flipH ? -1 : 1;
              var ty = flipV ? cy : 0;
              var sy = flipV ? -1 : 1;
              s.transform += "translate(" + this.format(tx) + "," + this.format(ty) + ")scale(" + this.format(sx) + "," + this.format(sy) + ")translate(" + this.format(-tx) + "," + this.format(-ty) + ")";
            }
            if (flipH ? !flipV : flipV) {
              theta *= -1;
            }
            if (theta != 0) {
              s.transform += "rotate(" + this.format(theta) + "," + this.format(cx) + "," + this.format(cy) + ")";
            }
            s.rotation = s.rotation + theta;
            s.rotationCx = cx;
            s.rotationCy = cy;
          }
        };
        mxSvgCanvas2D.prototype.begin = function() {
          mxAbstractCanvas2D.prototype.begin.apply(this, arguments);
          this.node = this.createElement("path");
        };
        mxSvgCanvas2D.prototype.rect = function(x, y, w2, h2) {
          var s = this.state;
          var n = this.createElement("rect");
          n.setAttribute("x", this.format((x + s.dx) * s.scale));
          n.setAttribute("y", this.format((y + s.dy) * s.scale));
          n.setAttribute("width", this.format(w2 * s.scale));
          n.setAttribute("height", this.format(h2 * s.scale));
          this.node = n;
        };
        mxSvgCanvas2D.prototype.roundrect = function(x, y, w2, h2, dx, dy) {
          this.rect(x, y, w2, h2);
          if (dx > 0) {
            this.node.setAttribute("rx", this.format(dx * this.state.scale));
          }
          if (dy > 0) {
            this.node.setAttribute("ry", this.format(dy * this.state.scale));
          }
        };
        mxSvgCanvas2D.prototype.ellipse = function(x, y, w2, h2) {
          var s = this.state;
          var n = this.createElement("ellipse");
          n.setAttribute("cx", this.format((x + w2 / 2 + s.dx) * s.scale));
          n.setAttribute("cy", this.format((y + h2 / 2 + s.dy) * s.scale));
          n.setAttribute("rx", w2 / 2 * s.scale);
          n.setAttribute("ry", h2 / 2 * s.scale);
          this.node = n;
        };
        mxSvgCanvas2D.prototype.image = function(x, y, w2, h2, src, aspect, flipH, flipV) {
          src = this.converter.convert(src);
          aspect = aspect != null ? aspect : true;
          flipH = flipH != null ? flipH : false;
          flipV = flipV != null ? flipV : false;
          var s = this.state;
          x += s.dx;
          y += s.dy;
          var node = this.createElement("image");
          node.setAttribute("x", this.format(x * s.scale) + this.imageOffset);
          node.setAttribute("y", this.format(y * s.scale) + this.imageOffset);
          node.setAttribute("width", this.format(w2 * s.scale));
          node.setAttribute("height", this.format(h2 * s.scale));
          if (node.setAttributeNS == null) {
            node.setAttribute("xlink:href", src);
          } else {
            node.setAttributeNS(mxConstants.NS_XLINK, "xlink:href", src);
          }
          if (!aspect) {
            node.setAttribute("preserveAspectRatio", "none");
          }
          if (s.alpha < 1 || s.fillAlpha < 1) {
            node.setAttribute("opacity", s.alpha * s.fillAlpha);
          }
          var tr = this.state.transform || "";
          if (flipH || flipV) {
            var sx = 1;
            var sy = 1;
            var dx = 0;
            var dy = 0;
            if (flipH) {
              sx = -1;
              dx = -w2 - 2 * x;
            }
            if (flipV) {
              sy = -1;
              dy = -h2 - 2 * y;
            }
            tr += "scale(" + sx + "," + sy + ")translate(" + dx * s.scale + "," + dy * s.scale + ")";
          }
          if (tr.length > 0) {
            node.setAttribute("transform", tr);
          }
          if (!this.pointerEvents) {
            node.setAttribute("pointer-events", "none");
          }
          this.root.appendChild(node);
        };
        mxSvgCanvas2D.prototype.convertHtml = function(val) {
          if (this.useDomParser) {
            var doc = new DOMParser().parseFromString(val, "text/html");
            if (doc != null) {
              val = new XMLSerializer().serializeToString(doc.body);
              if (val.substring(0, 5) == "<body") {
                val = val.substring(val.indexOf(">", 5) + 1);
              }
              if (val.substring(val.length - 7, val.length) == "</body>") {
                val = val.substring(0, val.length - 7);
              }
            }
          } else if (document.implementation != null && document.implementation.createDocument != null) {
            var xd = document.implementation.createDocument("http://www.w3.org/1999/xhtml", "html", null);
            var xb = xd.createElement("body");
            xd.documentElement.appendChild(xb);
            var div = document.createElement("div");
            div.innerHTML = val;
            var child = div.firstChild;
            while (child != null) {
              var next = child.nextSibling;
              xb.appendChild(xd.adoptNode(child));
              child = next;
            }
            return xb.innerHTML;
          } else {
            var ta = document.createElement("textarea");
            ta.innerHTML = val.replace(/&amp;/g, "&amp;amp;").replace(/&#60;/g, "&amp;lt;").replace(/&#62;/g, "&amp;gt;").replace(/&lt;/g, "&amp;lt;").replace(/&gt;/g, "&amp;gt;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            val = ta.value.replace(/&/g, "&amp;").replace(/&amp;lt;/g, "&lt;").replace(/&amp;gt;/g, "&gt;").replace(/&amp;amp;/g, "&amp;").replace(/<br>/g, "<br />").replace(/<hr>/g, "<hr />").replace(/(<img[^>]+)>/gm, "$1 />");
          }
          return val;
        };
        mxSvgCanvas2D.prototype.createDiv = function(str) {
          var val = str;
          if (!mxUtils.isNode(val)) {
            val = "<div><div>" + this.convertHtml(val) + "</div></div>";
          }
          if (!mxClient.IS_IE && !mxClient.IS_IE11 && document.createElementNS) {
            var div = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
            if (mxUtils.isNode(val)) {
              var div2 = document.createElement("div");
              var div3 = div2.cloneNode(false);
              if (this.root.ownerDocument != document) {
                div2.appendChild(val.cloneNode(true));
              } else {
                div2.appendChild(val);
              }
              div3.appendChild(div2);
              div.appendChild(div3);
            } else {
              div.innerHTML = val;
            }
            return div;
          } else {
            if (mxUtils.isNode(val)) {
              val = "<div><div>" + mxUtils.getXml(val) + "</div></div>";
            }
            val = '<div xmlns="http://www.w3.org/1999/xhtml">' + val + "</div>";
            return mxUtils.parseXml(val).documentElement;
          }
        };
        mxSvgCanvas2D.prototype.updateText = function(x, y, w2, h2, align, valign, wrap, overflow, clip2, rotation, node) {
          if (node != null && node.firstChild != null && node.firstChild.firstChild != null) {
            this.updateTextNodes(x, y, w2, h2, align, valign, wrap, overflow, clip2, rotation, node.firstChild);
          }
        };
        mxSvgCanvas2D.prototype.addForeignObject = function(x, y, w2, h2, str, align, valign, wrap, format, overflow, clip2, rotation, dir, div, root) {
          var group = this.createElement("g");
          var fo = this.createElement("foreignObject");
          fo.setAttribute("style", "overflow: visible; text-align: left;");
          fo.setAttribute("pointer-events", "none");
          if (div.ownerDocument != document) {
            div = mxUtils.importNodeImplementation(fo.ownerDocument, div, true);
          }
          fo.appendChild(div);
          group.appendChild(fo);
          this.updateTextNodes(x, y, w2, h2, align, valign, wrap, overflow, clip2, rotation, group);
          if (this.root.ownerDocument != document) {
            var alt = this.createAlternateContent(fo, x, y, w2, h2, str, align, valign, wrap, format, overflow, clip2, rotation);
            if (alt != null) {
              fo.setAttribute("requiredFeatures", "http://www.w3.org/TR/SVG11/feature#Extensibility");
              var sw = this.createElement("switch");
              sw.appendChild(fo);
              sw.appendChild(alt);
              group.appendChild(sw);
            }
          }
          root.appendChild(group);
        };
        mxSvgCanvas2D.prototype.updateTextNodes = function(x, y, w2, h2, align, valign, wrap, overflow, clip2, rotation, g) {
          var s = this.state.scale;
          mxSvgCanvas2D.createCss(
            w2 + 2,
            h2,
            align,
            valign,
            wrap,
            overflow,
            clip2,
            this.state.fontBackgroundColor != null ? this.state.fontBackgroundColor : null,
            this.state.fontBorderColor != null ? this.state.fontBorderColor : null,
            "display: flex; align-items: unsafe " + (valign == mxConstants.ALIGN_TOP ? "flex-start" : valign == mxConstants.ALIGN_BOTTOM ? "flex-end" : "center") + "; justify-content: unsafe " + (align == mxConstants.ALIGN_LEFT ? "flex-start" : align == mxConstants.ALIGN_RIGHT ? "flex-end" : "center") + "; ",
            this.getTextCss(),
            s,
            mxUtils.bind(this, function(dx, dy, flex, item, block) {
              x += this.state.dx;
              y += this.state.dy;
              var fo = g.firstChild;
              var div = fo.firstChild;
              var box = div.firstChild;
              var text = box.firstChild;
              var r = (this.rotateHtml ? this.state.rotation : 0) + (rotation != null ? rotation : 0);
              var t = (this.foOffset != 0 ? "translate(" + this.foOffset + " " + this.foOffset + ")" : "") + (s != 1 ? "scale(" + s + ")" : "");
              text.setAttribute("style", block);
              box.setAttribute("style", item);
              fo.setAttribute("width", Math.ceil(1 / Math.min(1, s) * 100) + "%");
              fo.setAttribute("height", Math.ceil(1 / Math.min(1, s) * 100) + "%");
              var yp = Math.round(y + dy);
              if (yp < 0) {
                fo.setAttribute("y", yp);
              } else {
                fo.removeAttribute("y");
                flex += "padding-top: " + yp + "px; ";
              }
              div.setAttribute("style", flex + "margin-left: " + Math.round(x + dx) + "px;");
              t += r != 0 ? "rotate(" + r + " " + x + " " + y + ")" : "";
              if (t != "") {
                g.setAttribute("transform", t);
              } else {
                g.removeAttribute("transform");
              }
              if (this.state.alpha != 1) {
                g.setAttribute("opacity", this.state.alpha);
              } else {
                g.removeAttribute("opacity");
              }
            })
          );
        };
        mxSvgCanvas2D.createCss = function(w2, h2, align, valign, wrap, overflow, clip2, bg, border, flex, block, s, callback) {
          var item = "box-sizing: border-box; font-size: 0; text-align: " + (align == mxConstants.ALIGN_LEFT ? "left" : align == mxConstants.ALIGN_RIGHT ? "right" : "center") + "; ";
          var pt = mxUtils.getAlignmentAsPoint(align, valign);
          var ofl = "overflow: hidden; ";
          var fw = "width: 1px; ";
          var fh = "height: 1px; ";
          var dx = pt.x * w2;
          var dy = pt.y * h2;
          if (clip2) {
            fw = "width: " + Math.round(w2) + "px; ";
            item += "max-height: " + Math.round(h2) + "px; ";
            dy = 0;
          } else if (overflow == "fill") {
            fw = "width: " + Math.round(w2) + "px; ";
            fh = "height: " + Math.round(h2) + "px; ";
            block += "width: 100%; height: 100%; ";
            item += fw + fh;
          } else if (overflow == "width") {
            fw = "width: " + Math.round(w2) + "px; ";
            block += "width: 100%; ";
            item += fw;
            dy = 0;
            if (h2 > 0) {
              item += "max-height: " + Math.round(h2) + "px; ";
            }
          } else {
            ofl = "";
            dy = 0;
          }
          var bgc = "";
          if (bg != null) {
            bgc += "background-color: " + bg + "; ";
          }
          if (border != null) {
            bgc += "border: 1px solid " + border + "; ";
          }
          if (ofl == "" || clip2) {
            block += bgc;
          } else {
            item += bgc;
          }
          if (wrap && w2 > 0) {
            block += "white-space: normal; word-wrap: " + mxConstants.WORD_WRAP + "; ";
            fw = "width: " + Math.round(w2) + "px; ";
            if (ofl != "" && overflow != "fill") {
              dy = 0;
            }
          } else {
            block += "white-space: nowrap; ";
            if (ofl == "") {
              dx = 0;
            }
          }
          callback(dx, dy, flex + fw + fh, item + ofl, block, ofl);
        };
        mxSvgCanvas2D.prototype.getTextCss = function() {
          var s = this.state;
          var lh = mxConstants.ABSOLUTE_LINE_HEIGHT ? s.fontSize * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT * this.lineHeightCorrection;
          var css = "display: inline-block; font-size: " + s.fontSize + "px; font-family: " + s.fontFamily + "; color: " + s.fontColor + "; line-height: " + lh + "; pointer-events: " + (this.pointerEvents ? this.pointerEventsValue : "none") + "; ";
          if ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
            css += "font-weight: bold; ";
          }
          if ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
            css += "font-style: italic; ";
          }
          var deco = [];
          if ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
            deco.push("underline");
          }
          if ((s.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
            deco.push("line-through");
          }
          if (deco.length > 0) {
            css += "text-decoration: " + deco.join(" ") + "; ";
          }
          return css;
        };
        mxSvgCanvas2D.prototype.text = function(x, y, w2, h2, str, align, valign, wrap, format, overflow, clip2, rotation, dir) {
          if (this.textEnabled && str != null) {
            rotation = rotation != null ? rotation : 0;
            if (this.foEnabled && format == "html") {
              var div = this.createDiv(str);
              if (div != null) {
                if (dir != null) {
                  div.setAttribute("dir", dir);
                }
                this.addForeignObject(
                  x,
                  y,
                  w2,
                  h2,
                  str,
                  align,
                  valign,
                  wrap,
                  format,
                  overflow,
                  clip2,
                  rotation,
                  dir,
                  div,
                  this.root
                );
              }
            } else {
              this.plainText(
                x + this.state.dx,
                y + this.state.dy,
                w2,
                h2,
                str,
                align,
                valign,
                wrap,
                overflow,
                clip2,
                rotation,
                dir
              );
            }
          }
        };
        mxSvgCanvas2D.prototype.createClip = function(x, y, w2, h2) {
          x = Math.round(x);
          y = Math.round(y);
          w2 = Math.round(w2);
          h2 = Math.round(h2);
          var id = "mx-clip-" + x + "-" + y + "-" + w2 + "-" + h2;
          var counter = 0;
          var tmp = id + "-" + counter;
          while (document.getElementById(tmp) != null) {
            tmp = id + "-" + ++counter;
          }
          clip = this.createElement("clipPath");
          clip.setAttribute("id", tmp);
          var rect = this.createElement("rect");
          rect.setAttribute("x", x);
          rect.setAttribute("y", y);
          rect.setAttribute("width", w2);
          rect.setAttribute("height", h2);
          clip.appendChild(rect);
          return clip;
        };
        mxSvgCanvas2D.prototype.plainText = function(x, y, w2, h2, str, align, valign, wrap, overflow, clip2, rotation, dir) {
          rotation = rotation != null ? rotation : 0;
          var s = this.state;
          var size = s.fontSize;
          var node = this.createElement("g");
          var tr = s.transform || "";
          this.updateFont(node);
          if (!this.pointerEvents && this.originalRoot == null) {
            node.setAttribute("pointer-events", "none");
          }
          if (rotation != 0) {
            tr += "rotate(" + rotation + "," + this.format(x * s.scale) + "," + this.format(y * s.scale) + ")";
          }
          if (dir != null) {
            node.setAttribute("direction", dir);
          }
          if (clip2 && w2 > 0 && h2 > 0) {
            var cx = x;
            var cy = y;
            if (align == mxConstants.ALIGN_CENTER) {
              cx -= w2 / 2;
            } else if (align == mxConstants.ALIGN_RIGHT) {
              cx -= w2;
            }
            if (overflow != "fill") {
              if (valign == mxConstants.ALIGN_MIDDLE) {
                cy -= h2 / 2;
              } else if (valign == mxConstants.ALIGN_BOTTOM) {
                cy -= h2;
              }
            }
            var c = this.createClip(cx * s.scale - 2, cy * s.scale - 2, w2 * s.scale + 4, h2 * s.scale + 4);
            if (this.defs != null) {
              this.defs.appendChild(c);
            } else {
              this.root.appendChild(c);
            }
            if (!mxClient.IS_CHROMEAPP && !mxClient.IS_IE && !mxClient.IS_IE11 && !mxClient.IS_EDGE && this.root.ownerDocument == document) {
              var base = this.getBaseUrl().replace(/([\(\)])/g, "\\$1");
              node.setAttribute("clip-path", "url(" + base + "#" + c.getAttribute("id") + ")");
            } else {
              node.setAttribute("clip-path", "url(#" + c.getAttribute("id") + ")");
            }
          }
          var anchor = align == mxConstants.ALIGN_RIGHT ? "end" : align == mxConstants.ALIGN_CENTER ? "middle" : "start";
          if (anchor != "start") {
            node.setAttribute("text-anchor", anchor);
          }
          if (!this.styleEnabled || size != mxConstants.DEFAULT_FONTSIZE) {
            node.setAttribute("font-size", size * s.scale + "px");
          }
          if (tr.length > 0) {
            node.setAttribute("transform", tr);
          }
          if (s.alpha < 1) {
            node.setAttribute("opacity", s.alpha);
          }
          var lines = str.split("\n");
          var lh = Math.round(size * mxConstants.LINE_HEIGHT);
          var textHeight = size + (lines.length - 1) * lh;
          var cy = y + size - 1;
          if (valign == mxConstants.ALIGN_MIDDLE) {
            if (overflow == "fill") {
              cy -= h2 / 2;
            } else {
              var dy = (this.matchHtmlAlignment && clip2 && h2 > 0 ? Math.min(textHeight, h2) : textHeight) / 2;
              cy -= dy;
            }
          } else if (valign == mxConstants.ALIGN_BOTTOM) {
            if (overflow == "fill") {
              cy -= h2;
            } else {
              var dy = this.matchHtmlAlignment && clip2 && h2 > 0 ? Math.min(textHeight, h2) : textHeight;
              cy -= dy + 1;
            }
          }
          for (var i = 0; i < lines.length; i++) {
            if (lines[i].length > 0 && mxUtils.trim(lines[i]).length > 0) {
              var text = this.createElement("text");
              text.setAttribute("x", this.format(x * s.scale) + this.textOffset);
              text.setAttribute("y", this.format(cy * s.scale) + this.textOffset);
              mxUtils.write(text, lines[i]);
              node.appendChild(text);
            }
            cy += lh;
          }
          this.root.appendChild(node);
          this.addTextBackground(node, str, x, y, w2, overflow == "fill" ? h2 : textHeight, align, valign, overflow);
        };
        mxSvgCanvas2D.prototype.updateFont = function(node) {
          var s = this.state;
          node.setAttribute("fill", s.fontColor);
          if (!this.styleEnabled || s.fontFamily != mxConstants.DEFAULT_FONTFAMILY) {
            node.setAttribute("font-family", s.fontFamily);
          }
          if ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
            node.setAttribute("font-weight", "bold");
          }
          if ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
            node.setAttribute("font-style", "italic");
          }
          var txtDecor = [];
          if ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
            txtDecor.push("underline");
          }
          if ((s.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
            txtDecor.push("line-through");
          }
          if (txtDecor.length > 0) {
            node.setAttribute("text-decoration", txtDecor.join(" "));
          }
        };
        mxSvgCanvas2D.prototype.addTextBackground = function(node, str, x, y, w2, h2, align, valign, overflow) {
          var s = this.state;
          if (s.fontBackgroundColor != null || s.fontBorderColor != null) {
            var bbox = null;
            if (overflow == "fill" || overflow == "width") {
              if (align == mxConstants.ALIGN_CENTER) {
                x -= w2 / 2;
              } else if (align == mxConstants.ALIGN_RIGHT) {
                x -= w2;
              }
              if (valign == mxConstants.ALIGN_MIDDLE) {
                y -= h2 / 2;
              } else if (valign == mxConstants.ALIGN_BOTTOM) {
                y -= h2;
              }
              bbox = new mxRectangle((x + 1) * s.scale, y * s.scale, (w2 - 2) * s.scale, (h2 + 2) * s.scale);
            } else if (node.getBBox != null && this.root.ownerDocument == document) {
              try {
                bbox = node.getBBox();
                var ie = mxClient.IS_IE && mxClient.IS_SVG;
                bbox = new mxRectangle(bbox.x, bbox.y + (ie ? 0 : 1), bbox.width, bbox.height + (ie ? 1 : 0));
              } catch (e) {
              }
            }
            if (bbox == null || bbox.width == 0 || bbox.height == 0) {
              var div = document.createElement("div");
              div.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? s.fontSize * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT;
              div.style.fontSize = s.fontSize + "px";
              div.style.fontFamily = s.fontFamily;
              div.style.whiteSpace = "nowrap";
              div.style.position = "absolute";
              div.style.visibility = "hidden";
              div.style.display = mxClient.IS_QUIRKS ? "inline" : "inline-block";
              div.style.zoom = "1";
              if ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
                div.style.fontWeight = "bold";
              }
              if ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
                div.style.fontStyle = "italic";
              }
              str = mxUtils.htmlEntities(str, false);
              div.innerHTML = str.replace(/\n/g, "<br/>");
              document.body.appendChild(div);
              var w2 = div.offsetWidth;
              var h2 = div.offsetHeight;
              div.parentNode.removeChild(div);
              if (align == mxConstants.ALIGN_CENTER) {
                x -= w2 / 2;
              } else if (align == mxConstants.ALIGN_RIGHT) {
                x -= w2;
              }
              if (valign == mxConstants.ALIGN_MIDDLE) {
                y -= h2 / 2;
              } else if (valign == mxConstants.ALIGN_BOTTOM) {
                y -= h2;
              }
              bbox = new mxRectangle((x + 1) * s.scale, (y + 2) * s.scale, w2 * s.scale, (h2 + 1) * s.scale);
            }
            if (bbox != null) {
              var n = this.createElement("rect");
              n.setAttribute("fill", s.fontBackgroundColor || "none");
              n.setAttribute("stroke", s.fontBorderColor || "none");
              n.setAttribute("x", Math.floor(bbox.x - 1));
              n.setAttribute("y", Math.floor(bbox.y - 1));
              n.setAttribute("width", Math.ceil(bbox.width + 2));
              n.setAttribute("height", Math.ceil(bbox.height));
              var sw = s.fontBorderColor != null ? Math.max(1, this.format(s.scale)) : 0;
              n.setAttribute("stroke-width", sw);
              if (this.root.ownerDocument == document && mxUtils.mod(sw, 2) == 1) {
                n.setAttribute("transform", "translate(0.5, 0.5)");
              }
              node.insertBefore(n, node.firstChild);
            }
          }
        };
        mxSvgCanvas2D.prototype.stroke = function() {
          this.addNode(false, true);
        };
        mxSvgCanvas2D.prototype.fill = function() {
          this.addNode(true, false);
        };
        mxSvgCanvas2D.prototype.fillAndStroke = function() {
          this.addNode(true, true);
        };
        __mxOutput.mxSvgCanvas2D = typeof mxSvgCanvas2D !== "undefined" ? mxSvgCanvas2D : void 0;
        var mxVmlCanvas2D = function(root) {
          mxAbstractCanvas2D.call(this);
          this.root = root;
        };
        mxUtils.extend(mxVmlCanvas2D, mxAbstractCanvas2D);
        mxVmlCanvas2D.prototype.node = null;
        mxVmlCanvas2D.prototype.textEnabled = true;
        mxVmlCanvas2D.prototype.moveOp = "m";
        mxVmlCanvas2D.prototype.lineOp = "l";
        mxVmlCanvas2D.prototype.curveOp = "c";
        mxVmlCanvas2D.prototype.closeOp = "x";
        mxVmlCanvas2D.prototype.rotatedHtmlBackground = "";
        mxVmlCanvas2D.prototype.vmlScale = 1;
        mxVmlCanvas2D.prototype.createElement = function(name2) {
          return document.createElement(name2);
        };
        mxVmlCanvas2D.prototype.createVmlElement = function(name2) {
          return this.createElement(mxClient.VML_PREFIX + ":" + name2);
        };
        mxVmlCanvas2D.prototype.addNode = function(filled, stroked) {
          var node = this.node;
          var s = this.state;
          if (node != null) {
            if (node.nodeName == "shape") {
              if (this.path != null && this.path.length > 0) {
                node.path = this.path.join(" ") + " e";
                node.style.width = this.root.style.width;
                node.style.height = this.root.style.height;
                node.coordsize = parseInt(node.style.width) + " " + parseInt(node.style.height);
              } else {
                return;
              }
            }
            node.strokeweight = this.format(Math.max(1, s.strokeWidth * s.scale / this.vmlScale)) + "px";
            if (s.shadow) {
              this.root.appendChild(this.createShadow(
                node,
                filled && s.fillColor != null,
                stroked && s.strokeColor != null
              ));
            }
            if (stroked && s.strokeColor != null) {
              node.stroked = "true";
              node.strokecolor = s.strokeColor;
            } else {
              node.stroked = "false";
            }
            node.appendChild(this.createStroke());
            if (filled && s.fillColor != null) {
              node.appendChild(this.createFill());
            } else if (this.pointerEvents && (node.nodeName != "shape" || this.path[this.path.length - 1] == this.closeOp)) {
              node.appendChild(this.createTransparentFill());
            } else {
              node.filled = "false";
            }
            this.root.appendChild(node);
          }
        };
        mxVmlCanvas2D.prototype.createTransparentFill = function() {
          var fill = this.createVmlElement("fill");
          fill.src = mxClient.imageBasePath + "/transparent.gif";
          fill.type = "tile";
          return fill;
        };
        mxVmlCanvas2D.prototype.createFill = function() {
          var s = this.state;
          var fill = this.createVmlElement("fill");
          fill.color = s.fillColor;
          if (s.gradientColor != null) {
            fill.type = "gradient";
            fill.method = "none";
            fill.color2 = s.gradientColor;
            var angle = 180 - s.rotation;
            if (s.gradientDirection == mxConstants.DIRECTION_WEST) {
              angle -= 90 + (this.root.style.flip == "x" ? 180 : 0);
            } else if (s.gradientDirection == mxConstants.DIRECTION_EAST) {
              angle += 90 + (this.root.style.flip == "x" ? 180 : 0);
            } else if (s.gradientDirection == mxConstants.DIRECTION_NORTH) {
              angle -= 180 + (this.root.style.flip == "y" ? -180 : 0);
            } else {
              angle += this.root.style.flip == "y" ? -180 : 0;
            }
            if (this.root.style.flip == "x" || this.root.style.flip == "y") {
              angle *= -1;
            }
            fill.angle = mxUtils.mod(angle, 360);
            fill.opacity = s.alpha * s.gradientFillAlpha * 100 + "%";
            fill.setAttribute(mxClient.OFFICE_PREFIX + ":opacity2", s.alpha * s.gradientAlpha * 100 + "%");
          } else if (s.alpha < 1 || s.fillAlpha < 1) {
            fill.opacity = s.alpha * s.fillAlpha * 100 + "%";
          }
          return fill;
        };
        mxVmlCanvas2D.prototype.createStroke = function() {
          var s = this.state;
          var stroke = this.createVmlElement("stroke");
          stroke.endcap = s.lineCap || "flat";
          stroke.joinstyle = s.lineJoin || "miter";
          stroke.miterlimit = s.miterLimit || "10";
          if (s.alpha < 1 || s.strokeAlpha < 1) {
            stroke.opacity = s.alpha * s.strokeAlpha * 100 + "%";
          }
          if (s.dashed) {
            stroke.dashstyle = this.getVmlDashStyle();
          }
          return stroke;
        };
        mxVmlCanvas2D.prototype.getVmlDashStyle = function() {
          var result2 = "dash";
          if (typeof this.state.dashPattern === "string") {
            var tok = this.state.dashPattern.split(" ");
            if (tok.length > 0 && tok[0] == 1) {
              result2 = "0 2";
            }
          }
          return result2;
        };
        mxVmlCanvas2D.prototype.createShadow = function(node, filled, stroked) {
          var s = this.state;
          var rad = -s.rotation * (Math.PI / 180);
          var cos = Math.cos(rad);
          var sin = Math.sin(rad);
          var dx = s.shadowDx * s.scale;
          var dy = s.shadowDy * s.scale;
          if (this.root.style.flip == "x") {
            dx *= -1;
          } else if (this.root.style.flip == "y") {
            dy *= -1;
          }
          var shadow = node.cloneNode(true);
          shadow.style.marginLeft = Math.round(dx * cos - dy * sin) + "px";
          shadow.style.marginTop = Math.round(dx * sin + dy * cos) + "px";
          if (document.documentMode == 8) {
            shadow.strokeweight = node.strokeweight;
            if (node.nodeName == "shape") {
              shadow.path = this.path.join(" ") + " e";
              shadow.style.width = this.root.style.width;
              shadow.style.height = this.root.style.height;
              shadow.coordsize = parseInt(node.style.width) + " " + parseInt(node.style.height);
            }
          }
          if (stroked) {
            shadow.strokecolor = s.shadowColor;
            shadow.appendChild(this.createShadowStroke());
          } else {
            shadow.stroked = "false";
          }
          if (filled) {
            shadow.appendChild(this.createShadowFill());
          } else {
            shadow.filled = "false";
          }
          return shadow;
        };
        mxVmlCanvas2D.prototype.createShadowFill = function() {
          var fill = this.createVmlElement("fill");
          fill.color = this.state.shadowColor;
          fill.opacity = this.state.alpha * this.state.shadowAlpha * 100 + "%";
          return fill;
        };
        mxVmlCanvas2D.prototype.createShadowStroke = function() {
          var stroke = this.createStroke();
          stroke.opacity = this.state.alpha * this.state.shadowAlpha * 100 + "%";
          return stroke;
        };
        mxVmlCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy) {
          if (flipH && flipV) {
            theta += 180;
          } else if (flipH) {
            this.root.style.flip = "x";
          } else if (flipV) {
            this.root.style.flip = "y";
          }
          if (flipH ? !flipV : flipV) {
            theta *= -1;
          }
          this.root.style.rotation = theta;
          this.state.rotation = this.state.rotation + theta;
          this.state.rotationCx = cx;
          this.state.rotationCy = cy;
        };
        mxVmlCanvas2D.prototype.begin = function() {
          mxAbstractCanvas2D.prototype.begin.apply(this, arguments);
          this.node = this.createVmlElement("shape");
          this.node.style.position = "absolute";
        };
        mxVmlCanvas2D.prototype.quadTo = function(x1, y1, x2, y2) {
          var s = this.state;
          var cpx0 = (this.lastX + s.dx) * s.scale;
          var cpy0 = (this.lastY + s.dy) * s.scale;
          var qpx1 = (x1 + s.dx) * s.scale;
          var qpy1 = (y1 + s.dy) * s.scale;
          var cpx3 = (x2 + s.dx) * s.scale;
          var cpy3 = (y2 + s.dy) * s.scale;
          var cpx1 = cpx0 + 2 / 3 * (qpx1 - cpx0);
          var cpy1 = cpy0 + 2 / 3 * (qpy1 - cpy0);
          var cpx2 = cpx3 + 2 / 3 * (qpx1 - cpx3);
          var cpy2 = cpy3 + 2 / 3 * (qpy1 - cpy3);
          this.path.push("c " + this.format(cpx1) + " " + this.format(cpy1) + " " + this.format(cpx2) + " " + this.format(cpy2) + " " + this.format(cpx3) + " " + this.format(cpy3));
          this.lastX = cpx3 / s.scale - s.dx;
          this.lastY = cpy3 / s.scale - s.dy;
        };
        mxVmlCanvas2D.prototype.createRect = function(nodeName, x, y, w2, h2) {
          var s = this.state;
          var n = this.createVmlElement(nodeName);
          n.style.position = "absolute";
          n.style.left = this.format((x + s.dx) * s.scale) + "px";
          n.style.top = this.format((y + s.dy) * s.scale) + "px";
          n.style.width = this.format(w2 * s.scale) + "px";
          n.style.height = this.format(h2 * s.scale) + "px";
          return n;
        };
        mxVmlCanvas2D.prototype.rect = function(x, y, w2, h2) {
          this.node = this.createRect("rect", x, y, w2, h2);
        };
        mxVmlCanvas2D.prototype.roundrect = function(x, y, w2, h2, dx, dy) {
          this.node = this.createRect("roundrect", x, y, w2, h2);
          this.node.setAttribute("arcsize", Math.max(dx * 100 / w2, dy * 100 / h2) + "%");
        };
        mxVmlCanvas2D.prototype.ellipse = function(x, y, w2, h2) {
          this.node = this.createRect("oval", x, y, w2, h2);
        };
        mxVmlCanvas2D.prototype.image = function(x, y, w2, h2, src, aspect, flipH, flipV) {
          var node = null;
          if (!aspect) {
            node = this.createRect("image", x, y, w2, h2);
            node.src = src;
          } else {
            node = this.createRect("rect", x, y, w2, h2);
            node.stroked = "false";
            var fill = this.createVmlElement("fill");
            fill.aspect = aspect ? "atmost" : "ignore";
            fill.rotate = "true";
            fill.type = "frame";
            fill.src = src;
            node.appendChild(fill);
          }
          if (flipH && flipV) {
            node.style.rotation = "180";
          } else if (flipH) {
            node.style.flip = "x";
          } else if (flipV) {
            node.style.flip = "y";
          }
          if (this.state.alpha < 1 || this.state.fillAlpha < 1) {
            node.style.filter += "alpha(opacity=" + this.state.alpha * this.state.fillAlpha * 100 + ")";
          }
          this.root.appendChild(node);
        };
        mxVmlCanvas2D.prototype.createDiv = function(str, align, valign, overflow) {
          var div = this.createElement("div");
          var state = this.state;
          var css = "";
          if (state.fontBackgroundColor != null) {
            css += "background-color:" + mxUtils.htmlEntities(state.fontBackgroundColor) + ";";
          }
          if (state.fontBorderColor != null) {
            css += "border:1px solid " + mxUtils.htmlEntities(state.fontBorderColor) + ";";
          }
          if (mxUtils.isNode(str)) {
            div.appendChild(str);
          } else {
            if (overflow != "fill" && overflow != "width") {
              var div2 = this.createElement("div");
              div2.style.cssText = css;
              div2.style.display = mxClient.IS_QUIRKS ? "inline" : "inline-block";
              div2.style.zoom = "1";
              div2.style.textDecoration = "inherit";
              div2.innerHTML = str;
              div.appendChild(div2);
            } else {
              div.style.cssText = css;
              div.innerHTML = str;
            }
          }
          var style = div.style;
          style.fontSize = state.fontSize / this.vmlScale + "px";
          style.fontFamily = state.fontFamily;
          style.color = state.fontColor;
          style.verticalAlign = "top";
          style.textAlign = align || "left";
          style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? state.fontSize * mxConstants.LINE_HEIGHT / this.vmlScale + "px" : mxConstants.LINE_HEIGHT;
          if ((state.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
            style.fontWeight = "bold";
          }
          if ((state.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
            style.fontStyle = "italic";
          }
          if ((state.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
            style.textDecoration = "underline";
          }
          return div;
        };
        mxVmlCanvas2D.prototype.text = function(x, y, w2, h2, str, align, valign, wrap, format, overflow, clip2, rotation, dir) {
          if (this.textEnabled && str != null) {
            var s = this.state;
            if (format == "html") {
              if (s.rotation != null) {
                var pt = this.rotatePoint(x, y, s.rotation, s.rotationCx, s.rotationCy);
                x = pt.x;
                y = pt.y;
              }
              if (document.documentMode == 8 && !mxClient.IS_EM) {
                x += s.dx;
                y += s.dy;
                if (overflow != "fill" && valign == mxConstants.ALIGN_TOP) {
                  y -= 1;
                }
              } else {
                x *= s.scale;
                y *= s.scale;
              }
              var abs = document.documentMode == 8 && !mxClient.IS_EM ? this.createVmlElement("group") : this.createElement("div");
              abs.style.position = "absolute";
              abs.style.display = "inline";
              abs.style.left = this.format(x) + "px";
              abs.style.top = this.format(y) + "px";
              abs.style.zoom = s.scale;
              var box = this.createElement("div");
              box.style.position = "relative";
              box.style.display = "inline";
              var margin = mxUtils.getAlignmentAsPoint(align, valign);
              var dx = margin.x;
              var dy = margin.y;
              var div = this.createDiv(str, align, valign, overflow);
              var inner = this.createElement("div");
              if (dir != null) {
                div.setAttribute("dir", dir);
              }
              if (wrap && w2 > 0) {
                if (!clip2) {
                  div.style.width = Math.round(w2) + "px";
                }
                div.style.wordWrap = mxConstants.WORD_WRAP;
                div.style.whiteSpace = "normal";
                if (div.style.wordWrap == "break-word") {
                  var tmp = div;
                  if (tmp.firstChild != null && tmp.firstChild.nodeName == "DIV") {
                    tmp.firstChild.style.width = "100%";
                  }
                }
              } else {
                div.style.whiteSpace = "nowrap";
              }
              var rot = s.rotation + (rotation || 0);
              if (this.rotateHtml && rot != 0) {
                inner.style.display = "inline";
                inner.style.zoom = "1";
                inner.appendChild(div);
                if (document.documentMode == 8 && !mxClient.IS_EM && this.root.nodeName != "DIV") {
                  box.appendChild(inner);
                  abs.appendChild(box);
                } else {
                  abs.appendChild(inner);
                }
              } else if (document.documentMode == 8 && !mxClient.IS_EM) {
                box.appendChild(div);
                abs.appendChild(box);
              } else {
                div.style.display = "inline";
                abs.appendChild(div);
              }
              if (this.root.nodeName != "DIV") {
                var rect = this.createVmlElement("rect");
                rect.stroked = "false";
                rect.filled = "false";
                rect.appendChild(abs);
                this.root.appendChild(rect);
              } else {
                this.root.appendChild(abs);
              }
              if (clip2) {
                div.style.overflow = "hidden";
                div.style.width = Math.round(w2) + "px";
                if (!mxClient.IS_QUIRKS) {
                  div.style.maxHeight = Math.round(h2) + "px";
                }
              } else if (overflow == "fill") {
                div.style.overflow = "hidden";
                div.style.width = Math.max(0, w2) + 1 + "px";
                div.style.height = Math.max(0, h2) + 1 + "px";
              } else if (overflow == "width") {
                div.style.overflow = "hidden";
                div.style.width = Math.max(0, w2) + 1 + "px";
                div.style.maxHeight = Math.max(0, h2) + 1 + "px";
              }
              if (this.rotateHtml && rot != 0) {
                var rad = rot * (Math.PI / 180);
                var real_cos = parseFloat(parseFloat(Math.cos(rad)).toFixed(8));
                var real_sin = parseFloat(parseFloat(Math.sin(-rad)).toFixed(8));
                rad %= 2 * Math.PI;
                if (rad < 0) rad += 2 * Math.PI;
                rad %= Math.PI;
                if (rad > Math.PI / 2) rad = Math.PI - rad;
                var cos = Math.cos(rad);
                var sin = Math.sin(rad);
                if (document.documentMode == 8 && !mxClient.IS_EM) {
                  div.style.display = "inline-block";
                  inner.style.display = "inline-block";
                  box.style.display = "inline-block";
                }
                div.style.visibility = "hidden";
                div.style.position = "absolute";
                document.body.appendChild(div);
                var sizeDiv = div;
                if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == "DIV") {
                  sizeDiv = sizeDiv.firstChild;
                }
                var tmp = sizeDiv.offsetWidth + 3;
                var oh = sizeDiv.offsetHeight;
                if (clip2) {
                  w2 = Math.min(w2, tmp);
                  oh = Math.min(oh, h2);
                } else {
                  w2 = tmp;
                }
                if (wrap) {
                  div.style.width = w2 + "px";
                }
                if (mxClient.IS_QUIRKS && (clip2 || overflow == "width") && oh > h2) {
                  oh = h2;
                  div.style.height = oh + "px";
                }
                h2 = oh;
                var top_fix = (h2 - h2 * cos + w2 * -sin) / 2 - real_sin * w2 * (dx + 0.5) + real_cos * h2 * (dy + 0.5);
                var left_fix = (w2 - w2 * cos + h2 * -sin) / 2 + real_cos * w2 * (dx + 0.5) + real_sin * h2 * (dy + 0.5);
                if (abs.nodeName == "group" && this.root.nodeName == "DIV") {
                  var pos = this.createElement("div");
                  pos.style.display = "inline-block";
                  pos.style.position = "absolute";
                  pos.style.left = this.format(x + (left_fix - w2 / 2) * s.scale) + "px";
                  pos.style.top = this.format(y + (top_fix - h2 / 2) * s.scale) + "px";
                  abs.parentNode.appendChild(pos);
                  pos.appendChild(abs);
                } else {
                  var sc = document.documentMode == 8 && !mxClient.IS_EM ? 1 : s.scale;
                  abs.style.left = this.format(x + (left_fix - w2 / 2) * sc) + "px";
                  abs.style.top = this.format(y + (top_fix - h2 / 2) * sc) + "px";
                }
                inner.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11=" + real_cos + ", M12=" + real_sin + ", M21=" + -real_sin + ", M22=" + real_cos + ", sizingMethod='auto expand')";
                inner.style.backgroundColor = this.rotatedHtmlBackground;
                if (this.state.alpha < 1) {
                  inner.style.filter += "alpha(opacity=" + this.state.alpha * 100 + ")";
                }
                inner.appendChild(div);
                div.style.position = "";
                div.style.visibility = "";
              } else if (document.documentMode != 8 || mxClient.IS_EM) {
                div.style.verticalAlign = "top";
                if (this.state.alpha < 1) {
                  abs.style.filter = "alpha(opacity=" + this.state.alpha * 100 + ")";
                }
                var divParent = div.parentNode;
                div.style.visibility = "hidden";
                document.body.appendChild(div);
                w2 = div.offsetWidth;
                var oh = div.offsetHeight;
                if (mxClient.IS_QUIRKS && clip2 && oh > h2) {
                  oh = h2;
                  div.style.height = oh + "px";
                }
                h2 = oh;
                div.style.visibility = "";
                divParent.appendChild(div);
                abs.style.left = this.format(x + w2 * dx * this.state.scale) + "px";
                abs.style.top = this.format(y + h2 * dy * this.state.scale) + "px";
              } else {
                if (this.state.alpha < 1) {
                  div.style.filter = "alpha(opacity=" + this.state.alpha * 100 + ")";
                }
                box.style.left = dx * 100 + "%";
                box.style.top = dy * 100 + "%";
              }
            } else {
              this.plainText(x, y, w2, h2, mxUtils.htmlEntities(str, false), align, valign, wrap, format, overflow, clip2, rotation, dir);
            }
          }
        };
        mxVmlCanvas2D.prototype.plainText = function(x, y, w2, h2, str, align, valign, wrap, format, overflow, clip2, rotation, dir) {
          var s = this.state;
          x = (x + s.dx) * s.scale;
          y = (y + s.dy) * s.scale;
          var node = this.createVmlElement("shape");
          node.style.width = "1px";
          node.style.height = "1px";
          node.stroked = "false";
          var fill = this.createVmlElement("fill");
          fill.color = s.fontColor;
          fill.opacity = s.alpha * 100 + "%";
          node.appendChild(fill);
          var path = this.createVmlElement("path");
          path.textpathok = "true";
          path.v = "m " + this.format(0) + " " + this.format(0) + " l " + this.format(1) + " " + this.format(0);
          node.appendChild(path);
          var tp = this.createVmlElement("textpath");
          tp.style.cssText = "v-text-align:" + align;
          tp.style.align = align;
          tp.style.fontFamily = s.fontFamily;
          tp.string = str;
          tp.on = "true";
          var size = s.fontSize * s.scale / this.vmlScale;
          tp.style.fontSize = size + "px";
          if ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
            tp.style.fontWeight = "bold";
          }
          if ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
            tp.style.fontStyle = "italic";
          }
          if ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
            tp.style.textDecoration = "underline";
          }
          var lines = str.split("\n");
          var textHeight = size + (lines.length - 1) * size * mxConstants.LINE_HEIGHT;
          var dx = 0;
          var dy = 0;
          if (valign == mxConstants.ALIGN_BOTTOM) {
            dy = -textHeight / 2;
          } else if (valign != mxConstants.ALIGN_MIDDLE) {
            dy = textHeight / 2;
          }
          if (rotation != null) {
            node.style.rotation = rotation;
            var rad = rotation * (Math.PI / 180);
            dx = Math.sin(rad) * dy;
            dy = Math.cos(rad) * dy;
          }
          node.appendChild(tp);
          node.style.left = this.format(x - dx) + "px";
          node.style.top = this.format(y + dy) + "px";
          this.root.appendChild(node);
        };
        mxVmlCanvas2D.prototype.stroke = function() {
          this.addNode(false, true);
        };
        mxVmlCanvas2D.prototype.fill = function() {
          this.addNode(true, false);
        };
        mxVmlCanvas2D.prototype.fillAndStroke = function() {
          this.addNode(true, true);
        };
        __mxOutput.mxVmlCanvas2D = typeof mxVmlCanvas2D !== "undefined" ? mxVmlCanvas2D : void 0;
        function mxGuide(graph, states) {
          this.graph = graph;
          this.setStates(states);
        }
        ;
        mxGuide.prototype.graph = null;
        mxGuide.prototype.states = null;
        mxGuide.prototype.horizontal = true;
        mxGuide.prototype.vertical = true;
        mxGuide.prototype.guideX = null;
        mxGuide.prototype.guideY = null;
        mxGuide.prototype.rounded = false;
        mxGuide.prototype.tolerance = 2;
        mxGuide.prototype.setStates = function(states) {
          this.states = states;
        };
        mxGuide.prototype.isEnabledForEvent = function(evt) {
          return true;
        };
        mxGuide.prototype.getGuideTolerance = function(gridEnabled) {
          return gridEnabled && this.graph.gridEnabled ? this.graph.gridSize / 2 : this.tolerance;
        };
        mxGuide.prototype.createGuideShape = function(horizontal) {
          var guide = new mxPolyline([], mxConstants.GUIDE_COLOR, mxConstants.GUIDE_STROKEWIDTH);
          guide.isDashed = true;
          return guide;
        };
        mxGuide.prototype.isStateIgnored = function(state) {
          return false;
        };
        mxGuide.prototype.move = function(bounds, delta, gridEnabled, clone) {
          if (this.states != null && (this.horizontal || this.vertical) && bounds != null && delta != null) {
            let snapX2 = function(x, state2, centerAlign) {
              var override = false;
              if (centerAlign && Math.abs(x - center) < ttX) {
                delta.x = x - bounds.getCenterX();
                ttX = Math.abs(x - center);
                override = true;
              } else if (!centerAlign) {
                if (Math.abs(x - left) < ttX) {
                  delta.x = x - bounds.x;
                  ttX = Math.abs(x - left);
                  override = true;
                } else if (Math.abs(x - right) < ttX) {
                  delta.x = x - bounds.x - bounds.width;
                  ttX = Math.abs(x - right);
                  override = true;
                }
              }
              if (override) {
                stateX = state2;
                valueX = x;
                if (this.guideX == null) {
                  this.guideX = this.createGuideShape(true);
                  this.guideX.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
                  this.guideX.pointerEvents = false;
                  this.guideX.init(this.graph.getView().getOverlayPane());
                }
              }
              overrideX = overrideX || override;
            }, snapY2 = function(y, state2, centerAlign) {
              var override = false;
              if (centerAlign && Math.abs(y - middle) < ttY) {
                delta.y = y - bounds.getCenterY();
                ttY = Math.abs(y - middle);
                override = true;
              } else if (!centerAlign) {
                if (Math.abs(y - top) < ttY) {
                  delta.y = y - bounds.y;
                  ttY = Math.abs(y - top);
                  override = true;
                } else if (Math.abs(y - bottom) < ttY) {
                  delta.y = y - bounds.y - bounds.height;
                  ttY = Math.abs(y - bottom);
                  override = true;
                }
              }
              if (override) {
                stateY = state2;
                valueY = y;
                if (this.guideY == null) {
                  this.guideY = this.createGuideShape(false);
                  this.guideY.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
                  this.guideY.pointerEvents = false;
                  this.guideY.init(this.graph.getView().getOverlayPane());
                }
              }
              overrideY = overrideY || override;
            };
            var snapX = snapX2, snapY = snapY2;
            var scale = this.graph.getView().scale;
            var tt = this.getGuideTolerance(gridEnabled) * scale;
            var b = bounds.clone();
            b.x += delta.x;
            b.y += delta.y;
            var overrideX = false;
            var stateX = null;
            var valueX = null;
            var overrideY = false;
            var stateY = null;
            var valueY = null;
            var ttX = tt;
            var ttY = tt;
            var left = b.x;
            var right = b.x + b.width;
            var center = b.getCenterX();
            var top = b.y;
            var bottom = b.y + b.height;
            var middle = b.getCenterY();
            ;
            ;
            for (var i = 0; i < this.states.length; i++) {
              var state = this.states[i];
              if (state != null && !this.isStateIgnored(state)) {
                if (this.horizontal) {
                  snapX2.call(this, state.getCenterX(), state, true);
                  snapX2.call(this, state.x, state, false);
                  snapX2.call(this, state.x + state.width, state, false);
                  if (state.cell == null) {
                    snapX2.call(this, state.getCenterX(), state, false);
                  }
                }
                if (this.vertical) {
                  snapY2.call(this, state.getCenterY(), state, true);
                  snapY2.call(this, state.y, state, false);
                  snapY2.call(this, state.y + state.height, state, false);
                  if (state.cell == null) {
                    snapY2.call(this, state.getCenterY(), state, false);
                  }
                }
              }
            }
            this.graph.snapDelta(delta, bounds, !gridEnabled, overrideX, overrideY);
            delta = this.getDelta(bounds, stateX, delta.x, stateY, delta.y);
            var c = this.graph.container;
            if (!overrideX && this.guideX != null) {
              this.guideX.node.style.visibility = "hidden";
            } else if (this.guideX != null) {
              var minY = null;
              var maxY = null;
              if (stateX != null && bounds != null) {
                minY = Math.min(bounds.y + delta.y - this.graph.panDy, stateX.y);
                maxY = Math.max(bounds.y + bounds.height + delta.y - this.graph.panDy, stateX.y + stateX.height);
              }
              if (minY != null && maxY != null) {
                this.guideX.points = [new mxPoint(valueX, minY), new mxPoint(valueX, maxY)];
              } else {
                this.guideX.points = [
                  new mxPoint(valueX, -this.graph.panDy),
                  new mxPoint(valueX, c.scrollHeight - 3 - this.graph.panDy)
                ];
              }
              this.guideX.stroke = this.getGuideColor(stateX, true);
              this.guideX.node.style.visibility = "visible";
              this.guideX.redraw();
            }
            if (!overrideY && this.guideY != null) {
              this.guideY.node.style.visibility = "hidden";
            } else if (this.guideY != null) {
              var minX = null;
              var maxX = null;
              if (stateY != null && bounds != null) {
                minX = Math.min(bounds.x + delta.x - this.graph.panDx, stateY.x);
                maxX = Math.max(bounds.x + bounds.width + delta.x - this.graph.panDx, stateY.x + stateY.width);
              }
              if (minX != null && maxX != null) {
                this.guideY.points = [new mxPoint(minX, valueY), new mxPoint(maxX, valueY)];
              } else {
                this.guideY.points = [
                  new mxPoint(-this.graph.panDx, valueY),
                  new mxPoint(c.scrollWidth - 3 - this.graph.panDx, valueY)
                ];
              }
              this.guideY.stroke = this.getGuideColor(stateY, false);
              this.guideY.node.style.visibility = "visible";
              this.guideY.redraw();
            }
          }
          return delta;
        };
        mxGuide.prototype.getDelta = function(bounds, stateX, dx, stateY, dy) {
          var s = this.graph.view.scale;
          if (this.rounded || stateX != null && stateX.cell == null) {
            dx = Math.round((bounds.x + dx) / s) * s - bounds.x;
          }
          if (this.rounded || stateY != null && stateY.cell == null) {
            dy = Math.round((bounds.y + dy) / s) * s - bounds.y;
          }
          return new mxPoint(dx, dy);
        };
        mxGuide.prototype.getGuideColor = function(state, horizontal) {
          return mxConstants.GUIDE_COLOR;
        };
        mxGuide.prototype.hide = function() {
          this.setVisible(false);
        };
        mxGuide.prototype.setVisible = function(visible) {
          if (this.guideX != null) {
            this.guideX.node.style.visibility = visible ? "visible" : "hidden";
          }
          if (this.guideY != null) {
            this.guideY.node.style.visibility = visible ? "visible" : "hidden";
          }
        };
        mxGuide.prototype.destroy = function() {
          if (this.guideX != null) {
            this.guideX.destroy();
            this.guideX = null;
          }
          if (this.guideY != null) {
            this.guideY.destroy();
            this.guideY = null;
          }
        };
        __mxOutput.mxGuide = typeof mxGuide !== "undefined" ? mxGuide : void 0;
        function mxShape(stencil) {
          this.stencil = stencil;
          this.initStyles();
        }
        ;
        mxShape.prototype.dialect = null;
        mxShape.prototype.scale = 1;
        mxShape.prototype.antiAlias = true;
        mxShape.prototype.minSvgStrokeWidth = 1;
        mxShape.prototype.bounds = null;
        mxShape.prototype.points = null;
        mxShape.prototype.node = null;
        mxShape.prototype.state = null;
        mxShape.prototype.style = null;
        mxShape.prototype.boundingBox = null;
        mxShape.prototype.stencil = null;
        mxShape.prototype.svgStrokeTolerance = 8;
        mxShape.prototype.pointerEvents = true;
        mxShape.prototype.svgPointerEvents = "all";
        mxShape.prototype.shapePointerEvents = false;
        mxShape.prototype.stencilPointerEvents = false;
        mxShape.prototype.vmlScale = 1;
        mxShape.prototype.outline = false;
        mxShape.prototype.visible = true;
        mxShape.prototype.useSvgBoundingBox = false;
        mxShape.prototype.init = function(container) {
          if (this.node == null) {
            this.node = this.create(container);
            if (container != null) {
              container.appendChild(this.node);
            }
          }
        };
        mxShape.prototype.initStyles = function(container) {
          this.strokewidth = 1;
          this.rotation = 0;
          this.opacity = 100;
          this.fillOpacity = 100;
          this.strokeOpacity = 100;
          this.flipH = false;
          this.flipV = false;
        };
        mxShape.prototype.isParseVml = function() {
          return true;
        };
        mxShape.prototype.isHtmlAllowed = function() {
          return false;
        };
        mxShape.prototype.getSvgScreenOffset = function() {
          var sw = this.stencil && this.stencil.strokewidth != "inherit" ? Number(this.stencil.strokewidth) : this.strokewidth;
          return mxUtils.mod(Math.max(1, Math.round(sw * this.scale)), 2) == 1 ? 0.5 : 0;
        };
        mxShape.prototype.create = function(container) {
          var node = null;
          if (container != null && container.ownerSVGElement != null) {
            node = this.createSvg(container);
          } else if (document.documentMode == 8 || !mxClient.IS_VML || this.dialect != mxConstants.DIALECT_VML && this.isHtmlAllowed()) {
            node = this.createHtml(container);
          } else {
            node = this.createVml(container);
          }
          return node;
        };
        mxShape.prototype.createSvg = function() {
          return document.createElementNS(mxConstants.NS_SVG, "g");
        };
        mxShape.prototype.createVml = function() {
          var node = document.createElement(mxClient.VML_PREFIX + ":group");
          node.style.position = "absolute";
          return node;
        };
        mxShape.prototype.createHtml = function() {
          var node = document.createElement("div");
          node.style.position = "absolute";
          return node;
        };
        mxShape.prototype.reconfigure = function() {
          this.redraw();
        };
        mxShape.prototype.redraw = function() {
          this.updateBoundsFromPoints();
          if (this.visible && this.checkBounds()) {
            if (this.node?.style) {
              this.node.style.display = "";
            }
            this.clear();
            if (this.node?.nodeName == "DIV" && (this.isHtmlAllowed() || !mxClient.IS_VML)) {
              this.redrawHtmlShape();
            } else {
              this.redrawShape();
            }
            this.updateBoundingBox();
          } else {
            this.node.style.display = "none";
            this.boundingBox = null;
          }
        };
        mxShape.prototype.clear = function() {
          if (this.node?.ownerSVGElement != null) {
            while (this.node.lastChild != null) {
              this.node.removeChild(this.node.lastChild);
            }
          } else {
            if (this.node) {
              this.node.style.cssText = "position:absolute;" + (this.cursor != null ? "cursor:" + this.cursor + ";" : "");
              this.node.innerHTML = "";
            }
          }
        };
        mxShape.prototype.updateBoundsFromPoints = function() {
          var pts = this.points;
          if (pts != null && pts.length > 0 && pts[0] != null) {
            this.bounds = new mxRectangle(Number(pts[0].x), Number(pts[0].y), 1, 1);
            for (var i = 1; i < this.points.length; i++) {
              if (pts[i] != null) {
                this.bounds.add(new mxRectangle(Number(pts[i].x), Number(pts[i].y), 1, 1));
              }
            }
          }
        };
        mxShape.prototype.getLabelBounds = function(rect) {
          var d = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
          var bounds = rect;
          if (d != mxConstants.DIRECTION_SOUTH && d != mxConstants.DIRECTION_NORTH && this.state != null && this.state.text != null && this.state.text.isPaintBoundsInverted()) {
            bounds = bounds.clone();
            var tmp = bounds.width;
            bounds.width = bounds.height;
            bounds.height = tmp;
          }
          var m = this.getLabelMargins(bounds);
          if (m != null) {
            var flipH = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, false) == "1";
            var flipV = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, false) == "1";
            if (this.state != null && this.state.text != null && this.state.text.isPaintBoundsInverted()) {
              var tmp = m.x;
              m.x = m.height;
              m.height = m.width;
              m.width = m.y;
              m.y = tmp;
              tmp = flipH;
              flipH = flipV;
              flipV = tmp;
            }
            return mxUtils.getDirectedBounds(rect, m, this.style, flipH, flipV);
          }
          return rect;
        };
        mxShape.prototype.getLabelMargins = function(rect) {
          return null;
        };
        mxShape.prototype.checkBounds = function() {
          return !isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 && this.bounds != null && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height) && this.bounds.width > 0 && this.bounds.height > 0;
        };
        mxShape.prototype.createVmlGroup = function() {
          var node = document.createElement(mxClient.VML_PREFIX + ":group");
          node.style.position = "absolute";
          node.style.width = this.node.style.width;
          node.style.height = this.node.style.height;
          return node;
        };
        mxShape.prototype.redrawShape = function() {
          var canvas = this.createCanvas();
          if (canvas != null) {
            canvas.pointerEvents = this.pointerEvents;
            this.beforePaint(canvas);
            this.paint(canvas);
            this.afterPaint(canvas);
            if (this.node != canvas.root) {
              this.node.insertAdjacentHTML("beforeend", canvas.root.outerHTML);
            }
            if (this.node.nodeName == "DIV" && document.documentMode == 8) {
              this.node.style.filter = "";
              mxUtils.addTransparentBackgroundFilter(this.node);
            }
            this.destroyCanvas(canvas);
          }
        };
        mxShape.prototype.createCanvas = function() {
          var canvas = null;
          if (this.node?.ownerSVGElement != null) {
            canvas = this.createSvgCanvas();
          } else if (mxClient.IS_VML) {
            this.updateVmlContainer();
            canvas = this.createVmlCanvas();
          }
          if (canvas != null && this.outline) {
            canvas.setStrokeWidth(this.strokewidth);
            canvas.setStrokeColor(this.stroke);
            if (this.isDashed != null) {
              canvas.setDashed(this.isDashed);
            }
            canvas.setStrokeWidth = function() {
            };
            canvas.setStrokeColor = function() {
            };
            canvas.setFillColor = function() {
            };
            canvas.setGradient = function() {
            };
            canvas.setDashed = function() {
            };
            canvas.text = function() {
            };
          }
          return canvas;
        };
        mxShape.prototype.createSvgCanvas = function() {
          var canvas = new mxSvgCanvas2D(this.node, false);
          canvas.strokeTolerance = this.pointerEvents ? this.svgStrokeTolerance : 0;
          canvas.pointerEventsValue = this.svgPointerEvents;
          var off = this.getSvgScreenOffset();
          if (off != 0) {
            this.node.setAttribute("transform", "translate(" + off + "," + off + ")");
          } else {
            this.node.removeAttribute("transform");
          }
          canvas.minStrokeWidth = this.minSvgStrokeWidth;
          if (!this.antiAlias) {
            canvas.format = function(value) {
              return Math.round(parseFloat(value));
            };
          }
          return canvas;
        };
        mxShape.prototype.createVmlCanvas = function() {
          var node = document.documentMode == 8 && this.isParseVml() ? this.createVmlGroup() : this.node;
          var canvas = new mxVmlCanvas2D(node, false);
          if (node.tagUrn != "") {
            var w2 = Math.max(1, Math.round(this.bounds.width));
            var h2 = Math.max(1, Math.round(this.bounds.height));
            node.coordsize = w2 * this.vmlScale + "," + h2 * this.vmlScale;
            canvas.scale(this.vmlScale);
            canvas.vmlScale = this.vmlScale;
          }
          var s = this.scale;
          canvas.translate(-Math.round(this.bounds.x / s), -Math.round(this.bounds.y / s));
          return canvas;
        };
        mxShape.prototype.updateVmlContainer = function() {
          this.node.style.left = Math.round(this.bounds.x) + "px";
          this.node.style.top = Math.round(this.bounds.y) + "px";
          var w2 = Math.max(1, Math.round(this.bounds.width));
          var h2 = Math.max(1, Math.round(this.bounds.height));
          this.node.style.width = w2 + "px";
          this.node.style.height = h2 + "px";
          this.node.style.overflow = "visible";
        };
        mxShape.prototype.redrawHtmlShape = function() {
          this.updateHtmlBounds(this.node);
          this.updateHtmlFilters(this.node);
          this.updateHtmlColors(this.node);
        };
        mxShape.prototype.updateHtmlFilters = function(node) {
          var f = "";
          if (this.opacity < 100) {
            f += "alpha(opacity=" + this.opacity + ")";
          }
          if (this.isShadow) {
            f += "progid:DXImageTransform.Microsoft.dropShadow (OffX='" + Math.round(mxConstants.SHADOW_OFFSET_X * this.scale) + "', OffY='" + Math.round(mxConstants.SHADOW_OFFSET_Y * this.scale) + "', Color='" + mxConstants.VML_SHADOWCOLOR + "')";
          }
          if (this.fill != null && this.fill != mxConstants.NONE && this.gradient && this.gradient != mxConstants.NONE) {
            var start = this.fill;
            var end = this.gradient;
            var type = "0";
            var lookup = { east: 0, south: 1, west: 2, north: 3 };
            var dir = this.direction != null ? lookup[this.direction] : 0;
            if (this.gradientDirection != null) {
              dir = mxUtils.mod(dir + lookup[this.gradientDirection] - 1, 4);
            }
            if (dir == 1) {
              type = "1";
              var tmp = start;
              start = end;
              end = tmp;
            } else if (dir == 2) {
              var tmp = start;
              start = end;
              end = tmp;
            } else if (dir == 3) {
              type = "1";
            }
            f += "progid:DXImageTransform.Microsoft.gradient(startColorStr='" + start + "', endColorStr='" + end + "', gradientType='" + type + "')";
          }
          node.style.filter = f;
        };
        mxShape.prototype.updateHtmlColors = function(node) {
          var color = this.stroke;
          if (color != null && color != mxConstants.NONE) {
            node.style.borderColor = color;
            if (this.isDashed) {
              node.style.borderStyle = "dashed";
            } else if (this.strokewidth > 0) {
              node.style.borderStyle = "solid";
            }
            node.style.borderWidth = Math.max(1, Math.ceil(this.strokewidth * this.scale)) + "px";
          } else {
            node.style.borderWidth = "0px";
          }
          color = this.outline ? null : this.fill;
          if (color != null && color != mxConstants.NONE) {
            node.style.backgroundColor = color;
            node.style.backgroundImage = "none";
          } else if (this.pointerEvents) {
            node.style.backgroundColor = "transparent";
          } else if (document.documentMode == 8) {
            mxUtils.addTransparentBackgroundFilter(node);
          } else {
            this.setTransparentBackgroundImage(node);
          }
        };
        mxShape.prototype.updateHtmlBounds = function(node) {
          var sw = document.documentMode >= 9 ? 0 : Math.ceil(this.strokewidth * this.scale);
          node.style.borderWidth = Math.max(1, sw) + "px";
          node.style.overflow = "hidden";
          node.style.left = Math.round(this.bounds.x - sw / 2) + "px";
          node.style.top = Math.round(this.bounds.y - sw / 2) + "px";
          if (document.compatMode == "CSS1Compat") {
            sw = -sw;
          }
          node.style.width = Math.round(Math.max(0, this.bounds.width + sw)) + "px";
          node.style.height = Math.round(Math.max(0, this.bounds.height + sw)) + "px";
        };
        mxShape.prototype.destroyCanvas = function(canvas) {
          if (canvas instanceof mxSvgCanvas2D) {
            for (var key in canvas.gradients) {
              var gradient = canvas.gradients[key];
              if (gradient != null) {
                gradient.mxRefCount = (gradient.mxRefCount || 0) + 1;
              }
            }
            this.releaseSvgGradients(this.oldGradients);
            this.oldGradients = canvas.gradients;
          }
        };
        mxShape.prototype.beforePaint = function(c) {
        };
        mxShape.prototype.afterPaint = function(c) {
        };
        mxShape.prototype.paint = function(c) {
          var strokeDrawn = false;
          if (c != null && this.outline) {
            var stroke = c.stroke;
            c.stroke = function() {
              strokeDrawn = true;
              stroke.apply(this, arguments);
            };
            var fillAndStroke = c.fillAndStroke;
            c.fillAndStroke = function() {
              strokeDrawn = true;
              fillAndStroke.apply(this, arguments);
            };
          }
          var s = this.scale;
          var x = this.bounds.x / s;
          var y = this.bounds.y / s;
          var w2 = this.bounds.width / s;
          var h2 = this.bounds.height / s;
          if (this.isPaintBoundsInverted()) {
            var t = (w2 - h2) / 2;
            x += t;
            y -= t;
            var tmp = w2;
            w2 = h2;
            h2 = tmp;
          }
          this.updateTransform(c, x, y, w2, h2);
          this.configureCanvas(c, x, y, w2, h2);
          var bg = null;
          if (this.stencil == null && this.points == null && this.shapePointerEvents || this.stencil != null && this.stencilPointerEvents) {
            var bb = this.createBoundingBox();
            if (this.dialect == mxConstants.DIALECT_SVG) {
              bg = this.createTransparentSvgRectangle(bb.x, bb.y, bb.width, bb.height);
              this.node.appendChild(bg);
            } else {
              var rect = c.createRect("rect", bb.x / s, bb.y / s, bb.width / s, bb.height / s);
              rect.appendChild(c.createTransparentFill());
              rect.stroked = "false";
              c.root.appendChild(rect);
            }
          }
          if (this.stencil != null) {
            this.stencil.drawShape(c, this, x, y, w2, h2);
          } else {
            c.setStrokeWidth(this.strokewidth);
            if (this.points != null) {
              var pts = [];
              for (var i = 0; i < this.points.length; i++) {
                if (this.points[i] != null) {
                  pts.push(new mxPoint(this.points[i].x / s, this.points[i].y / s));
                }
              }
              this.paintEdgeShape(c, pts);
            } else {
              this.paintVertexShape(c, x, y, w2, h2);
            }
          }
          if (bg != null && c.state != null && c.state.transform != null) {
            bg.setAttribute("transform", c.state.transform);
          }
          if (c != null && this.outline && !strokeDrawn) {
            c.rect(x, y, w2, h2);
            c.stroke();
          }
        };
        mxShape.prototype.configureCanvas = function(c, x, y, w2, h2) {
          var dash = null;
          if (this.style != null) {
            dash = this.style["dashPattern"];
          }
          c.setAlpha(this.opacity / 100);
          c.setFillAlpha(this.fillOpacity / 100);
          c.setStrokeAlpha(this.strokeOpacity / 100);
          if (this.isShadow != null) {
            c.setShadow(this.isShadow);
          }
          if (this.isDashed != null) {
            c.setDashed(this.isDashed, this.style != null ? mxUtils.getValue(this.style, mxConstants.STYLE_FIX_DASH, false) == 1 : false);
          }
          if (dash != null) {
            c.setDashPattern(dash);
          }
          if (this.fill != null && this.fill != mxConstants.NONE && this.gradient && this.gradient != mxConstants.NONE) {
            var b = this.getGradientBounds(c, x, y, w2, h2);
            c.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection);
          } else {
            c.setFillColor(this.fill);
          }
          c.setStrokeColor(this.stroke);
        };
        mxShape.prototype.getGradientBounds = function(c, x, y, w2, h2) {
          return new mxRectangle(x, y, w2, h2);
        };
        mxShape.prototype.updateTransform = function(c, x, y, w2, h2) {
          c.scale(this.scale);
          c.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + w2 / 2, y + h2 / 2);
        };
        mxShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
          this.paintBackground(c, x, y, w2, h2);
          if (!this.outline || this.style == null || mxUtils.getValue(
            this.style,
            mxConstants.STYLE_BACKGROUND_OUTLINE,
            0
          ) == 0) {
            c.setShadow(false);
            this.paintForeground(c, x, y, w2, h2);
          }
        };
        mxShape.prototype.paintBackground = function(c, x, y, w2, h2) {
        };
        mxShape.prototype.paintForeground = function(c, x, y, w2, h2) {
        };
        mxShape.prototype.paintEdgeShape = function(c, pts) {
        };
        mxShape.prototype.getArcSize = function(w2, h2) {
          var r = 0;
          if (mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0) == "1") {
            r = Math.min(w2 / 2, Math.min(h2 / 2, mxUtils.getValue(
              this.style,
              mxConstants.STYLE_ARCSIZE,
              mxConstants.LINE_ARCSIZE
            ) / 2));
          } else {
            var f = mxUtils.getValue(
              this.style,
              mxConstants.STYLE_ARCSIZE,
              mxConstants.RECTANGLE_ROUNDING_FACTOR * 100
            ) / 100;
            r = Math.min(w2 * f, h2 * f);
          }
          return r;
        };
        mxShape.prototype.paintGlassEffect = function(c, x, y, w2, h2, arc) {
          var sw = Math.ceil(this.strokewidth / 2);
          var size = 0.4;
          c.setGradient("#ffffff", "#ffffff", x, y, w2, h2 * 0.6, "south", 0.9, 0.1);
          c.begin();
          arc += 2 * sw;
          if (this.isRounded) {
            c.moveTo(x - sw + arc, y - sw);
            c.quadTo(x - sw, y - sw, x - sw, y - sw + arc);
            c.lineTo(x - sw, y + h2 * size);
            c.quadTo(x + w2 * 0.5, y + h2 * 0.7, x + w2 + sw, y + h2 * size);
            c.lineTo(x + w2 + sw, y - sw + arc);
            c.quadTo(x + w2 + sw, y - sw, x + w2 + sw - arc, y - sw);
          } else {
            c.moveTo(x - sw, y - sw);
            c.lineTo(x - sw, y + h2 * size);
            c.quadTo(x + w2 * 0.5, y + h2 * 0.7, x + w2 + sw, y + h2 * size);
            c.lineTo(x + w2 + sw, y - sw);
          }
          c.close();
          c.fill();
        };
        mxShape.prototype.addPoints = function(c, pts, rounded, arcSize, close, exclude, initialMove) {
          if (pts != null && pts.length > 0) {
            initialMove = initialMove != null ? initialMove : true;
            var pe = pts[pts.length - 1];
            if (close && rounded) {
              pts = pts.slice();
              var p0 = pts[0];
              var wp = new mxPoint(pe.x + (p0.x - pe.x) / 2, pe.y + (p0.y - pe.y) / 2);
              pts.splice(0, 0, wp);
            }
            var pt = pts[0];
            var i = 1;
            if (initialMove) {
              c.moveTo(pt.x, pt.y);
            } else {
              c.lineTo(pt.x, pt.y);
            }
            while (i < (close ? pts.length : pts.length - 1)) {
              var tmp = pts[mxUtils.mod(i, pts.length)];
              var dx = pt.x - tmp.x;
              var dy = pt.y - tmp.y;
              if (rounded && (dx != 0 || dy != 0) && (exclude == null || mxUtils.indexOf(exclude, i - 1) < 0)) {
                var dist = Math.sqrt(dx * dx + dy * dy);
                var nx1 = dx * Math.min(arcSize, dist / 2) / dist;
                var ny1 = dy * Math.min(arcSize, dist / 2) / dist;
                var x1 = tmp.x + nx1;
                var y1 = tmp.y + ny1;
                c.lineTo(x1, y1);
                var next = pts[mxUtils.mod(i + 1, pts.length)];
                while (i < pts.length - 2 && Math.round(next.x - tmp.x) == 0 && Math.round(next.y - tmp.y) == 0) {
                  next = pts[mxUtils.mod(i + 2, pts.length)];
                  i++;
                }
                dx = next.x - tmp.x;
                dy = next.y - tmp.y;
                dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
                var nx2 = dx * Math.min(arcSize, dist / 2) / dist;
                var ny2 = dy * Math.min(arcSize, dist / 2) / dist;
                var x2 = tmp.x + nx2;
                var y2 = tmp.y + ny2;
                c.quadTo(tmp.x, tmp.y, x2, y2);
                tmp = new mxPoint(x2, y2);
              } else {
                c.lineTo(tmp.x, tmp.y);
              }
              pt = tmp;
              i++;
            }
            if (close) {
              c.close();
            } else {
              c.lineTo(pe.x, pe.y);
            }
          }
        };
        mxShape.prototype.resetStyles = function() {
          this.initStyles();
          this.spacing = 0;
          delete this.fill;
          delete this.gradient;
          delete this.gradientDirection;
          delete this.stroke;
          delete this.startSize;
          delete this.endSize;
          delete this.startArrow;
          delete this.endArrow;
          delete this.direction;
          delete this.isShadow;
          delete this.isDashed;
          delete this.isRounded;
          delete this.glass;
        };
        mxShape.prototype.apply = function(state) {
          this.state = state;
          this.style = state.style;
          if (this.style != null) {
            this.fill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, this.fill);
            this.gradient = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENTCOLOR, this.gradient);
            this.gradientDirection = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENT_DIRECTION, this.gradientDirection);
            this.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_OPACITY, this.opacity);
            this.fillOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_FILL_OPACITY, this.fillOpacity);
            this.strokeOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_STROKE_OPACITY, this.strokeOpacity);
            this.stroke = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, this.stroke);
            this.strokewidth = mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth);
            this.spacing = mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing);
            this.startSize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, this.startSize);
            this.endSize = mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, this.endSize);
            this.startArrow = mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, this.startArrow);
            this.endArrow = mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, this.endArrow);
            this.rotation = mxUtils.getValue(this.style, mxConstants.STYLE_ROTATION, this.rotation);
            this.direction = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, this.direction);
            this.flipH = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0) == 1;
            this.flipV = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0) == 1;
            if (this.stencil != null) {
              this.flipH = mxUtils.getValue(this.style, "stencilFlipH", 0) == 1 || this.flipH;
              this.flipV = mxUtils.getValue(this.style, "stencilFlipV", 0) == 1 || this.flipV;
            }
            if (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH) {
              var tmp = this.flipH;
              this.flipH = this.flipV;
              this.flipV = tmp;
            }
            this.isShadow = mxUtils.getValue(this.style, mxConstants.STYLE_SHADOW, this.isShadow) == 1;
            this.isDashed = mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, this.isDashed) == 1;
            this.isRounded = mxUtils.getValue(this.style, mxConstants.STYLE_ROUNDED, this.isRounded) == 1;
            this.glass = mxUtils.getValue(this.style, mxConstants.STYLE_GLASS, this.glass) == 1;
            if (this.fill == mxConstants.NONE) {
              this.fill = null;
            }
            if (this.gradient == mxConstants.NONE) {
              this.gradient = null;
            }
            if (this.stroke == mxConstants.NONE) {
              this.stroke = null;
            }
          }
        };
        mxShape.prototype.setCursor = function(cursor) {
          if (cursor == null) {
            cursor = "";
          }
          this.cursor = cursor;
          if (this.node != null) {
            this.node.style.cursor = cursor;
          }
        };
        mxShape.prototype.getCursor = function() {
          return this.cursor;
        };
        mxShape.prototype.isRoundable = function() {
          return false;
        };
        mxShape.prototype.updateBoundingBox = function() {
          if (this.useSvgBoundingBox && this.node != null && this.node.ownerSVGElement != null) {
            try {
              var b = this.node.getBBox();
              if (b.width > 0 && b.height > 0) {
                this.boundingBox = new mxRectangle(b.x, b.y, b.width, b.height);
                this.boundingBox.grow(this.strokewidth * this.scale / 2);
                return;
              }
            } catch (e) {
            }
          }
          if (this.bounds != null) {
            var bbox = this.createBoundingBox();
            if (bbox != null) {
              this.augmentBoundingBox(bbox);
              var rot = this.getShapeRotation();
              if (rot != 0) {
                bbox = mxUtils.getBoundingBox(bbox, rot);
              }
            }
            this.boundingBox = bbox;
          }
        };
        mxShape.prototype.createBoundingBox = function() {
          var bb = this.bounds.clone();
          if (this.stencil != null && (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH) || this.isPaintBoundsInverted()) {
            bb.rotate90();
          }
          return bb;
        };
        mxShape.prototype.augmentBoundingBox = function(bbox) {
          if (this.isShadow) {
            bbox.width += Math.ceil(mxConstants.SHADOW_OFFSET_X * this.scale);
            bbox.height += Math.ceil(mxConstants.SHADOW_OFFSET_Y * this.scale);
          }
          bbox.grow(this.strokewidth * this.scale / 2);
        };
        mxShape.prototype.isPaintBoundsInverted = function() {
          return this.stencil == null && (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH);
        };
        mxShape.prototype.getRotation = function() {
          return this.rotation != null ? this.rotation : 0;
        };
        mxShape.prototype.getTextRotation = function() {
          var rot = this.getRotation();
          if (mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1) != 1) {
            rot += mxText.prototype.verticalTextRotation;
          }
          return rot;
        };
        mxShape.prototype.getShapeRotation = function() {
          var rot = this.getRotation();
          if (this.direction != null) {
            if (this.direction == mxConstants.DIRECTION_NORTH) {
              rot += 270;
            } else if (this.direction == mxConstants.DIRECTION_WEST) {
              rot += 180;
            } else if (this.direction == mxConstants.DIRECTION_SOUTH) {
              rot += 90;
            }
          }
          return rot;
        };
        mxShape.prototype.createTransparentSvgRectangle = function(x, y, w2, h2) {
          var rect = document.createElementNS(mxConstants.NS_SVG, "rect");
          rect.setAttribute("x", x);
          rect.setAttribute("y", y);
          rect.setAttribute("width", w2);
          rect.setAttribute("height", h2);
          rect.setAttribute("fill", "none");
          rect.setAttribute("stroke", "none");
          rect.setAttribute("pointer-events", "all");
          return rect;
        };
        mxShape.prototype.setTransparentBackgroundImage = function(node) {
          node.style.backgroundImage = "url('" + mxClient.imageBasePath + "/transparent.gif')";
        };
        mxShape.prototype.releaseSvgGradients = function(grads) {
          if (grads != null) {
            for (var key in grads) {
              var gradient = grads[key];
              if (gradient != null) {
                gradient.mxRefCount = (gradient.mxRefCount || 0) - 1;
                if (gradient.mxRefCount == 0 && gradient.parentNode != null) {
                  gradient.parentNode.removeChild(gradient);
                }
              }
            }
          }
        };
        mxShape.prototype.destroy = function() {
          if (this.node != null) {
            mxEvent.release(this.node);
            if (this.node.parentNode != null) {
              this.node.parentNode.removeChild(this.node);
            }
            this.node = null;
          }
          this.releaseSvgGradients(this.oldGradients);
          this.oldGradients = null;
        };
        __mxOutput.mxShape = typeof mxShape !== "undefined" ? mxShape : void 0;
        function mxStencil(desc) {
          this.desc = desc;
          this.parseDescription();
          this.parseConstraints();
        }
        ;
        mxUtils.extend(mxStencil, mxShape);
        mxStencil.defaultLocalized = false;
        mxStencil.allowEval = false;
        mxStencil.prototype.desc = null;
        mxStencil.prototype.constraints = null;
        mxStencil.prototype.aspect = null;
        mxStencil.prototype.w0 = null;
        mxStencil.prototype.h0 = null;
        mxStencil.prototype.bgNode = null;
        mxStencil.prototype.fgNode = null;
        mxStencil.prototype.strokewidth = null;
        mxStencil.prototype.parseDescription = function() {
          this.fgNode = this.desc.getElementsByTagName("foreground")[0];
          this.bgNode = this.desc.getElementsByTagName("background")[0];
          this.w0 = Number(this.desc.getAttribute("w") || 100);
          this.h0 = Number(this.desc.getAttribute("h") || 100);
          var aspect = this.desc.getAttribute("aspect");
          this.aspect = aspect != null ? aspect : "variable";
          var sw = this.desc.getAttribute("strokewidth");
          this.strokewidth = sw != null ? sw : "1";
        };
        mxStencil.prototype.parseConstraints = function() {
          var conns = this.desc.getElementsByTagName("connections")[0];
          if (conns != null) {
            var tmp = mxUtils.getChildNodes(conns);
            if (tmp != null && tmp.length > 0) {
              this.constraints = [];
              for (var i = 0; i < tmp.length; i++) {
                this.constraints.push(this.parseConstraint(tmp[i]));
              }
            }
          }
        };
        mxStencil.prototype.parseConstraint = function(node) {
          var x = Number(node.getAttribute("x"));
          var y = Number(node.getAttribute("y"));
          var perimeter = node.getAttribute("perimeter") == "1";
          var name2 = node.getAttribute("name");
          return new mxConnectionConstraint(new mxPoint(x, y), perimeter, name2);
        };
        mxStencil.prototype.evaluateTextAttribute = function(node, attribute, shape2) {
          var result2 = this.evaluateAttribute(node, attribute, shape2);
          var loc = node.getAttribute("localized");
          if (mxStencil.defaultLocalized && loc == null || loc == "1") {
            result2 = mxResources.get(result2);
          }
          return result2;
        };
        mxStencil.prototype.evaluateAttribute = function(node, attribute, shape2) {
          var result2 = node.getAttribute(attribute);
          if (result2 == null) {
            var text = mxUtils.getTextContent(node);
            if (text != null && mxStencil.allowEval) {
              var funct = mxUtils.eval(text);
              if (typeof funct == "function") {
                result2 = funct(shape2);
              }
            }
          }
          return result2;
        };
        mxStencil.prototype.drawShape = function(canvas, shape2, x, y, w2, h2) {
          var stack = canvas.states.slice();
          var direction = mxUtils.getValue(shape2.style, mxConstants.STYLE_DIRECTION, null);
          var aspect = this.computeAspect(shape2.style, x, y, w2, h2, direction);
          var minScale = Math.min(aspect.width, aspect.height);
          var sw = this.strokewidth == "inherit" ? Number(mxUtils.getNumber(shape2.style, mxConstants.STYLE_STROKEWIDTH, 1)) : Number(this.strokewidth) * minScale;
          canvas.setStrokeWidth(sw);
          if (shape2.style != null && mxUtils.getValue(shape2.style, mxConstants.STYLE_POINTER_EVENTS, "0") == "1") {
            canvas.setStrokeColor(mxConstants.NONE);
            canvas.rect(x, y, w2, h2);
            canvas.stroke();
            canvas.setStrokeColor(shape2.stroke);
          }
          this.drawChildren(canvas, shape2, x, y, w2, h2, this.bgNode, aspect, false, true);
          this.drawChildren(
            canvas,
            shape2,
            x,
            y,
            w2,
            h2,
            this.fgNode,
            aspect,
            true,
            !shape2.outline || shape2.style == null || mxUtils.getValue(
              shape2.style,
              mxConstants.STYLE_BACKGROUND_OUTLINE,
              0
            ) == 0
          );
          if (canvas.states.length != stack.length) {
            canvas.states = stack;
          }
        };
        mxStencil.prototype.drawChildren = function(canvas, shape2, x, y, w2, h2, node, aspect, disableShadow, paint) {
          if (node != null && w2 > 0 && h2 > 0) {
            var tmp = node.firstChild;
            while (tmp != null) {
              if (tmp.nodeType == mxConstants.NODETYPE_ELEMENT) {
                this.drawNode(canvas, shape2, tmp, aspect, disableShadow, paint);
              }
              tmp = tmp.nextSibling;
            }
          }
        };
        mxStencil.prototype.computeAspect = function(shape2, x, y, w2, h2, direction) {
          var x0 = x;
          var y0 = y;
          var sx = w2 / this.w0;
          var sy = h2 / this.h0;
          var inverse = direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH;
          if (inverse) {
            sy = w2 / this.h0;
            sx = h2 / this.w0;
            var delta = (w2 - h2) / 2;
            x0 += delta;
            y0 -= delta;
          }
          if (this.aspect == "fixed") {
            sy = Math.min(sx, sy);
            sx = sy;
            if (inverse) {
              x0 += (h2 - this.w0 * sx) / 2;
              y0 += (w2 - this.h0 * sy) / 2;
            } else {
              x0 += (w2 - this.w0 * sx) / 2;
              y0 += (h2 - this.h0 * sy) / 2;
            }
          }
          return new mxRectangle(x0, y0, sx, sy);
        };
        mxStencil.prototype.drawNode = function(canvas, shape2, node, aspect, disableShadow, paint) {
          var name2 = node.nodeName;
          var x0 = aspect.x;
          var y0 = aspect.y;
          var sx = aspect.width;
          var sy = aspect.height;
          var minScale = Math.min(sx, sy);
          if (name2 == "save") {
            canvas.save();
          } else if (name2 == "restore") {
            canvas.restore();
          } else if (paint) {
            if (name2 == "path") {
              canvas.begin();
              var parseRegularly = true;
              if (node.getAttribute("rounded") == "1") {
                parseRegularly = false;
                var arcSize = Number(node.getAttribute("arcSize"));
                var pointCount = 0;
                var segs = [];
                var childNode = node.firstChild;
                while (childNode != null) {
                  if (childNode.nodeType == mxConstants.NODETYPE_ELEMENT) {
                    var childName = childNode.nodeName;
                    if (childName == "move" || childName == "line") {
                      if (childName == "move" || segs.length == 0) {
                        segs.push([]);
                      }
                      segs[segs.length - 1].push(new mxPoint(
                        x0 + Number(childNode.getAttribute("x")) * sx,
                        y0 + Number(childNode.getAttribute("y")) * sy
                      ));
                      pointCount++;
                    } else {
                      parseRegularly = true;
                      break;
                    }
                  }
                  childNode = childNode.nextSibling;
                }
                if (!parseRegularly && pointCount > 0) {
                  for (var i = 0; i < segs.length; i++) {
                    var close = false, ps = segs[i][0], pe = segs[i][segs[i].length - 1];
                    if (ps.x == pe.x && ps.y == pe.y) {
                      segs[i].pop();
                      close = true;
                    }
                    this.addPoints(canvas, segs[i], true, arcSize, close);
                  }
                } else {
                  parseRegularly = true;
                }
              }
              if (parseRegularly) {
                var childNode = node.firstChild;
                while (childNode != null) {
                  if (childNode.nodeType == mxConstants.NODETYPE_ELEMENT) {
                    this.drawNode(canvas, shape2, childNode, aspect, disableShadow, paint);
                  }
                  childNode = childNode.nextSibling;
                }
              }
            } else if (name2 == "close") {
              canvas.close();
            } else if (name2 == "move") {
              canvas.moveTo(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy);
            } else if (name2 == "line") {
              canvas.lineTo(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy);
            } else if (name2 == "quad") {
              canvas.quadTo(
                x0 + Number(node.getAttribute("x1")) * sx,
                y0 + Number(node.getAttribute("y1")) * sy,
                x0 + Number(node.getAttribute("x2")) * sx,
                y0 + Number(node.getAttribute("y2")) * sy
              );
            } else if (name2 == "curve") {
              canvas.curveTo(
                x0 + Number(node.getAttribute("x1")) * sx,
                y0 + Number(node.getAttribute("y1")) * sy,
                x0 + Number(node.getAttribute("x2")) * sx,
                y0 + Number(node.getAttribute("y2")) * sy,
                x0 + Number(node.getAttribute("x3")) * sx,
                y0 + Number(node.getAttribute("y3")) * sy
              );
            } else if (name2 == "arc") {
              canvas.arcTo(
                Number(node.getAttribute("rx")) * sx,
                Number(node.getAttribute("ry")) * sy,
                Number(node.getAttribute("x-axis-rotation")),
                Number(node.getAttribute("large-arc-flag")),
                Number(node.getAttribute("sweep-flag")),
                x0 + Number(node.getAttribute("x")) * sx,
                y0 + Number(node.getAttribute("y")) * sy
              );
            } else if (name2 == "rect") {
              canvas.rect(
                x0 + Number(node.getAttribute("x")) * sx,
                y0 + Number(node.getAttribute("y")) * sy,
                Number(node.getAttribute("w")) * sx,
                Number(node.getAttribute("h")) * sy
              );
            } else if (name2 == "roundrect") {
              var arcsize = Number(node.getAttribute("arcsize"));
              if (arcsize == 0) {
                arcsize = mxConstants.RECTANGLE_ROUNDING_FACTOR * 100;
              }
              var w2 = Number(node.getAttribute("w")) * sx;
              var h2 = Number(node.getAttribute("h")) * sy;
              var factor = Number(arcsize) / 100;
              var r = Math.min(w2 * factor, h2 * factor);
              canvas.roundrect(
                x0 + Number(node.getAttribute("x")) * sx,
                y0 + Number(node.getAttribute("y")) * sy,
                w2,
                h2,
                r,
                r
              );
            } else if (name2 == "ellipse") {
              canvas.ellipse(
                x0 + Number(node.getAttribute("x")) * sx,
                y0 + Number(node.getAttribute("y")) * sy,
                Number(node.getAttribute("w")) * sx,
                Number(node.getAttribute("h")) * sy
              );
            } else if (name2 == "image") {
              if (!shape2.outline) {
                var src = this.evaluateAttribute(node, "src", shape2);
                canvas.image(
                  x0 + Number(node.getAttribute("x")) * sx,
                  y0 + Number(node.getAttribute("y")) * sy,
                  Number(node.getAttribute("w")) * sx,
                  Number(node.getAttribute("h")) * sy,
                  src,
                  false,
                  node.getAttribute("flipH") == "1",
                  node.getAttribute("flipV") == "1"
                );
              }
            } else if (name2 == "text") {
              if (!shape2.outline) {
                var str = this.evaluateTextAttribute(node, "str", shape2);
                var rotation = node.getAttribute("vertical") == "1" ? -90 : 0;
                if (node.getAttribute("align-shape") == "0") {
                  var dr = shape2.rotation;
                  var flipH = mxUtils.getValue(shape2.style, mxConstants.STYLE_FLIPH, 0) == 1;
                  var flipV = mxUtils.getValue(shape2.style, mxConstants.STYLE_FLIPV, 0) == 1;
                  if (flipH && flipV) {
                    rotation -= dr;
                  } else if (flipH || flipV) {
                    rotation += dr;
                  } else {
                    rotation -= dr;
                  }
                }
                rotation -= node.getAttribute("rotation");
                canvas.text(
                  x0 + Number(node.getAttribute("x")) * sx,
                  y0 + Number(node.getAttribute("y")) * sy,
                  0,
                  0,
                  str,
                  node.getAttribute("align") || "left",
                  node.getAttribute("valign") || "top",
                  false,
                  "",
                  null,
                  false,
                  rotation
                );
              }
            } else if (name2 == "include-shape") {
              var stencil = mxStencilRegistry.getStencil(node.getAttribute("name"));
              if (stencil != null) {
                var x = x0 + Number(node.getAttribute("x")) * sx;
                var y = y0 + Number(node.getAttribute("y")) * sy;
                var w2 = Number(node.getAttribute("w")) * sx;
                var h2 = Number(node.getAttribute("h")) * sy;
                stencil.drawShape(canvas, shape2, x, y, w2, h2);
              }
            } else if (name2 == "fillstroke") {
              canvas.fillAndStroke();
            } else if (name2 == "fill") {
              canvas.fill();
            } else if (name2 == "stroke") {
              canvas.stroke();
            } else if (name2 == "strokewidth") {
              var s = node.getAttribute("fixed") == "1" ? 1 : minScale;
              canvas.setStrokeWidth(Number(node.getAttribute("width")) * s);
            } else if (name2 == "dashed") {
              canvas.setDashed(node.getAttribute("dashed") == "1");
            } else if (name2 == "dashpattern") {
              var value = node.getAttribute("pattern");
              if (value != null) {
                var tmp = value.split(" ");
                var pat = [];
                for (var i = 0; i < tmp.length; i++) {
                  if (tmp[i].length > 0) {
                    pat.push(Number(tmp[i]) * minScale);
                  }
                }
                value = pat.join(" ");
                canvas.setDashPattern(value);
              }
            } else if (name2 == "strokecolor") {
              canvas.setStrokeColor(node.getAttribute("color"));
            } else if (name2 == "linecap") {
              canvas.setLineCap(node.getAttribute("cap"));
            } else if (name2 == "linejoin") {
              canvas.setLineJoin(node.getAttribute("join"));
            } else if (name2 == "miterlimit") {
              canvas.setMiterLimit(Number(node.getAttribute("limit")));
            } else if (name2 == "fillcolor") {
              canvas.setFillColor(node.getAttribute("color"));
            } else if (name2 == "alpha") {
              canvas.setAlpha(node.getAttribute("alpha"));
            } else if (name2 == "fillalpha") {
              canvas.setAlpha(node.getAttribute("alpha"));
            } else if (name2 == "strokealpha") {
              canvas.setAlpha(node.getAttribute("alpha"));
            } else if (name2 == "fontcolor") {
              canvas.setFontColor(node.getAttribute("color"));
            } else if (name2 == "fontstyle") {
              canvas.setFontStyle(node.getAttribute("style"));
            } else if (name2 == "fontfamily") {
              canvas.setFontFamily(node.getAttribute("family"));
            } else if (name2 == "fontsize") {
              canvas.setFontSize(Number(node.getAttribute("size")) * minScale);
            }
            if (disableShadow && (name2 == "fillstroke" || name2 == "fill" || name2 == "stroke")) {
              disableShadow = false;
              canvas.setShadow(false);
            }
          }
        };
        __mxOutput.mxStencil = typeof mxStencil !== "undefined" ? mxStencil : void 0;
        var mxStencilRegistry = {
          /**
           * Class: mxStencilRegistry
           * 
           * A singleton class that provides a registry for stencils and the methods
           * for painting those stencils onto a canvas or into a DOM.
           */
          stencils: {},
          /**
           * Function: addStencil
           * 
           * Adds the given <mxStencil>.
           */
          addStencil: function(name2, stencil) {
            mxStencilRegistry.stencils[name2] = stencil;
          },
          /**
           * Function: getStencil
           * 
           * Returns the <mxStencil> for the given name.
           */
          getStencil: function(name2) {
            return mxStencilRegistry.stencils[name2];
          }
        };
        __mxOutput.mxStencilRegistry = typeof mxStencilRegistry !== "undefined" ? mxStencilRegistry : void 0;
        var mxMarker = {
          /**
           * Class: mxMarker
           * 
           * A static class that implements all markers for VML and SVG using a
           * registry. NOTE: The signatures in this class will change.
           * 
           * Variable: markers
           * 
           * Maps from markers names to functions to paint the markers.
           */
          markers: [],
          /**
           * Function: addMarker
           * 
           * Adds a factory method that updates a given endpoint and returns a
           * function to paint the marker onto the given canvas.
           */
          addMarker: function(type, funct) {
            mxMarker.markers[type] = funct;
          },
          /**
           * Function: createMarker
           * 
           * Returns a function to paint the given marker.
           */
          createMarker: function(canvas, shape2, type, pe, unitX, unitY, size, source, sw, filled) {
            var funct = mxMarker.markers[type];
            return funct != null ? funct(canvas, shape2, type, pe, unitX, unitY, size, source, sw, filled) : null;
          }
        };
        (function() {
          function createArrow(widthFactor) {
            widthFactor = widthFactor != null ? widthFactor : 2;
            return function(canvas, shape2, type, pe, unitX, unitY, size, source, sw, filled) {
              var endOffsetX = unitX * sw * 1.118;
              var endOffsetY = unitY * sw * 1.118;
              unitX = unitX * (size + sw);
              unitY = unitY * (size + sw);
              var pt = pe.clone();
              pt.x -= endOffsetX;
              pt.y -= endOffsetY;
              var f = type != mxConstants.ARROW_CLASSIC && type != mxConstants.ARROW_CLASSIC_THIN ? 1 : 3 / 4;
              pe.x += -unitX * f - endOffsetX;
              pe.y += -unitY * f - endOffsetY;
              return function() {
                canvas.begin();
                canvas.moveTo(pt.x, pt.y);
                canvas.lineTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);
                if (type == mxConstants.ARROW_CLASSIC || type == mxConstants.ARROW_CLASSIC_THIN) {
                  canvas.lineTo(pt.x - unitX * 3 / 4, pt.y - unitY * 3 / 4);
                }
                canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);
                canvas.close();
                if (filled) {
                  canvas.fillAndStroke();
                } else {
                  canvas.stroke();
                }
              };
            };
          }
          ;
          mxMarker.addMarker("classic", createArrow(2));
          mxMarker.addMarker("classicThin", createArrow(3));
          mxMarker.addMarker("block", createArrow(2));
          mxMarker.addMarker("blockThin", createArrow(3));
          function createOpenArrow(widthFactor) {
            widthFactor = widthFactor != null ? widthFactor : 2;
            return function(canvas, shape2, type, pe, unitX, unitY, size, source, sw, filled) {
              var endOffsetX = unitX * sw * 1.118;
              var endOffsetY = unitY * sw * 1.118;
              unitX = unitX * (size + sw);
              unitY = unitY * (size + sw);
              var pt = pe.clone();
              pt.x -= endOffsetX;
              pt.y -= endOffsetY;
              pe.x += -endOffsetX * 2;
              pe.y += -endOffsetY * 2;
              return function() {
                canvas.begin();
                canvas.moveTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);
                canvas.lineTo(pt.x, pt.y);
                canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);
                canvas.stroke();
              };
            };
          }
          ;
          mxMarker.addMarker("open", createOpenArrow(2));
          mxMarker.addMarker("openThin", createOpenArrow(3));
          mxMarker.addMarker("oval", function(canvas, shape2, type, pe, unitX, unitY, size, source, sw, filled) {
            var a = size / 2;
            var pt = pe.clone();
            pe.x -= unitX * a;
            pe.y -= unitY * a;
            return function() {
              canvas.ellipse(pt.x - a, pt.y - a, size, size);
              if (filled) {
                canvas.fillAndStroke();
              } else {
                canvas.stroke();
              }
            };
          });
          function diamond(canvas, shape2, type, pe, unitX, unitY, size, source, sw, filled) {
            var swFactor = type == mxConstants.ARROW_DIAMOND ? 0.7071 : 0.9862;
            var endOffsetX = unitX * sw * swFactor;
            var endOffsetY = unitY * sw * swFactor;
            unitX = unitX * (size + sw);
            unitY = unitY * (size + sw);
            var pt = pe.clone();
            pt.x -= endOffsetX;
            pt.y -= endOffsetY;
            pe.x += -unitX - endOffsetX;
            pe.y += -unitY - endOffsetY;
            var tk = type == mxConstants.ARROW_DIAMOND ? 2 : 3.4;
            return function() {
              canvas.begin();
              canvas.moveTo(pt.x, pt.y);
              canvas.lineTo(pt.x - unitX / 2 - unitY / tk, pt.y + unitX / tk - unitY / 2);
              canvas.lineTo(pt.x - unitX, pt.y - unitY);
              canvas.lineTo(pt.x - unitX / 2 + unitY / tk, pt.y - unitY / 2 - unitX / tk);
              canvas.close();
              if (filled) {
                canvas.fillAndStroke();
              } else {
                canvas.stroke();
              }
            };
          }
          ;
          mxMarker.addMarker("diamond", diamond);
          mxMarker.addMarker("diamondThin", diamond);
        })();
        __mxOutput.mxMarker = typeof mxMarker !== "undefined" ? mxMarker : void 0;
        function mxActor(bounds, fill, stroke, strokewidth) {
          mxShape.call(this);
          this.bounds = bounds;
          this.fill = fill;
          this.stroke = stroke;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
        }
        ;
        mxUtils.extend(mxActor, mxShape);
        mxActor.prototype.paintVertexShape = function(c, x, y, w2, h2) {
          c.translate(x, y);
          c.begin();
          this.redrawPath(c, x, y, w2, h2);
          c.fillAndStroke();
        };
        mxActor.prototype.redrawPath = function(c, x, y, w2, h2) {
          var width = w2 / 3;
          c.moveTo(0, h2);
          c.curveTo(0, 3 * h2 / 5, 0, 2 * h2 / 5, w2 / 2, 2 * h2 / 5);
          c.curveTo(w2 / 2 - width, 2 * h2 / 5, w2 / 2 - width, 0, w2 / 2, 0);
          c.curveTo(w2 / 2 + width, 0, w2 / 2 + width, 2 * h2 / 5, w2 / 2, 2 * h2 / 5);
          c.curveTo(w2, 2 * h2 / 5, w2, 3 * h2 / 5, w2, h2);
          c.close();
        };
        __mxOutput.mxActor = typeof mxActor !== "undefined" ? mxActor : void 0;
        function mxCloud(bounds, fill, stroke, strokewidth) {
          mxActor.call(this);
          this.bounds = bounds;
          this.fill = fill;
          this.stroke = stroke;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
        }
        ;
        mxUtils.extend(mxCloud, mxActor);
        mxCloud.prototype.redrawPath = function(c, x, y, w2, h2) {
          c.moveTo(0.25 * w2, 0.25 * h2);
          c.curveTo(0.05 * w2, 0.25 * h2, 0, 0.5 * h2, 0.16 * w2, 0.55 * h2);
          c.curveTo(0, 0.66 * h2, 0.18 * w2, 0.9 * h2, 0.31 * w2, 0.8 * h2);
          c.curveTo(0.4 * w2, h2, 0.7 * w2, h2, 0.8 * w2, 0.8 * h2);
          c.curveTo(w2, 0.8 * h2, w2, 0.6 * h2, 0.875 * w2, 0.5 * h2);
          c.curveTo(w2, 0.3 * h2, 0.8 * w2, 0.1 * h2, 0.625 * w2, 0.2 * h2);
          c.curveTo(0.5 * w2, 0.05 * h2, 0.3 * w2, 0.05 * h2, 0.25 * w2, 0.25 * h2);
          c.close();
        };
        __mxOutput.mxCloud = typeof mxCloud !== "undefined" ? mxCloud : void 0;
        function mxRectangleShape(bounds, fill, stroke, strokewidth) {
          mxShape.call(this);
          this.bounds = bounds;
          this.fill = fill;
          this.stroke = stroke;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
        }
        ;
        mxUtils.extend(mxRectangleShape, mxShape);
        mxRectangleShape.prototype.isHtmlAllowed = function() {
          var events = true;
          if (this.style != null) {
            events = mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1") == "1";
          }
          return !this.isRounded && !this.glass && this.rotation == 0 && (events || this.fill != null && this.fill != mxConstants.NONE);
        };
        mxRectangleShape.prototype.paintBackground = function(c, x, y, w2, h2) {
          var events = true;
          if (this.style != null) {
            events = mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1") == "1";
          }
          if (events || this.fill != null && this.fill != mxConstants.NONE || this.stroke != null && this.stroke != mxConstants.NONE) {
            if (!events && (this.fill == null || this.fill == mxConstants.NONE)) {
              c.pointerEvents = false;
            }
            if (this.isRounded) {
              var r = 0;
              if (mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0) == "1") {
                r = Math.min(w2 / 2, Math.min(h2 / 2, mxUtils.getValue(
                  this.style,
                  mxConstants.STYLE_ARCSIZE,
                  mxConstants.LINE_ARCSIZE
                ) / 2));
              } else {
                var f = mxUtils.getValue(
                  this.style,
                  mxConstants.STYLE_ARCSIZE,
                  mxConstants.RECTANGLE_ROUNDING_FACTOR * 100
                ) / 100;
                r = Math.min(w2 * f, h2 * f);
              }
              c.roundrect(x, y, w2, h2, r, r);
            } else {
              c.rect(x, y, w2, h2);
            }
            c.fillAndStroke();
          }
        };
        mxRectangleShape.prototype.isRoundable = function(c, x, y, w2, h2) {
          return true;
        };
        mxRectangleShape.prototype.paintForeground = function(c, x, y, w2, h2) {
          if (this.glass && !this.outline && this.fill != null && this.fill != mxConstants.NONE) {
            this.paintGlassEffect(c, x, y, w2, h2, this.getArcSize(w2 + this.strokewidth, h2 + this.strokewidth));
          }
        };
        __mxOutput.mxRectangleShape = typeof mxRectangleShape !== "undefined" ? mxRectangleShape : void 0;
        function mxEllipse(bounds, fill, stroke, strokewidth) {
          mxShape.call(this);
          this.bounds = bounds;
          this.fill = fill;
          this.stroke = stroke;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
        }
        ;
        mxUtils.extend(mxEllipse, mxShape);
        mxEllipse.prototype.paintVertexShape = function(c, x, y, w2, h2) {
          c.ellipse(x, y, w2, h2);
          c.fillAndStroke();
        };
        __mxOutput.mxEllipse = typeof mxEllipse !== "undefined" ? mxEllipse : void 0;
        function mxDoubleEllipse(bounds, fill, stroke, strokewidth) {
          mxShape.call(this);
          this.bounds = bounds;
          this.fill = fill;
          this.stroke = stroke;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
        }
        ;
        mxUtils.extend(mxDoubleEllipse, mxShape);
        mxDoubleEllipse.prototype.vmlScale = 10;
        mxDoubleEllipse.prototype.paintBackground = function(c, x, y, w2, h2) {
          c.ellipse(x, y, w2, h2);
          c.fillAndStroke();
        };
        mxDoubleEllipse.prototype.paintForeground = function(c, x, y, w2, h2) {
          if (!this.outline) {
            var margin = mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(w2 / 5, h2 / 5)));
            x += margin;
            y += margin;
            w2 -= 2 * margin;
            h2 -= 2 * margin;
            if (w2 > 0 && h2 > 0) {
              c.ellipse(x, y, w2, h2);
            }
            c.stroke();
          }
        };
        mxDoubleEllipse.prototype.getLabelBounds = function(rect) {
          var margin = mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(
            3 + this.strokewidth,
            Math.min(rect.width / 5 / this.scale, rect.height / 5 / this.scale)
          )) * this.scale;
          return new mxRectangle(rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin);
        };
        __mxOutput.mxDoubleEllipse = typeof mxDoubleEllipse !== "undefined" ? mxDoubleEllipse : void 0;
        function mxRhombus(bounds, fill, stroke, strokewidth) {
          mxShape.call(this);
          this.bounds = bounds;
          this.fill = fill;
          this.stroke = stroke;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
        }
        ;
        mxUtils.extend(mxRhombus, mxShape);
        mxRhombus.prototype.isRoundable = function() {
          return true;
        };
        mxRhombus.prototype.paintVertexShape = function(c, x, y, w2, h2) {
          var hw = w2 / 2;
          var hh = h2 / 2;
          var arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
          c.begin();
          this.addPoints(c, [
            new mxPoint(x + hw, y),
            new mxPoint(x + w2, y + hh),
            new mxPoint(x + hw, y + h2),
            new mxPoint(x, y + hh)
          ], this.isRounded, arcSize, true);
          c.fillAndStroke();
        };
        __mxOutput.mxRhombus = typeof mxRhombus !== "undefined" ? mxRhombus : void 0;
        function mxPolyline(points, stroke, strokewidth) {
          mxShape.call(this);
          this.points = points;
          this.stroke = stroke;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
        }
        ;
        mxUtils.extend(mxPolyline, mxShape);
        mxPolyline.prototype.getRotation = function() {
          return 0;
        };
        mxPolyline.prototype.getShapeRotation = function() {
          return 0;
        };
        mxPolyline.prototype.isPaintBoundsInverted = function() {
          return false;
        };
        mxPolyline.prototype.paintEdgeShape = function(c, pts) {
          var prev = c.pointerEventsValue;
          c.pointerEventsValue = "stroke";
          if (this.style == null || this.style[mxConstants.STYLE_CURVED] != 1) {
            this.paintLine(c, pts, this.isRounded);
          } else {
            this.paintCurvedLine(c, pts);
          }
          c.pointerEventsValue = prev;
        };
        mxPolyline.prototype.paintLine = function(c, pts, rounded) {
          var arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
          c.begin();
          this.addPoints(c, pts, rounded, arcSize, false);
          c.stroke();
        };
        mxPolyline.prototype.paintCurvedLine = function(c, pts) {
          c.begin();
          var pt = pts[0];
          var n = pts.length;
          c.moveTo(pt.x, pt.y);
          for (var i = 1; i < n - 2; i++) {
            var p0 = pts[i];
            var p1 = pts[i + 1];
            var ix = (p0.x + p1.x) / 2;
            var iy = (p0.y + p1.y) / 2;
            c.quadTo(p0.x, p0.y, ix, iy);
          }
          var p0 = pts[n - 2];
          var p1 = pts[n - 1];
          c.quadTo(p0.x, p0.y, p1.x, p1.y);
          c.stroke();
        };
        __mxOutput.mxPolyline = typeof mxPolyline !== "undefined" ? mxPolyline : void 0;
        function mxPolygon(points, fill, stroke, strokewidth) {
          mxPolyline.call(this);
          this.points = points;
          this.stroke = stroke;
          this.fill = fill;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
        }
        ;
        mxUtils.extend(mxPolygon, mxPolyline);
        mxPolygon.prototype.paintLine = function(c, pts, rounded) {
          var arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
          c.begin();
          this.addPoints(c, pts, rounded, arcSize, true);
          c.fillAndStroke();
        };
        __mxOutput.mxPolygon = typeof mxPolygon !== "undefined" ? mxPolygon : void 0;
        function mxArrow(points, fill, stroke, strokewidth, arrowWidth, spacing, endSize) {
          mxShape.call(this);
          this.points = points;
          this.fill = fill;
          this.stroke = stroke;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
          this.arrowWidth = arrowWidth != null ? arrowWidth : mxConstants.ARROW_WIDTH;
          this.spacing = spacing != null ? spacing : mxConstants.ARROW_SPACING;
          this.endSize = endSize != null ? endSize : mxConstants.ARROW_SIZE;
        }
        ;
        mxUtils.extend(mxArrow, mxShape);
        mxArrow.prototype.augmentBoundingBox = function(bbox) {
          mxShape.prototype.augmentBoundingBox.apply(this, arguments);
          var w2 = Math.max(this.arrowWidth, this.endSize);
          bbox.grow((w2 / 2 + this.strokewidth) * this.scale);
        };
        mxArrow.prototype.paintEdgeShape = function(c, pts) {
          var spacing = mxConstants.ARROW_SPACING;
          var width = mxConstants.ARROW_WIDTH;
          var arrow = mxConstants.ARROW_SIZE;
          var p0 = pts[0];
          var pe = pts[pts.length - 1];
          var dx = pe.x - p0.x;
          var dy = pe.y - p0.y;
          var dist = Math.sqrt(dx * dx + dy * dy);
          var length = dist - 2 * spacing - arrow;
          var nx = dx / dist;
          var ny = dy / dist;
          var basex = length * nx;
          var basey = length * ny;
          var floorx = width * ny / 3;
          var floory = -width * nx / 3;
          var p0x = p0.x - floorx / 2 + spacing * nx;
          var p0y = p0.y - floory / 2 + spacing * ny;
          var p1x = p0x + floorx;
          var p1y = p0y + floory;
          var p2x = p1x + basex;
          var p2y = p1y + basey;
          var p3x = p2x + floorx;
          var p3y = p2y + floory;
          var p5x = p3x - 3 * floorx;
          var p5y = p3y - 3 * floory;
          c.begin();
          c.moveTo(p0x, p0y);
          c.lineTo(p1x, p1y);
          c.lineTo(p2x, p2y);
          c.lineTo(p3x, p3y);
          c.lineTo(pe.x - spacing * nx, pe.y - spacing * ny);
          c.lineTo(p5x, p5y);
          c.lineTo(p5x + floorx, p5y + floory);
          c.close();
          c.fillAndStroke();
        };
        __mxOutput.mxArrow = typeof mxArrow !== "undefined" ? mxArrow : void 0;
        function mxArrowConnector(points, fill, stroke, strokewidth, arrowWidth, spacing, endSize) {
          mxShape.call(this);
          this.points = points;
          this.fill = fill;
          this.stroke = stroke;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
          this.arrowWidth = arrowWidth != null ? arrowWidth : mxConstants.ARROW_WIDTH;
          this.arrowSpacing = spacing != null ? spacing : mxConstants.ARROW_SPACING;
          this.startSize = mxConstants.ARROW_SIZE / 5;
          this.endSize = mxConstants.ARROW_SIZE / 5;
        }
        ;
        mxUtils.extend(mxArrowConnector, mxShape);
        mxArrowConnector.prototype.useSvgBoundingBox = true;
        mxArrowConnector.prototype.isRoundable = function() {
          return true;
        };
        mxArrowConnector.prototype.resetStyles = function() {
          mxShape.prototype.resetStyles.apply(this, arguments);
          this.arrowSpacing = mxConstants.ARROW_SPACING;
        };
        mxArrowConnector.prototype.apply = function(state) {
          mxShape.prototype.apply.apply(this, arguments);
          if (this.style != null) {
            this.startSize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.ARROW_SIZE / 5) * 3;
            this.endSize = mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.ARROW_SIZE / 5) * 3;
          }
        };
        mxArrowConnector.prototype.augmentBoundingBox = function(bbox) {
          mxShape.prototype.augmentBoundingBox.apply(this, arguments);
          var w2 = this.getEdgeWidth();
          if (this.isMarkerStart()) {
            w2 = Math.max(w2, this.getStartArrowWidth());
          }
          if (this.isMarkerEnd()) {
            w2 = Math.max(w2, this.getEndArrowWidth());
          }
          bbox.grow((w2 / 2 + this.strokewidth) * this.scale);
        };
        mxArrowConnector.prototype.paintEdgeShape = function(c, pts) {
          var strokeWidth = this.strokewidth;
          if (this.outline) {
            strokeWidth = Math.max(1, mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth));
          }
          var startWidth = this.getStartArrowWidth() + strokeWidth;
          var endWidth = this.getEndArrowWidth() + strokeWidth;
          var edgeWidth = this.outline ? this.getEdgeWidth() + strokeWidth : this.getEdgeWidth();
          var openEnded = this.isOpenEnded();
          var markerStart = this.isMarkerStart();
          var markerEnd = this.isMarkerEnd();
          var spacing = openEnded ? 0 : this.arrowSpacing + strokeWidth / 2;
          var startSize = this.startSize + strokeWidth;
          var endSize = this.endSize + strokeWidth;
          var isRounded = this.isArrowRounded();
          var pe = pts[pts.length - 1];
          var i0 = 1;
          while (i0 < pts.length - 1 && pts[i0].x == pts[0].x && pts[i0].y == pts[0].y) {
            i0++;
          }
          var dx = pts[i0].x - pts[0].x;
          var dy = pts[i0].y - pts[0].y;
          var dist = Math.sqrt(dx * dx + dy * dy);
          if (dist == 0) {
            return;
          }
          var nx = dx / dist;
          var nx2, nx1 = nx;
          var ny = dy / dist;
          var ny2, ny1 = ny;
          var orthx = edgeWidth * ny;
          var orthy = -edgeWidth * nx;
          var fns = [];
          if (isRounded) {
            c.setLineJoin("round");
          } else if (pts.length > 2) {
            c.setMiterLimit(1.42);
          }
          c.begin();
          var startNx = nx;
          var startNy = ny;
          if (markerStart && !openEnded) {
            this.paintMarker(c, pts[0].x, pts[0].y, nx, ny, startSize, startWidth, edgeWidth, spacing, true);
          } else {
            var outStartX = pts[0].x + orthx / 2 + spacing * nx;
            var outStartY = pts[0].y + orthy / 2 + spacing * ny;
            var inEndX = pts[0].x - orthx / 2 + spacing * nx;
            var inEndY = pts[0].y - orthy / 2 + spacing * ny;
            if (openEnded) {
              c.moveTo(outStartX, outStartY);
              fns.push(function() {
                c.lineTo(inEndX, inEndY);
              });
            } else {
              c.moveTo(inEndX, inEndY);
              c.lineTo(outStartX, outStartY);
            }
          }
          var dx1 = 0;
          var dy1 = 0;
          var dist1 = 0;
          for (var i = 0; i < pts.length - 2; i++) {
            var pos = mxUtils.relativeCcw(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, pts[i + 2].x, pts[i + 2].y);
            dx1 = pts[i + 2].x - pts[i + 1].x;
            dy1 = pts[i + 2].y - pts[i + 1].y;
            dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            if (dist1 != 0) {
              nx1 = dx1 / dist1;
              ny1 = dy1 / dist1;
              var tmp1 = nx * nx1 + ny * ny1;
              var tmp = Math.max(Math.sqrt((tmp1 + 1) / 2), 0.04);
              nx2 = nx + nx1;
              ny2 = ny + ny1;
              var dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);
              if (dist2 != 0) {
                nx2 = nx2 / dist2;
                ny2 = ny2 / dist2;
                var strokeWidthFactor = Math.max(tmp, Math.min(this.strokewidth / 200 + 0.04, 0.35));
                var angleFactor = pos != 0 && isRounded ? Math.max(0.1, strokeWidthFactor) : Math.max(tmp, 0.06);
                var outX = pts[i + 1].x + ny2 * edgeWidth / 2 / angleFactor;
                var outY = pts[i + 1].y - nx2 * edgeWidth / 2 / angleFactor;
                var inX = pts[i + 1].x - ny2 * edgeWidth / 2 / angleFactor;
                var inY = pts[i + 1].y + nx2 * edgeWidth / 2 / angleFactor;
                if (pos == 0 || !isRounded) {
                  c.lineTo(outX, outY);
                  (function(x, y) {
                    fns.push(function() {
                      c.lineTo(x, y);
                    });
                  })(inX, inY);
                } else if (pos == -1) {
                  var c1x = inX + ny * edgeWidth;
                  var c1y = inY - nx * edgeWidth;
                  var c2x = inX + ny1 * edgeWidth;
                  var c2y = inY - nx1 * edgeWidth;
                  c.lineTo(c1x, c1y);
                  c.quadTo(outX, outY, c2x, c2y);
                  (function(x, y) {
                    fns.push(function() {
                      c.lineTo(x, y);
                    });
                  })(inX, inY);
                } else {
                  c.lineTo(outX, outY);
                  (function(x, y) {
                    var c1x2 = outX - ny * edgeWidth;
                    var c1y2 = outY + nx * edgeWidth;
                    var c2x2 = outX - ny1 * edgeWidth;
                    var c2y2 = outY + nx1 * edgeWidth;
                    fns.push(function() {
                      c.quadTo(x, y, c1x2, c1y2);
                    });
                    fns.push(function() {
                      c.lineTo(c2x2, c2y2);
                    });
                  })(inX, inY);
                }
                nx = nx1;
                ny = ny1;
              }
            }
          }
          orthx = edgeWidth * ny1;
          orthy = -edgeWidth * nx1;
          if (markerEnd && !openEnded) {
            this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, false);
          } else {
            c.lineTo(pe.x - spacing * nx1 + orthx / 2, pe.y - spacing * ny1 + orthy / 2);
            var inStartX = pe.x - spacing * nx1 - orthx / 2;
            var inStartY = pe.y - spacing * ny1 - orthy / 2;
            if (!openEnded) {
              c.lineTo(inStartX, inStartY);
            } else {
              c.moveTo(inStartX, inStartY);
              fns.splice(0, 0, function() {
                c.moveTo(inStartX, inStartY);
              });
            }
          }
          for (var i = fns.length - 1; i >= 0; i--) {
            fns[i]();
          }
          if (openEnded) {
            c.end();
            c.stroke();
          } else {
            c.close();
            c.fillAndStroke();
          }
          c.setShadow(false);
          c.setMiterLimit(4);
          if (isRounded) {
            c.setLineJoin("flat");
          }
          if (pts.length > 2) {
            c.setMiterLimit(4);
            if (markerStart && !openEnded) {
              c.begin();
              this.paintMarker(c, pts[0].x, pts[0].y, startNx, startNy, startSize, startWidth, edgeWidth, spacing, true);
              c.stroke();
              c.end();
            }
            if (markerEnd && !openEnded) {
              c.begin();
              this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, true);
              c.stroke();
              c.end();
            }
          }
        };
        mxArrowConnector.prototype.paintMarker = function(c, ptX, ptY, nx, ny, size, arrowWidth, edgeWidth, spacing, initialMove) {
          var widthArrowRatio = edgeWidth / arrowWidth;
          var orthx = edgeWidth * ny / 2;
          var orthy = -edgeWidth * nx / 2;
          var spaceX = (spacing + size) * nx;
          var spaceY = (spacing + size) * ny;
          if (initialMove) {
            c.moveTo(ptX - orthx + spaceX, ptY - orthy + spaceY);
          } else {
            c.lineTo(ptX - orthx + spaceX, ptY - orthy + spaceY);
          }
          c.lineTo(ptX - orthx / widthArrowRatio + spaceX, ptY - orthy / widthArrowRatio + spaceY);
          c.lineTo(ptX + spacing * nx, ptY + spacing * ny);
          c.lineTo(ptX + orthx / widthArrowRatio + spaceX, ptY + orthy / widthArrowRatio + spaceY);
          c.lineTo(ptX + orthx + spaceX, ptY + orthy + spaceY);
        };
        mxArrowConnector.prototype.isArrowRounded = function() {
          return this.isRounded;
        };
        mxArrowConnector.prototype.getStartArrowWidth = function() {
          return mxConstants.ARROW_WIDTH;
        };
        mxArrowConnector.prototype.getEndArrowWidth = function() {
          return mxConstants.ARROW_WIDTH;
        };
        mxArrowConnector.prototype.getEdgeWidth = function() {
          return mxConstants.ARROW_WIDTH / 3;
        };
        mxArrowConnector.prototype.isOpenEnded = function() {
          return false;
        };
        mxArrowConnector.prototype.isMarkerStart = function() {
          return mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE;
        };
        mxArrowConnector.prototype.isMarkerEnd = function() {
          return mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE;
        };
        __mxOutput.mxArrowConnector = typeof mxArrowConnector !== "undefined" ? mxArrowConnector : void 0;
        function mxText(value, bounds, align, valign, color, family, size, fontStyle, spacing, spacingTop, spacingRight, spacingBottom, spacingLeft, horizontal, background, border, wrap, clipped, overflow, labelPadding, textDirection) {
          mxShape.call(this);
          this.value = value;
          this.bounds = bounds;
          this.color = color != null ? color : "black";
          this.align = align != null ? align : mxConstants.ALIGN_CENTER;
          this.valign = valign != null ? valign : mxConstants.ALIGN_MIDDLE;
          this.family = family != null ? family : mxConstants.DEFAULT_FONTFAMILY;
          this.size = size != null ? size : mxConstants.DEFAULT_FONTSIZE;
          this.fontStyle = fontStyle != null ? fontStyle : mxConstants.DEFAULT_FONTSTYLE;
          this.spacing = parseInt(spacing || 2);
          this.spacingTop = this.spacing + parseInt(spacingTop || 0);
          this.spacingRight = this.spacing + parseInt(spacingRight || 0);
          this.spacingBottom = this.spacing + parseInt(spacingBottom || 0);
          this.spacingLeft = this.spacing + parseInt(spacingLeft || 0);
          this.horizontal = horizontal != null ? horizontal : true;
          this.background = background;
          this.border = border;
          this.wrap = wrap != null ? wrap : false;
          this.clipped = clipped != null ? clipped : false;
          this.overflow = overflow != null ? overflow : "visible";
          this.labelPadding = labelPadding != null ? labelPadding : 0;
          this.textDirection = textDirection;
          this.rotation = 0;
          this.updateMargin();
        }
        ;
        mxUtils.extend(mxText, mxShape);
        mxText.prototype.baseSpacingTop = 0;
        mxText.prototype.baseSpacingBottom = 0;
        mxText.prototype.baseSpacingLeft = 0;
        mxText.prototype.baseSpacingRight = 0;
        mxText.prototype.replaceLinefeeds = true;
        mxText.prototype.verticalTextRotation = -90;
        mxText.prototype.ignoreClippedStringSize = true;
        mxText.prototype.ignoreStringSize = false;
        mxText.prototype.textWidthPadding = document.documentMode == 8 && !mxClient.IS_EM ? 4 : 3;
        mxText.prototype.lastValue = null;
        mxText.prototype.cacheEnabled = true;
        mxText.prototype.isParseVml = function() {
          return false;
        };
        mxText.prototype.isHtmlAllowed = function() {
          return document.documentMode != 8 || mxClient.IS_EM;
        };
        mxText.prototype.getSvgScreenOffset = function() {
          return 0;
        };
        mxText.prototype.checkBounds = function() {
          return !isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 && this.bounds != null && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height);
        };
        mxText.prototype.paint = function(c, update) {
          var s = this.scale;
          var x = this.bounds.x / s;
          var y = this.bounds.y / s;
          var w2 = this.bounds.width / s;
          var h2 = this.bounds.height / s;
          this.updateTransform(c, x, y, w2, h2);
          this.configureCanvas(c, x, y, w2, h2);
          if (update) {
            c.updateText(
              x,
              y,
              w2,
              h2,
              this.align,
              this.valign,
              this.wrap,
              this.overflow,
              this.clipped,
              this.getTextRotation(),
              this.node
            );
          } else {
            var realHtml = mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML;
            var fmt = realHtml || c instanceof mxVmlCanvas2D ? "html" : "";
            var val = this.value;
            if (!realHtml && fmt == "html") {
              val = mxUtils.htmlEntities(val, false);
            }
            if (fmt == "html" && !mxUtils.isNode(this.value)) {
              val = mxUtils.replaceTrailingNewlines(val, "<div><br></div>");
            }
            val = !mxUtils.isNode(this.value) && this.replaceLinefeeds && fmt == "html" ? val.replace(/\n/g, "<br/>") : val;
            var dir = this.textDirection;
            if (dir == mxConstants.TEXT_DIRECTION_AUTO && !realHtml) {
              dir = this.getAutoDirection();
            }
            if (dir != mxConstants.TEXT_DIRECTION_LTR && dir != mxConstants.TEXT_DIRECTION_RTL) {
              dir = null;
            }
            c.text(
              x,
              y,
              w2,
              h2,
              val,
              this.align,
              this.valign,
              this.wrap,
              fmt,
              this.overflow,
              this.clipped,
              this.getTextRotation(),
              dir
            );
          }
        };
        mxText.prototype.redraw = function() {
          if (this.visible && this.checkBounds() && this.cacheEnabled && this.lastValue == this.value && (mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML)) {
            if (this.node.nodeName == "DIV" && (this.isHtmlAllowed() || !mxClient.IS_VML)) {
              if (mxClient.IS_SVG) {
                this.redrawHtmlShapeWithCss3();
              } else {
                this.updateSize(this.node, this.state == null || this.state.view.textDiv == null);
                if (mxClient.IS_IE && (document.documentMode == null || document.documentMode <= 8)) {
                  this.updateHtmlFilter();
                } else {
                  this.updateHtmlTransform();
                }
              }
              this.updateBoundingBox();
            } else {
              var canvas = this.createCanvas();
              if (canvas != null && canvas.updateText != null) {
                canvas.pointerEvents = this.pointerEvents;
                this.paint(canvas, true);
                this.destroyCanvas(canvas);
                this.updateBoundingBox();
              } else {
                mxShape.prototype.redraw.apply(this, arguments);
              }
            }
          } else {
            mxShape.prototype.redraw.apply(this, arguments);
            if (mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML) {
              this.lastValue = this.value;
            } else {
              this.lastValue = null;
            }
          }
        };
        mxText.prototype.resetStyles = function() {
          mxShape.prototype.resetStyles.apply(this, arguments);
          this.color = "black";
          this.align = mxConstants.ALIGN_CENTER;
          this.valign = mxConstants.ALIGN_MIDDLE;
          this.family = mxConstants.DEFAULT_FONTFAMILY;
          this.size = mxConstants.DEFAULT_FONTSIZE;
          this.fontStyle = mxConstants.DEFAULT_FONTSTYLE;
          this.spacing = 2;
          this.spacingTop = 2;
          this.spacingRight = 2;
          this.spacingBottom = 2;
          this.spacingLeft = 2;
          this.horizontal = true;
          delete this.background;
          delete this.border;
          this.textDirection = mxConstants.DEFAULT_TEXT_DIRECTION;
          delete this.margin;
        };
        mxText.prototype.apply = function(state) {
          var old = this.spacing;
          mxShape.prototype.apply.apply(this, arguments);
          if (this.style != null) {
            this.fontStyle = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSTYLE, this.fontStyle);
            this.family = mxUtils.getValue(this.style, mxConstants.STYLE_FONTFAMILY, this.family);
            this.size = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, this.size);
            this.color = mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, this.color);
            this.align = mxUtils.getValue(this.style, mxConstants.STYLE_ALIGN, this.align);
            this.valign = mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_ALIGN, this.valign);
            this.spacing = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing));
            this.spacingTop = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_TOP, this.spacingTop - old)) + this.spacing;
            this.spacingRight = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_RIGHT, this.spacingRight - old)) + this.spacing;
            this.spacingBottom = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_BOTTOM, this.spacingBottom - old)) + this.spacing;
            this.spacingLeft = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_LEFT, this.spacingLeft - old)) + this.spacing;
            this.horizontal = mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, this.horizontal);
            this.background = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BACKGROUNDCOLOR, this.background);
            this.border = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BORDERCOLOR, this.border);
            this.textDirection = mxUtils.getValue(this.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);
            this.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_TEXT_OPACITY, 100);
            this.updateMargin();
          }
          this.flipV = null;
          this.flipH = null;
        };
        mxText.prototype.getAutoDirection = function() {
          var tmp = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(this.value);
          return tmp != null && tmp.length > 0 && tmp[0] > "z" ? mxConstants.TEXT_DIRECTION_RTL : mxConstants.TEXT_DIRECTION_LTR;
        };
        mxText.prototype.getContentNode = function() {
          var result2 = this.node;
          if (result2 != null) {
            if (result2.ownerSVGElement == null) {
              result2 = this.node.firstChild.firstChild;
            } else {
              result2 = result2.firstChild.firstChild.firstChild.firstChild.firstChild;
            }
          }
          return result2;
        };
        mxText.prototype.updateBoundingBox = function() {
          var node = this.node;
          this.boundingBox = this.bounds.clone();
          var rot = this.getTextRotation();
          var h2 = this.style != null ? mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER) : null;
          var v = this.style != null ? mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE) : null;
          if (!this.ignoreStringSize && node != null && this.overflow != "fill" && (!this.clipped || !this.ignoreClippedStringSize || h2 != mxConstants.ALIGN_CENTER || v != mxConstants.ALIGN_MIDDLE)) {
            var ow = null;
            var oh = null;
            if (node.ownerSVGElement != null) {
              if (node.firstChild != null && node.firstChild.firstChild != null && node.firstChild.firstChild.nodeName == "foreignObject") {
                node = node.firstChild.firstChild.firstChild.firstChild;
                oh = node.offsetHeight * this.scale;
                if (this.overflow == "width") {
                  ow = this.boundingBox.width;
                } else {
                  ow = node.offsetWidth * this.scale;
                }
              } else {
                try {
                  var b = node.getBBox();
                  if (typeof this.value == "string" && mxUtils.trim(this.value) == 0) {
                    this.boundingBox = null;
                  } else if (b.width == 0 && b.height == 0) {
                    this.boundingBox = null;
                  } else {
                    this.boundingBox = new mxRectangle(b.x, b.y, b.width, b.height);
                  }
                  return;
                } catch (e) {
                }
              }
            } else {
              var td2 = this.state != null ? this.state.view.textDiv : null;
              if (this.offsetWidth != null && this.offsetHeight != null) {
                ow = this.offsetWidth * this.scale;
                oh = this.offsetHeight * this.scale;
              } else {
                if (td2 != null) {
                  this.updateFont(td2);
                  this.updateSize(td2, false);
                  this.updateInnerHtml(td2);
                  node = td2;
                }
                var sizeDiv = node;
                if (document.documentMode == 8 && !mxClient.IS_EM) {
                  var w2 = Math.round(this.bounds.width / this.scale);
                  if (this.wrap && w2 > 0) {
                    node.style.wordWrap = mxConstants.WORD_WRAP;
                    node.style.whiteSpace = "normal";
                    if (node.style.wordWrap != "break-word") {
                      var divs = sizeDiv.getElementsByTagName("div");
                      if (divs.length > 0) {
                        sizeDiv = divs[divs.length - 1];
                      }
                      ow = sizeDiv.offsetWidth + 2;
                      divs = this.node.getElementsByTagName("div");
                      if (this.clipped) {
                        ow = Math.min(w2, ow);
                      }
                      if (divs.length > 1) {
                        divs[divs.length - 2].style.width = ow + "px";
                      }
                    }
                  } else {
                    node.style.whiteSpace = "nowrap";
                  }
                } else if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == "DIV") {
                  sizeDiv = sizeDiv.firstChild;
                }
                this.offsetWidth = sizeDiv.offsetWidth + this.textWidthPadding;
                this.offsetHeight = sizeDiv.offsetHeight;
                ow = this.offsetWidth * this.scale;
                oh = this.offsetHeight * this.scale;
              }
            }
            if (ow != null && oh != null) {
              this.boundingBox = new mxRectangle(
                this.bounds.x,
                this.bounds.y,
                ow,
                oh
              );
            }
          }
          if (this.boundingBox != null) {
            if (rot != 0) {
              var bbox = mxUtils.getBoundingBox(
                new mxRectangle(
                  this.margin.x * this.boundingBox.width,
                  this.margin.y * this.boundingBox.height,
                  this.boundingBox.width,
                  this.boundingBox.height
                ),
                rot,
                new mxPoint(0, 0)
              );
              this.unrotatedBoundingBox = mxRectangle.fromRectangle(this.boundingBox);
              this.unrotatedBoundingBox.x += this.margin.x * this.unrotatedBoundingBox.width;
              this.unrotatedBoundingBox.y += this.margin.y * this.unrotatedBoundingBox.height;
              this.boundingBox.x += bbox.x;
              this.boundingBox.y += bbox.y;
              this.boundingBox.width = bbox.width;
              this.boundingBox.height = bbox.height;
            } else {
              this.boundingBox.x += this.margin.x * this.boundingBox.width;
              this.boundingBox.y += this.margin.y * this.boundingBox.height;
              this.unrotatedBoundingBox = null;
            }
          }
        };
        mxText.prototype.getShapeRotation = function() {
          return 0;
        };
        mxText.prototype.getTextRotation = function() {
          return this.state != null && this.state.shape != null ? this.state.shape.getTextRotation() : 0;
        };
        mxText.prototype.isPaintBoundsInverted = function() {
          return !this.horizontal && this.state != null && this.state.view.graph.model.isVertex(this.state.cell);
        };
        mxText.prototype.configureCanvas = function(c, x, y, w2, h2) {
          mxShape.prototype.configureCanvas.apply(this, arguments);
          c.setFontColor(this.color);
          c.setFontBackgroundColor(this.background);
          c.setFontBorderColor(this.border);
          c.setFontFamily(this.family);
          c.setFontSize(this.size);
          c.setFontStyle(this.fontStyle);
        };
        mxText.prototype.updateVmlContainer = function() {
          this.node.style.left = Math.round(this.bounds.x) + "px";
          this.node.style.top = Math.round(this.bounds.y) + "px";
          this.node.style.width = "1px";
          this.node.style.height = "1px";
          this.node.style.overflow = "visible";
        };
        mxText.prototype.getHtmlValue = function() {
          var val = this.value;
          if (this.dialect != mxConstants.DIALECT_STRICTHTML) {
            val = mxUtils.htmlEntities(val, false);
          }
          val = mxUtils.replaceTrailingNewlines(val, "<div><br></div>");
          val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
          return val;
        };
        mxText.prototype.getTextCss = function() {
          var lh = mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT;
          var css = "display: inline-block; font-size: " + this.size + "px; font-family: " + this.family + "; color: " + this.color + "; line-height: " + lh + "; pointer-events: " + (this.pointerEvents ? "all" : "none") + "; ";
          if ((this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
            css += "font-weight: bold; ";
          }
          if ((this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
            css += "font-style: italic; ";
          }
          var deco = [];
          if ((this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
            deco.push("underline");
          }
          if ((this.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
            deco.push("line-through");
          }
          if (deco.length > 0) {
            css += "text-decoration: " + deco.join(" ") + "; ";
          }
          return css;
        };
        mxText.prototype.redrawHtmlShape = function() {
          if (mxClient.IS_SVG) {
            this.redrawHtmlShapeWithCss3();
          } else {
            var style = this.node.style;
            style.whiteSpace = "normal";
            style.overflow = "";
            style.width = "";
            style.height = "";
            this.updateValue();
            this.updateFont(this.node);
            this.updateSize(this.node, this.state == null || this.state.view.textDiv == null);
            this.offsetWidth = null;
            this.offsetHeight = null;
            if (mxClient.IS_IE && (document.documentMode == null || document.documentMode <= 8)) {
              this.updateHtmlFilter();
            } else {
              this.updateHtmlTransform();
            }
          }
        };
        mxText.prototype.redrawHtmlShapeWithCss3 = function() {
          var w2 = Math.max(0, Math.round(this.bounds.width / this.scale));
          var h2 = Math.max(0, Math.round(this.bounds.height / this.scale));
          var flex = "position: absolute; left: " + Math.round(this.bounds.x) + "px; top: " + Math.round(this.bounds.y) + "px; pointer-events: none; ";
          var block = this.getTextCss();
          mxSvgCanvas2D.createCss(
            w2 + 2,
            h2,
            this.align,
            this.valign,
            this.wrap,
            this.overflow,
            this.clipped,
            this.background != null ? mxUtils.htmlEntities(this.background) : null,
            this.border != null ? mxUtils.htmlEntities(this.border) : null,
            flex,
            block,
            this.scale,
            mxUtils.bind(this, function(dx, dy, flex2, item, block2, ofl) {
              var r = this.getTextRotation();
              var tr = (this.scale != 1 ? "scale(" + this.scale + ") " : "") + (r != 0 ? "rotate(" + r + "deg) " : "") + (this.margin.x != 0 || this.margin.y != 0 ? "translate(" + this.margin.x * 100 + "%," + this.margin.y * 100 + "%)" : "");
              if (tr != "") {
                tr = "transform-origin: 0 0; transform: " + tr + "; ";
              }
              if (ofl == "") {
                flex2 += item;
                item = "display:inline-block; min-width: 100%; " + tr;
              } else {
                item += tr;
                if (mxClient.IS_SF) {
                  item += "-webkit-clip-path: content-box;";
                }
              }
              if (this.opacity < 100) {
                block2 += "opacity: " + this.opacity / 100 + "; ";
              }
              this.node.setAttribute("style", flex2);
              var html = mxUtils.isNode(this.value) ? this.value.outerHTML : this.getHtmlValue();
              if (this.node.firstChild == null) {
                this.node.innerHTML = "<div><div>" + html + "</div></div>";
              }
              this.node.firstChild.firstChild.setAttribute("style", block2);
              this.node.firstChild.setAttribute("style", item);
            })
          );
        };
        mxText.prototype.updateHtmlTransform = function() {
          var theta = this.getTextRotation();
          var style = this.node.style;
          var dx = this.margin.x;
          var dy = this.margin.y;
          if (theta != 0) {
            mxUtils.setPrefixedStyle(style, "transformOrigin", -dx * 100 + "% " + -dy * 100 + "%");
            mxUtils.setPrefixedStyle(style, "transform", "translate(" + dx * 100 + "%," + dy * 100 + "%) scale(" + this.scale + ") rotate(" + theta + "deg)");
          } else {
            mxUtils.setPrefixedStyle(style, "transformOrigin", "0% 0%");
            mxUtils.setPrefixedStyle(style, "transform", "scale(" + this.scale + ") translate(" + dx * 100 + "%," + dy * 100 + "%)");
          }
          style.left = Math.round(this.bounds.x - Math.ceil(dx * (this.overflow != "fill" && this.overflow != "width" ? 3 : 1))) + "px";
          style.top = Math.round(this.bounds.y - dy * (this.overflow != "fill" ? 3 : 1)) + "px";
          if (this.opacity < 100) {
            style.opacity = this.opacity / 100;
          } else {
            style.opacity = "";
          }
        };
        mxText.prototype.updateInnerHtml = function(elt) {
          if (mxUtils.isNode(this.value)) {
            elt.innerHTML = this.value.outerHTML;
          } else {
            var val = this.value;
            if (this.dialect != mxConstants.DIALECT_STRICTHTML) {
              val = mxUtils.htmlEntities(val, false);
            }
            val = mxUtils.replaceTrailingNewlines(val, "<div>&nbsp;</div>");
            val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
            val = '<div style="display:inline-block;_display:inline;">' + val + "</div>";
            elt.innerHTML = val;
          }
        };
        mxText.prototype.updateHtmlFilter = function() {
          var style = this.node.style;
          var dx = this.margin.x;
          var dy = this.margin.y;
          var s = this.scale;
          mxUtils.setOpacity(this.node, this.opacity);
          var ow = 0;
          var oh = 0;
          var td2 = this.state != null ? this.state.view.textDiv : null;
          var sizeDiv = this.node;
          if (td2 != null) {
            td2.style.overflow = "";
            td2.style.height = "";
            td2.style.width = "";
            this.updateFont(td2);
            this.updateSize(td2, false);
            this.updateInnerHtml(td2);
            var w2 = Math.round(this.bounds.width / this.scale);
            if (this.wrap && w2 > 0) {
              td2.style.whiteSpace = "normal";
              td2.style.wordWrap = mxConstants.WORD_WRAP;
              ow = w2;
              if (this.clipped) {
                ow = Math.min(ow, this.bounds.width);
              }
              td2.style.width = ow + "px";
            } else {
              td2.style.whiteSpace = "nowrap";
            }
            sizeDiv = td2;
            if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == "DIV") {
              sizeDiv = sizeDiv.firstChild;
              if (this.wrap && td2.style.wordWrap == "break-word") {
                sizeDiv.style.width = "100%";
              }
            }
            if (!this.clipped && this.wrap && w2 > 0) {
              ow = sizeDiv.offsetWidth + this.textWidthPadding;
              td2.style.width = ow + "px";
            }
            oh = sizeDiv.offsetHeight + 2;
            if (mxClient.IS_QUIRKS && this.border != null && this.border != mxConstants.NONE) {
              oh += 3;
            }
          } else if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == "DIV") {
            sizeDiv = sizeDiv.firstChild;
            oh = sizeDiv.offsetHeight;
          }
          ow = sizeDiv.offsetWidth + this.textWidthPadding;
          if (this.clipped) {
            oh = Math.min(oh, this.bounds.height);
          }
          var w2 = this.bounds.width / s;
          var h2 = this.bounds.height / s;
          if (this.overflow == "fill") {
            oh = h2;
            ow = w2;
          } else if (this.overflow == "width") {
            oh = sizeDiv.scrollHeight;
            ow = w2;
          }
          this.offsetWidth = ow;
          this.offsetHeight = oh;
          if (mxClient.IS_QUIRKS && (this.clipped || this.overflow == "width" && h2 > 0)) {
            h2 = Math.min(h2, oh);
            style.height = Math.round(h2) + "px";
          } else {
            h2 = oh;
          }
          if (this.overflow != "fill" && this.overflow != "width") {
            if (this.clipped) {
              ow = Math.min(w2, ow);
            }
            w2 = ow;
            if (mxClient.IS_QUIRKS && this.clipped || this.wrap) {
              style.width = Math.round(w2) + "px";
            }
          }
          h2 *= s;
          w2 *= s;
          var rad = this.getTextRotation() * (Math.PI / 180);
          var real_cos = parseFloat(parseFloat(Math.cos(rad)).toFixed(8));
          var real_sin = parseFloat(parseFloat(Math.sin(-rad)).toFixed(8));
          rad %= 2 * Math.PI;
          if (rad < 0) {
            rad += 2 * Math.PI;
          }
          rad %= Math.PI;
          if (rad > Math.PI / 2) {
            rad = Math.PI - rad;
          }
          var cos = Math.cos(rad);
          var sin = Math.sin(-rad);
          var tx = w2 * -(dx + 0.5);
          var ty = h2 * -(dy + 0.5);
          var top_fix = (h2 - h2 * cos + w2 * sin) / 2 + real_sin * tx - real_cos * ty;
          var left_fix = (w2 - w2 * cos + h2 * sin) / 2 - real_cos * tx - real_sin * ty;
          if (rad != 0) {
            var f = "progid:DXImageTransform.Microsoft.Matrix(M11=" + real_cos + ", M12=" + real_sin + ", M21=" + -real_sin + ", M22=" + real_cos + ", sizingMethod='auto expand')";
            if (style.filter != null && style.filter.length > 0) {
              style.filter += " " + f;
            } else {
              style.filter = f;
            }
          }
          var dy = 0;
          if (this.overflow != "fill" && mxClient.IS_QUIRKS) {
            if (this.valign == mxConstants.ALIGN_TOP) {
              dy -= 1;
            } else if (this.valign == mxConstants.ALIGN_BOTTOM) {
              dy += 2;
            } else {
              dy += 1;
            }
          }
          style.zoom = s;
          style.left = Math.round(this.bounds.x + left_fix - w2 / 2) + "px";
          style.top = Math.round(this.bounds.y + top_fix - h2 / 2 + dy) + "px";
        };
        mxText.prototype.updateValue = function() {
          if (mxUtils.isNode(this.value)) {
            this.node.innerHTML = "";
            this.node.appendChild(this.value);
          } else {
            var val = this.value;
            if (this.dialect != mxConstants.DIALECT_STRICTHTML) {
              val = mxUtils.htmlEntities(val, false);
            }
            val = mxUtils.replaceTrailingNewlines(val, "<div><br></div>");
            val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
            var bg = this.background != null && this.background != mxConstants.NONE ? this.background : null;
            var bd = this.border != null && this.border != mxConstants.NONE ? this.border : null;
            if (this.overflow == "fill" || this.overflow == "width") {
              if (bg != null) {
                this.node.style.backgroundColor = bg;
              }
              if (bd != null) {
                this.node.style.border = "1px solid " + bd;
              }
            } else {
              var css = "";
              if (bg != null) {
                css += "background-color:" + mxUtils.htmlEntities(bg) + ";";
              }
              if (bd != null) {
                css += "border:1px solid " + mxUtils.htmlEntities(bd) + ";";
              }
              var lh = mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT;
              val = '<div style="zoom:1;' + css + "display:inline-block;_display:inline;text-decoration:inherit;padding-bottom:1px;padding-right:1px;line-height:" + lh + '">' + val + "</div>";
            }
            this.node.innerHTML = val;
            var divs = this.node.getElementsByTagName("div");
            if (divs.length > 0) {
              var dir = this.textDirection;
              if (dir == mxConstants.TEXT_DIRECTION_AUTO && this.dialect != mxConstants.DIALECT_STRICTHTML) {
                dir = this.getAutoDirection();
              }
              if (dir == mxConstants.TEXT_DIRECTION_LTR || dir == mxConstants.TEXT_DIRECTION_RTL) {
                divs[divs.length - 1].setAttribute("dir", dir);
              } else {
                divs[divs.length - 1].removeAttribute("dir");
              }
            }
          }
        };
        mxText.prototype.updateFont = function(node) {
          var style = node.style;
          style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + "px" : mxConstants.LINE_HEIGHT;
          style.fontSize = this.size + "px";
          style.fontFamily = this.family;
          style.verticalAlign = "top";
          style.color = this.color;
          if ((this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {
            style.fontWeight = "bold";
          } else {
            style.fontWeight = "";
          }
          if ((this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {
            style.fontStyle = "italic";
          } else {
            style.fontStyle = "";
          }
          var txtDecor = [];
          if ((this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
            txtDecor.push("underline");
          }
          if ((this.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
            txtDecor.push("line-through");
          }
          style.textDecoration = txtDecor.join(" ");
          if (this.align == mxConstants.ALIGN_CENTER) {
            style.textAlign = "center";
          } else if (this.align == mxConstants.ALIGN_RIGHT) {
            style.textAlign = "right";
          } else {
            style.textAlign = "left";
          }
        };
        mxText.prototype.updateSize = function(node, enableWrap) {
          var w2 = Math.max(0, Math.round(this.bounds.width / this.scale));
          var h2 = Math.max(0, Math.round(this.bounds.height / this.scale));
          var style = node.style;
          if (this.clipped) {
            style.overflow = "hidden";
            if (!mxClient.IS_QUIRKS) {
              style.maxHeight = h2 + "px";
              style.maxWidth = w2 + "px";
            } else {
              style.width = w2 + "px";
            }
          } else if (this.overflow == "fill") {
            style.width = w2 + 1 + "px";
            style.height = h2 + 1 + "px";
            style.overflow = "hidden";
          } else if (this.overflow == "width") {
            style.width = w2 + 1 + "px";
            style.maxHeight = h2 + 1 + "px";
            style.overflow = "hidden";
          }
          if (this.wrap && w2 > 0) {
            style.wordWrap = mxConstants.WORD_WRAP;
            style.whiteSpace = "normal";
            style.width = w2 + "px";
            if (enableWrap && this.overflow != "fill" && this.overflow != "width") {
              var sizeDiv = node;
              if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == "DIV") {
                sizeDiv = sizeDiv.firstChild;
                if (node.style.wordWrap == "break-word") {
                  sizeDiv.style.width = "100%";
                }
              }
              var tmp = sizeDiv.offsetWidth;
              if (tmp == 0) {
                var prev = node.parentNode;
                node.style.visibility = "hidden";
                document.body.appendChild(node);
                tmp = sizeDiv.offsetWidth;
                node.style.visibility = "";
                prev.appendChild(node);
              }
              tmp += 3;
              if (this.clipped) {
                tmp = Math.min(tmp, w2);
              }
              style.width = tmp + "px";
            }
          } else {
            style.whiteSpace = "nowrap";
          }
        };
        mxText.prototype.updateMargin = function() {
          this.margin = mxUtils.getAlignmentAsPoint(this.align, this.valign);
        };
        mxText.prototype.getSpacing = function() {
          var dx = 0;
          var dy = 0;
          if (this.align == mxConstants.ALIGN_CENTER) {
            dx = (this.spacingLeft - this.spacingRight) / 2;
          } else if (this.align == mxConstants.ALIGN_RIGHT) {
            dx = -this.spacingRight - this.baseSpacingRight;
          } else {
            dx = this.spacingLeft + this.baseSpacingLeft;
          }
          if (this.valign == mxConstants.ALIGN_MIDDLE) {
            dy = (this.spacingTop - this.spacingBottom) / 2;
          } else if (this.valign == mxConstants.ALIGN_BOTTOM) {
            dy = -this.spacingBottom - this.baseSpacingBottom;
            ;
          } else {
            dy = this.spacingTop + this.baseSpacingTop;
          }
          return new mxPoint(dx, dy);
        };
        __mxOutput.mxText = typeof mxText !== "undefined" ? mxText : void 0;
        function mxTriangle() {
          mxActor.call(this);
        }
        ;
        mxUtils.extend(mxTriangle, mxActor);
        mxTriangle.prototype.isRoundable = function() {
          return true;
        };
        mxTriangle.prototype.redrawPath = function(c, x, y, w2, h2) {
          var arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
          this.addPoints(c, [new mxPoint(0, 0), new mxPoint(w2, 0.5 * h2), new mxPoint(0, h2)], this.isRounded, arcSize, true);
        };
        __mxOutput.mxTriangle = typeof mxTriangle !== "undefined" ? mxTriangle : void 0;
        function mxHexagon() {
          mxActor.call(this);
        }
        ;
        mxUtils.extend(mxHexagon, mxActor);
        mxHexagon.prototype.redrawPath = function(c, x, y, w2, h2) {
          var arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
          this.addPoints(c, [
            new mxPoint(0.25 * w2, 0),
            new mxPoint(0.75 * w2, 0),
            new mxPoint(w2, 0.5 * h2),
            new mxPoint(0.75 * w2, h2),
            new mxPoint(0.25 * w2, h2),
            new mxPoint(0, 0.5 * h2)
          ], this.isRounded, arcSize, true);
        };
        __mxOutput.mxHexagon = typeof mxHexagon !== "undefined" ? mxHexagon : void 0;
        function mxLine(bounds, stroke, strokewidth, vertical) {
          mxShape.call(this);
          this.bounds = bounds;
          this.stroke = stroke;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
          this.vertical = vertical != null ? vertical : this.vertical;
        }
        ;
        mxUtils.extend(mxLine, mxShape);
        mxLine.prototype.vertical = false;
        mxLine.prototype.paintVertexShape = function(c, x, y, w2, h2) {
          c.begin();
          if (this.vertical) {
            var mid = x + w2 / 2;
            c.moveTo(mid, y);
            c.lineTo(mid, y + h2);
          } else {
            var mid = y + h2 / 2;
            c.moveTo(x, mid);
            c.lineTo(x + w2, mid);
          }
          c.stroke();
        };
        __mxOutput.mxLine = typeof mxLine !== "undefined" ? mxLine : void 0;
        function mxImageShape(bounds, image, fill, stroke, strokewidth) {
          mxShape.call(this);
          this.bounds = bounds;
          this.image = image;
          this.fill = fill;
          this.stroke = stroke;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
          this.shadow = false;
        }
        ;
        mxUtils.extend(mxImageShape, mxRectangleShape);
        mxImageShape.prototype.preserveImageAspect = true;
        mxImageShape.prototype.getSvgScreenOffset = function() {
          return 0;
        };
        mxImageShape.prototype.apply = function(state) {
          mxShape.prototype.apply.apply(this, arguments);
          this.fill = null;
          this.stroke = null;
          this.gradient = null;
          if (this.style != null) {
            this.preserveImageAspect = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_ASPECT, 1) == 1;
            this.flipH = this.flipH || mxUtils.getValue(this.style, "imageFlipH", 0) == 1;
            this.flipV = this.flipV || mxUtils.getValue(this.style, "imageFlipV", 0) == 1;
          }
        };
        mxImageShape.prototype.isHtmlAllowed = function() {
          return !this.preserveImageAspect;
        };
        mxImageShape.prototype.createHtml = function() {
          var node = document.createElement("div");
          node.style.position = "absolute";
          return node;
        };
        mxImageShape.prototype.isRoundable = function(c, x, y, w2, h2) {
          return false;
        };
        mxImageShape.prototype.paintVertexShape = function(c, x, y, w2, h2) {
          if (this.image != null) {
            var fill = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, null);
            var stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null);
            if (fill != null) {
              c.setFillColor(fill);
              c.setStrokeColor(stroke);
              c.rect(x, y, w2, h2);
              c.fillAndStroke();
            }
            c.image(x, y, w2, h2, this.image, this.preserveImageAspect, false, false);
            var stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null);
            if (stroke != null) {
              c.setShadow(false);
              c.setStrokeColor(stroke);
              c.rect(x, y, w2, h2);
              c.stroke();
            }
          } else {
            mxRectangleShape.prototype.paintBackground.apply(this, arguments);
          }
        };
        mxImageShape.prototype.redrawHtmlShape = function() {
          this.node.style.left = Math.round(this.bounds.x) + "px";
          this.node.style.top = Math.round(this.bounds.y) + "px";
          this.node.style.width = Math.max(0, Math.round(this.bounds.width)) + "px";
          this.node.style.height = Math.max(0, Math.round(this.bounds.height)) + "px";
          this.node.innerHTML = "";
          if (this.image != null) {
            var fill = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, "");
            var stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, "");
            this.node.style.backgroundColor = fill;
            this.node.style.borderColor = stroke;
            var useVml = mxClient.IS_IE6 || (document.documentMode == null || document.documentMode <= 8) && this.rotation != 0;
            var img = document.createElement(useVml ? mxClient.VML_PREFIX + ":image" : "img");
            img.setAttribute("border", "0");
            img.style.position = "absolute";
            img.src = this.image;
            var filter = this.opacity < 100 ? "alpha(opacity=" + this.opacity + ")" : "";
            this.node.style.filter = filter;
            if (this.flipH && this.flipV) {
              filter += "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
            } else if (this.flipH) {
              filter += "progid:DXImageTransform.Microsoft.BasicImage(mirror=1)";
            } else if (this.flipV) {
              filter += "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
            }
            if (img.style.filter != filter) {
              img.style.filter = filter;
            }
            if (img.nodeName == "image") {
              img.style.rotation = this.rotation;
            } else if (this.rotation != 0) {
              mxUtils.setPrefixedStyle(img.style, "transform", "rotate(" + this.rotation + "deg)");
            } else {
              mxUtils.setPrefixedStyle(img.style, "transform", "");
            }
            img.style.width = this.node.style.width;
            img.style.height = this.node.style.height;
            this.node.style.backgroundImage = "";
            this.node.appendChild(img);
          } else {
            this.setTransparentBackgroundImage(this.node);
          }
        };
        __mxOutput.mxImageShape = typeof mxImageShape !== "undefined" ? mxImageShape : void 0;
        function mxLabel(bounds, fill, stroke, strokewidth) {
          mxRectangleShape.call(this, bounds, fill, stroke, strokewidth);
        }
        ;
        mxUtils.extend(mxLabel, mxRectangleShape);
        mxLabel.prototype.imageSize = mxConstants.DEFAULT_IMAGESIZE;
        mxLabel.prototype.spacing = 2;
        mxLabel.prototype.indicatorSize = 10;
        mxLabel.prototype.indicatorSpacing = 2;
        mxLabel.prototype.init = function(container) {
          mxShape.prototype.init.apply(this, arguments);
          if (this.indicatorShape != null) {
            this.indicator = new this.indicatorShape();
            this.indicator.dialect = this.dialect;
            this.indicator.init(this.node);
          }
        };
        mxLabel.prototype.redraw = function() {
          if (this.indicator != null) {
            this.indicator.fill = this.indicatorColor;
            this.indicator.stroke = this.indicatorStrokeColor;
            this.indicator.gradient = this.indicatorGradientColor;
            this.indicator.direction = this.indicatorDirection;
            this.indicator.redraw();
          }
          mxShape.prototype.redraw.apply(this, arguments);
        };
        mxLabel.prototype.isHtmlAllowed = function() {
          return mxRectangleShape.prototype.isHtmlAllowed.apply(this, arguments) && this.indicatorColor == null && this.indicatorShape == null;
        };
        mxLabel.prototype.paintForeground = function(c, x, y, w2, h2) {
          this.paintImage(c, x, y, w2, h2);
          this.paintIndicator(c, x, y, w2, h2);
          mxRectangleShape.prototype.paintForeground.apply(this, arguments);
        };
        mxLabel.prototype.paintImage = function(c, x, y, w2, h2) {
          if (this.image != null) {
            var bounds = this.getImageBounds(x, y, w2, h2);
            c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.image, false, false, false);
          }
        };
        mxLabel.prototype.getImageBounds = function(x, y, w2, h2) {
          var align = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT);
          var valign = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
          var width = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_WIDTH, mxConstants.DEFAULT_IMAGESIZE);
          var height = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_HEIGHT, mxConstants.DEFAULT_IMAGESIZE);
          var spacing = mxUtils.getNumber(this.style, mxConstants.STYLE_SPACING, this.spacing) + 5;
          if (align == mxConstants.ALIGN_CENTER) {
            x += (w2 - width) / 2;
          } else if (align == mxConstants.ALIGN_RIGHT) {
            x += w2 - width - spacing;
          } else {
            x += spacing;
          }
          if (valign == mxConstants.ALIGN_TOP) {
            y += spacing;
          } else if (valign == mxConstants.ALIGN_BOTTOM) {
            y += h2 - height - spacing;
          } else {
            y += (h2 - height) / 2;
          }
          return new mxRectangle(x, y, width, height);
        };
        mxLabel.prototype.paintIndicator = function(c, x, y, w2, h2) {
          if (this.indicator != null) {
            this.indicator.bounds = this.getIndicatorBounds(x, y, w2, h2);
            this.indicator.paint(c);
          } else if (this.indicatorImage != null) {
            var bounds = this.getIndicatorBounds(x, y, w2, h2);
            c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.indicatorImage, false, false, false);
          }
        };
        mxLabel.prototype.getIndicatorBounds = function(x, y, w2, h2) {
          var align = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT);
          var valign = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
          var width = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_WIDTH, this.indicatorSize);
          var height = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_HEIGHT, this.indicatorSize);
          var spacing = this.spacing + 5;
          if (align == mxConstants.ALIGN_RIGHT) {
            x += w2 - width - spacing;
          } else if (align == mxConstants.ALIGN_CENTER) {
            x += (w2 - width) / 2;
          } else {
            x += spacing;
          }
          if (valign == mxConstants.ALIGN_BOTTOM) {
            y += h2 - height - spacing;
          } else if (valign == mxConstants.ALIGN_TOP) {
            y += spacing;
          } else {
            y += (h2 - height) / 2;
          }
          return new mxRectangle(x, y, width, height);
        };
        mxLabel.prototype.redrawHtmlShape = function() {
          mxRectangleShape.prototype.redrawHtmlShape.apply(this, arguments);
          while (this.node.hasChildNodes()) {
            this.node.removeChild(this.node.lastChild);
          }
          if (this.image != null) {
            var node = document.createElement("img");
            node.style.position = "relative";
            node.setAttribute("border", "0");
            var bounds = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
            bounds.x -= this.bounds.x;
            bounds.y -= this.bounds.y;
            node.style.left = Math.round(bounds.x) + "px";
            node.style.top = Math.round(bounds.y) + "px";
            node.style.width = Math.round(bounds.width) + "px";
            node.style.height = Math.round(bounds.height) + "px";
            node.src = this.image;
            this.node.appendChild(node);
          }
        };
        __mxOutput.mxLabel = typeof mxLabel !== "undefined" ? mxLabel : void 0;
        function mxCylinder(bounds, fill, stroke, strokewidth) {
          mxShape.call(this);
          this.bounds = bounds;
          this.fill = fill;
          this.stroke = stroke;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
        }
        ;
        mxUtils.extend(mxCylinder, mxShape);
        mxCylinder.prototype.maxHeight = 40;
        mxCylinder.prototype.svgStrokeTolerance = 0;
        mxCylinder.prototype.paintVertexShape = function(c, x, y, w2, h2) {
          c.translate(x, y);
          c.begin();
          this.redrawPath(c, x, y, w2, h2, false);
          c.fillAndStroke();
          if (!this.outline || this.style == null || mxUtils.getValue(
            this.style,
            mxConstants.STYLE_BACKGROUND_OUTLINE,
            0
          ) == 0) {
            c.setShadow(false);
            c.begin();
            this.redrawPath(c, x, y, w2, h2, true);
            c.stroke();
          }
        };
        mxCylinder.prototype.getCylinderSize = function(x, y, w2, h2) {
          return Math.min(this.maxHeight, Math.round(h2 / 5));
        };
        mxCylinder.prototype.redrawPath = function(c, x, y, w2, h2, isForeground) {
          var dy = this.getCylinderSize(x, y, w2, h2);
          if (isForeground && this.fill != null || !isForeground && this.fill == null) {
            c.moveTo(0, dy);
            c.curveTo(0, 2 * dy, w2, 2 * dy, w2, dy);
            if (!isForeground) {
              c.stroke();
              c.begin();
            }
          }
          if (!isForeground) {
            c.moveTo(0, dy);
            c.curveTo(0, -dy / 3, w2, -dy / 3, w2, dy);
            c.lineTo(w2, h2 - dy);
            c.curveTo(w2, h2 + dy / 3, 0, h2 + dy / 3, 0, h2 - dy);
            c.close();
          }
        };
        __mxOutput.mxCylinder = typeof mxCylinder !== "undefined" ? mxCylinder : void 0;
        function mxConnector(points, stroke, strokewidth) {
          mxPolyline.call(this, points, stroke, strokewidth);
        }
        ;
        mxUtils.extend(mxConnector, mxPolyline);
        mxConnector.prototype.updateBoundingBox = function() {
          this.useSvgBoundingBox = this.style != null && this.style[mxConstants.STYLE_CURVED] == 1;
          mxShape.prototype.updateBoundingBox.apply(this, arguments);
        };
        mxConnector.prototype.paintEdgeShape = function(c, pts) {
          var sourceMarker = this.createMarker(c, pts, true);
          var targetMarker = this.createMarker(c, pts, false);
          mxPolyline.prototype.paintEdgeShape.apply(this, arguments);
          c.setFillColor(this.stroke);
          c.setShadow(false);
          c.setDashed(false);
          if (sourceMarker != null) {
            sourceMarker();
          }
          if (targetMarker != null) {
            targetMarker();
          }
        };
        mxConnector.prototype.createMarker = function(c, pts, source) {
          var result2 = null;
          var n = pts.length;
          var type = mxUtils.getValue(this.style, source ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW);
          var p0 = source ? pts[1] : pts[n - 2];
          var pe = source ? pts[0] : pts[n - 1];
          if (type != null && p0 != null && pe != null) {
            var count = 1;
            while (count < n - 1 && Math.round(p0.x - pe.x) == 0 && Math.round(p0.y - pe.y) == 0) {
              p0 = source ? pts[1 + count] : pts[n - 2 - count];
              count++;
            }
            var dx = pe.x - p0.x;
            var dy = pe.y - p0.y;
            var dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
            var unitX = dx / dist;
            var unitY = dy / dist;
            var size = mxUtils.getNumber(this.style, source ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE);
            var filled = this.style[source ? mxConstants.STYLE_STARTFILL : mxConstants.STYLE_ENDFILL] != 0;
            result2 = mxMarker.createMarker(c, this, type, pe, unitX, unitY, size, source, this.strokewidth, filled);
          }
          return result2;
        };
        mxConnector.prototype.augmentBoundingBox = function(bbox) {
          mxShape.prototype.augmentBoundingBox.apply(this, arguments);
          var size = 0;
          if (mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE) {
            size = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_MARKERSIZE) + 1;
          }
          if (mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE) {
            size = Math.max(size, mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE)) + 1;
          }
          bbox.grow(size * this.scale);
        };
        __mxOutput.mxConnector = typeof mxConnector !== "undefined" ? mxConnector : void 0;
        function mxSwimlane(bounds, fill, stroke, strokewidth) {
          mxShape.call(this);
          this.bounds = bounds;
          this.fill = fill;
          this.stroke = stroke;
          this.strokewidth = strokewidth != null ? strokewidth : 1;
        }
        ;
        mxUtils.extend(mxSwimlane, mxShape);
        mxSwimlane.prototype.imageSize = 16;
        mxSwimlane.prototype.isRoundable = function(c, x, y, w2, h2) {
          return true;
        };
        mxSwimlane.prototype.getTitleSize = function() {
          return Math.max(0, mxUtils.getValue(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
        };
        mxSwimlane.prototype.getLabelBounds = function(rect) {
          var start = this.getTitleSize();
          var bounds = new mxRectangle(rect.x, rect.y, rect.width, rect.height);
          var horizontal = this.isHorizontal();
          var flipH = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0) == 1;
          var flipV = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0) == 1;
          var shapeVertical = this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH;
          var realHorizontal = horizontal == !shapeVertical;
          var realFlipH = !realHorizontal && flipH != (this.direction == mxConstants.DIRECTION_SOUTH || this.direction == mxConstants.DIRECTION_WEST);
          var realFlipV = realHorizontal && flipV != (this.direction == mxConstants.DIRECTION_SOUTH || this.direction == mxConstants.DIRECTION_WEST);
          if (!shapeVertical) {
            var tmp = Math.min(bounds.height, start * this.scale);
            if (realFlipH || realFlipV) {
              bounds.y += bounds.height - tmp;
            }
            bounds.height = tmp;
          } else {
            var tmp = Math.min(bounds.width, start * this.scale);
            if (realFlipH || realFlipV) {
              bounds.x += bounds.width - tmp;
            }
            bounds.width = tmp;
          }
          return bounds;
        };
        mxSwimlane.prototype.getGradientBounds = function(c, x, y, w2, h2) {
          var start = this.getTitleSize();
          if (this.isHorizontal()) {
            start = Math.min(start, h2);
            return new mxRectangle(x, y, w2, start);
          } else {
            start = Math.min(start, w2);
            return new mxRectangle(x, y, start, h2);
          }
        };
        mxSwimlane.prototype.getSwimlaneArcSize = function(w2, h2, start) {
          if (mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0) == "1") {
            return Math.min(w2 / 2, Math.min(h2 / 2, mxUtils.getValue(
              this.style,
              mxConstants.STYLE_ARCSIZE,
              mxConstants.LINE_ARCSIZE
            ) / 2));
          } else {
            var f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.RECTANGLE_ROUNDING_FACTOR * 100) / 100;
            return start * f * 3;
          }
        };
        mxSwimlane.prototype.isHorizontal = function() {
          return mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1) == 1;
        };
        mxSwimlane.prototype.paintVertexShape = function(c, x, y, w2, h2) {
          var start = this.getTitleSize();
          var fill = mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_FILLCOLOR, mxConstants.NONE);
          var swimlaneLine = mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_LINE, 1) == 1;
          var r = 0;
          if (this.isHorizontal()) {
            start = Math.min(start, h2);
          } else {
            start = Math.min(start, w2);
          }
          c.translate(x, y);
          if (!this.isRounded) {
            this.paintSwimlane(c, x, y, w2, h2, start, fill, swimlaneLine);
          } else {
            r = this.getSwimlaneArcSize(w2, h2, start);
            r = Math.min((this.isHorizontal() ? h2 : w2) - start, Math.min(start, r));
            this.paintRoundedSwimlane(c, x, y, w2, h2, start, r, fill, swimlaneLine);
          }
          var sep = mxUtils.getValue(this.style, mxConstants.STYLE_SEPARATORCOLOR, mxConstants.NONE);
          this.paintSeparator(c, x, y, w2, h2, start, sep);
          if (this.image != null) {
            var bounds = this.getImageBounds(x, y, w2, h2);
            c.image(
              bounds.x - x,
              bounds.y - y,
              bounds.width,
              bounds.height,
              this.image,
              false,
              false,
              false
            );
          }
          if (this.glass) {
            c.setShadow(false);
            this.paintGlassEffect(c, 0, 0, w2, start, r);
          }
        };
        mxSwimlane.prototype.paintSwimlane = function(c, x, y, w2, h2, start, fill, swimlaneLine) {
          c.begin();
          var events = true;
          if (this.style != null) {
            events = mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1") == "1";
          }
          if (!events && (this.fill == null || this.fill == mxConstants.NONE)) {
            c.pointerEvents = false;
          }
          if (this.isHorizontal()) {
            c.moveTo(0, start);
            c.lineTo(0, 0);
            c.lineTo(w2, 0);
            c.lineTo(w2, start);
            c.fillAndStroke();
            if (start < h2) {
              if (fill == mxConstants.NONE || !events) {
                c.pointerEvents = false;
              }
              if (fill != mxConstants.NONE) {
                c.setFillColor(fill);
              }
              c.begin();
              c.moveTo(0, start);
              c.lineTo(0, h2);
              c.lineTo(w2, h2);
              c.lineTo(w2, start);
              if (fill == mxConstants.NONE) {
                c.stroke();
              } else {
                c.fillAndStroke();
              }
            }
          } else {
            c.moveTo(start, 0);
            c.lineTo(0, 0);
            c.lineTo(0, h2);
            c.lineTo(start, h2);
            c.fillAndStroke();
            if (start < w2) {
              if (fill == mxConstants.NONE || !events) {
                c.pointerEvents = false;
              }
              if (fill != mxConstants.NONE) {
                c.setFillColor(fill);
              }
              c.begin();
              c.moveTo(start, 0);
              c.lineTo(w2, 0);
              c.lineTo(w2, h2);
              c.lineTo(start, h2);
              if (fill == mxConstants.NONE) {
                c.stroke();
              } else {
                c.fillAndStroke();
              }
            }
          }
          if (swimlaneLine) {
            this.paintDivider(c, x, y, w2, h2, start, fill == mxConstants.NONE);
          }
        };
        mxSwimlane.prototype.paintRoundedSwimlane = function(c, x, y, w2, h2, start, r, fill, swimlaneLine) {
          c.begin();
          var events = true;
          if (this.style != null) {
            events = mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, "1") == "1";
          }
          if (!events && (this.fill == null || this.fill == mxConstants.NONE)) {
            c.pointerEvents = false;
          }
          if (this.isHorizontal()) {
            c.moveTo(w2, start);
            c.lineTo(w2, r);
            c.quadTo(w2, 0, w2 - Math.min(w2 / 2, r), 0);
            c.lineTo(Math.min(w2 / 2, r), 0);
            c.quadTo(0, 0, 0, r);
            c.lineTo(0, start);
            c.fillAndStroke();
            if (start < h2) {
              if (fill == mxConstants.NONE || !events) {
                c.pointerEvents = false;
              }
              if (fill != mxConstants.NONE) {
                c.setFillColor(fill);
              }
              c.begin();
              c.moveTo(0, start);
              c.lineTo(0, h2 - r);
              c.quadTo(0, h2, Math.min(w2 / 2, r), h2);
              c.lineTo(w2 - Math.min(w2 / 2, r), h2);
              c.quadTo(w2, h2, w2, h2 - r);
              c.lineTo(w2, start);
              if (fill == mxConstants.NONE) {
                c.stroke();
              } else {
                c.fillAndStroke();
              }
            }
          } else {
            c.moveTo(start, 0);
            c.lineTo(r, 0);
            c.quadTo(0, 0, 0, Math.min(h2 / 2, r));
            c.lineTo(0, h2 - Math.min(h2 / 2, r));
            c.quadTo(0, h2, r, h2);
            c.lineTo(start, h2);
            c.fillAndStroke();
            if (start < w2) {
              if (fill == mxConstants.NONE || !events) {
                c.pointerEvents = false;
              }
              if (fill != mxConstants.NONE) {
                c.setFillColor(fill);
              }
              c.begin();
              c.moveTo(start, h2);
              c.lineTo(w2 - r, h2);
              c.quadTo(w2, h2, w2, h2 - Math.min(h2 / 2, r));
              c.lineTo(w2, Math.min(h2 / 2, r));
              c.quadTo(w2, 0, w2 - r, 0);
              c.lineTo(start, 0);
              if (fill == mxConstants.NONE) {
                c.stroke();
              } else {
                c.fillAndStroke();
              }
            }
          }
          if (swimlaneLine) {
            this.paintDivider(c, x, y, w2, h2, start, fill == mxConstants.NONE);
          }
        };
        mxSwimlane.prototype.paintDivider = function(c, x, y, w2, h2, start, shadow) {
          if (!shadow) {
            c.setShadow(false);
          }
          c.begin();
          if (this.isHorizontal()) {
            c.moveTo(0, start);
            c.lineTo(w2, start);
          } else {
            c.moveTo(start, 0);
            c.lineTo(start, h2);
          }
          c.stroke();
        };
        mxSwimlane.prototype.paintSeparator = function(c, x, y, w2, h2, start, color) {
          if (color != mxConstants.NONE) {
            c.setStrokeColor(color);
            c.setDashed(true);
            c.begin();
            if (this.isHorizontal()) {
              c.moveTo(w2, start);
              c.lineTo(w2, h2);
            } else {
              c.moveTo(start, 0);
              c.lineTo(w2, 0);
            }
            c.stroke();
            c.setDashed(false);
          }
        };
        mxSwimlane.prototype.getImageBounds = function(x, y, w2, h2) {
          if (this.isHorizontal()) {
            return new mxRectangle(x + w2 - this.imageSize, y, this.imageSize, this.imageSize);
          } else {
            return new mxRectangle(x, y, this.imageSize, this.imageSize);
          }
        };
        __mxOutput.mxSwimlane = typeof mxSwimlane !== "undefined" ? mxSwimlane : void 0;
        function mxGraphLayout(graph) {
          this.graph = graph;
        }
        ;
        mxGraphLayout.prototype.graph = null;
        mxGraphLayout.prototype.useBoundingBox = true;
        mxGraphLayout.prototype.parent = null;
        mxGraphLayout.prototype.moveCell = function(cell2, x, y) {
        };
        mxGraphLayout.prototype.resizeCell = function(cell2, bounds) {
        };
        mxGraphLayout.prototype.execute = function(parent) {
        };
        mxGraphLayout.prototype.getGraph = function() {
          return this.graph;
        };
        mxGraphLayout.prototype.getConstraint = function(key, cell2, edge, source) {
          return this.graph.getCurrentCellStyle(cell2)[key];
        };
        mxGraphLayout.traverse = function(vertex, directed, func, edge, visited) {
          if (func != null && vertex != null) {
            directed = directed != null ? directed : true;
            visited = visited || new mxDictionary();
            if (!visited.get(vertex)) {
              visited.put(vertex, true);
              var result2 = func(vertex, edge);
              if (result2 == null || result2) {
                var edgeCount = this.graph.model.getEdgeCount(vertex);
                if (edgeCount > 0) {
                  for (var i = 0; i < edgeCount; i++) {
                    var e = this.graph.model.getEdgeAt(vertex, i);
                    var isSource = this.graph.model.getTerminal(e, true) == vertex;
                    if (!directed || isSource) {
                      var next = this.graph.view.getVisibleTerminal(e, !isSource);
                      this.traverse(next, directed, func, e, visited);
                    }
                  }
                }
              }
            }
          }
        };
        mxGraphLayout.prototype.isAncestor = function(parent, child, traverseAncestors) {
          if (!traverseAncestors) {
            return this.graph.model.getParent(child) == parent;
          }
          if (child == parent) {
            return false;
          }
          while (child != null && child != parent) {
            child = this.graph.model.getParent(child);
          }
          return child == parent;
        };
        mxGraphLayout.prototype.isVertexMovable = function(cell2) {
          return this.graph.isCellMovable(cell2);
        };
        mxGraphLayout.prototype.isVertexIgnored = function(vertex) {
          return !this.graph.getModel().isVertex(vertex) || !this.graph.isCellVisible(vertex);
        };
        mxGraphLayout.prototype.isEdgeIgnored = function(edge) {
          var model = this.graph.getModel();
          return !model.isEdge(edge) || !this.graph.isCellVisible(edge) || model.getTerminal(edge, true) == null || model.getTerminal(edge, false) == null;
        };
        mxGraphLayout.prototype.setEdgeStyleEnabled = function(edge, value) {
          this.graph.setCellStyles(
            mxConstants.STYLE_NOEDGESTYLE,
            value ? "0" : "1",
            [edge]
          );
        };
        mxGraphLayout.prototype.setOrthogonalEdge = function(edge, value) {
          this.graph.setCellStyles(
            mxConstants.STYLE_ORTHOGONAL,
            value ? "1" : "0",
            [edge]
          );
        };
        mxGraphLayout.prototype.getParentOffset = function(parent) {
          var result2 = new mxPoint();
          if (parent != null && parent != this.parent) {
            var model = this.graph.getModel();
            if (model.isAncestor(this.parent, parent)) {
              var parentGeo = model.getGeometry(parent);
              while (parent != this.parent) {
                result2.x = result2.x + parentGeo.x;
                result2.y = result2.y + parentGeo.y;
                parent = model.getParent(parent);
                ;
                parentGeo = model.getGeometry(parent);
              }
            }
          }
          return result2;
        };
        mxGraphLayout.prototype.setEdgePoints = function(edge, points) {
          if (edge != null) {
            var model = this.graph.model;
            var geometry = model.getGeometry(edge);
            if (geometry == null) {
              geometry = new mxGeometry();
              geometry.setRelative(true);
            } else {
              geometry = geometry.clone();
            }
            if (this.parent != null && points != null) {
              var parent = model.getParent(edge);
              var parentOffset = this.getParentOffset(parent);
              for (var i = 0; i < points.length; i++) {
                points[i].x = points[i].x - parentOffset.x;
                points[i].y = points[i].y - parentOffset.y;
              }
            }
            geometry.points = points;
            model.setGeometry(edge, geometry);
          }
        };
        mxGraphLayout.prototype.setVertexLocation = function(cell2, x, y) {
          var model = this.graph.getModel();
          var geometry = model.getGeometry(cell2);
          var result2 = null;
          if (geometry != null) {
            result2 = new mxRectangle(x, y, geometry.width, geometry.height);
            if (this.useBoundingBox) {
              var state = this.graph.getView().getState(cell2);
              if (state != null && state.text != null && state.text.boundingBox != null) {
                var scale = this.graph.getView().scale;
                var box = state.text.boundingBox;
                if (state.text.boundingBox.x < state.x) {
                  x += (state.x - box.x) / scale;
                  result2.width = box.width;
                }
                if (state.text.boundingBox.y < state.y) {
                  y += (state.y - box.y) / scale;
                  result2.height = box.height;
                }
              }
            }
            if (this.parent != null) {
              var parent = model.getParent(cell2);
              if (parent != null && parent != this.parent) {
                var parentOffset = this.getParentOffset(parent);
                x = x - parentOffset.x;
                y = y - parentOffset.y;
              }
            }
            if (geometry.x != x || geometry.y != y) {
              geometry = geometry.clone();
              geometry.x = x;
              geometry.y = y;
              model.setGeometry(cell2, geometry);
            }
          }
          return result2;
        };
        mxGraphLayout.prototype.getVertexBounds = function(cell2) {
          var geo = this.graph.getModel().getGeometry(cell2);
          if (this.useBoundingBox) {
            var state = this.graph.getView().getState(cell2);
            if (state != null && state.text != null && state.text.boundingBox != null) {
              var scale = this.graph.getView().scale;
              var tmp = state.text.boundingBox;
              var dx0 = Math.max(state.x - tmp.x, 0) / scale;
              var dy0 = Math.max(state.y - tmp.y, 0) / scale;
              var dx1 = Math.max(tmp.x + tmp.width - (state.x + state.width), 0) / scale;
              var dy1 = Math.max(tmp.y + tmp.height - (state.y + state.height), 0) / scale;
              geo = new mxRectangle(geo.x - dx0, geo.y - dy0, geo.width + dx0 + dx1, geo.height + dy0 + dy1);
            }
          }
          if (this.parent != null) {
            var parent = this.graph.getModel().getParent(cell2);
            geo = geo.clone();
            if (parent != null && parent != this.parent) {
              var parentOffset = this.getParentOffset(parent);
              geo.x = geo.x + parentOffset.x;
              geo.y = geo.y + parentOffset.y;
            }
          }
          return new mxRectangle(geo.x, geo.y, geo.width, geo.height);
        };
        mxGraphLayout.prototype.arrangeGroups = function(cells, border, topBorder, rightBorder, bottomBorder, leftBorder) {
          return this.graph.updateGroupBounds(cells, border, true, topBorder, rightBorder, bottomBorder, leftBorder);
        };
        function WeightedCellSorter(cell2, weightedValue) {
          this.cell = cell2;
          this.weightedValue = weightedValue;
        }
        ;
        WeightedCellSorter.prototype.weightedValue = 0;
        WeightedCellSorter.prototype.nudge = false;
        WeightedCellSorter.prototype.visited = false;
        WeightedCellSorter.prototype.rankIndex = null;
        WeightedCellSorter.prototype.cell = null;
        WeightedCellSorter.prototype.compare = function(a, b) {
          if (a != null && b != null) {
            if (b.weightedValue > a.weightedValue) {
              return -1;
            } else if (b.weightedValue < a.weightedValue) {
              return 1;
            } else {
              if (b.nudge) {
                return -1;
              } else {
                return 1;
              }
            }
          } else {
            return 0;
          }
        };
        __mxOutput.mxGraphLayout = typeof mxGraphLayout !== "undefined" ? mxGraphLayout : void 0;
        function mxStackLayout(graph, horizontal, spacing, x0, y0, border) {
          mxGraphLayout.call(this, graph);
          this.horizontal = horizontal != null ? horizontal : true;
          this.spacing = spacing != null ? spacing : 0;
          this.x0 = x0 != null ? x0 : 0;
          this.y0 = y0 != null ? y0 : 0;
          this.border = border != null ? border : 0;
        }
        ;
        mxStackLayout.prototype = new mxGraphLayout();
        mxStackLayout.prototype.constructor = mxStackLayout;
        mxStackLayout.prototype.horizontal = null;
        mxStackLayout.prototype.spacing = null;
        mxStackLayout.prototype.x0 = null;
        mxStackLayout.prototype.y0 = null;
        mxStackLayout.prototype.border = 0;
        mxStackLayout.prototype.marginTop = 0;
        mxStackLayout.prototype.marginLeft = 0;
        mxStackLayout.prototype.marginRight = 0;
        mxStackLayout.prototype.marginBottom = 0;
        mxStackLayout.prototype.keepFirstLocation = false;
        mxStackLayout.prototype.fill = false;
        mxStackLayout.prototype.resizeParent = false;
        mxStackLayout.prototype.resizeParentMax = false;
        mxStackLayout.prototype.resizeLast = false;
        mxStackLayout.prototype.wrap = null;
        mxStackLayout.prototype.borderCollapse = true;
        mxStackLayout.prototype.allowGaps = false;
        mxStackLayout.prototype.gridSize = 0;
        mxStackLayout.prototype.isHorizontal = function() {
          return this.horizontal;
        };
        mxStackLayout.prototype.moveCell = function(cell2, x, y) {
          var model = this.graph.getModel();
          var parent = model.getParent(cell2);
          var horizontal = this.isHorizontal();
          if (cell2 != null && parent != null) {
            var i = 0;
            var last = 0;
            var childCount = model.getChildCount(parent);
            var value = horizontal ? x : y;
            var pstate = this.graph.getView().getState(parent);
            if (pstate != null) {
              value -= horizontal ? pstate.x : pstate.y;
            }
            value /= this.graph.view.scale;
            for (i = 0; i < childCount; i++) {
              var child = model.getChildAt(parent, i);
              if (child != cell2) {
                var bounds = model.getGeometry(child);
                if (bounds != null) {
                  var tmp = horizontal ? bounds.x + bounds.width / 2 : bounds.y + bounds.height / 2;
                  if (last <= value && tmp > value) {
                    break;
                  }
                  last = tmp;
                }
              }
            }
            var idx = parent.getIndex(cell2);
            idx = Math.max(0, i - (i > idx ? 1 : 0));
            model.add(parent, cell2, idx);
          }
        };
        mxStackLayout.prototype.getParentSize = function(parent) {
          var model = this.graph.getModel();
          var pgeo = model.getGeometry(parent);
          if (this.graph.container != null && (pgeo == null && model.isLayer(parent) || parent == this.graph.getView().currentRoot)) {
            var width = this.graph.container.offsetWidth - 1;
            var height = this.graph.container.offsetHeight - 1;
            pgeo = new mxRectangle(0, 0, width, height);
          }
          return pgeo;
        };
        mxStackLayout.prototype.getLayoutCells = function(parent) {
          var model = this.graph.getModel();
          var childCount = model.getChildCount(parent);
          var cells = [];
          for (var i = 0; i < childCount; i++) {
            var child = model.getChildAt(parent, i);
            if (!this.isVertexIgnored(child) && this.isVertexMovable(child)) {
              cells.push(child);
            }
          }
          if (this.allowGaps) {
            cells.sort(mxUtils.bind(this, function(c1, c2) {
              var geo1 = this.graph.getCellGeometry(c1);
              var geo2 = this.graph.getCellGeometry(c2);
              return this.horizontal ? geo1.x == geo2.x ? 0 : geo1.x > geo2.x > 0 ? 1 : -1 : geo1.y == geo2.y ? 0 : geo1.y > geo2.y > 0 ? 1 : -1;
            }));
          }
          return cells;
        };
        mxStackLayout.prototype.snap = function(value) {
          if (this.gridSize != null && this.gridSize > 0) {
            value = Math.max(value, this.gridSize);
            if (value / this.gridSize > 1) {
              var mod = value % this.gridSize;
              value += mod > this.gridSize / 2 ? this.gridSize - mod : -mod;
            }
          }
          return value;
        };
        mxStackLayout.prototype.execute = function(parent) {
          if (parent != null) {
            var pgeo = this.getParentSize(parent);
            var horizontal = this.isHorizontal();
            var model = this.graph.getModel();
            var fillValue = null;
            if (pgeo != null) {
              fillValue = horizontal ? pgeo.height - this.marginTop - this.marginBottom : pgeo.width - this.marginLeft - this.marginRight;
            }
            fillValue -= 2 * this.border;
            var x0 = this.x0 + this.border + this.marginLeft;
            var y0 = this.y0 + this.border + this.marginTop;
            if (this.graph.isSwimlane(parent)) {
              var style = this.graph.getCellStyle(parent);
              var start = mxUtils.getNumber(style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE);
              var horz = mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true) == 1;
              if (pgeo != null) {
                if (horz) {
                  start = Math.min(start, pgeo.height);
                } else {
                  start = Math.min(start, pgeo.width);
                }
              }
              if (horizontal == horz) {
                fillValue -= start;
              }
              if (horz) {
                y0 += start;
              } else {
                x0 += start;
              }
            }
            model.beginUpdate();
            try {
              var tmp = 0;
              var last = null;
              var lastValue = 0;
              var lastChild = null;
              var cells = this.getLayoutCells(parent);
              for (var i = 0; i < cells.length; i++) {
                var child = cells[i];
                var geo = model.getGeometry(child);
                if (geo != null) {
                  geo = geo.clone();
                  if (this.wrap != null && last != null) {
                    if (horizontal && last.x + last.width + geo.width + 2 * this.spacing > this.wrap || !horizontal && last.y + last.height + geo.height + 2 * this.spacing > this.wrap) {
                      last = null;
                      if (horizontal) {
                        y0 += tmp + this.spacing;
                      } else {
                        x0 += tmp + this.spacing;
                      }
                      tmp = 0;
                    }
                  }
                  tmp = Math.max(tmp, horizontal ? geo.height : geo.width);
                  var sw = 0;
                  if (!this.borderCollapse) {
                    var childStyle = this.graph.getCellStyle(child);
                    sw = mxUtils.getNumber(childStyle, mxConstants.STYLE_STROKEWIDTH, 1);
                  }
                  if (last != null) {
                    var temp = lastValue + this.spacing + Math.floor(sw / 2);
                    if (horizontal) {
                      geo.x = this.snap((this.allowGaps ? Math.max(temp, geo.x) : temp) - this.marginLeft) + this.marginLeft;
                    } else {
                      geo.y = this.snap((this.allowGaps ? Math.max(temp, geo.y) : temp) - this.marginTop) + this.marginTop;
                    }
                  } else if (!this.keepFirstLocation) {
                    if (horizontal) {
                      geo.x = this.allowGaps && geo.x > x0 ? Math.max(this.snap(geo.x - this.marginLeft) + this.marginLeft, x0) : x0;
                    } else {
                      geo.y = this.allowGaps && geo.y > y0 ? Math.max(this.snap(geo.y - this.marginTop) + this.marginTop, y0) : y0;
                    }
                  }
                  if (horizontal) {
                    geo.y = y0;
                  } else {
                    geo.x = x0;
                  }
                  if (this.fill && fillValue != null) {
                    if (horizontal) {
                      geo.height = fillValue;
                    } else {
                      geo.width = fillValue;
                    }
                  }
                  if (horizontal) {
                    geo.width = this.snap(geo.width);
                  } else {
                    geo.height = this.snap(geo.height);
                  }
                  this.setChildGeometry(child, geo);
                  lastChild = child;
                  last = geo;
                  if (horizontal) {
                    lastValue = last.x + last.width + Math.floor(sw / 2);
                  } else {
                    lastValue = last.y + last.height + Math.floor(sw / 2);
                  }
                }
              }
              if (this.resizeParent && pgeo != null && last != null && !this.graph.isCellCollapsed(parent)) {
                this.updateParentGeometry(parent, pgeo, last);
              } else if (this.resizeLast && pgeo != null && last != null && lastChild != null) {
                if (horizontal) {
                  last.width = pgeo.width - last.x - this.spacing - this.marginRight - this.marginLeft;
                } else {
                  last.height = pgeo.height - last.y - this.spacing - this.marginBottom;
                }
                this.setChildGeometry(lastChild, last);
              }
            } finally {
              model.endUpdate();
            }
          }
        };
        mxStackLayout.prototype.setChildGeometry = function(child, geo) {
          var geo2 = this.graph.getCellGeometry(child);
          if (geo2 == null || geo.x != geo2.x || geo.y != geo2.y || geo.width != geo2.width || geo.height != geo2.height) {
            this.graph.getModel().setGeometry(child, geo);
          }
        };
        mxStackLayout.prototype.updateParentGeometry = function(parent, pgeo, last) {
          var horizontal = this.isHorizontal();
          var model = this.graph.getModel();
          var pgeo2 = pgeo.clone();
          if (horizontal) {
            var tmp = last.x + last.width + this.marginRight + this.border;
            if (this.resizeParentMax) {
              pgeo2.width = Math.max(pgeo2.width, tmp);
            } else {
              pgeo2.width = tmp;
            }
          } else {
            var tmp = last.y + last.height + this.marginBottom + this.border;
            if (this.resizeParentMax) {
              pgeo2.height = Math.max(pgeo2.height, tmp);
            } else {
              pgeo2.height = tmp;
            }
          }
          if (pgeo.x != pgeo2.x || pgeo.y != pgeo2.y || pgeo.width != pgeo2.width || pgeo.height != pgeo2.height) {
            model.setGeometry(parent, pgeo2);
          }
        };
        __mxOutput.mxStackLayout = typeof mxStackLayout !== "undefined" ? mxStackLayout : void 0;
        function mxPartitionLayout(graph, horizontal, spacing, border) {
          mxGraphLayout.call(this, graph);
          this.horizontal = horizontal != null ? horizontal : true;
          this.spacing = spacing || 0;
          this.border = border || 0;
        }
        ;
        mxPartitionLayout.prototype = new mxGraphLayout();
        mxPartitionLayout.prototype.constructor = mxPartitionLayout;
        mxPartitionLayout.prototype.horizontal = null;
        mxPartitionLayout.prototype.spacing = null;
        mxPartitionLayout.prototype.border = null;
        mxPartitionLayout.prototype.resizeVertices = true;
        mxPartitionLayout.prototype.isHorizontal = function() {
          return this.horizontal;
        };
        mxPartitionLayout.prototype.moveCell = function(cell2, x, y) {
          var model = this.graph.getModel();
          var parent = model.getParent(cell2);
          if (cell2 != null && parent != null) {
            var i = 0;
            var last = 0;
            var childCount = model.getChildCount(parent);
            for (i = 0; i < childCount; i++) {
              var child = model.getChildAt(parent, i);
              var bounds = this.getVertexBounds(child);
              if (bounds != null) {
                var tmp = bounds.x + bounds.width / 2;
                if (last < x && tmp > x) {
                  break;
                }
                last = tmp;
              }
            }
            var idx = parent.getIndex(cell2);
            idx = Math.max(0, i - (i > idx ? 1 : 0));
            model.add(parent, cell2, idx);
          }
        };
        mxPartitionLayout.prototype.execute = function(parent) {
          var horizontal = this.isHorizontal();
          var model = this.graph.getModel();
          var pgeo = model.getGeometry(parent);
          if (this.graph.container != null && (pgeo == null && model.isLayer(parent) || parent == this.graph.getView().currentRoot)) {
            var width = this.graph.container.offsetWidth - 1;
            var height = this.graph.container.offsetHeight - 1;
            pgeo = new mxRectangle(0, 0, width, height);
          }
          if (pgeo != null) {
            var children = [];
            var childCount = model.getChildCount(parent);
            for (var i = 0; i < childCount; i++) {
              var child = model.getChildAt(parent, i);
              if (!this.isVertexIgnored(child) && this.isVertexMovable(child)) {
                children.push(child);
              }
            }
            var n = children.length;
            if (n > 0) {
              var x0 = this.border;
              var y0 = this.border;
              var other = horizontal ? pgeo.height : pgeo.width;
              other -= 2 * this.border;
              var size = this.graph.isSwimlane(parent) ? this.graph.getStartSize(parent) : new mxRectangle();
              other -= horizontal ? size.height : size.width;
              x0 = x0 + size.width;
              y0 = y0 + size.height;
              var tmp = this.border + (n - 1) * this.spacing;
              var value = horizontal ? (pgeo.width - x0 - tmp) / n : (pgeo.height - y0 - tmp) / n;
              if (value > 0) {
                model.beginUpdate();
                try {
                  for (var i = 0; i < n; i++) {
                    var child = children[i];
                    var geo = model.getGeometry(child);
                    if (geo != null) {
                      geo = geo.clone();
                      geo.x = x0;
                      geo.y = y0;
                      if (horizontal) {
                        if (this.resizeVertices) {
                          geo.width = value;
                          geo.height = other;
                        }
                        x0 += value + this.spacing;
                      } else {
                        if (this.resizeVertices) {
                          geo.height = value;
                          geo.width = other;
                        }
                        y0 += value + this.spacing;
                      }
                      model.setGeometry(child, geo);
                    }
                  }
                } finally {
                  model.endUpdate();
                }
              }
            }
          }
        };
        __mxOutput.mxPartitionLayout = typeof mxPartitionLayout !== "undefined" ? mxPartitionLayout : void 0;
        function mxCompactTreeLayout(graph, horizontal, invert) {
          mxGraphLayout.call(this, graph);
          this.horizontal = horizontal != null ? horizontal : true;
          this.invert = invert != null ? invert : false;
        }
        ;
        mxCompactTreeLayout.prototype = new mxGraphLayout();
        mxCompactTreeLayout.prototype.constructor = mxCompactTreeLayout;
        mxCompactTreeLayout.prototype.horizontal = null;
        mxCompactTreeLayout.prototype.invert = null;
        mxCompactTreeLayout.prototype.resizeParent = true;
        mxCompactTreeLayout.prototype.maintainParentLocation = false;
        mxCompactTreeLayout.prototype.groupPadding = 10;
        mxCompactTreeLayout.prototype.groupPaddingTop = 0;
        mxCompactTreeLayout.prototype.groupPaddingRight = 0;
        mxCompactTreeLayout.prototype.groupPaddingBottom = 0;
        mxCompactTreeLayout.prototype.groupPaddingLeft = 0;
        mxCompactTreeLayout.prototype.parentsChanged = null;
        mxCompactTreeLayout.prototype.moveTree = false;
        mxCompactTreeLayout.prototype.visited = null;
        mxCompactTreeLayout.prototype.levelDistance = 10;
        mxCompactTreeLayout.prototype.nodeDistance = 20;
        mxCompactTreeLayout.prototype.resetEdges = true;
        mxCompactTreeLayout.prototype.prefHozEdgeSep = 5;
        mxCompactTreeLayout.prototype.prefVertEdgeOff = 4;
        mxCompactTreeLayout.prototype.minEdgeJetty = 8;
        mxCompactTreeLayout.prototype.channelBuffer = 4;
        mxCompactTreeLayout.prototype.edgeRouting = true;
        mxCompactTreeLayout.prototype.sortEdges = false;
        mxCompactTreeLayout.prototype.alignRanks = false;
        mxCompactTreeLayout.prototype.maxRankHeight = null;
        mxCompactTreeLayout.prototype.root = null;
        mxCompactTreeLayout.prototype.node = null;
        mxCompactTreeLayout.prototype.isVertexIgnored = function(vertex) {
          return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || this.graph.getConnections(vertex).length == 0;
        };
        mxCompactTreeLayout.prototype.isHorizontal = function() {
          return this.horizontal;
        };
        mxCompactTreeLayout.prototype.execute = function(parent, root) {
          this.parent = parent;
          var model = this.graph.getModel();
          if (root == null) {
            if (this.graph.getEdges(
              parent,
              model.getParent(parent),
              this.invert,
              !this.invert,
              false
            ).length > 0) {
              this.root = parent;
            } else {
              var roots = this.graph.findTreeRoots(parent, true, this.invert);
              if (roots.length > 0) {
                for (var i = 0; i < roots.length; i++) {
                  if (!this.isVertexIgnored(roots[i]) && this.graph.getEdges(
                    roots[i],
                    null,
                    this.invert,
                    !this.invert,
                    false
                  ).length > 0) {
                    this.root = roots[i];
                    break;
                  }
                }
              }
            }
          } else {
            this.root = root;
          }
          if (this.root != null) {
            if (this.resizeParent) {
              this.parentsChanged = new Object();
            } else {
              this.parentsChanged = null;
            }
            this.parentX = null;
            this.parentY = null;
            if (parent != this.root && model.isVertex(parent) != null && this.maintainParentLocation) {
              var geo = this.graph.getCellGeometry(parent);
              if (geo != null) {
                this.parentX = geo.x;
                this.parentY = geo.y;
              }
            }
            model.beginUpdate();
            try {
              this.visited = new Object();
              this.node = this.dfs(this.root, parent);
              if (this.alignRanks) {
                this.maxRankHeight = [];
                this.findRankHeights(this.node, 0);
                this.setCellHeights(this.node, 0);
              }
              if (this.node != null) {
                this.layout(this.node);
                var x0 = this.graph.gridSize;
                var y0 = x0;
                if (!this.moveTree) {
                  var g = this.getVertexBounds(this.root);
                  if (g != null) {
                    x0 = g.x;
                    y0 = g.y;
                  }
                }
                var bounds = null;
                if (this.isHorizontal()) {
                  bounds = this.horizontalLayout(this.node, x0, y0);
                } else {
                  bounds = this.verticalLayout(this.node, null, x0, y0);
                }
                if (bounds != null) {
                  var dx = 0;
                  var dy = 0;
                  if (bounds.x < 0) {
                    dx = Math.abs(x0 - bounds.x);
                  }
                  if (bounds.y < 0) {
                    dy = Math.abs(y0 - bounds.y);
                  }
                  if (dx != 0 || dy != 0) {
                    this.moveNode(this.node, dx, dy);
                  }
                  if (this.resizeParent) {
                    this.adjustParents();
                  }
                  if (this.edgeRouting) {
                    this.localEdgeProcessing(this.node);
                  }
                }
                if (this.parentX != null && this.parentY != null) {
                  var geo = this.graph.getCellGeometry(parent);
                  if (geo != null) {
                    geo = geo.clone();
                    geo.x = this.parentX;
                    geo.y = this.parentY;
                    model.setGeometry(parent, geo);
                  }
                }
              }
            } finally {
              model.endUpdate();
            }
          }
        };
        mxCompactTreeLayout.prototype.moveNode = function(node, dx, dy) {
          node.x += dx;
          node.y += dy;
          this.apply(node);
          var child = node.child;
          while (child != null) {
            this.moveNode(child, dx, dy);
            child = child.next;
          }
        };
        mxCompactTreeLayout.prototype.sortOutgoingEdges = function(source, edges) {
          var lookup = new mxDictionary();
          edges.sort(function(e1, e2) {
            var end1 = e1.getTerminal(e1.getTerminal(false) == source);
            var p1 = lookup.get(end1);
            if (p1 == null) {
              p1 = mxCellPath.create(end1).split(mxCellPath.PATH_SEPARATOR);
              lookup.put(end1, p1);
            }
            var end2 = e2.getTerminal(e2.getTerminal(false) == source);
            var p2 = lookup.get(end2);
            if (p2 == null) {
              p2 = mxCellPath.create(end2).split(mxCellPath.PATH_SEPARATOR);
              lookup.put(end2, p2);
            }
            return mxCellPath.compare(p1, p2);
          });
        };
        mxCompactTreeLayout.prototype.findRankHeights = function(node, rank) {
          if (this.maxRankHeight[rank] == null || this.maxRankHeight[rank] < node.height) {
            this.maxRankHeight[rank] = node.height;
          }
          var child = node.child;
          while (child != null) {
            this.findRankHeights(child, rank + 1);
            child = child.next;
          }
        };
        mxCompactTreeLayout.prototype.setCellHeights = function(node, rank) {
          if (this.maxRankHeight[rank] != null && this.maxRankHeight[rank] > node.height) {
            node.height = this.maxRankHeight[rank];
          }
          var child = node.child;
          while (child != null) {
            this.setCellHeights(child, rank + 1);
            child = child.next;
          }
        };
        mxCompactTreeLayout.prototype.dfs = function(cell2, parent) {
          var id = mxCellPath.create(cell2);
          var node = null;
          if (cell2 != null && this.visited[id] == null && !this.isVertexIgnored(cell2)) {
            this.visited[id] = cell2;
            node = this.createNode(cell2);
            var model = this.graph.getModel();
            var prev = null;
            var out = this.graph.getEdges(cell2, parent, this.invert, !this.invert, false, true);
            var view = this.graph.getView();
            if (this.sortEdges) {
              this.sortOutgoingEdges(cell2, out);
            }
            for (var i = 0; i < out.length; i++) {
              var edge = out[i];
              if (!this.isEdgeIgnored(edge)) {
                if (this.resetEdges) {
                  this.setEdgePoints(edge, null);
                }
                if (this.edgeRouting) {
                  this.setEdgeStyleEnabled(edge, false);
                  this.setEdgePoints(edge, null);
                }
                var state = view.getState(edge);
                var target = state != null ? state.getVisibleTerminal(this.invert) : view.getVisibleTerminal(edge, this.invert);
                var tmp = this.dfs(target, parent);
                if (tmp != null && model.getGeometry(target) != null) {
                  if (prev == null) {
                    node.child = tmp;
                  } else {
                    prev.next = tmp;
                  }
                  prev = tmp;
                }
              }
            }
          }
          return node;
        };
        mxCompactTreeLayout.prototype.layout = function(node) {
          if (node != null) {
            var child = node.child;
            while (child != null) {
              this.layout(child);
              child = child.next;
            }
            if (node.child != null) {
              this.attachParent(node, this.join(node));
            } else {
              this.layoutLeaf(node);
            }
          }
        };
        mxCompactTreeLayout.prototype.horizontalLayout = function(node, x0, y0, bounds) {
          node.x += x0 + node.offsetX;
          node.y += y0 + node.offsetY;
          bounds = this.apply(node, bounds);
          var child = node.child;
          if (child != null) {
            bounds = this.horizontalLayout(child, node.x, node.y, bounds);
            var siblingOffset = node.y + child.offsetY;
            var s = child.next;
            while (s != null) {
              bounds = this.horizontalLayout(s, node.x + child.offsetX, siblingOffset, bounds);
              siblingOffset += s.offsetY;
              s = s.next;
            }
          }
          return bounds;
        };
        mxCompactTreeLayout.prototype.verticalLayout = function(node, parent, x0, y0, bounds) {
          node.x += x0 + node.offsetY;
          node.y += y0 + node.offsetX;
          bounds = this.apply(node, bounds);
          var child = node.child;
          if (child != null) {
            bounds = this.verticalLayout(child, node, node.x, node.y, bounds);
            var siblingOffset = node.x + child.offsetY;
            var s = child.next;
            while (s != null) {
              bounds = this.verticalLayout(s, node, siblingOffset, node.y + child.offsetX, bounds);
              siblingOffset += s.offsetY;
              s = s.next;
            }
          }
          return bounds;
        };
        mxCompactTreeLayout.prototype.attachParent = function(node, height) {
          var x = this.nodeDistance + this.levelDistance;
          var y2 = (height - node.width) / 2 - this.nodeDistance;
          var y1 = y2 + node.width + 2 * this.nodeDistance - height;
          node.child.offsetX = x + node.height;
          node.child.offsetY = y1;
          node.contour.upperHead = this.createLine(
            node.height,
            0,
            this.createLine(x, y1, node.contour.upperHead)
          );
          node.contour.lowerHead = this.createLine(
            node.height,
            0,
            this.createLine(x, y2, node.contour.lowerHead)
          );
        };
        mxCompactTreeLayout.prototype.layoutLeaf = function(node) {
          var dist = 2 * this.nodeDistance;
          node.contour.upperTail = this.createLine(
            node.height + dist,
            0
          );
          node.contour.upperHead = node.contour.upperTail;
          node.contour.lowerTail = this.createLine(
            0,
            -node.width - dist
          );
          node.contour.lowerHead = this.createLine(
            node.height + dist,
            0,
            node.contour.lowerTail
          );
        };
        mxCompactTreeLayout.prototype.join = function(node) {
          var dist = 2 * this.nodeDistance;
          var child = node.child;
          node.contour = child.contour;
          var h2 = child.width + dist;
          var sum = h2;
          child = child.next;
          while (child != null) {
            var d = this.merge(node.contour, child.contour);
            child.offsetY = d + h2;
            child.offsetX = 0;
            h2 = child.width + dist;
            sum += d + h2;
            child = child.next;
          }
          return sum;
        };
        mxCompactTreeLayout.prototype.merge = function(p1, p2) {
          var x = 0;
          var y = 0;
          var total = 0;
          var upper = p1.lowerHead;
          var lower = p2.upperHead;
          while (lower != null && upper != null) {
            var d = this.offset(
              x,
              y,
              lower.dx,
              lower.dy,
              upper.dx,
              upper.dy
            );
            y += d;
            total += d;
            if (x + lower.dx <= upper.dx) {
              x += lower.dx;
              y += lower.dy;
              lower = lower.next;
            } else {
              x -= upper.dx;
              y -= upper.dy;
              upper = upper.next;
            }
          }
          if (lower != null) {
            var b = this.bridge(p1.upperTail, 0, 0, lower, x, y);
            p1.upperTail = b.next != null ? p2.upperTail : b;
            p1.lowerTail = p2.lowerTail;
          } else {
            var b = this.bridge(p2.lowerTail, x, y, upper, 0, 0);
            if (b.next == null) {
              p1.lowerTail = b;
            }
          }
          p1.lowerHead = p2.lowerHead;
          return total;
        };
        mxCompactTreeLayout.prototype.offset = function(p1, p2, a1, a2, b1, b2) {
          var d = 0;
          if (b1 <= p1 || p1 + a1 <= 0) {
            return 0;
          }
          var t = b1 * a2 - a1 * b2;
          if (t > 0) {
            if (p1 < 0) {
              var s = p1 * a2;
              d = s / a1 - p2;
            } else if (p1 > 0) {
              var s = p1 * b2;
              d = s / b1 - p2;
            } else {
              d = -p2;
            }
          } else if (b1 < p1 + a1) {
            var s = (b1 - p1) * a2;
            d = b2 - (p2 + s / a1);
          } else if (b1 > p1 + a1) {
            var s = (a1 + p1) * b2;
            d = s / b1 - (p2 + a2);
          } else {
            d = b2 - (p2 + a2);
          }
          if (d > 0) {
            return d;
          } else {
            return 0;
          }
        };
        mxCompactTreeLayout.prototype.bridge = function(line1, x1, y1, line2, x2, y2) {
          var dx = x2 + line2.dx - x1;
          var dy = 0;
          var s = 0;
          if (line2.dx == 0) {
            dy = line2.dy;
          } else {
            s = dx * line2.dy;
            dy = s / line2.dx;
          }
          var r = this.createLine(dx, dy, line2.next);
          line1.next = this.createLine(0, y2 + line2.dy - dy - y1, r);
          return r;
        };
        mxCompactTreeLayout.prototype.createNode = function(cell2) {
          var node = new Object();
          node.cell = cell2;
          node.x = 0;
          node.y = 0;
          node.width = 0;
          node.height = 0;
          var geo = this.getVertexBounds(cell2);
          if (geo != null) {
            if (this.isHorizontal()) {
              node.width = geo.height;
              node.height = geo.width;
            } else {
              node.width = geo.width;
              node.height = geo.height;
            }
          }
          node.offsetX = 0;
          node.offsetY = 0;
          node.contour = new Object();
          return node;
        };
        mxCompactTreeLayout.prototype.apply = function(node, bounds) {
          var model = this.graph.getModel();
          var cell2 = node.cell;
          var g = model.getGeometry(cell2);
          if (cell2 != null && g != null) {
            if (this.isVertexMovable(cell2)) {
              g = this.setVertexLocation(cell2, node.x, node.y);
              if (this.resizeParent) {
                var parent = model.getParent(cell2);
                var id = mxCellPath.create(parent);
                if (this.parentsChanged[id] == null) {
                  this.parentsChanged[id] = parent;
                }
              }
            }
            if (bounds == null) {
              bounds = new mxRectangle(g.x, g.y, g.width, g.height);
            } else {
              bounds = new mxRectangle(
                Math.min(bounds.x, g.x),
                Math.min(bounds.y, g.y),
                Math.max(bounds.x + bounds.width, g.x + g.width),
                Math.max(bounds.y + bounds.height, g.y + g.height)
              );
            }
          }
          return bounds;
        };
        mxCompactTreeLayout.prototype.createLine = function(dx, dy, next) {
          var line = new Object();
          line.dx = dx;
          line.dy = dy;
          line.next = next;
          return line;
        };
        mxCompactTreeLayout.prototype.adjustParents = function() {
          var tmp = [];
          for (var id in this.parentsChanged) {
            tmp.push(this.parentsChanged[id]);
          }
          this.arrangeGroups(
            mxUtils.sortCells(tmp, true),
            this.groupPadding,
            this.groupPaddingTop,
            this.groupPaddingRight,
            this.groupPaddingBottom,
            this.groupPaddingLeft
          );
        };
        mxCompactTreeLayout.prototype.localEdgeProcessing = function(node) {
          this.processNodeOutgoing(node);
          var child = node.child;
          while (child != null) {
            this.localEdgeProcessing(child);
            child = child.next;
          }
        };
        mxCompactTreeLayout.prototype.processNodeOutgoing = function(node) {
          var child = node.child;
          var parentCell = node.cell;
          var childCount = 0;
          var sortedCells = [];
          while (child != null) {
            childCount++;
            var sortingCriterion = child.x;
            if (this.horizontal) {
              sortingCriterion = child.y;
            }
            sortedCells.push(new WeightedCellSorter(child, sortingCriterion));
            child = child.next;
          }
          sortedCells.sort(WeightedCellSorter.prototype.compare);
          var availableWidth = node.width;
          var requiredWidth = (childCount + 1) * this.prefHozEdgeSep;
          if (availableWidth > requiredWidth + 2 * this.prefHozEdgeSep) {
            availableWidth -= 2 * this.prefHozEdgeSep;
          }
          var edgeSpacing = availableWidth / childCount;
          var currentXOffset = edgeSpacing / 2;
          if (availableWidth > requiredWidth + 2 * this.prefHozEdgeSep) {
            currentXOffset += this.prefHozEdgeSep;
          }
          var currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;
          var maxYOffset = 0;
          var parentBounds = this.getVertexBounds(parentCell);
          child = node.child;
          for (var j = 0; j < sortedCells.length; j++) {
            var childCell = sortedCells[j].cell.cell;
            var childBounds = this.getVertexBounds(childCell);
            var edges = this.graph.getEdgesBetween(
              parentCell,
              childCell,
              false
            );
            var newPoints = [];
            var x = 0;
            var y = 0;
            for (var i = 0; i < edges.length; i++) {
              if (this.horizontal) {
                x = parentBounds.x + parentBounds.width;
                y = parentBounds.y + currentXOffset;
                newPoints.push(new mxPoint(x, y));
                x = parentBounds.x + parentBounds.width + currentYOffset;
                newPoints.push(new mxPoint(x, y));
                y = childBounds.y + childBounds.height / 2;
                newPoints.push(new mxPoint(x, y));
                this.setEdgePoints(edges[i], newPoints);
              } else {
                x = parentBounds.x + currentXOffset;
                y = parentBounds.y + parentBounds.height;
                newPoints.push(new mxPoint(x, y));
                y = parentBounds.y + parentBounds.height + currentYOffset;
                newPoints.push(new mxPoint(x, y));
                x = childBounds.x + childBounds.width / 2;
                newPoints.push(new mxPoint(x, y));
                this.setEdgePoints(edges[i], newPoints);
              }
            }
            if (j < childCount / 2) {
              currentYOffset += this.prefVertEdgeOff;
            } else if (j > childCount / 2) {
              currentYOffset -= this.prefVertEdgeOff;
            }
            currentXOffset += edgeSpacing;
            maxYOffset = Math.max(maxYOffset, currentYOffset);
          }
        };
        __mxOutput.mxCompactTreeLayout = typeof mxCompactTreeLayout !== "undefined" ? mxCompactTreeLayout : void 0;
        function mxRadialTreeLayout(graph) {
          mxCompactTreeLayout.call(this, graph, false);
        }
        ;
        mxUtils.extend(mxRadialTreeLayout, mxCompactTreeLayout);
        mxRadialTreeLayout.prototype.angleOffset = 0.5;
        mxRadialTreeLayout.prototype.rootx = 0;
        mxRadialTreeLayout.prototype.rooty = 0;
        mxRadialTreeLayout.prototype.levelDistance = 120;
        mxRadialTreeLayout.prototype.nodeDistance = 10;
        mxRadialTreeLayout.prototype.autoRadius = false;
        mxRadialTreeLayout.prototype.sortEdges = false;
        mxRadialTreeLayout.prototype.rowMinX = [];
        mxRadialTreeLayout.prototype.rowMaxX = [];
        mxRadialTreeLayout.prototype.rowMinCenX = [];
        mxRadialTreeLayout.prototype.rowMaxCenX = [];
        mxRadialTreeLayout.prototype.rowRadi = [];
        mxRadialTreeLayout.prototype.row = [];
        mxRadialTreeLayout.prototype.isVertexIgnored = function(vertex) {
          return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || this.graph.getConnections(vertex).length == 0;
        };
        mxRadialTreeLayout.prototype.execute = function(parent, root) {
          this.parent = parent;
          this.useBoundingBox = false;
          this.edgeRouting = false;
          mxCompactTreeLayout.prototype.execute.apply(this, arguments);
          var bounds = null;
          var rootBounds = this.getVertexBounds(this.root);
          this.centerX = rootBounds.x + rootBounds.width / 2;
          this.centerY = rootBounds.y + rootBounds.height / 2;
          for (var vertex in this.visited) {
            var vertexBounds = this.getVertexBounds(this.visited[vertex]);
            bounds = bounds != null ? bounds : vertexBounds.clone();
            bounds.add(vertexBounds);
          }
          this.calcRowDims([this.node], 0);
          var maxLeftGrad = 0;
          var maxRightGrad = 0;
          for (var i = 0; i < this.row.length; i++) {
            var leftGrad = (this.centerX - this.rowMinX[i] - this.nodeDistance) / this.rowRadi[i];
            var rightGrad = (this.rowMaxX[i] - this.centerX - this.nodeDistance) / this.rowRadi[i];
            maxLeftGrad = Math.max(maxLeftGrad, leftGrad);
            maxRightGrad = Math.max(maxRightGrad, rightGrad);
          }
          for (var i = 0; i < this.row.length; i++) {
            var xLeftLimit = this.centerX - this.nodeDistance - maxLeftGrad * this.rowRadi[i];
            var xRightLimit = this.centerX + this.nodeDistance + maxRightGrad * this.rowRadi[i];
            var fullWidth = xRightLimit - xLeftLimit;
            for (var j = 0; j < this.row[i].length; j++) {
              var row = this.row[i];
              var node = row[j];
              var vertexBounds = this.getVertexBounds(node.cell);
              var xProportion = (vertexBounds.x + vertexBounds.width / 2 - xLeftLimit) / fullWidth;
              var theta = 2 * Math.PI * xProportion;
              node.theta = theta;
            }
          }
          for (var i = this.row.length - 2; i >= 0; i--) {
            var row = this.row[i];
            for (var j = 0; j < row.length; j++) {
              var node = row[j];
              var child = node.child;
              var counter = 0;
              var totalTheta = 0;
              while (child != null) {
                totalTheta += child.theta;
                counter++;
                child = child.next;
              }
              if (counter > 0) {
                var averTheta = totalTheta / counter;
                if (averTheta > node.theta && j < row.length - 1) {
                  var nextTheta = row[j + 1].theta;
                  node.theta = Math.min(averTheta, nextTheta - Math.PI / 10);
                } else if (averTheta < node.theta && j > 0) {
                  var lastTheta = row[j - 1].theta;
                  node.theta = Math.max(averTheta, lastTheta + Math.PI / 10);
                }
              }
            }
          }
          for (var i = 0; i < this.row.length; i++) {
            for (var j = 0; j < this.row[i].length; j++) {
              var row = this.row[i];
              var node = row[j];
              var vertexBounds = this.getVertexBounds(node.cell);
              this.setVertexLocation(
                node.cell,
                this.centerX - vertexBounds.width / 2 + this.rowRadi[i] * Math.cos(node.theta),
                this.centerY - vertexBounds.height / 2 + this.rowRadi[i] * Math.sin(node.theta)
              );
            }
          }
        };
        mxRadialTreeLayout.prototype.calcRowDims = function(row, rowNum) {
          if (row == null || row.length == 0) {
            return;
          }
          this.rowMinX[rowNum] = this.centerX;
          this.rowMaxX[rowNum] = this.centerX;
          this.rowMinCenX[rowNum] = this.centerX;
          this.rowMaxCenX[rowNum] = this.centerX;
          this.row[rowNum] = [];
          var rowHasChildren = false;
          for (var i = 0; i < row.length; i++) {
            var child = row[i] != null ? row[i].child : null;
            while (child != null) {
              var cell2 = child.cell;
              var vertexBounds = this.getVertexBounds(cell2);
              this.rowMinX[rowNum] = Math.min(vertexBounds.x, this.rowMinX[rowNum]);
              this.rowMaxX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width, this.rowMaxX[rowNum]);
              this.rowMinCenX[rowNum] = Math.min(vertexBounds.x + vertexBounds.width / 2, this.rowMinCenX[rowNum]);
              this.rowMaxCenX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width / 2, this.rowMaxCenX[rowNum]);
              this.rowRadi[rowNum] = vertexBounds.y - this.getVertexBounds(this.root).y;
              if (child.child != null) {
                rowHasChildren = true;
              }
              this.row[rowNum].push(child);
              child = child.next;
            }
          }
          if (rowHasChildren) {
            this.calcRowDims(this.row[rowNum], rowNum + 1);
          }
        };
        __mxOutput.mxRadialTreeLayout = typeof mxRadialTreeLayout !== "undefined" ? mxRadialTreeLayout : void 0;
        function mxFastOrganicLayout(graph) {
          mxGraphLayout.call(this, graph);
        }
        ;
        mxFastOrganicLayout.prototype = new mxGraphLayout();
        mxFastOrganicLayout.prototype.constructor = mxFastOrganicLayout;
        mxFastOrganicLayout.prototype.useInputOrigin = true;
        mxFastOrganicLayout.prototype.resetEdges = true;
        mxFastOrganicLayout.prototype.disableEdgeStyle = true;
        mxFastOrganicLayout.prototype.forceConstant = 50;
        mxFastOrganicLayout.prototype.forceConstantSquared = 0;
        mxFastOrganicLayout.prototype.minDistanceLimit = 2;
        mxFastOrganicLayout.prototype.maxDistanceLimit = 500;
        mxFastOrganicLayout.prototype.minDistanceLimitSquared = 4;
        mxFastOrganicLayout.prototype.initialTemp = 200;
        mxFastOrganicLayout.prototype.temperature = 0;
        mxFastOrganicLayout.prototype.maxIterations = 0;
        mxFastOrganicLayout.prototype.iteration = 0;
        mxFastOrganicLayout.prototype.vertexArray;
        mxFastOrganicLayout.prototype.dispX;
        mxFastOrganicLayout.prototype.dispY;
        mxFastOrganicLayout.prototype.cellLocation;
        mxFastOrganicLayout.prototype.radius;
        mxFastOrganicLayout.prototype.radiusSquared;
        mxFastOrganicLayout.prototype.isMoveable;
        mxFastOrganicLayout.prototype.neighbours;
        mxFastOrganicLayout.prototype.indices;
        mxFastOrganicLayout.prototype.allowedToRun = true;
        mxFastOrganicLayout.prototype.isVertexIgnored = function(vertex) {
          return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || this.graph.getConnections(vertex).length == 0;
        };
        mxFastOrganicLayout.prototype.execute = function(parent) {
          var model = this.graph.getModel();
          this.vertexArray = [];
          var cells = this.graph.getChildVertices(parent);
          for (var i = 0; i < cells.length; i++) {
            if (!this.isVertexIgnored(cells[i])) {
              this.vertexArray.push(cells[i]);
            }
          }
          var initialBounds = this.useInputOrigin ? this.graph.getBoundingBoxFromGeometry(this.vertexArray) : null;
          var n = this.vertexArray.length;
          this.indices = [];
          this.dispX = [];
          this.dispY = [];
          this.cellLocation = [];
          this.isMoveable = [];
          this.neighbours = [];
          this.radius = [];
          this.radiusSquared = [];
          if (this.forceConstant < 1e-3) {
            this.forceConstant = 1e-3;
          }
          this.forceConstantSquared = this.forceConstant * this.forceConstant;
          for (var i = 0; i < this.vertexArray.length; i++) {
            var vertex = this.vertexArray[i];
            this.cellLocation[i] = [];
            var id = mxObjectIdentity.get(vertex);
            this.indices[id] = i;
            var bounds = this.getVertexBounds(vertex);
            var width = bounds.width;
            var height = bounds.height;
            var x = bounds.x;
            var y = bounds.y;
            this.cellLocation[i][0] = x + width / 2;
            this.cellLocation[i][1] = y + height / 2;
            this.radius[i] = Math.min(width, height);
            this.radiusSquared[i] = this.radius[i] * this.radius[i];
          }
          model.beginUpdate();
          try {
            for (var i = 0; i < n; i++) {
              this.dispX[i] = 0;
              this.dispY[i] = 0;
              this.isMoveable[i] = this.isVertexMovable(this.vertexArray[i]);
              var edges = this.graph.getConnections(this.vertexArray[i], parent);
              var cells = this.graph.getOpposites(edges, this.vertexArray[i]);
              this.neighbours[i] = [];
              for (var j = 0; j < cells.length; j++) {
                if (this.resetEdges) {
                  this.graph.resetEdge(edges[j]);
                }
                if (this.disableEdgeStyle) {
                  this.setEdgeStyleEnabled(edges[j], false);
                }
                var id = mxObjectIdentity.get(cells[j]);
                var index = this.indices[id];
                if (index != null) {
                  this.neighbours[i][j] = index;
                } else {
                  this.neighbours[i][j] = i;
                }
              }
            }
            this.temperature = this.initialTemp;
            if (this.maxIterations == 0) {
              this.maxIterations = 20 * Math.sqrt(n);
            }
            for (this.iteration = 0; this.iteration < this.maxIterations; this.iteration++) {
              if (!this.allowedToRun) {
                return;
              }
              this.calcRepulsion();
              this.calcAttraction();
              this.calcPositions();
              this.reduceTemperature();
            }
            var minx = null;
            var miny = null;
            for (var i = 0; i < this.vertexArray.length; i++) {
              var vertex = this.vertexArray[i];
              if (this.isVertexMovable(vertex)) {
                var bounds = this.getVertexBounds(vertex);
                if (bounds != null) {
                  this.cellLocation[i][0] -= bounds.width / 2;
                  this.cellLocation[i][1] -= bounds.height / 2;
                  var x = this.graph.snap(Math.round(this.cellLocation[i][0]));
                  var y = this.graph.snap(Math.round(this.cellLocation[i][1]));
                  this.setVertexLocation(vertex, x, y);
                  if (minx == null) {
                    minx = x;
                  } else {
                    minx = Math.min(minx, x);
                  }
                  if (miny == null) {
                    miny = y;
                  } else {
                    miny = Math.min(miny, y);
                  }
                }
              }
            }
            var dx = -(minx || 0) + 1;
            var dy = -(miny || 0) + 1;
            if (initialBounds != null) {
              dx += initialBounds.x;
              dy += initialBounds.y;
            }
            this.graph.moveCells(this.vertexArray, dx, dy);
          } finally {
            model.endUpdate();
          }
        };
        mxFastOrganicLayout.prototype.calcPositions = function() {
          for (var index = 0; index < this.vertexArray.length; index++) {
            if (this.isMoveable[index]) {
              var deltaLength = Math.sqrt(this.dispX[index] * this.dispX[index] + this.dispY[index] * this.dispY[index]);
              if (deltaLength < 1e-3) {
                deltaLength = 1e-3;
              }
              var newXDisp = this.dispX[index] / deltaLength * Math.min(deltaLength, this.temperature);
              var newYDisp = this.dispY[index] / deltaLength * Math.min(deltaLength, this.temperature);
              this.dispX[index] = 0;
              this.dispY[index] = 0;
              this.cellLocation[index][0] += newXDisp;
              this.cellLocation[index][1] += newYDisp;
            }
          }
        };
        mxFastOrganicLayout.prototype.calcAttraction = function() {
          for (var i = 0; i < this.vertexArray.length; i++) {
            for (var k = 0; k < this.neighbours[i].length; k++) {
              var j = this.neighbours[i][k];
              if (i != j && this.isMoveable[i] && this.isMoveable[j]) {
                var xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];
                var yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];
                var deltaLengthSquared = xDelta * xDelta + yDelta * yDelta - this.radiusSquared[i] - this.radiusSquared[j];
                if (deltaLengthSquared < this.minDistanceLimitSquared) {
                  deltaLengthSquared = this.minDistanceLimitSquared;
                }
                var deltaLength = Math.sqrt(deltaLengthSquared);
                var force = deltaLengthSquared / this.forceConstant;
                var displacementX = xDelta / deltaLength * force;
                var displacementY = yDelta / deltaLength * force;
                this.dispX[i] -= displacementX;
                this.dispY[i] -= displacementY;
                this.dispX[j] += displacementX;
                this.dispY[j] += displacementY;
              }
            }
          }
        };
        mxFastOrganicLayout.prototype.calcRepulsion = function() {
          var vertexCount = this.vertexArray.length;
          for (var i = 0; i < vertexCount; i++) {
            for (var j = i; j < vertexCount; j++) {
              if (!this.allowedToRun) {
                return;
              }
              if (j != i && this.isMoveable[i] && this.isMoveable[j]) {
                var xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];
                var yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];
                if (xDelta == 0) {
                  xDelta = 0.01 + Math.random();
                }
                if (yDelta == 0) {
                  yDelta = 0.01 + Math.random();
                }
                var deltaLength = Math.sqrt(xDelta * xDelta + yDelta * yDelta);
                var deltaLengthWithRadius = deltaLength - this.radius[i] - this.radius[j];
                if (deltaLengthWithRadius > this.maxDistanceLimit) {
                  continue;
                }
                if (deltaLengthWithRadius < this.minDistanceLimit) {
                  deltaLengthWithRadius = this.minDistanceLimit;
                }
                var force = this.forceConstantSquared / deltaLengthWithRadius;
                var displacementX = xDelta / deltaLength * force;
                var displacementY = yDelta / deltaLength * force;
                this.dispX[i] += displacementX;
                this.dispY[i] += displacementY;
                this.dispX[j] -= displacementX;
                this.dispY[j] -= displacementY;
              }
            }
          }
        };
        mxFastOrganicLayout.prototype.reduceTemperature = function() {
          this.temperature = this.initialTemp * (1 - this.iteration / this.maxIterations);
        };
        __mxOutput.mxFastOrganicLayout = typeof mxFastOrganicLayout !== "undefined" ? mxFastOrganicLayout : void 0;
        function mxCircleLayout(graph, radius) {
          mxGraphLayout.call(this, graph);
          this.radius = radius != null ? radius : 100;
        }
        ;
        mxCircleLayout.prototype = new mxGraphLayout();
        mxCircleLayout.prototype.constructor = mxCircleLayout;
        mxCircleLayout.prototype.radius = null;
        mxCircleLayout.prototype.moveCircle = false;
        mxCircleLayout.prototype.x0 = 0;
        mxCircleLayout.prototype.y0 = 0;
        mxCircleLayout.prototype.resetEdges = true;
        mxCircleLayout.prototype.disableEdgeStyle = true;
        mxCircleLayout.prototype.execute = function(parent) {
          var model = this.graph.getModel();
          model.beginUpdate();
          try {
            var max = 0;
            var top = null;
            var left = null;
            var vertices = [];
            var childCount = model.getChildCount(parent);
            for (var i = 0; i < childCount; i++) {
              var cell2 = model.getChildAt(parent, i);
              if (!this.isVertexIgnored(cell2)) {
                vertices.push(cell2);
                var bounds = this.getVertexBounds(cell2);
                if (top == null) {
                  top = bounds.y;
                } else {
                  top = Math.min(top, bounds.y);
                }
                if (left == null) {
                  left = bounds.x;
                } else {
                  left = Math.min(left, bounds.x);
                }
                max = Math.max(max, Math.max(bounds.width, bounds.height));
              } else if (!this.isEdgeIgnored(cell2)) {
                if (this.resetEdges) {
                  this.graph.resetEdge(cell2);
                }
                if (this.disableEdgeStyle) {
                  this.setEdgeStyleEnabled(cell2, false);
                }
              }
            }
            var r = this.getRadius(vertices.length, max);
            if (this.moveCircle) {
              left = this.x0;
              top = this.y0;
            }
            this.circle(vertices, r, left, top);
          } finally {
            model.endUpdate();
          }
        };
        mxCircleLayout.prototype.getRadius = function(count, max) {
          return Math.max(count * max / Math.PI, this.radius);
        };
        mxCircleLayout.prototype.circle = function(vertices, r, left, top) {
          var vertexCount = vertices.length;
          var phi = 2 * Math.PI / vertexCount;
          for (var i = 0; i < vertexCount; i++) {
            if (this.isVertexMovable(vertices[i])) {
              this.setVertexLocation(
                vertices[i],
                Math.round(left + r + r * Math.sin(i * phi)),
                Math.round(top + r + r * Math.cos(i * phi))
              );
            }
          }
        };
        __mxOutput.mxCircleLayout = typeof mxCircleLayout !== "undefined" ? mxCircleLayout : void 0;
        function mxParallelEdgeLayout(graph) {
          mxGraphLayout.call(this, graph);
        }
        ;
        mxParallelEdgeLayout.prototype = new mxGraphLayout();
        mxParallelEdgeLayout.prototype.constructor = mxParallelEdgeLayout;
        mxParallelEdgeLayout.prototype.spacing = 20;
        mxParallelEdgeLayout.prototype.checkOverlap = false;
        mxParallelEdgeLayout.prototype.execute = function(parent, cells) {
          var lookup = this.findParallels(parent, cells);
          this.graph.model.beginUpdate();
          try {
            for (var i in lookup) {
              var parallels = lookup[i];
              if (parallels.length > 1) {
                this.layout(parallels);
              }
            }
          } finally {
            this.graph.model.endUpdate();
          }
        };
        mxParallelEdgeLayout.prototype.findParallels = function(parent, cells) {
          var lookup = [];
          var addCell = mxUtils.bind(this, function(cell2) {
            if (!this.isEdgeIgnored(cell2)) {
              var id = this.getEdgeId(cell2);
              if (id != null) {
                if (lookup[id] == null) {
                  lookup[id] = [];
                }
                lookup[id].push(cell2);
              }
            }
          });
          if (cells != null) {
            for (var i = 0; i < cells.length; i++) {
              addCell(cells[i]);
            }
          } else {
            var model = this.graph.getModel();
            var childCount = model.getChildCount(parent);
            for (var i = 0; i < childCount; i++) {
              addCell(model.getChildAt(parent, i));
            }
          }
          return lookup;
        };
        mxParallelEdgeLayout.prototype.getEdgeId = function(edge) {
          var view = this.graph.getView();
          var src = view.getVisibleTerminal(edge, true);
          var trg = view.getVisibleTerminal(edge, false);
          var pts = "";
          if (src != null && trg != null) {
            src = mxObjectIdentity.get(src);
            trg = mxObjectIdentity.get(trg);
            if (this.checkOverlap) {
              var state = this.graph.view.getState(edge);
              if (state != null && state.absolutePoints != null) {
                var tmp = [];
                for (var i = 0; i < state.absolutePoints.length; i++) {
                  var pt = state.absolutePoints[i];
                  if (pt != null) {
                    tmp.push(pt.x, pt.y);
                  }
                }
                pts = tmp.join(",");
              }
            }
            ;
            return (src > trg ? trg + "-" + src : src + "-" + trg) + pts;
          }
          return null;
        };
        mxParallelEdgeLayout.prototype.layout = function(parallels) {
          var edge = parallels[0];
          var view = this.graph.getView();
          var model = this.graph.getModel();
          var src = model.getGeometry(view.getVisibleTerminal(edge, true));
          var trg = model.getGeometry(view.getVisibleTerminal(edge, false));
          if (src == trg) {
            var x0 = src.x + src.width + this.spacing;
            var y0 = src.y + src.height / 2;
            for (var i = 0; i < parallels.length; i++) {
              this.route(parallels[i], x0, y0);
              x0 += this.spacing;
            }
          } else if (src != null && trg != null) {
            var scx = src.x + src.width / 2;
            var scy = src.y + src.height / 2;
            var tcx = trg.x + trg.width / 2;
            var tcy = trg.y + trg.height / 2;
            var dx = tcx - scx;
            var dy = tcy - scy;
            var len = Math.sqrt(dx * dx + dy * dy);
            if (len > 0) {
              var x0 = scx + dx / 2;
              var y0 = scy + dy / 2;
              var nx = dy * this.spacing / len;
              var ny = dx * this.spacing / len;
              x0 += nx * (parallels.length - 1) / 2;
              y0 -= ny * (parallels.length - 1) / 2;
              for (var i = 0; i < parallels.length; i++) {
                this.route(parallels[i], x0, y0);
                x0 -= nx;
                y0 += ny;
              }
            }
          }
        };
        mxParallelEdgeLayout.prototype.route = function(edge, x, y) {
          if (this.graph.isCellMovable(edge)) {
            this.setEdgePoints(edge, [new mxPoint(x, y)]);
          }
        };
        __mxOutput.mxParallelEdgeLayout = typeof mxParallelEdgeLayout !== "undefined" ? mxParallelEdgeLayout : void 0;
        function mxCompositeLayout(graph, layouts, master) {
          mxGraphLayout.call(this, graph);
          this.layouts = layouts;
          this.master = master;
        }
        ;
        mxCompositeLayout.prototype = new mxGraphLayout();
        mxCompositeLayout.prototype.constructor = mxCompositeLayout;
        mxCompositeLayout.prototype.layouts = null;
        mxCompositeLayout.prototype.master = null;
        mxCompositeLayout.prototype.moveCell = function(cell2, x, y) {
          if (this.master != null) {
            this.master.moveCell.apply(this.master, arguments);
          } else {
            this.layouts[0].moveCell.apply(this.layouts[0], arguments);
          }
        };
        mxCompositeLayout.prototype.execute = function(parent) {
          var model = this.graph.getModel();
          model.beginUpdate();
          try {
            for (var i = 0; i < this.layouts.length; i++) {
              this.layouts[i].execute.apply(this.layouts[i], arguments);
            }
          } finally {
            model.endUpdate();
          }
        };
        __mxOutput.mxCompositeLayout = typeof mxCompositeLayout !== "undefined" ? mxCompositeLayout : void 0;
        function mxEdgeLabelLayout(graph, radius) {
          mxGraphLayout.call(this, graph);
        }
        ;
        mxEdgeLabelLayout.prototype = new mxGraphLayout();
        mxEdgeLabelLayout.prototype.constructor = mxEdgeLabelLayout;
        mxEdgeLabelLayout.prototype.execute = function(parent) {
          var view = this.graph.view;
          var model = this.graph.getModel();
          var edges = [];
          var vertices = [];
          var childCount = model.getChildCount(parent);
          for (var i = 0; i < childCount; i++) {
            var cell2 = model.getChildAt(parent, i);
            var state = view.getState(cell2);
            if (state != null) {
              if (!this.isVertexIgnored(cell2)) {
                vertices.push(state);
              } else if (!this.isEdgeIgnored(cell2)) {
                edges.push(state);
              }
            }
          }
          this.placeLabels(vertices, edges);
        };
        mxEdgeLabelLayout.prototype.placeLabels = function(v, e) {
          var model = this.graph.getModel();
          model.beginUpdate();
          try {
            for (var i = 0; i < e.length; i++) {
              var edge = e[i];
              if (edge != null && edge.text != null && edge.text.boundingBox != null) {
                for (var j = 0; j < v.length; j++) {
                  var vertex = v[j];
                  if (vertex != null) {
                    this.avoid(edge, vertex);
                  }
                }
              }
            }
          } finally {
            model.endUpdate();
          }
        };
        mxEdgeLabelLayout.prototype.avoid = function(edge, vertex) {
          var model = this.graph.getModel();
          var labRect = edge.text.boundingBox;
          if (mxUtils.intersects(labRect, vertex)) {
            var dy1 = -labRect.y - labRect.height + vertex.y;
            var dy2 = -labRect.y + vertex.y + vertex.height;
            var dy = Math.abs(dy1) < Math.abs(dy2) ? dy1 : dy2;
            var dx1 = -labRect.x - labRect.width + vertex.x;
            var dx2 = -labRect.x + vertex.x + vertex.width;
            var dx = Math.abs(dx1) < Math.abs(dx2) ? dx1 : dx2;
            if (Math.abs(dx) < Math.abs(dy)) {
              dy = 0;
            } else {
              dx = 0;
            }
            var g = model.getGeometry(edge.cell);
            if (g != null) {
              g = g.clone();
              if (g.offset != null) {
                g.offset.x += dx;
                g.offset.y += dy;
              } else {
                g.offset = new mxPoint(dx, dy);
              }
              model.setGeometry(edge.cell, g);
            }
          }
        };
        __mxOutput.mxEdgeLabelLayout = typeof mxEdgeLabelLayout !== "undefined" ? mxEdgeLabelLayout : void 0;
        function mxGraphAbstractHierarchyCell() {
          this.x = [];
          this.y = [];
          this.temp = [];
        }
        ;
        mxGraphAbstractHierarchyCell.prototype.maxRank = -1;
        mxGraphAbstractHierarchyCell.prototype.minRank = -1;
        mxGraphAbstractHierarchyCell.prototype.x = null;
        mxGraphAbstractHierarchyCell.prototype.y = null;
        mxGraphAbstractHierarchyCell.prototype.width = 0;
        mxGraphAbstractHierarchyCell.prototype.height = 0;
        mxGraphAbstractHierarchyCell.prototype.nextLayerConnectedCells = null;
        mxGraphAbstractHierarchyCell.prototype.previousLayerConnectedCells = null;
        mxGraphAbstractHierarchyCell.prototype.temp = null;
        mxGraphAbstractHierarchyCell.prototype.getNextLayerConnectedCells = function(layer) {
          return null;
        };
        mxGraphAbstractHierarchyCell.prototype.getPreviousLayerConnectedCells = function(layer) {
          return null;
        };
        mxGraphAbstractHierarchyCell.prototype.isEdge = function() {
          return false;
        };
        mxGraphAbstractHierarchyCell.prototype.isVertex = function() {
          return false;
        };
        mxGraphAbstractHierarchyCell.prototype.getGeneralPurposeVariable = function(layer) {
          return null;
        };
        mxGraphAbstractHierarchyCell.prototype.setGeneralPurposeVariable = function(layer, value) {
          return null;
        };
        mxGraphAbstractHierarchyCell.prototype.setX = function(layer, value) {
          if (this.isVertex()) {
            this.x[0] = value;
          } else if (this.isEdge()) {
            this.x[layer - this.minRank - 1] = value;
          }
        };
        mxGraphAbstractHierarchyCell.prototype.getX = function(layer) {
          if (this.isVertex()) {
            return this.x[0];
          } else if (this.isEdge()) {
            return this.x[layer - this.minRank - 1];
          }
          return 0;
        };
        mxGraphAbstractHierarchyCell.prototype.setY = function(layer, value) {
          if (this.isVertex()) {
            this.y[0] = value;
          } else if (this.isEdge()) {
            this.y[layer - this.minRank - 1] = value;
          }
        };
        __mxOutput.mxGraphAbstractHierarchyCell = typeof mxGraphAbstractHierarchyCell !== "undefined" ? mxGraphAbstractHierarchyCell : void 0;
        function mxGraphHierarchyNode(cell2) {
          mxGraphAbstractHierarchyCell.apply(this, arguments);
          this.cell = cell2;
          this.id = mxObjectIdentity.get(cell2);
          this.connectsAsTarget = [];
          this.connectsAsSource = [];
        }
        ;
        mxGraphHierarchyNode.prototype = new mxGraphAbstractHierarchyCell();
        mxGraphHierarchyNode.prototype.constructor = mxGraphHierarchyNode;
        mxGraphHierarchyNode.prototype.cell = null;
        mxGraphHierarchyNode.prototype.id = null;
        mxGraphHierarchyNode.prototype.connectsAsTarget = null;
        mxGraphHierarchyNode.prototype.connectsAsSource = null;
        mxGraphHierarchyNode.prototype.hashCode = false;
        mxGraphHierarchyNode.prototype.getRankValue = function(layer) {
          return this.maxRank;
        };
        mxGraphHierarchyNode.prototype.getNextLayerConnectedCells = function(layer) {
          if (this.nextLayerConnectedCells == null) {
            this.nextLayerConnectedCells = [];
            this.nextLayerConnectedCells[0] = [];
            for (var i = 0; i < this.connectsAsTarget.length; i++) {
              var edge = this.connectsAsTarget[i];
              if (edge.maxRank == -1 || edge.maxRank == layer + 1) {
                this.nextLayerConnectedCells[0].push(edge.source);
              } else {
                this.nextLayerConnectedCells[0].push(edge);
              }
            }
          }
          return this.nextLayerConnectedCells[0];
        };
        mxGraphHierarchyNode.prototype.getPreviousLayerConnectedCells = function(layer) {
          if (this.previousLayerConnectedCells == null) {
            this.previousLayerConnectedCells = [];
            this.previousLayerConnectedCells[0] = [];
            for (var i = 0; i < this.connectsAsSource.length; i++) {
              var edge = this.connectsAsSource[i];
              if (edge.minRank == -1 || edge.minRank == layer - 1) {
                this.previousLayerConnectedCells[0].push(edge.target);
              } else {
                this.previousLayerConnectedCells[0].push(edge);
              }
            }
          }
          return this.previousLayerConnectedCells[0];
        };
        mxGraphHierarchyNode.prototype.isVertex = function() {
          return true;
        };
        mxGraphHierarchyNode.prototype.getGeneralPurposeVariable = function(layer) {
          return this.temp[0];
        };
        mxGraphHierarchyNode.prototype.setGeneralPurposeVariable = function(layer, value) {
          this.temp[0] = value;
        };
        mxGraphHierarchyNode.prototype.isAncestor = function(otherNode) {
          if (otherNode != null && this.hashCode != null && otherNode.hashCode != null && this.hashCode.length < otherNode.hashCode.length) {
            if (this.hashCode == otherNode.hashCode) {
              return true;
            }
            if (this.hashCode == null || this.hashCode == null) {
              return false;
            }
            for (var i = 0; i < this.hashCode.length; i++) {
              if (this.hashCode[i] != otherNode.hashCode[i]) {
                return false;
              }
            }
            return true;
          }
          return false;
        };
        mxGraphHierarchyNode.prototype.getCoreCell = function() {
          return this.cell;
        };
        __mxOutput.mxGraphHierarchyNode = typeof mxGraphHierarchyNode !== "undefined" ? mxGraphHierarchyNode : void 0;
        function mxGraphHierarchyEdge(edges) {
          mxGraphAbstractHierarchyCell.apply(this, arguments);
          this.edges = edges;
          this.ids = [];
          for (var i = 0; i < edges.length; i++) {
            this.ids.push(mxObjectIdentity.get(edges[i]));
          }
        }
        ;
        mxGraphHierarchyEdge.prototype = new mxGraphAbstractHierarchyCell();
        mxGraphHierarchyEdge.prototype.constructor = mxGraphHierarchyEdge;
        mxGraphHierarchyEdge.prototype.edges = null;
        mxGraphHierarchyEdge.prototype.ids = null;
        mxGraphHierarchyEdge.prototype.source = null;
        mxGraphHierarchyEdge.prototype.target = null;
        mxGraphHierarchyEdge.prototype.isReversed = false;
        mxGraphHierarchyEdge.prototype.invert = function(layer) {
          var temp = this.source;
          this.source = this.target;
          this.target = temp;
          this.isReversed = !this.isReversed;
        };
        mxGraphHierarchyEdge.prototype.getNextLayerConnectedCells = function(layer) {
          if (this.nextLayerConnectedCells == null) {
            this.nextLayerConnectedCells = [];
            for (var i = 0; i < this.temp.length; i++) {
              this.nextLayerConnectedCells[i] = [];
              if (i == this.temp.length - 1) {
                this.nextLayerConnectedCells[i].push(this.source);
              } else {
                this.nextLayerConnectedCells[i].push(this);
              }
            }
          }
          return this.nextLayerConnectedCells[layer - this.minRank - 1];
        };
        mxGraphHierarchyEdge.prototype.getPreviousLayerConnectedCells = function(layer) {
          if (this.previousLayerConnectedCells == null) {
            this.previousLayerConnectedCells = [];
            for (var i = 0; i < this.temp.length; i++) {
              this.previousLayerConnectedCells[i] = [];
              if (i == 0) {
                this.previousLayerConnectedCells[i].push(this.target);
              } else {
                this.previousLayerConnectedCells[i].push(this);
              }
            }
          }
          return this.previousLayerConnectedCells[layer - this.minRank - 1];
        };
        mxGraphHierarchyEdge.prototype.isEdge = function() {
          return true;
        };
        mxGraphHierarchyEdge.prototype.getGeneralPurposeVariable = function(layer) {
          return this.temp[layer - this.minRank - 1];
        };
        mxGraphHierarchyEdge.prototype.setGeneralPurposeVariable = function(layer, value) {
          this.temp[layer - this.minRank - 1] = value;
        };
        mxGraphHierarchyEdge.prototype.getCoreCell = function() {
          if (this.edges != null && this.edges.length > 0) {
            return this.edges[0];
          }
          return null;
        };
        __mxOutput.mxGraphHierarchyEdge = typeof mxGraphHierarchyEdge !== "undefined" ? mxGraphHierarchyEdge : void 0;
        function mxGraphHierarchyModel(layout, vertices, roots, parent, tightenToSource) {
          var graph = layout.getGraph();
          this.tightenToSource = tightenToSource;
          this.roots = roots;
          this.parent = parent;
          this.vertexMapper = new mxDictionary();
          this.edgeMapper = new mxDictionary();
          this.maxRank = 0;
          var internalVertices = [];
          if (vertices == null) {
            vertices = this.graph.getChildVertices(parent);
          }
          this.maxRank = this.SOURCESCANSTARTRANK;
          this.createInternalCells(layout, vertices, internalVertices);
          for (var i = 0; i < vertices.length; i++) {
            var edges = internalVertices[i].connectsAsSource;
            for (var j = 0; j < edges.length; j++) {
              var internalEdge = edges[j];
              var realEdges = internalEdge.edges;
              if (realEdges != null && realEdges.length > 0) {
                var realEdge = realEdges[0];
                var targetCell = layout.getVisibleTerminal(
                  realEdge,
                  false
                );
                var internalTargetCell = this.vertexMapper.get(targetCell);
                if (internalVertices[i] == internalTargetCell) {
                  targetCell = layout.getVisibleTerminal(
                    realEdge,
                    true
                  );
                  internalTargetCell = this.vertexMapper.get(targetCell);
                }
                if (internalTargetCell != null && internalVertices[i] != internalTargetCell) {
                  internalEdge.target = internalTargetCell;
                  if (internalTargetCell.connectsAsTarget.length == 0) {
                    internalTargetCell.connectsAsTarget = [];
                  }
                  if (mxUtils.indexOf(internalTargetCell.connectsAsTarget, internalEdge) < 0) {
                    internalTargetCell.connectsAsTarget.push(internalEdge);
                  }
                }
              }
            }
            internalVertices[i].temp[0] = 1;
          }
        }
        ;
        mxGraphHierarchyModel.prototype.maxRank = null;
        mxGraphHierarchyModel.prototype.vertexMapper = null;
        mxGraphHierarchyModel.prototype.edgeMapper = null;
        mxGraphHierarchyModel.prototype.ranks = null;
        mxGraphHierarchyModel.prototype.roots = null;
        mxGraphHierarchyModel.prototype.parent = null;
        mxGraphHierarchyModel.prototype.dfsCount = 0;
        mxGraphHierarchyModel.prototype.SOURCESCANSTARTRANK = 1e8;
        mxGraphHierarchyModel.prototype.tightenToSource = false;
        mxGraphHierarchyModel.prototype.createInternalCells = function(layout, vertices, internalVertices) {
          var graph = layout.getGraph();
          for (var i = 0; i < vertices.length; i++) {
            internalVertices[i] = new mxGraphHierarchyNode(vertices[i]);
            this.vertexMapper.put(vertices[i], internalVertices[i]);
            var conns = layout.getEdges(vertices[i]);
            internalVertices[i].connectsAsSource = [];
            for (var j = 0; j < conns.length; j++) {
              var cell2 = layout.getVisibleTerminal(conns[j], false);
              if (cell2 != vertices[i] && layout.graph.model.isVertex(cell2) && !layout.isVertexIgnored(cell2)) {
                var undirectedEdges = layout.getEdgesBetween(
                  vertices[i],
                  cell2,
                  false
                );
                var directedEdges = layout.getEdgesBetween(
                  vertices[i],
                  cell2,
                  true
                );
                if (undirectedEdges != null && undirectedEdges.length > 0 && this.edgeMapper.get(undirectedEdges[0]) == null && directedEdges.length * 2 >= undirectedEdges.length) {
                  var internalEdge = new mxGraphHierarchyEdge(undirectedEdges);
                  for (var k = 0; k < undirectedEdges.length; k++) {
                    var edge = undirectedEdges[k];
                    this.edgeMapper.put(edge, internalEdge);
                    graph.resetEdge(edge);
                    if (layout.disableEdgeStyle) {
                      layout.setEdgeStyleEnabled(edge, false);
                      layout.setOrthogonalEdge(edge, true);
                    }
                  }
                  internalEdge.source = internalVertices[i];
                  if (mxUtils.indexOf(internalVertices[i].connectsAsSource, internalEdge) < 0) {
                    internalVertices[i].connectsAsSource.push(internalEdge);
                  }
                }
              }
            }
            internalVertices[i].temp[0] = 0;
          }
        };
        mxGraphHierarchyModel.prototype.initialRank = function() {
          var startNodes = [];
          if (this.roots != null) {
            for (var i = 0; i < this.roots.length; i++) {
              var internalNode = this.vertexMapper.get(this.roots[i]);
              if (internalNode != null) {
                startNodes.push(internalNode);
              }
            }
          }
          var internalNodes = this.vertexMapper.getValues();
          for (var i = 0; i < internalNodes.length; i++) {
            internalNodes[i].temp[0] = -1;
          }
          var startNodesCopy = startNodes.slice();
          while (startNodes.length > 0) {
            var internalNode = startNodes[0];
            var layerDeterminingEdges;
            var edgesToBeMarked;
            layerDeterminingEdges = internalNode.connectsAsTarget;
            edgesToBeMarked = internalNode.connectsAsSource;
            var allEdgesScanned = true;
            var minimumLayer = this.SOURCESCANSTARTRANK;
            for (var i = 0; i < layerDeterminingEdges.length; i++) {
              var internalEdge = layerDeterminingEdges[i];
              if (internalEdge.temp[0] == 5270620) {
                var otherNode = internalEdge.source;
                minimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);
              } else {
                allEdgesScanned = false;
                break;
              }
            }
            if (allEdgesScanned) {
              internalNode.temp[0] = minimumLayer;
              this.maxRank = Math.min(this.maxRank, minimumLayer);
              if (edgesToBeMarked != null) {
                for (var i = 0; i < edgesToBeMarked.length; i++) {
                  var internalEdge = edgesToBeMarked[i];
                  internalEdge.temp[0] = 5270620;
                  var otherNode = internalEdge.target;
                  if (otherNode.temp[0] == -1) {
                    startNodes.push(otherNode);
                    otherNode.temp[0] = -2;
                  }
                }
              }
              startNodes.shift();
            } else {
              var removedCell = startNodes.shift();
              startNodes.push(internalNode);
              if (removedCell == internalNode && startNodes.length == 1) {
                break;
              }
            }
          }
          for (var i = 0; i < internalNodes.length; i++) {
            internalNodes[i].temp[0] -= this.maxRank;
          }
          for (var i = 0; i < startNodesCopy.length; i++) {
            var internalNode = startNodesCopy[i];
            var currentMaxLayer = 0;
            var layerDeterminingEdges = internalNode.connectsAsSource;
            for (var j = 0; j < layerDeterminingEdges.length; j++) {
              var internalEdge = layerDeterminingEdges[j];
              var otherNode = internalEdge.target;
              internalNode.temp[0] = Math.max(
                currentMaxLayer,
                otherNode.temp[0] + 1
              );
              currentMaxLayer = internalNode.temp[0];
            }
          }
          this.maxRank = this.SOURCESCANSTARTRANK - this.maxRank;
        };
        mxGraphHierarchyModel.prototype.fixRanks = function() {
          var rankList = [];
          this.ranks = [];
          for (var i = 0; i < this.maxRank + 1; i++) {
            rankList[i] = [];
            this.ranks[i] = rankList[i];
          }
          var rootsArray = null;
          if (this.roots != null) {
            var oldRootsArray = this.roots;
            rootsArray = [];
            for (var i = 0; i < oldRootsArray.length; i++) {
              var cell2 = oldRootsArray[i];
              var internalNode = this.vertexMapper.get(cell2);
              rootsArray[i] = internalNode;
            }
          }
          this.visit(function(parent, node, edge, layer, seen) {
            if (seen == 0 && node.maxRank < 0 && node.minRank < 0) {
              rankList[node.temp[0]].push(node);
              node.maxRank = node.temp[0];
              node.minRank = node.temp[0];
              node.temp[0] = rankList[node.maxRank].length - 1;
            }
            if (parent != null && edge != null) {
              var parentToCellRankDifference = parent.maxRank - node.maxRank;
              if (parentToCellRankDifference > 1) {
                edge.maxRank = parent.maxRank;
                edge.minRank = node.maxRank;
                edge.temp = [];
                edge.x = [];
                edge.y = [];
                for (var i2 = edge.minRank + 1; i2 < edge.maxRank; i2++) {
                  rankList[i2].push(edge);
                  edge.setGeneralPurposeVariable(i2, rankList[i2].length - 1);
                }
              }
            }
          }, rootsArray, false, null);
        };
        mxGraphHierarchyModel.prototype.visit = function(visitor, dfsRoots, trackAncestors, seenNodes) {
          if (dfsRoots != null) {
            for (var i = 0; i < dfsRoots.length; i++) {
              var internalNode = dfsRoots[i];
              if (internalNode != null) {
                if (seenNodes == null) {
                  seenNodes = new Object();
                }
                if (trackAncestors) {
                  internalNode.hashCode = [];
                  internalNode.hashCode[0] = this.dfsCount;
                  internalNode.hashCode[1] = i;
                  this.extendedDfs(
                    null,
                    internalNode,
                    null,
                    visitor,
                    seenNodes,
                    internalNode.hashCode,
                    i,
                    0
                  );
                } else {
                  this.dfs(null, internalNode, null, visitor, seenNodes, 0);
                }
              }
            }
            this.dfsCount++;
          }
        };
        mxGraphHierarchyModel.prototype.dfs = function(parent, root, connectingEdge, visitor, seen, layer) {
          if (root != null) {
            var rootId = root.id;
            if (seen[rootId] == null) {
              seen[rootId] = root;
              visitor(parent, root, connectingEdge, layer, 0);
              var outgoingEdges = root.connectsAsSource.slice();
              for (var i = 0; i < outgoingEdges.length; i++) {
                var internalEdge = outgoingEdges[i];
                var targetNode = internalEdge.target;
                this.dfs(
                  root,
                  targetNode,
                  internalEdge,
                  visitor,
                  seen,
                  layer + 1
                );
              }
            } else {
              visitor(parent, root, connectingEdge, layer, 1);
            }
          }
        };
        mxGraphHierarchyModel.prototype.extendedDfs = function(parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer) {
          if (root != null) {
            if (parent != null) {
              if (root.hashCode == null || root.hashCode[0] != parent.hashCode[0]) {
                var hashCodeLength = parent.hashCode.length + 1;
                root.hashCode = parent.hashCode.slice();
                root.hashCode[hashCodeLength - 1] = childHash;
              }
            }
            var rootId = root.id;
            if (seen[rootId] == null) {
              seen[rootId] = root;
              visitor(parent, root, connectingEdge, layer, 0);
              var outgoingEdges = root.connectsAsSource.slice();
              for (var i = 0; i < outgoingEdges.length; i++) {
                var internalEdge = outgoingEdges[i];
                var targetNode = internalEdge.target;
                this.extendedDfs(
                  root,
                  targetNode,
                  internalEdge,
                  visitor,
                  seen,
                  root.hashCode,
                  i,
                  layer + 1
                );
              }
            } else {
              visitor(parent, root, connectingEdge, layer, 1);
            }
          }
        };
        __mxOutput.mxGraphHierarchyModel = typeof mxGraphHierarchyModel !== "undefined" ? mxGraphHierarchyModel : void 0;
        function mxSwimlaneModel(layout, vertices, roots, parent, tightenToSource) {
          var graph = layout.getGraph();
          this.tightenToSource = tightenToSource;
          this.roots = roots;
          this.parent = parent;
          this.vertexMapper = new mxDictionary();
          this.edgeMapper = new mxDictionary();
          this.maxRank = 0;
          var internalVertices = [];
          if (vertices == null) {
            vertices = this.graph.getChildVertices(parent);
          }
          this.maxRank = this.SOURCESCANSTARTRANK;
          this.createInternalCells(layout, vertices, internalVertices);
          for (var i = 0; i < vertices.length; i++) {
            var edges = internalVertices[i].connectsAsSource;
            for (var j = 0; j < edges.length; j++) {
              var internalEdge = edges[j];
              var realEdges = internalEdge.edges;
              if (realEdges != null && realEdges.length > 0) {
                var realEdge = realEdges[0];
                var targetCell = layout.getVisibleTerminal(
                  realEdge,
                  false
                );
                var internalTargetCell = this.vertexMapper.get(targetCell);
                if (internalVertices[i] == internalTargetCell) {
                  targetCell = layout.getVisibleTerminal(
                    realEdge,
                    true
                  );
                  internalTargetCell = this.vertexMapper.get(targetCell);
                }
                if (internalTargetCell != null && internalVertices[i] != internalTargetCell) {
                  internalEdge.target = internalTargetCell;
                  if (internalTargetCell.connectsAsTarget.length == 0) {
                    internalTargetCell.connectsAsTarget = [];
                  }
                  if (mxUtils.indexOf(internalTargetCell.connectsAsTarget, internalEdge) < 0) {
                    internalTargetCell.connectsAsTarget.push(internalEdge);
                  }
                }
              }
            }
            internalVertices[i].temp[0] = 1;
          }
        }
        ;
        mxSwimlaneModel.prototype.maxRank = null;
        mxSwimlaneModel.prototype.vertexMapper = null;
        mxSwimlaneModel.prototype.edgeMapper = null;
        mxSwimlaneModel.prototype.ranks = null;
        mxSwimlaneModel.prototype.roots = null;
        mxSwimlaneModel.prototype.parent = null;
        mxSwimlaneModel.prototype.dfsCount = 0;
        mxSwimlaneModel.prototype.SOURCESCANSTARTRANK = 1e8;
        mxSwimlaneModel.prototype.tightenToSource = false;
        mxSwimlaneModel.prototype.ranksPerGroup = null;
        mxSwimlaneModel.prototype.createInternalCells = function(layout, vertices, internalVertices) {
          var graph = layout.getGraph();
          var swimlanes = layout.swimlanes;
          for (var i = 0; i < vertices.length; i++) {
            internalVertices[i] = new mxGraphHierarchyNode(vertices[i]);
            this.vertexMapper.put(vertices[i], internalVertices[i]);
            internalVertices[i].swimlaneIndex = -1;
            for (var ii = 0; ii < swimlanes.length; ii++) {
              if (graph.model.getParent(vertices[i]) == swimlanes[ii]) {
                internalVertices[i].swimlaneIndex = ii;
                break;
              }
            }
            var conns = layout.getEdges(vertices[i]);
            internalVertices[i].connectsAsSource = [];
            for (var j = 0; j < conns.length; j++) {
              var cell2 = layout.getVisibleTerminal(conns[j], false);
              if (cell2 != vertices[i] && layout.graph.model.isVertex(cell2) && !layout.isVertexIgnored(cell2)) {
                var undirectedEdges = layout.getEdgesBetween(
                  vertices[i],
                  cell2,
                  false
                );
                var directedEdges = layout.getEdgesBetween(
                  vertices[i],
                  cell2,
                  true
                );
                if (undirectedEdges != null && undirectedEdges.length > 0 && this.edgeMapper.get(undirectedEdges[0]) == null && directedEdges.length * 2 >= undirectedEdges.length) {
                  var internalEdge = new mxGraphHierarchyEdge(undirectedEdges);
                  for (var k = 0; k < undirectedEdges.length; k++) {
                    var edge = undirectedEdges[k];
                    this.edgeMapper.put(edge, internalEdge);
                    graph.resetEdge(edge);
                    if (layout.disableEdgeStyle) {
                      layout.setEdgeStyleEnabled(edge, false);
                      layout.setOrthogonalEdge(edge, true);
                    }
                  }
                  internalEdge.source = internalVertices[i];
                  if (mxUtils.indexOf(internalVertices[i].connectsAsSource, internalEdge) < 0) {
                    internalVertices[i].connectsAsSource.push(internalEdge);
                  }
                }
              }
            }
            internalVertices[i].temp[0] = 0;
          }
        };
        mxSwimlaneModel.prototype.initialRank = function() {
          this.ranksPerGroup = [];
          var startNodes = [];
          var seen = new Object();
          if (this.roots != null) {
            for (var i = 0; i < this.roots.length; i++) {
              var internalNode = this.vertexMapper.get(this.roots[i]);
              this.maxChainDfs(null, internalNode, null, seen, 0);
              if (internalNode != null) {
                startNodes.push(internalNode);
              }
            }
          }
          var lowerRank = [];
          var upperRank = [];
          for (var i = this.ranksPerGroup.length - 1; i >= 0; i--) {
            if (i == this.ranksPerGroup.length - 1) {
              lowerRank[i] = 0;
            } else {
              lowerRank[i] = upperRank[i + 1] + 1;
            }
            upperRank[i] = lowerRank[i] + this.ranksPerGroup[i];
          }
          this.maxRank = upperRank[0];
          var internalNodes = this.vertexMapper.getValues();
          for (var i = 0; i < internalNodes.length; i++) {
            internalNodes[i].temp[0] = -1;
          }
          var startNodesCopy = startNodes.slice();
          while (startNodes.length > 0) {
            var internalNode = startNodes[0];
            var layerDeterminingEdges;
            var edgesToBeMarked;
            layerDeterminingEdges = internalNode.connectsAsTarget;
            edgesToBeMarked = internalNode.connectsAsSource;
            var allEdgesScanned = true;
            var minimumLayer = upperRank[0];
            for (var i = 0; i < layerDeterminingEdges.length; i++) {
              var internalEdge = layerDeterminingEdges[i];
              if (internalEdge.temp[0] == 5270620) {
                var otherNode = internalEdge.source;
                minimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);
              } else {
                allEdgesScanned = false;
                break;
              }
            }
            if (allEdgesScanned) {
              if (minimumLayer > upperRank[internalNode.swimlaneIndex]) {
                minimumLayer = upperRank[internalNode.swimlaneIndex];
              }
              internalNode.temp[0] = minimumLayer;
              if (edgesToBeMarked != null) {
                for (var i = 0; i < edgesToBeMarked.length; i++) {
                  var internalEdge = edgesToBeMarked[i];
                  internalEdge.temp[0] = 5270620;
                  var otherNode = internalEdge.target;
                  if (otherNode.temp[0] == -1) {
                    startNodes.push(otherNode);
                    otherNode.temp[0] = -2;
                  }
                }
              }
              startNodes.shift();
            } else {
              var removedCell = startNodes.shift();
              startNodes.push(internalNode);
              if (removedCell == internalNode && startNodes.length == 1) {
                break;
              }
            }
          }
        };
        mxSwimlaneModel.prototype.maxChainDfs = function(parent, root, connectingEdge, seen, chainCount) {
          if (root != null) {
            var rootId = mxCellPath.create(root.cell);
            if (seen[rootId] == null) {
              seen[rootId] = root;
              var slIndex = root.swimlaneIndex;
              if (this.ranksPerGroup[slIndex] == null || this.ranksPerGroup[slIndex] < chainCount) {
                this.ranksPerGroup[slIndex] = chainCount;
              }
              var outgoingEdges = root.connectsAsSource.slice();
              for (var i = 0; i < outgoingEdges.length; i++) {
                var internalEdge = outgoingEdges[i];
                var targetNode = internalEdge.target;
                if (root.swimlaneIndex < targetNode.swimlaneIndex) {
                  this.maxChainDfs(root, targetNode, internalEdge, mxUtils.clone(seen, null, true), 0);
                } else if (root.swimlaneIndex == targetNode.swimlaneIndex) {
                  this.maxChainDfs(root, targetNode, internalEdge, mxUtils.clone(seen, null, true), chainCount + 1);
                }
              }
            }
          }
        };
        mxSwimlaneModel.prototype.fixRanks = function() {
          var rankList = [];
          this.ranks = [];
          for (var i = 0; i < this.maxRank + 1; i++) {
            rankList[i] = [];
            this.ranks[i] = rankList[i];
          }
          var rootsArray = null;
          if (this.roots != null) {
            var oldRootsArray = this.roots;
            rootsArray = [];
            for (var i = 0; i < oldRootsArray.length; i++) {
              var cell2 = oldRootsArray[i];
              var internalNode = this.vertexMapper.get(cell2);
              rootsArray[i] = internalNode;
            }
          }
          this.visit(function(parent, node, edge, layer, seen) {
            if (seen == 0 && node.maxRank < 0 && node.minRank < 0) {
              rankList[node.temp[0]].push(node);
              node.maxRank = node.temp[0];
              node.minRank = node.temp[0];
              node.temp[0] = rankList[node.maxRank].length - 1;
            }
            if (parent != null && edge != null) {
              var parentToCellRankDifference = parent.maxRank - node.maxRank;
              if (parentToCellRankDifference > 1) {
                edge.maxRank = parent.maxRank;
                edge.minRank = node.maxRank;
                edge.temp = [];
                edge.x = [];
                edge.y = [];
                for (var i2 = edge.minRank + 1; i2 < edge.maxRank; i2++) {
                  rankList[i2].push(edge);
                  edge.setGeneralPurposeVariable(i2, rankList[i2].length - 1);
                }
              }
            }
          }, rootsArray, false, null);
        };
        mxSwimlaneModel.prototype.visit = function(visitor, dfsRoots, trackAncestors, seenNodes) {
          if (dfsRoots != null) {
            for (var i = 0; i < dfsRoots.length; i++) {
              var internalNode = dfsRoots[i];
              if (internalNode != null) {
                if (seenNodes == null) {
                  seenNodes = new Object();
                }
                if (trackAncestors) {
                  internalNode.hashCode = [];
                  internalNode.hashCode[0] = this.dfsCount;
                  internalNode.hashCode[1] = i;
                  this.extendedDfs(
                    null,
                    internalNode,
                    null,
                    visitor,
                    seenNodes,
                    internalNode.hashCode,
                    i,
                    0
                  );
                } else {
                  this.dfs(null, internalNode, null, visitor, seenNodes, 0);
                }
              }
            }
            this.dfsCount++;
          }
        };
        mxSwimlaneModel.prototype.dfs = function(parent, root, connectingEdge, visitor, seen, layer) {
          if (root != null) {
            var rootId = root.id;
            if (seen[rootId] == null) {
              seen[rootId] = root;
              visitor(parent, root, connectingEdge, layer, 0);
              var outgoingEdges = root.connectsAsSource.slice();
              for (var i = 0; i < outgoingEdges.length; i++) {
                var internalEdge = outgoingEdges[i];
                var targetNode = internalEdge.target;
                this.dfs(
                  root,
                  targetNode,
                  internalEdge,
                  visitor,
                  seen,
                  layer + 1
                );
              }
            } else {
              visitor(parent, root, connectingEdge, layer, 1);
            }
          }
        };
        mxSwimlaneModel.prototype.extendedDfs = function(parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer) {
          if (root != null) {
            if (parent != null) {
              if (root.hashCode == null || root.hashCode[0] != parent.hashCode[0]) {
                var hashCodeLength = parent.hashCode.length + 1;
                root.hashCode = parent.hashCode.slice();
                root.hashCode[hashCodeLength - 1] = childHash;
              }
            }
            var rootId = root.id;
            if (seen[rootId] == null) {
              seen[rootId] = root;
              visitor(parent, root, connectingEdge, layer, 0);
              var outgoingEdges = root.connectsAsSource.slice();
              var incomingEdges = root.connectsAsTarget.slice();
              for (var i = 0; i < outgoingEdges.length; i++) {
                var internalEdge = outgoingEdges[i];
                var targetNode = internalEdge.target;
                if (root.swimlaneIndex <= targetNode.swimlaneIndex) {
                  this.extendedDfs(
                    root,
                    targetNode,
                    internalEdge,
                    visitor,
                    seen,
                    root.hashCode,
                    i,
                    layer + 1
                  );
                }
              }
              for (var i = 0; i < incomingEdges.length; i++) {
                var internalEdge = incomingEdges[i];
                var targetNode = internalEdge.source;
                if (root.swimlaneIndex < targetNode.swimlaneIndex) {
                  this.extendedDfs(
                    root,
                    targetNode,
                    internalEdge,
                    visitor,
                    seen,
                    root.hashCode,
                    i,
                    layer + 1
                  );
                }
              }
            } else {
              visitor(parent, root, connectingEdge, layer, 1);
            }
          }
        };
        __mxOutput.mxSwimlaneModel = typeof mxSwimlaneModel !== "undefined" ? mxSwimlaneModel : void 0;
        function mxHierarchicalLayoutStage() {
        }
        ;
        mxHierarchicalLayoutStage.prototype.execute = function(parent) {
        };
        __mxOutput.mxHierarchicalLayoutStage = typeof mxHierarchicalLayoutStage !== "undefined" ? mxHierarchicalLayoutStage : void 0;
        function mxMedianHybridCrossingReduction(layout) {
          this.layout = layout;
        }
        ;
        mxMedianHybridCrossingReduction.prototype = new mxHierarchicalLayoutStage();
        mxMedianHybridCrossingReduction.prototype.constructor = mxMedianHybridCrossingReduction;
        mxMedianHybridCrossingReduction.prototype.layout = null;
        mxMedianHybridCrossingReduction.prototype.maxIterations = 24;
        mxMedianHybridCrossingReduction.prototype.nestedBestRanks = null;
        mxMedianHybridCrossingReduction.prototype.currentBestCrossings = 0;
        mxMedianHybridCrossingReduction.prototype.iterationsWithoutImprovement = 0;
        mxMedianHybridCrossingReduction.prototype.maxNoImprovementIterations = 2;
        mxMedianHybridCrossingReduction.prototype.execute = function(parent) {
          var model = this.layout.getModel();
          this.nestedBestRanks = [];
          for (var i = 0; i < model.ranks.length; i++) {
            this.nestedBestRanks[i] = model.ranks[i].slice();
          }
          var iterationsWithoutImprovement = 0;
          var currentBestCrossings = this.calculateCrossings(model);
          for (var i = 0; i < this.maxIterations && iterationsWithoutImprovement < this.maxNoImprovementIterations; i++) {
            this.weightedMedian(i, model);
            this.transpose(i, model);
            var candidateCrossings = this.calculateCrossings(model);
            if (candidateCrossings < currentBestCrossings) {
              currentBestCrossings = candidateCrossings;
              iterationsWithoutImprovement = 0;
              for (var j = 0; j < this.nestedBestRanks.length; j++) {
                var rank = model.ranks[j];
                for (var k = 0; k < rank.length; k++) {
                  var cell2 = rank[k];
                  this.nestedBestRanks[j][cell2.getGeneralPurposeVariable(j)] = cell2;
                }
              }
            } else {
              iterationsWithoutImprovement++;
              for (var j = 0; j < this.nestedBestRanks.length; j++) {
                var rank = model.ranks[j];
                for (var k = 0; k < rank.length; k++) {
                  var cell2 = rank[k];
                  cell2.setGeneralPurposeVariable(j, k);
                }
              }
            }
            if (currentBestCrossings == 0) {
              break;
            }
          }
          var ranks = [];
          var rankList = [];
          for (var i = 0; i < model.maxRank + 1; i++) {
            rankList[i] = [];
            ranks[i] = rankList[i];
          }
          for (var i = 0; i < this.nestedBestRanks.length; i++) {
            for (var j = 0; j < this.nestedBestRanks[i].length; j++) {
              rankList[i].push(this.nestedBestRanks[i][j]);
            }
          }
          model.ranks = ranks;
        };
        mxMedianHybridCrossingReduction.prototype.calculateCrossings = function(model) {
          var numRanks = model.ranks.length;
          var totalCrossings = 0;
          for (var i = 1; i < numRanks; i++) {
            totalCrossings += this.calculateRankCrossing(i, model);
          }
          return totalCrossings;
        };
        mxMedianHybridCrossingReduction.prototype.calculateRankCrossing = function(i, model) {
          var totalCrossings = 0;
          var rank = model.ranks[i];
          var previousRank = model.ranks[i - 1];
          var tmpIndices = [];
          for (var j = 0; j < rank.length; j++) {
            var node = rank[j];
            var rankPosition = node.getGeneralPurposeVariable(i);
            var connectedCells = node.getPreviousLayerConnectedCells(i);
            var nodeIndices = [];
            for (var k = 0; k < connectedCells.length; k++) {
              var connectedNode = connectedCells[k];
              var otherCellRankPosition = connectedNode.getGeneralPurposeVariable(i - 1);
              nodeIndices.push(otherCellRankPosition);
            }
            nodeIndices.sort(function(x, y) {
              return x - y;
            });
            tmpIndices[rankPosition] = nodeIndices;
          }
          var indices = [];
          for (var j = 0; j < tmpIndices.length; j++) {
            indices = indices.concat(tmpIndices[j]);
          }
          var firstIndex = 1;
          while (firstIndex < previousRank.length) {
            firstIndex <<= 1;
          }
          var treeSize = 2 * firstIndex - 1;
          firstIndex -= 1;
          var tree = [];
          for (var j = 0; j < treeSize; ++j) {
            tree[j] = 0;
          }
          for (var j = 0; j < indices.length; j++) {
            var index = indices[j];
            var treeIndex = index + firstIndex;
            ++tree[treeIndex];
            while (treeIndex > 0) {
              if (treeIndex % 2) {
                totalCrossings += tree[treeIndex + 1];
              }
              treeIndex = treeIndex - 1 >> 1;
              ++tree[treeIndex];
            }
          }
          return totalCrossings;
        };
        mxMedianHybridCrossingReduction.prototype.transpose = function(mainLoopIteration, model) {
          var improved = true;
          var count = 0;
          var maxCount = 10;
          while (improved && count++ < maxCount) {
            var nudge = mainLoopIteration % 2 == 1 && count % 2 == 1;
            improved = false;
            for (var i = 0; i < model.ranks.length; i++) {
              var rank = model.ranks[i];
              var orderedCells = [];
              for (var j = 0; j < rank.length; j++) {
                var cell2 = rank[j];
                var tempRank = cell2.getGeneralPurposeVariable(i);
                if (tempRank < 0) {
                  tempRank = j;
                }
                orderedCells[tempRank] = cell2;
              }
              var leftCellAboveConnections = null;
              var leftCellBelowConnections = null;
              var rightCellAboveConnections = null;
              var rightCellBelowConnections = null;
              var leftAbovePositions = null;
              var leftBelowPositions = null;
              var rightAbovePositions = null;
              var rightBelowPositions = null;
              var leftCell = null;
              var rightCell = null;
              for (var j = 0; j < rank.length - 1; j++) {
                if (j == 0) {
                  leftCell = orderedCells[j];
                  leftCellAboveConnections = leftCell.getNextLayerConnectedCells(i);
                  leftCellBelowConnections = leftCell.getPreviousLayerConnectedCells(i);
                  leftAbovePositions = [];
                  leftBelowPositions = [];
                  for (var k = 0; k < leftCellAboveConnections.length; k++) {
                    leftAbovePositions[k] = leftCellAboveConnections[k].getGeneralPurposeVariable(i + 1);
                  }
                  for (var k = 0; k < leftCellBelowConnections.length; k++) {
                    leftBelowPositions[k] = leftCellBelowConnections[k].getGeneralPurposeVariable(i - 1);
                  }
                } else {
                  leftCellAboveConnections = rightCellAboveConnections;
                  leftCellBelowConnections = rightCellBelowConnections;
                  leftAbovePositions = rightAbovePositions;
                  leftBelowPositions = rightBelowPositions;
                  leftCell = rightCell;
                }
                rightCell = orderedCells[j + 1];
                rightCellAboveConnections = rightCell.getNextLayerConnectedCells(i);
                rightCellBelowConnections = rightCell.getPreviousLayerConnectedCells(i);
                rightAbovePositions = [];
                rightBelowPositions = [];
                for (var k = 0; k < rightCellAboveConnections.length; k++) {
                  rightAbovePositions[k] = rightCellAboveConnections[k].getGeneralPurposeVariable(i + 1);
                }
                for (var k = 0; k < rightCellBelowConnections.length; k++) {
                  rightBelowPositions[k] = rightCellBelowConnections[k].getGeneralPurposeVariable(i - 1);
                }
                var totalCurrentCrossings = 0;
                var totalSwitchedCrossings = 0;
                for (var k = 0; k < leftAbovePositions.length; k++) {
                  for (var ik = 0; ik < rightAbovePositions.length; ik++) {
                    if (leftAbovePositions[k] > rightAbovePositions[ik]) {
                      totalCurrentCrossings++;
                    }
                    if (leftAbovePositions[k] < rightAbovePositions[ik]) {
                      totalSwitchedCrossings++;
                    }
                  }
                }
                for (var k = 0; k < leftBelowPositions.length; k++) {
                  for (var ik = 0; ik < rightBelowPositions.length; ik++) {
                    if (leftBelowPositions[k] > rightBelowPositions[ik]) {
                      totalCurrentCrossings++;
                    }
                    if (leftBelowPositions[k] < rightBelowPositions[ik]) {
                      totalSwitchedCrossings++;
                    }
                  }
                }
                if (totalSwitchedCrossings < totalCurrentCrossings || totalSwitchedCrossings == totalCurrentCrossings && nudge) {
                  var temp = leftCell.getGeneralPurposeVariable(i);
                  leftCell.setGeneralPurposeVariable(i, rightCell.getGeneralPurposeVariable(i));
                  rightCell.setGeneralPurposeVariable(i, temp);
                  rightCellAboveConnections = leftCellAboveConnections;
                  rightCellBelowConnections = leftCellBelowConnections;
                  rightAbovePositions = leftAbovePositions;
                  rightBelowPositions = leftBelowPositions;
                  rightCell = leftCell;
                  if (!nudge) {
                    improved = true;
                  }
                }
              }
            }
          }
        };
        mxMedianHybridCrossingReduction.prototype.weightedMedian = function(iteration, model) {
          var downwardSweep = iteration % 2 == 0;
          if (downwardSweep) {
            for (var j = model.maxRank - 1; j >= 0; j--) {
              this.medianRank(j, downwardSweep);
            }
          } else {
            for (var j = 1; j < model.maxRank; j++) {
              this.medianRank(j, downwardSweep);
            }
          }
        };
        mxMedianHybridCrossingReduction.prototype.medianRank = function(rankValue, downwardSweep) {
          var numCellsForRank = this.nestedBestRanks[rankValue].length;
          var medianValues = [];
          var reservedPositions = [];
          for (var i = 0; i < numCellsForRank; i++) {
            var cell2 = this.nestedBestRanks[rankValue][i];
            var sorterEntry = new MedianCellSorter();
            sorterEntry.cell = cell2;
            var nextLevelConnectedCells;
            if (downwardSweep) {
              nextLevelConnectedCells = cell2.getNextLayerConnectedCells(rankValue);
            } else {
              nextLevelConnectedCells = cell2.getPreviousLayerConnectedCells(rankValue);
            }
            var nextRankValue;
            if (downwardSweep) {
              nextRankValue = rankValue + 1;
            } else {
              nextRankValue = rankValue - 1;
            }
            if (nextLevelConnectedCells != null && nextLevelConnectedCells.length != 0) {
              sorterEntry.medianValue = this.medianValue(
                nextLevelConnectedCells,
                nextRankValue
              );
              medianValues.push(sorterEntry);
            } else {
              reservedPositions[cell2.getGeneralPurposeVariable(rankValue)] = true;
            }
          }
          medianValues.sort(MedianCellSorter.prototype.compare);
          for (var i = 0; i < numCellsForRank; i++) {
            if (reservedPositions[i] == null) {
              var cell2 = medianValues.shift().cell;
              cell2.setGeneralPurposeVariable(rankValue, i);
            }
          }
        };
        mxMedianHybridCrossingReduction.prototype.medianValue = function(connectedCells, rankValue) {
          var medianValues = [];
          var arrayCount = 0;
          for (var i = 0; i < connectedCells.length; i++) {
            var cell2 = connectedCells[i];
            medianValues[arrayCount++] = cell2.getGeneralPurposeVariable(rankValue);
          }
          medianValues.sort(function(a, b) {
            return a - b;
          });
          if (arrayCount % 2 == 1) {
            return medianValues[Math.floor(arrayCount / 2)];
          } else if (arrayCount == 2) {
            return (medianValues[0] + medianValues[1]) / 2;
          } else {
            var medianPoint = arrayCount / 2;
            var leftMedian = medianValues[medianPoint - 1] - medianValues[0];
            var rightMedian = medianValues[arrayCount - 1] - medianValues[medianPoint];
            return (medianValues[medianPoint - 1] * rightMedian + medianValues[medianPoint] * leftMedian) / (leftMedian + rightMedian);
          }
        };
        function MedianCellSorter() {
        }
        ;
        MedianCellSorter.prototype.medianValue = 0;
        MedianCellSorter.prototype.cell = false;
        MedianCellSorter.prototype.compare = function(a, b) {
          if (a != null && b != null) {
            if (b.medianValue > a.medianValue) {
              return -1;
            } else if (b.medianValue < a.medianValue) {
              return 1;
            } else {
              return 0;
            }
          } else {
            return 0;
          }
        };
        __mxOutput.mxMedianHybridCrossingReduction = typeof mxMedianHybridCrossingReduction !== "undefined" ? mxMedianHybridCrossingReduction : void 0;
        function mxMinimumCycleRemover(layout) {
          this.layout = layout;
        }
        ;
        mxMinimumCycleRemover.prototype = new mxHierarchicalLayoutStage();
        mxMinimumCycleRemover.prototype.constructor = mxMinimumCycleRemover;
        mxMinimumCycleRemover.prototype.layout = null;
        mxMinimumCycleRemover.prototype.execute = function(parent) {
          var model = this.layout.getModel();
          var seenNodes = new Object();
          var unseenNodesArray = model.vertexMapper.getValues();
          var unseenNodes = new Object();
          for (var i = 0; i < unseenNodesArray.length; i++) {
            unseenNodes[unseenNodesArray[i].id] = unseenNodesArray[i];
          }
          var rootsArray = null;
          if (model.roots != null) {
            var modelRoots = model.roots;
            rootsArray = [];
            for (var i = 0; i < modelRoots.length; i++) {
              rootsArray[i] = model.vertexMapper.get(modelRoots[i]);
            }
          }
          model.visit(function(parent2, node, connectingEdge, layer, seen) {
            if (node.isAncestor(parent2)) {
              connectingEdge.invert();
              mxUtils.remove(connectingEdge, parent2.connectsAsSource);
              parent2.connectsAsTarget.push(connectingEdge);
              mxUtils.remove(connectingEdge, node.connectsAsTarget);
              node.connectsAsSource.push(connectingEdge);
            }
            seenNodes[node.id] = node;
            delete unseenNodes[node.id];
          }, rootsArray, true, null);
          var seenNodesCopy = mxUtils.clone(seenNodes, null, true);
          model.visit(function(parent2, node, connectingEdge, layer, seen) {
            if (node.isAncestor(parent2)) {
              connectingEdge.invert();
              mxUtils.remove(connectingEdge, parent2.connectsAsSource);
              node.connectsAsSource.push(connectingEdge);
              parent2.connectsAsTarget.push(connectingEdge);
              mxUtils.remove(connectingEdge, node.connectsAsTarget);
            }
            seenNodes[node.id] = node;
            delete unseenNodes[node.id];
          }, unseenNodes, true, seenNodesCopy);
        };
        __mxOutput.mxMinimumCycleRemover = typeof mxMinimumCycleRemover !== "undefined" ? mxMinimumCycleRemover : void 0;
        function mxCoordinateAssignment(layout, intraCellSpacing, interRankCellSpacing, orientation, initialX, parallelEdgeSpacing) {
          this.layout = layout;
          this.intraCellSpacing = intraCellSpacing;
          this.interRankCellSpacing = interRankCellSpacing;
          this.orientation = orientation;
          this.initialX = initialX;
          this.parallelEdgeSpacing = parallelEdgeSpacing;
        }
        ;
        mxCoordinateAssignment.prototype = new mxHierarchicalLayoutStage();
        mxCoordinateAssignment.prototype.constructor = mxCoordinateAssignment;
        mxCoordinateAssignment.prototype.layout = null;
        mxCoordinateAssignment.prototype.intraCellSpacing = 30;
        mxCoordinateAssignment.prototype.interRankCellSpacing = 100;
        mxCoordinateAssignment.prototype.parallelEdgeSpacing = 10;
        mxCoordinateAssignment.prototype.maxIterations = 8;
        mxCoordinateAssignment.prototype.prefHozEdgeSep = 5;
        mxCoordinateAssignment.prototype.prefVertEdgeOff = 2;
        mxCoordinateAssignment.prototype.minEdgeJetty = 12;
        mxCoordinateAssignment.prototype.channelBuffer = 4;
        mxCoordinateAssignment.prototype.jettyPositions = null;
        mxCoordinateAssignment.prototype.orientation = mxConstants.DIRECTION_NORTH;
        mxCoordinateAssignment.prototype.initialX = null;
        mxCoordinateAssignment.prototype.limitX = null;
        mxCoordinateAssignment.prototype.currentXDelta = null;
        mxCoordinateAssignment.prototype.widestRank = null;
        mxCoordinateAssignment.prototype.rankTopY = null;
        mxCoordinateAssignment.prototype.rankBottomY = null;
        mxCoordinateAssignment.prototype.widestRankValue = null;
        mxCoordinateAssignment.prototype.rankWidths = null;
        mxCoordinateAssignment.prototype.rankY = null;
        mxCoordinateAssignment.prototype.fineTuning = true;
        mxCoordinateAssignment.prototype.nextLayerConnectedCache = null;
        mxCoordinateAssignment.prototype.previousLayerConnectedCache = null;
        mxCoordinateAssignment.prototype.groupPadding = 10;
        mxCoordinateAssignment.prototype.printStatus = function() {
          var model = this.layout.getModel();
          mxLog.show();
          mxLog.writeln("======Coord assignment debug=======");
          for (var j = 0; j < model.ranks.length; j++) {
            mxLog.write("Rank ", j, " : ");
            var rank = model.ranks[j];
            for (var k = 0; k < rank.length; k++) {
              var cell2 = rank[k];
              mxLog.write(cell2.getGeneralPurposeVariable(j), "  ");
            }
            mxLog.writeln();
          }
          mxLog.writeln("====================================");
        };
        mxCoordinateAssignment.prototype.execute = function(parent) {
          this.jettyPositions = Object();
          var model = this.layout.getModel();
          this.currentXDelta = 0;
          this.initialCoords(this.layout.getGraph(), model);
          if (this.fineTuning) {
            this.minNode(model);
          }
          var bestXDelta = 1e8;
          if (this.fineTuning) {
            for (var i = 0; i < this.maxIterations; i++) {
              if (i != 0) {
                this.medianPos(i, model);
                this.minNode(model);
              }
              if (this.currentXDelta < bestXDelta) {
                for (var j = 0; j < model.ranks.length; j++) {
                  var rank = model.ranks[j];
                  for (var k = 0; k < rank.length; k++) {
                    var cell2 = rank[k];
                    cell2.setX(j, cell2.getGeneralPurposeVariable(j));
                  }
                }
                bestXDelta = this.currentXDelta;
              } else {
                for (var j = 0; j < model.ranks.length; j++) {
                  var rank = model.ranks[j];
                  for (var k = 0; k < rank.length; k++) {
                    var cell2 = rank[k];
                    cell2.setGeneralPurposeVariable(j, cell2.getX(j));
                  }
                }
              }
              this.minPath(this.layout.getGraph(), model);
              this.currentXDelta = 0;
            }
          }
          this.setCellLocations(this.layout.getGraph(), model);
        };
        mxCoordinateAssignment.prototype.minNode = function(model) {
          var nodeList = [];
          var map = new mxDictionary();
          var rank = [];
          for (var i = 0; i <= model.maxRank; i++) {
            rank[i] = model.ranks[i];
            for (var j = 0; j < rank[i].length; j++) {
              var node = rank[i][j];
              var nodeWrapper = new WeightedCellSorter(node, i);
              nodeWrapper.rankIndex = j;
              nodeWrapper.visited = true;
              nodeList.push(nodeWrapper);
              map.put(node, nodeWrapper);
            }
          }
          var maxTries = nodeList.length * 10;
          var count = 0;
          var tolerance = 1;
          while (nodeList.length > 0 && count <= maxTries) {
            var cellWrapper = nodeList.shift();
            var cell2 = cellWrapper.cell;
            var rankValue = cellWrapper.weightedValue;
            var rankIndex = parseInt(cellWrapper.rankIndex);
            var nextLayerConnectedCells = cell2.getNextLayerConnectedCells(rankValue);
            var previousLayerConnectedCells = cell2.getPreviousLayerConnectedCells(rankValue);
            var numNextLayerConnected = nextLayerConnectedCells.length;
            var numPreviousLayerConnected = previousLayerConnectedCells.length;
            var medianNextLevel = this.medianXValue(
              nextLayerConnectedCells,
              rankValue + 1
            );
            var medianPreviousLevel = this.medianXValue(
              previousLayerConnectedCells,
              rankValue - 1
            );
            var numConnectedNeighbours = numNextLayerConnected + numPreviousLayerConnected;
            var currentPosition = cell2.getGeneralPurposeVariable(rankValue);
            var cellMedian = currentPosition;
            if (numConnectedNeighbours > 0) {
              cellMedian = (medianNextLevel * numNextLayerConnected + medianPreviousLevel * numPreviousLayerConnected) / numConnectedNeighbours;
            }
            var positionChanged = false;
            if (cellMedian < currentPosition - tolerance) {
              if (rankIndex == 0) {
                cell2.setGeneralPurposeVariable(rankValue, cellMedian);
                positionChanged = true;
              } else {
                var leftCell = rank[rankValue][rankIndex - 1];
                var leftLimit = leftCell.getGeneralPurposeVariable(rankValue);
                leftLimit = leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell2.width / 2;
                if (leftLimit < cellMedian) {
                  cell2.setGeneralPurposeVariable(rankValue, cellMedian);
                  positionChanged = true;
                } else if (leftLimit < cell2.getGeneralPurposeVariable(rankValue) - tolerance) {
                  cell2.setGeneralPurposeVariable(rankValue, leftLimit);
                  positionChanged = true;
                }
              }
            } else if (cellMedian > currentPosition + tolerance) {
              var rankSize = rank[rankValue].length;
              if (rankIndex == rankSize - 1) {
                cell2.setGeneralPurposeVariable(rankValue, cellMedian);
                positionChanged = true;
              } else {
                var rightCell = rank[rankValue][rankIndex + 1];
                var rightLimit = rightCell.getGeneralPurposeVariable(rankValue);
                rightLimit = rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell2.width / 2;
                if (rightLimit > cellMedian) {
                  cell2.setGeneralPurposeVariable(rankValue, cellMedian);
                  positionChanged = true;
                } else if (rightLimit > cell2.getGeneralPurposeVariable(rankValue) + tolerance) {
                  cell2.setGeneralPurposeVariable(rankValue, rightLimit);
                  positionChanged = true;
                }
              }
            }
            if (positionChanged) {
              for (var i = 0; i < nextLayerConnectedCells.length; i++) {
                var connectedCell = nextLayerConnectedCells[i];
                var connectedCellWrapper = map.get(connectedCell);
                if (connectedCellWrapper != null) {
                  if (connectedCellWrapper.visited == false) {
                    connectedCellWrapper.visited = true;
                    nodeList.push(connectedCellWrapper);
                  }
                }
              }
              for (var i = 0; i < previousLayerConnectedCells.length; i++) {
                var connectedCell = previousLayerConnectedCells[i];
                var connectedCellWrapper = map.get(connectedCell);
                if (connectedCellWrapper != null) {
                  if (connectedCellWrapper.visited == false) {
                    connectedCellWrapper.visited = true;
                    nodeList.push(connectedCellWrapper);
                  }
                }
              }
            }
            cellWrapper.visited = false;
            count++;
          }
        };
        mxCoordinateAssignment.prototype.medianPos = function(i, model) {
          var downwardSweep = i % 2 == 0;
          if (downwardSweep) {
            for (var j = model.maxRank; j > 0; j--) {
              this.rankMedianPosition(j - 1, model, j);
            }
          } else {
            for (var j = 0; j < model.maxRank - 1; j++) {
              this.rankMedianPosition(j + 1, model, j);
            }
          }
        };
        mxCoordinateAssignment.prototype.rankMedianPosition = function(rankValue, model, nextRankValue) {
          var rank = model.ranks[rankValue];
          var weightedValues = [];
          var cellMap = new Object();
          for (var i = 0; i < rank.length; i++) {
            var currentCell = rank[i];
            weightedValues[i] = new WeightedCellSorter();
            weightedValues[i].cell = currentCell;
            weightedValues[i].rankIndex = i;
            cellMap[currentCell.id] = weightedValues[i];
            var nextLayerConnectedCells = null;
            if (nextRankValue < rankValue) {
              nextLayerConnectedCells = currentCell.getPreviousLayerConnectedCells(rankValue);
            } else {
              nextLayerConnectedCells = currentCell.getNextLayerConnectedCells(rankValue);
            }
            weightedValues[i].weightedValue = this.calculatedWeightedValue(
              currentCell,
              nextLayerConnectedCells
            );
          }
          weightedValues.sort(WeightedCellSorter.prototype.compare);
          for (var i = 0; i < weightedValues.length; i++) {
            var numConnectionsNextLevel = 0;
            var cell2 = weightedValues[i].cell;
            var nextLayerConnectedCells = null;
            var medianNextLevel = 0;
            if (nextRankValue < rankValue) {
              nextLayerConnectedCells = cell2.getPreviousLayerConnectedCells(
                rankValue
              ).slice();
            } else {
              nextLayerConnectedCells = cell2.getNextLayerConnectedCells(
                rankValue
              ).slice();
            }
            if (nextLayerConnectedCells != null) {
              numConnectionsNextLevel = nextLayerConnectedCells.length;
              if (numConnectionsNextLevel > 0) {
                medianNextLevel = this.medianXValue(
                  nextLayerConnectedCells,
                  nextRankValue
                );
              } else {
                medianNextLevel = cell2.getGeneralPurposeVariable(rankValue);
              }
            }
            var leftBuffer = 0;
            var leftLimit = -1e8;
            for (var j = weightedValues[i].rankIndex - 1; j >= 0; ) {
              var weightedValue = cellMap[rank[j].id];
              if (weightedValue != null) {
                var leftCell = weightedValue.cell;
                if (weightedValue.visited) {
                  leftLimit = leftCell.getGeneralPurposeVariable(rankValue) + leftCell.width / 2 + this.intraCellSpacing + leftBuffer + cell2.width / 2;
                  j = -1;
                } else {
                  leftBuffer += leftCell.width + this.intraCellSpacing;
                  j--;
                }
              }
            }
            var rightBuffer = 0;
            var rightLimit = 1e8;
            for (var j = weightedValues[i].rankIndex + 1; j < weightedValues.length; ) {
              var weightedValue = cellMap[rank[j].id];
              if (weightedValue != null) {
                var rightCell = weightedValue.cell;
                if (weightedValue.visited) {
                  rightLimit = rightCell.getGeneralPurposeVariable(rankValue) - rightCell.width / 2 - this.intraCellSpacing - rightBuffer - cell2.width / 2;
                  j = weightedValues.length;
                } else {
                  rightBuffer += rightCell.width + this.intraCellSpacing;
                  j++;
                }
              }
            }
            if (medianNextLevel >= leftLimit && medianNextLevel <= rightLimit) {
              cell2.setGeneralPurposeVariable(rankValue, medianNextLevel);
            } else if (medianNextLevel < leftLimit) {
              cell2.setGeneralPurposeVariable(rankValue, leftLimit);
              this.currentXDelta += leftLimit - medianNextLevel;
            } else if (medianNextLevel > rightLimit) {
              cell2.setGeneralPurposeVariable(rankValue, rightLimit);
              this.currentXDelta += medianNextLevel - rightLimit;
            }
            weightedValues[i].visited = true;
          }
        };
        mxCoordinateAssignment.prototype.calculatedWeightedValue = function(currentCell, collection) {
          var totalWeight = 0;
          for (var i = 0; i < collection.length; i++) {
            var cell2 = collection[i];
            if (currentCell.isVertex() && cell2.isVertex()) {
              totalWeight++;
            } else if (currentCell.isEdge() && cell2.isEdge()) {
              totalWeight += 8;
            } else {
              totalWeight += 2;
            }
          }
          return totalWeight;
        };
        mxCoordinateAssignment.prototype.medianXValue = function(connectedCells, rankValue) {
          if (connectedCells.length == 0) {
            return 0;
          }
          var medianValues = [];
          for (var i = 0; i < connectedCells.length; i++) {
            medianValues[i] = connectedCells[i].getGeneralPurposeVariable(rankValue);
          }
          medianValues.sort(function(a, b) {
            return a - b;
          });
          if (connectedCells.length % 2 == 1) {
            return medianValues[Math.floor(connectedCells.length / 2)];
          } else {
            var medianPoint = connectedCells.length / 2;
            var leftMedian = medianValues[medianPoint - 1];
            var rightMedian = medianValues[medianPoint];
            return (leftMedian + rightMedian) / 2;
          }
        };
        mxCoordinateAssignment.prototype.initialCoords = function(facade, model) {
          this.calculateWidestRank(facade, model);
          for (var i = this.widestRank; i >= 0; i--) {
            if (i < model.maxRank) {
              this.rankCoordinates(i, facade, model);
            }
          }
          for (var i = this.widestRank + 1; i <= model.maxRank; i++) {
            if (i > 0) {
              this.rankCoordinates(i, facade, model);
            }
          }
        };
        mxCoordinateAssignment.prototype.rankCoordinates = function(rankValue, graph, model) {
          var rank = model.ranks[rankValue];
          var maxY = 0;
          var localX = this.initialX + (this.widestRankValue - this.rankWidths[rankValue]) / 2;
          var boundsWarning = false;
          for (var i = 0; i < rank.length; i++) {
            var node = rank[i];
            if (node.isVertex()) {
              var bounds = this.layout.getVertexBounds(node.cell);
              if (bounds != null) {
                if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
                  node.width = bounds.width;
                  node.height = bounds.height;
                } else {
                  node.width = bounds.height;
                  node.height = bounds.width;
                }
              } else {
                boundsWarning = true;
              }
              maxY = Math.max(maxY, node.height);
            } else if (node.isEdge()) {
              var numEdges = 1;
              if (node.edges != null) {
                numEdges = node.edges.length;
              } else {
                mxLog.warn("edge.edges is null");
              }
              node.width = (numEdges - 1) * this.parallelEdgeSpacing;
            }
            localX += node.width / 2;
            node.setX(rankValue, localX);
            node.setGeneralPurposeVariable(rankValue, localX);
            localX += node.width / 2;
            localX += this.intraCellSpacing;
          }
          if (boundsWarning == true) {
            mxLog.warn("At least one cell has no bounds");
          }
        };
        mxCoordinateAssignment.prototype.calculateWidestRank = function(graph, model) {
          var y = -this.interRankCellSpacing;
          var lastRankMaxCellHeight = 0;
          this.rankWidths = [];
          this.rankY = [];
          for (var rankValue = model.maxRank; rankValue >= 0; rankValue--) {
            var maxCellHeight = 0;
            var rank = model.ranks[rankValue];
            var localX = this.initialX;
            var boundsWarning = false;
            for (var i = 0; i < rank.length; i++) {
              var node = rank[i];
              if (node.isVertex()) {
                var bounds = this.layout.getVertexBounds(node.cell);
                if (bounds != null) {
                  if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
                    node.width = bounds.width;
                    node.height = bounds.height;
                  } else {
                    node.width = bounds.height;
                    node.height = bounds.width;
                  }
                } else {
                  boundsWarning = true;
                }
                maxCellHeight = Math.max(maxCellHeight, node.height);
              } else if (node.isEdge()) {
                var numEdges = 1;
                if (node.edges != null) {
                  numEdges = node.edges.length;
                } else {
                  mxLog.warn("edge.edges is null");
                }
                node.width = (numEdges - 1) * this.parallelEdgeSpacing;
              }
              localX += node.width / 2;
              node.setX(rankValue, localX);
              node.setGeneralPurposeVariable(rankValue, localX);
              localX += node.width / 2;
              localX += this.intraCellSpacing;
              if (localX > this.widestRankValue) {
                this.widestRankValue = localX;
                this.widestRank = rankValue;
              }
              this.rankWidths[rankValue] = localX;
            }
            if (boundsWarning == true) {
              mxLog.warn("At least one cell has no bounds");
            }
            this.rankY[rankValue] = y;
            var distanceToNextRank = maxCellHeight / 2 + lastRankMaxCellHeight / 2 + this.interRankCellSpacing;
            lastRankMaxCellHeight = maxCellHeight;
            if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_WEST) {
              y += distanceToNextRank;
            } else {
              y -= distanceToNextRank;
            }
            for (var i = 0; i < rank.length; i++) {
              var cell2 = rank[i];
              cell2.setY(rankValue, y);
            }
          }
        };
        mxCoordinateAssignment.prototype.minPath = function(graph, model) {
          var edges = model.edgeMapper.getValues();
          for (var j = 0; j < edges.length; j++) {
            var cell2 = edges[j];
            if (cell2.maxRank - cell2.minRank - 1 < 1) {
              continue;
            }
            var referenceX = cell2.getGeneralPurposeVariable(cell2.minRank + 1);
            var edgeStraight = true;
            var refSegCount = 0;
            for (var i = cell2.minRank + 2; i < cell2.maxRank; i++) {
              var x = cell2.getGeneralPurposeVariable(i);
              if (referenceX != x) {
                edgeStraight = false;
                referenceX = x;
              } else {
                refSegCount++;
              }
            }
            if (!edgeStraight) {
              var upSegCount = 0;
              var downSegCount = 0;
              var upXPositions = [];
              var downXPositions = [];
              var currentX = cell2.getGeneralPurposeVariable(cell2.minRank + 1);
              for (var i = cell2.minRank + 1; i < cell2.maxRank - 1; i++) {
                var nextX = cell2.getX(i + 1);
                if (currentX == nextX) {
                  upXPositions[i - cell2.minRank - 1] = currentX;
                  upSegCount++;
                } else if (this.repositionValid(model, cell2, i + 1, currentX)) {
                  upXPositions[i - cell2.minRank - 1] = currentX;
                  upSegCount++;
                } else {
                  upXPositions[i - cell2.minRank - 1] = nextX;
                  currentX = nextX;
                }
              }
              currentX = cell2.getX(i);
              for (var i = cell2.maxRank - 1; i > cell2.minRank + 1; i--) {
                var nextX = cell2.getX(i - 1);
                if (currentX == nextX) {
                  downXPositions[i - cell2.minRank - 2] = currentX;
                  downSegCount++;
                } else if (this.repositionValid(model, cell2, i - 1, currentX)) {
                  downXPositions[i - cell2.minRank - 2] = currentX;
                  downSegCount++;
                } else {
                  downXPositions[i - cell2.minRank - 2] = cell2.getX(i - 1);
                  currentX = nextX;
                }
              }
              if (downSegCount > refSegCount || upSegCount > refSegCount) {
                if (downSegCount >= upSegCount) {
                  for (var i = cell2.maxRank - 2; i > cell2.minRank; i--) {
                    cell2.setX(i, downXPositions[i - cell2.minRank - 1]);
                  }
                } else if (upSegCount > downSegCount) {
                  for (var i = cell2.minRank + 2; i < cell2.maxRank; i++) {
                    cell2.setX(i, upXPositions[i - cell2.minRank - 2]);
                  }
                } else {
                }
              }
            }
          }
        };
        mxCoordinateAssignment.prototype.repositionValid = function(model, cell2, rank, position) {
          var rankArray = model.ranks[rank];
          var rankIndex = -1;
          for (var i = 0; i < rankArray.length; i++) {
            if (cell2 == rankArray[i]) {
              rankIndex = i;
              break;
            }
          }
          if (rankIndex < 0) {
            return false;
          }
          var currentX = cell2.getGeneralPurposeVariable(rank);
          if (position < currentX) {
            if (rankIndex == 0) {
              return true;
            }
            var leftCell = rankArray[rankIndex - 1];
            var leftLimit = leftCell.getGeneralPurposeVariable(rank);
            leftLimit = leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell2.width / 2;
            if (leftLimit <= position) {
              return true;
            } else {
              return false;
            }
          } else if (position > currentX) {
            if (rankIndex == rankArray.length - 1) {
              return true;
            }
            var rightCell = rankArray[rankIndex + 1];
            var rightLimit = rightCell.getGeneralPurposeVariable(rank);
            rightLimit = rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell2.width / 2;
            if (rightLimit >= position) {
              return true;
            } else {
              return false;
            }
          }
          return true;
        };
        mxCoordinateAssignment.prototype.setCellLocations = function(graph, model) {
          this.rankTopY = [];
          this.rankBottomY = [];
          for (var i = 0; i < model.ranks.length; i++) {
            this.rankTopY[i] = Number.MAX_VALUE;
            this.rankBottomY[i] = -Number.MAX_VALUE;
          }
          var vertices = model.vertexMapper.getValues();
          for (var i = 0; i < vertices.length; i++) {
            this.setVertexLocation(vertices[i]);
          }
          if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.ORTHOGONAL || this.layout.edgeStyle == mxHierarchicalEdgeStyle.POLYLINE || this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
            this.localEdgeProcessing(model);
          }
          var edges = model.edgeMapper.getValues();
          for (var i = 0; i < edges.length; i++) {
            this.setEdgePosition(edges[i]);
          }
        };
        mxCoordinateAssignment.prototype.localEdgeProcessing = function(model) {
          for (var rankIndex = 0; rankIndex < model.ranks.length; rankIndex++) {
            var rank = model.ranks[rankIndex];
            for (var cellIndex = 0; cellIndex < rank.length; cellIndex++) {
              var cell2 = rank[cellIndex];
              if (cell2.isVertex()) {
                var currentCells = cell2.getPreviousLayerConnectedCells(rankIndex);
                var currentRank = rankIndex - 1;
                for (var k = 0; k < 2; k++) {
                  if (currentRank > -1 && currentRank < model.ranks.length && currentCells != null && currentCells.length > 0) {
                    var sortedCells = [];
                    for (var j = 0; j < currentCells.length; j++) {
                      var sorter = new WeightedCellSorter(
                        currentCells[j],
                        currentCells[j].getX(currentRank)
                      );
                      sortedCells.push(sorter);
                    }
                    sortedCells.sort(WeightedCellSorter.prototype.compare);
                    var leftLimit = cell2.x[0] - cell2.width / 2;
                    var rightLimit = leftLimit + cell2.width;
                    var connectedEdgeCount = 0;
                    var connectedEdgeGroupCount = 0;
                    var connectedEdges = [];
                    for (var j = 0; j < sortedCells.length; j++) {
                      var innerCell = sortedCells[j].cell;
                      var connections;
                      if (innerCell.isVertex()) {
                        if (k == 0) {
                          connections = cell2.connectsAsSource;
                        } else {
                          connections = cell2.connectsAsTarget;
                        }
                        for (var connIndex = 0; connIndex < connections.length; connIndex++) {
                          if (connections[connIndex].source == innerCell || connections[connIndex].target == innerCell) {
                            connectedEdgeCount += connections[connIndex].edges.length;
                            connectedEdgeGroupCount++;
                            connectedEdges.push(connections[connIndex]);
                          }
                        }
                      } else {
                        connectedEdgeCount += innerCell.edges.length;
                        connectedEdgeGroupCount++;
                        connectedEdges.push(innerCell);
                      }
                    }
                    var requiredWidth = (connectedEdgeCount + 1) * this.prefHozEdgeSep;
                    if (cell2.width > requiredWidth + 2 * this.prefHozEdgeSep) {
                      leftLimit += this.prefHozEdgeSep;
                      rightLimit -= this.prefHozEdgeSep;
                    }
                    var availableWidth = rightLimit - leftLimit;
                    var edgeSpacing = availableWidth / connectedEdgeCount;
                    var currentX = leftLimit + edgeSpacing / 2;
                    var currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;
                    var maxYOffset = 0;
                    for (var j = 0; j < connectedEdges.length; j++) {
                      var numActualEdges = connectedEdges[j].edges.length;
                      var pos = this.jettyPositions[connectedEdges[j].ids[0]];
                      if (pos == null) {
                        pos = [];
                        this.jettyPositions[connectedEdges[j].ids[0]] = pos;
                      }
                      if (j < connectedEdgeCount / 2) {
                        currentYOffset += this.prefVertEdgeOff;
                      } else if (j > connectedEdgeCount / 2) {
                        currentYOffset -= this.prefVertEdgeOff;
                      }
                      for (var m = 0; m < numActualEdges; m++) {
                        pos[m * 4 + k * 2] = currentX;
                        currentX += edgeSpacing;
                        pos[m * 4 + k * 2 + 1] = currentYOffset;
                      }
                      maxYOffset = Math.max(
                        maxYOffset,
                        currentYOffset
                      );
                    }
                  }
                  currentCells = cell2.getNextLayerConnectedCells(rankIndex);
                  currentRank = rankIndex + 1;
                }
              }
            }
          }
        };
        mxCoordinateAssignment.prototype.setEdgePosition = function(cell2) {
          var offsetX = 0;
          if (cell2.temp[0] != 101207) {
            var maxRank = cell2.maxRank;
            var minRank = cell2.minRank;
            if (maxRank == minRank) {
              maxRank = cell2.source.maxRank;
              minRank = cell2.target.minRank;
            }
            var parallelEdgeCount = 0;
            var jettys = this.jettyPositions[cell2.ids[0]];
            var source = cell2.isReversed ? cell2.target.cell : cell2.source.cell;
            var graph = this.layout.graph;
            var layoutReversed = this.orientation == mxConstants.DIRECTION_EAST || this.orientation == mxConstants.DIRECTION_SOUTH;
            for (var i = 0; i < cell2.edges.length; i++) {
              var realEdge = cell2.edges[i];
              var realSource = this.layout.getVisibleTerminal(realEdge, true);
              var newPoints = [];
              var reversed = cell2.isReversed;
              if (realSource != source) {
                reversed = !reversed;
              }
              if (jettys != null) {
                var arrayOffset = reversed ? 2 : 0;
                var y = reversed ? layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank] : layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank];
                var jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];
                if (reversed != layoutReversed) {
                  jetty = -jetty;
                }
                y += jetty;
                var x = jettys[parallelEdgeCount * 4 + arrayOffset];
                var modelSource = graph.model.getTerminal(realEdge, true);
                if (this.layout.isPort(modelSource) && graph.model.getParent(modelSource) == realSource) {
                  var state = graph.view.getState(modelSource);
                  if (state != null) {
                    x = state.x;
                  } else {
                    x = realSource.geometry.x + cell2.source.width * modelSource.geometry.x;
                  }
                }
                if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
                  newPoints.push(new mxPoint(x, y));
                  if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
                    newPoints.push(new mxPoint(x, y + jetty));
                  }
                } else {
                  newPoints.push(new mxPoint(y, x));
                  if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
                    newPoints.push(new mxPoint(y + jetty, x));
                  }
                }
              }
              var loopStart = cell2.x.length - 1;
              var loopLimit = -1;
              var loopDelta = -1;
              var currentRank = cell2.maxRank - 1;
              if (reversed) {
                loopStart = 0;
                loopLimit = cell2.x.length;
                loopDelta = 1;
                currentRank = cell2.minRank + 1;
              }
              for (var j = loopStart; cell2.maxRank != cell2.minRank && j != loopLimit; j += loopDelta) {
                var positionX = cell2.x[j] + offsetX;
                var topChannelY = (this.rankTopY[currentRank] + this.rankBottomY[currentRank + 1]) / 2;
                var bottomChannelY = (this.rankTopY[currentRank - 1] + this.rankBottomY[currentRank]) / 2;
                if (reversed) {
                  var tmp = topChannelY;
                  topChannelY = bottomChannelY;
                  bottomChannelY = tmp;
                }
                if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
                  newPoints.push(new mxPoint(positionX, topChannelY));
                  newPoints.push(new mxPoint(positionX, bottomChannelY));
                } else {
                  newPoints.push(new mxPoint(topChannelY, positionX));
                  newPoints.push(new mxPoint(bottomChannelY, positionX));
                }
                this.limitX = Math.max(this.limitX, positionX);
                currentRank += loopDelta;
              }
              if (jettys != null) {
                var arrayOffset = reversed ? 2 : 0;
                var rankY = reversed ? layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank] : layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank];
                var jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];
                if (reversed != layoutReversed) {
                  jetty = -jetty;
                }
                var y = rankY - jetty;
                var x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];
                var modelTarget = graph.model.getTerminal(realEdge, false);
                var realTarget = this.layout.getVisibleTerminal(realEdge, false);
                if (this.layout.isPort(modelTarget) && graph.model.getParent(modelTarget) == realTarget) {
                  var state = graph.view.getState(modelTarget);
                  if (state != null) {
                    x = state.x;
                  } else {
                    x = realTarget.geometry.x + cell2.target.width * modelTarget.geometry.x;
                  }
                }
                if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
                  if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
                    newPoints.push(new mxPoint(x, y - jetty));
                  }
                  newPoints.push(new mxPoint(x, y));
                } else {
                  if (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE) {
                    newPoints.push(new mxPoint(y - jetty, x));
                  }
                  newPoints.push(new mxPoint(y, x));
                }
              }
              if (cell2.isReversed) {
                this.processReversedEdge(cell2, realEdge);
              }
              this.layout.setEdgePoints(realEdge, newPoints);
              if (offsetX == 0) {
                offsetX = this.parallelEdgeSpacing;
              } else if (offsetX > 0) {
                offsetX = -offsetX;
              } else {
                offsetX = -offsetX + this.parallelEdgeSpacing;
              }
              parallelEdgeCount++;
            }
            cell2.temp[0] = 101207;
          }
        };
        mxCoordinateAssignment.prototype.setVertexLocation = function(cell2) {
          var realCell = cell2.cell;
          var positionX = cell2.x[0] - cell2.width / 2;
          var positionY = cell2.y[0] - cell2.height / 2;
          this.rankTopY[cell2.minRank] = Math.min(this.rankTopY[cell2.minRank], positionY);
          this.rankBottomY[cell2.minRank] = Math.max(
            this.rankBottomY[cell2.minRank],
            positionY + cell2.height
          );
          if (this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH) {
            this.layout.setVertexLocation(realCell, positionX, positionY);
          } else {
            this.layout.setVertexLocation(realCell, positionY, positionX);
          }
          this.limitX = Math.max(this.limitX, positionX + cell2.width);
        };
        mxCoordinateAssignment.prototype.processReversedEdge = function(graph, model) {
        };
        __mxOutput.mxCoordinateAssignment = typeof mxCoordinateAssignment !== "undefined" ? mxCoordinateAssignment : void 0;
        function mxSwimlaneOrdering(layout) {
          this.layout = layout;
        }
        ;
        mxSwimlaneOrdering.prototype = new mxHierarchicalLayoutStage();
        mxSwimlaneOrdering.prototype.constructor = mxSwimlaneOrdering;
        mxSwimlaneOrdering.prototype.layout = null;
        mxSwimlaneOrdering.prototype.execute = function(parent) {
          var model = this.layout.getModel();
          var seenNodes = new Object();
          var unseenNodes = mxUtils.clone(model.vertexMapper, null, true);
          var rootsArray = null;
          if (model.roots != null) {
            var modelRoots = model.roots;
            rootsArray = [];
            for (var i = 0; i < modelRoots.length; i++) {
              rootsArray[i] = model.vertexMapper.get(modelRoots[i]);
            }
          }
          model.visit(function(parent2, node, connectingEdge, layer, seen) {
            var isAncestor = parent2 != null && parent2.swimlaneIndex == node.swimlaneIndex && node.isAncestor(parent2);
            var reversedOverSwimlane = parent2 != null && connectingEdge != null && parent2.swimlaneIndex < node.swimlaneIndex && connectingEdge.source == node;
            if (isAncestor) {
              connectingEdge.invert();
              mxUtils.remove(connectingEdge, parent2.connectsAsSource);
              node.connectsAsSource.push(connectingEdge);
              parent2.connectsAsTarget.push(connectingEdge);
              mxUtils.remove(connectingEdge, node.connectsAsTarget);
            } else if (reversedOverSwimlane) {
              connectingEdge.invert();
              mxUtils.remove(connectingEdge, parent2.connectsAsTarget);
              node.connectsAsTarget.push(connectingEdge);
              parent2.connectsAsSource.push(connectingEdge);
              mxUtils.remove(connectingEdge, node.connectsAsSource);
            }
            var cellId = mxCellPath.create(node.cell);
            seenNodes[cellId] = node;
            delete unseenNodes[cellId];
          }, rootsArray, true, null);
        };
        __mxOutput.mxSwimlaneOrdering = typeof mxSwimlaneOrdering !== "undefined" ? mxSwimlaneOrdering : void 0;
        function mxHierarchicalLayout(graph, orientation, deterministic) {
          mxGraphLayout.call(this, graph);
          this.orientation = orientation != null ? orientation : mxConstants.DIRECTION_NORTH;
          this.deterministic = deterministic != null ? deterministic : true;
        }
        ;
        var mxHierarchicalEdgeStyle = {
          ORTHOGONAL: 1,
          POLYLINE: 2,
          STRAIGHT: 3,
          CURVE: 4
        };
        mxHierarchicalLayout.prototype = new mxGraphLayout();
        mxHierarchicalLayout.prototype.constructor = mxHierarchicalLayout;
        mxHierarchicalLayout.prototype.roots = null;
        mxHierarchicalLayout.prototype.resizeParent = false;
        mxHierarchicalLayout.prototype.maintainParentLocation = false;
        mxHierarchicalLayout.prototype.moveParent = false;
        mxHierarchicalLayout.prototype.parentBorder = 0;
        mxHierarchicalLayout.prototype.intraCellSpacing = 30;
        mxHierarchicalLayout.prototype.interRankCellSpacing = 100;
        mxHierarchicalLayout.prototype.interHierarchySpacing = 60;
        mxHierarchicalLayout.prototype.parallelEdgeSpacing = 10;
        mxHierarchicalLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;
        mxHierarchicalLayout.prototype.fineTuning = true;
        mxHierarchicalLayout.prototype.tightenToSource = true;
        mxHierarchicalLayout.prototype.disableEdgeStyle = true;
        mxHierarchicalLayout.prototype.traverseAncestors = true;
        mxHierarchicalLayout.prototype.model = null;
        mxHierarchicalLayout.prototype.edgesCache = null;
        mxHierarchicalLayout.prototype.edgeSourceTermCache = null;
        mxHierarchicalLayout.prototype.edgesTargetTermCache = null;
        mxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;
        mxHierarchicalLayout.prototype.getModel = function() {
          return this.model;
        };
        mxHierarchicalLayout.prototype.execute = function(parent, roots) {
          this.parent = parent;
          var model = this.graph.model;
          this.edgesCache = new mxDictionary();
          this.edgeSourceTermCache = new mxDictionary();
          this.edgesTargetTermCache = new mxDictionary();
          if (roots != null && !(roots instanceof Array)) {
            roots = [roots];
          }
          if (roots == null && parent == null) {
            return;
          }
          this.parentX = null;
          this.parentY = null;
          if (parent != this.root && model.isVertex(parent) != null && this.maintainParentLocation) {
            var geo = this.graph.getCellGeometry(parent);
            if (geo != null) {
              this.parentX = geo.x;
              this.parentY = geo.y;
            }
          }
          if (roots != null) {
            var rootsCopy = [];
            for (var i = 0; i < roots.length; i++) {
              var ancestor = parent != null ? model.isAncestor(parent, roots[i]) : true;
              if (ancestor && model.isVertex(roots[i])) {
                rootsCopy.push(roots[i]);
              }
            }
            this.roots = rootsCopy;
          }
          model.beginUpdate();
          try {
            this.run(parent);
            if (this.resizeParent && !this.graph.isCellCollapsed(parent)) {
              this.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);
            }
            if (this.parentX != null && this.parentY != null) {
              var geo = this.graph.getCellGeometry(parent);
              if (geo != null) {
                geo = geo.clone();
                geo.x = this.parentX;
                geo.y = this.parentY;
                model.setGeometry(parent, geo);
              }
            }
          } finally {
            model.endUpdate();
          }
        };
        mxHierarchicalLayout.prototype.findRoots = function(parent, vertices) {
          var roots = [];
          if (parent != null && vertices != null) {
            var model = this.graph.model;
            var best = null;
            var maxDiff = -1e5;
            for (var i in vertices) {
              var cell2 = vertices[i];
              if (model.isVertex(cell2) && this.graph.isCellVisible(cell2)) {
                var conns = this.getEdges(cell2);
                var fanOut = 0;
                var fanIn = 0;
                for (var k = 0; k < conns.length; k++) {
                  var src = this.getVisibleTerminal(conns[k], true);
                  if (src == cell2) {
                    fanOut++;
                  } else {
                    fanIn++;
                  }
                }
                if (fanIn == 0 && fanOut > 0) {
                  roots.push(cell2);
                }
                var diff = fanOut - fanIn;
                if (diff > maxDiff) {
                  maxDiff = diff;
                  best = cell2;
                }
              }
            }
            if (roots.length == 0 && best != null) {
              roots.push(best);
            }
          }
          return roots;
        };
        mxHierarchicalLayout.prototype.getEdges = function(cell2) {
          var cachedEdges = this.edgesCache.get(cell2);
          if (cachedEdges != null) {
            return cachedEdges;
          }
          var model = this.graph.model;
          var edges = [];
          var isCollapsed = this.graph.isCellCollapsed(cell2);
          var childCount = model.getChildCount(cell2);
          for (var i = 0; i < childCount; i++) {
            var child = model.getChildAt(cell2, i);
            if (this.isPort(child)) {
              edges = edges.concat(model.getEdges(child, true, true));
            } else if (isCollapsed || !this.graph.isCellVisible(child)) {
              edges = edges.concat(model.getEdges(child, true, true));
            }
          }
          edges = edges.concat(model.getEdges(cell2, true, true));
          var result2 = [];
          for (var i = 0; i < edges.length; i++) {
            var source = this.getVisibleTerminal(edges[i], true);
            var target = this.getVisibleTerminal(edges[i], false);
            if (source == target || source != target && (target == cell2 && (this.parent == null || this.isAncestor(this.parent, source, this.traverseAncestors)) || source == cell2 && (this.parent == null || this.isAncestor(this.parent, target, this.traverseAncestors)))) {
              result2.push(edges[i]);
            }
          }
          this.edgesCache.put(cell2, result2);
          return result2;
        };
        mxHierarchicalLayout.prototype.getVisibleTerminal = function(edge, source) {
          var terminalCache = this.edgesTargetTermCache;
          if (source) {
            terminalCache = this.edgeSourceTermCache;
          }
          var term = terminalCache.get(edge);
          if (term != null) {
            return term;
          }
          var state = this.graph.view.getState(edge);
          var terminal = state != null ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);
          if (terminal == null) {
            terminal = state != null ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);
          }
          if (terminal != null) {
            if (this.isPort(terminal)) {
              terminal = this.graph.model.getParent(terminal);
            }
            terminalCache.put(edge, terminal);
          }
          return terminal;
        };
        mxHierarchicalLayout.prototype.run = function(parent) {
          var hierarchyVertices = [];
          var allVertexSet = [];
          if (this.roots == null && parent != null) {
            var filledVertexSet = Object();
            this.filterDescendants(parent, filledVertexSet);
            this.roots = [];
            var filledVertexSetEmpty = true;
            for (var key in filledVertexSet) {
              if (filledVertexSet[key] != null) {
                filledVertexSetEmpty = false;
                break;
              }
            }
            while (!filledVertexSetEmpty) {
              var candidateRoots = this.findRoots(parent, filledVertexSet);
              for (var i = 0; i < candidateRoots.length; i++) {
                var vertexSet = Object();
                hierarchyVertices.push(vertexSet);
                this.traverse(
                  candidateRoots[i],
                  true,
                  null,
                  allVertexSet,
                  vertexSet,
                  hierarchyVertices,
                  filledVertexSet
                );
              }
              for (var i = 0; i < candidateRoots.length; i++) {
                this.roots.push(candidateRoots[i]);
              }
              filledVertexSetEmpty = true;
              for (var key in filledVertexSet) {
                if (filledVertexSet[key] != null) {
                  filledVertexSetEmpty = false;
                  break;
                }
              }
            }
          } else {
            for (var i = 0; i < this.roots.length; i++) {
              var vertexSet = Object();
              hierarchyVertices.push(vertexSet);
              this.traverse(
                this.roots[i],
                true,
                null,
                allVertexSet,
                vertexSet,
                hierarchyVertices,
                null
              );
            }
          }
          var initialX = 0;
          for (var i = 0; i < hierarchyVertices.length; i++) {
            var vertexSet = hierarchyVertices[i];
            var tmp = [];
            for (var key in vertexSet) {
              tmp.push(vertexSet[key]);
            }
            this.model = new mxGraphHierarchyModel(
              this,
              tmp,
              this.roots,
              parent,
              this.tightenToSource
            );
            this.cycleStage(parent);
            this.layeringStage();
            this.crossingStage(parent);
            initialX = this.placementStage(initialX, parent);
          }
        };
        mxHierarchicalLayout.prototype.filterDescendants = function(cell2, result2) {
          var model = this.graph.model;
          if (model.isVertex(cell2) && cell2 != this.parent && this.graph.isCellVisible(cell2)) {
            result2[mxObjectIdentity.get(cell2)] = cell2;
          }
          if (this.traverseAncestors || cell2 == this.parent && this.graph.isCellVisible(cell2)) {
            var childCount = model.getChildCount(cell2);
            for (var i = 0; i < childCount; i++) {
              var child = model.getChildAt(cell2, i);
              if (!this.isPort(child)) {
                this.filterDescendants(child, result2);
              }
            }
          }
        };
        mxHierarchicalLayout.prototype.isPort = function(cell2) {
          if (cell2 != null && cell2.geometry != null) {
            return cell2.geometry.relative;
          } else {
            return false;
          }
        };
        mxHierarchicalLayout.prototype.getEdgesBetween = function(source, target, directed) {
          directed = directed != null ? directed : false;
          var edges = this.getEdges(source);
          var result2 = [];
          for (var i = 0; i < edges.length; i++) {
            var src = this.getVisibleTerminal(edges[i], true);
            var trg = this.getVisibleTerminal(edges[i], false);
            if (src == source && trg == target || !directed && src == target && trg == source) {
              result2.push(edges[i]);
            }
          }
          return result2;
        };
        mxHierarchicalLayout.prototype.traverse = function(vertex, directed, edge, allVertices, currentComp, hierarchyVertices, filledVertexSet) {
          if (vertex != null && allVertices != null) {
            var vertexID = mxObjectIdentity.get(vertex);
            if (allVertices[vertexID] == null && (filledVertexSet == null ? true : filledVertexSet[vertexID] != null)) {
              if (currentComp[vertexID] == null) {
                currentComp[vertexID] = vertex;
              }
              if (allVertices[vertexID] == null) {
                allVertices[vertexID] = vertex;
              }
              if (filledVertexSet !== null) {
                delete filledVertexSet[vertexID];
              }
              var edges = this.getEdges(vertex);
              var edgeIsSource = [];
              for (var i = 0; i < edges.length; i++) {
                edgeIsSource[i] = this.getVisibleTerminal(edges[i], true) == vertex;
              }
              for (var i = 0; i < edges.length; i++) {
                if (!directed || edgeIsSource[i]) {
                  var next = this.getVisibleTerminal(edges[i], !edgeIsSource[i]);
                  var netCount = 1;
                  for (var j = 0; j < edges.length; j++) {
                    if (j == i) {
                      continue;
                    } else {
                      var isSource2 = edgeIsSource[j];
                      var otherTerm = this.getVisibleTerminal(edges[j], !isSource2);
                      if (otherTerm == next) {
                        if (isSource2) {
                          netCount++;
                        } else {
                          netCount--;
                        }
                      }
                    }
                  }
                  if (netCount >= 0) {
                    currentComp = this.traverse(
                      next,
                      directed,
                      edges[i],
                      allVertices,
                      currentComp,
                      hierarchyVertices,
                      filledVertexSet
                    );
                  }
                }
              }
            } else {
              if (currentComp[vertexID] == null) {
                for (var i = 0; i < hierarchyVertices.length; i++) {
                  var comp = hierarchyVertices[i];
                  if (comp[vertexID] != null) {
                    for (var key in comp) {
                      currentComp[key] = comp[key];
                    }
                    hierarchyVertices.splice(i, 1);
                    return currentComp;
                  }
                }
              }
            }
          }
          return currentComp;
        };
        mxHierarchicalLayout.prototype.cycleStage = function(parent) {
          var cycleStage = new mxMinimumCycleRemover(this);
          cycleStage.execute(parent);
        };
        mxHierarchicalLayout.prototype.layeringStage = function() {
          this.model.initialRank();
          this.model.fixRanks();
        };
        mxHierarchicalLayout.prototype.crossingStage = function(parent) {
          var crossingStage = new mxMedianHybridCrossingReduction(this);
          crossingStage.execute(parent);
        };
        mxHierarchicalLayout.prototype.placementStage = function(initialX, parent) {
          var placementStage = new mxCoordinateAssignment(
            this,
            this.intraCellSpacing,
            this.interRankCellSpacing,
            this.orientation,
            initialX,
            this.parallelEdgeSpacing
          );
          placementStage.fineTuning = this.fineTuning;
          placementStage.execute(parent);
          return placementStage.limitX + this.interHierarchySpacing;
        };
        __mxOutput.mxHierarchicalLayout = typeof mxHierarchicalLayout !== "undefined" ? mxHierarchicalLayout : void 0;
        function mxSwimlaneLayout(graph, orientation, deterministic) {
          mxGraphLayout.call(this, graph);
          this.orientation = orientation != null ? orientation : mxConstants.DIRECTION_NORTH;
          this.deterministic = deterministic != null ? deterministic : true;
        }
        ;
        mxSwimlaneLayout.prototype = new mxGraphLayout();
        mxSwimlaneLayout.prototype.constructor = mxSwimlaneLayout;
        mxSwimlaneLayout.prototype.roots = null;
        mxSwimlaneLayout.prototype.swimlanes = null;
        mxSwimlaneLayout.prototype.dummyVertexWidth = 50;
        mxSwimlaneLayout.prototype.resizeParent = false;
        mxSwimlaneLayout.prototype.maintainParentLocation = false;
        mxSwimlaneLayout.prototype.moveParent = false;
        mxSwimlaneLayout.prototype.parentBorder = 30;
        mxSwimlaneLayout.prototype.intraCellSpacing = 30;
        mxSwimlaneLayout.prototype.interRankCellSpacing = 100;
        mxSwimlaneLayout.prototype.interHierarchySpacing = 60;
        mxSwimlaneLayout.prototype.parallelEdgeSpacing = 10;
        mxSwimlaneLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;
        mxSwimlaneLayout.prototype.fineTuning = true;
        mxSwimlaneLayout.prototype.tightenToSource = true;
        mxSwimlaneLayout.prototype.disableEdgeStyle = true;
        mxSwimlaneLayout.prototype.traverseAncestors = true;
        mxSwimlaneLayout.prototype.model = null;
        mxSwimlaneLayout.prototype.edgesCache = null;
        mxHierarchicalLayout.prototype.edgeSourceTermCache = null;
        mxHierarchicalLayout.prototype.edgesTargetTermCache = null;
        mxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;
        mxSwimlaneLayout.prototype.getModel = function() {
          return this.model;
        };
        mxSwimlaneLayout.prototype.execute = function(parent, swimlanes) {
          this.parent = parent;
          var model = this.graph.model;
          this.edgesCache = new mxDictionary();
          this.edgeSourceTermCache = new mxDictionary();
          this.edgesTargetTermCache = new mxDictionary();
          if (swimlanes == null || swimlanes.length < 1) {
            return;
          }
          if (parent == null) {
            parent = model.getParent(swimlanes[0]);
          }
          this.parentX = null;
          this.parentY = null;
          if (parent != this.root && model.isVertex(parent) != null && this.maintainParentLocation) {
            var geo = this.graph.getCellGeometry(parent);
            if (geo != null) {
              this.parentX = geo.x;
              this.parentY = geo.y;
            }
          }
          this.swimlanes = swimlanes;
          var dummyVertices = [];
          for (var i = 0; i < swimlanes.length; i++) {
            var children = this.graph.getChildCells(swimlanes[i]);
            if (children == null || children.length == 0) {
              var vertex = this.graph.insertVertex(swimlanes[i], null, null, 0, 0, this.dummyVertexWidth, 0);
              dummyVertices.push(vertex);
            }
          }
          model.beginUpdate();
          try {
            this.run(parent);
            if (this.resizeParent && !this.graph.isCellCollapsed(parent)) {
              this.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);
            }
            if (this.parentX != null && this.parentY != null) {
              var geo = this.graph.getCellGeometry(parent);
              if (geo != null) {
                geo = geo.clone();
                geo.x = this.parentX;
                geo.y = this.parentY;
                model.setGeometry(parent, geo);
              }
            }
            this.graph.removeCells(dummyVertices);
          } finally {
            model.endUpdate();
          }
        };
        mxSwimlaneLayout.prototype.updateGroupBounds = function() {
          var cells = [];
          var model = this.model;
          for (var key in model.edgeMapper) {
            var edge = model.edgeMapper[key];
            for (var i = 0; i < edge.edges.length; i++) {
              cells.push(edge.edges[i]);
            }
          }
          var layoutBounds = this.graph.getBoundingBoxFromGeometry(cells, true);
          var childBounds = [];
          for (var i = 0; i < this.swimlanes.length; i++) {
            var lane = this.swimlanes[i];
            var geo = this.graph.getCellGeometry(lane);
            if (geo != null) {
              var children = this.graph.getChildCells(lane);
              var size = this.graph.isSwimlane(lane) ? this.graph.getStartSize(lane) : new mxRectangle();
              var bounds = this.graph.getBoundingBoxFromGeometry(children);
              childBounds[i] = bounds;
              var childrenY = bounds.y + geo.y - size.height - this.parentBorder;
              var maxChildrenY = bounds.y + geo.y + bounds.height;
              if (layoutBounds == null) {
                layoutBounds = new mxRectangle(0, childrenY, 0, maxChildrenY - childrenY);
              } else {
                layoutBounds.y = Math.min(layoutBounds.y, childrenY);
                var maxY = Math.max(layoutBounds.y + layoutBounds.height, maxChildrenY);
                layoutBounds.height = maxY - layoutBounds.y;
              }
            }
          }
          for (var i = 0; i < this.swimlanes.length; i++) {
            var lane = this.swimlanes[i];
            var geo = this.graph.getCellGeometry(lane);
            if (geo != null) {
              var children = this.graph.getChildCells(lane);
              var size = this.graph.isSwimlane(lane) ? this.graph.getStartSize(lane) : new mxRectangle();
              var newGeo = geo.clone();
              var leftGroupBorder = i == 0 ? this.parentBorder : this.interRankCellSpacing / 2;
              var w2 = size.width + leftGroupBorder;
              var x = childBounds[i].x - w2;
              var y = layoutBounds.y - this.parentBorder;
              newGeo.x += x;
              newGeo.y = y;
              newGeo.width = childBounds[i].width + w2 + this.interRankCellSpacing / 2;
              newGeo.height = layoutBounds.height + size.height + 2 * this.parentBorder;
              this.graph.model.setGeometry(lane, newGeo);
              this.graph.moveCells(children, -x, geo.y - y);
            }
          }
        };
        mxSwimlaneLayout.prototype.findRoots = function(parent, vertices) {
          var roots = [];
          if (parent != null && vertices != null) {
            var model = this.graph.model;
            var best = null;
            var maxDiff = -1e5;
            for (var i in vertices) {
              var cell2 = vertices[i];
              if (cell2 != null && model.isVertex(cell2) && this.graph.isCellVisible(cell2) && model.isAncestor(parent, cell2)) {
                var conns = this.getEdges(cell2);
                var fanOut = 0;
                var fanIn = 0;
                for (var k = 0; k < conns.length; k++) {
                  var src = this.getVisibleTerminal(conns[k], true);
                  if (src == cell2) {
                    var other = this.getVisibleTerminal(conns[k], false);
                    if (model.isAncestor(parent, other)) {
                      fanOut++;
                    }
                  } else if (model.isAncestor(parent, src)) {
                    fanIn++;
                  }
                }
                if (fanIn == 0 && fanOut > 0) {
                  roots.push(cell2);
                }
                var diff = fanOut - fanIn;
                if (diff > maxDiff) {
                  maxDiff = diff;
                  best = cell2;
                }
              }
            }
            if (roots.length == 0 && best != null) {
              roots.push(best);
            }
          }
          return roots;
        };
        mxSwimlaneLayout.prototype.getEdges = function(cell2) {
          var cachedEdges = this.edgesCache.get(cell2);
          if (cachedEdges != null) {
            return cachedEdges;
          }
          var model = this.graph.model;
          var edges = [];
          var isCollapsed = this.graph.isCellCollapsed(cell2);
          var childCount = model.getChildCount(cell2);
          for (var i = 0; i < childCount; i++) {
            var child = model.getChildAt(cell2, i);
            if (this.isPort(child)) {
              edges = edges.concat(model.getEdges(child, true, true));
            } else if (isCollapsed || !this.graph.isCellVisible(child)) {
              edges = edges.concat(model.getEdges(child, true, true));
            }
          }
          edges = edges.concat(model.getEdges(cell2, true, true));
          var result2 = [];
          for (var i = 0; i < edges.length; i++) {
            var source = this.getVisibleTerminal(edges[i], true);
            var target = this.getVisibleTerminal(edges[i], false);
            if (source == target || source != target && (target == cell2 && (this.parent == null || this.graph.isValidAncestor(source, this.parent, this.traverseAncestors)) || source == cell2 && (this.parent == null || this.graph.isValidAncestor(target, this.parent, this.traverseAncestors)))) {
              result2.push(edges[i]);
            }
          }
          this.edgesCache.put(cell2, result2);
          return result2;
        };
        mxSwimlaneLayout.prototype.getVisibleTerminal = function(edge, source) {
          var terminalCache = this.edgesTargetTermCache;
          if (source) {
            terminalCache = this.edgeSourceTermCache;
          }
          var term = terminalCache.get(edge);
          if (term != null) {
            return term;
          }
          var state = this.graph.view.getState(edge);
          var terminal = state != null ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);
          if (terminal == null) {
            terminal = state != null ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);
          }
          if (terminal != null) {
            if (this.isPort(terminal)) {
              terminal = this.graph.model.getParent(terminal);
            }
            terminalCache.put(edge, terminal);
          }
          return terminal;
        };
        mxSwimlaneLayout.prototype.run = function(parent) {
          var hierarchyVertices = [];
          var allVertexSet = Object();
          if (this.swimlanes != null && this.swimlanes.length > 0 && parent != null) {
            var filledVertexSet = Object();
            for (var i = 0; i < this.swimlanes.length; i++) {
              this.filterDescendants(this.swimlanes[i], filledVertexSet);
            }
            this.roots = [];
            var filledVertexSetEmpty = true;
            for (var key in filledVertexSet) {
              if (filledVertexSet[key] != null) {
                filledVertexSetEmpty = false;
                break;
              }
            }
            var laneCounter = 0;
            while (!filledVertexSetEmpty && laneCounter < this.swimlanes.length) {
              var candidateRoots = this.findRoots(this.swimlanes[laneCounter], filledVertexSet);
              if (candidateRoots.length == 0) {
                laneCounter++;
                continue;
              }
              for (var i = 0; i < candidateRoots.length; i++) {
                var vertexSet = Object();
                hierarchyVertices.push(vertexSet);
                this.traverse(
                  candidateRoots[i],
                  true,
                  null,
                  allVertexSet,
                  vertexSet,
                  hierarchyVertices,
                  filledVertexSet,
                  laneCounter
                );
              }
              for (var i = 0; i < candidateRoots.length; i++) {
                this.roots.push(candidateRoots[i]);
              }
              filledVertexSetEmpty = true;
              for (var key in filledVertexSet) {
                if (filledVertexSet[key] != null) {
                  filledVertexSetEmpty = false;
                  break;
                }
              }
            }
          } else {
            for (var i = 0; i < this.roots.length; i++) {
              var vertexSet = Object();
              hierarchyVertices.push(vertexSet);
              this.traverse(
                this.roots[i],
                true,
                null,
                allVertexSet,
                vertexSet,
                hierarchyVertices,
                null
              );
            }
          }
          var tmp = [];
          for (var key in allVertexSet) {
            tmp.push(allVertexSet[key]);
          }
          this.model = new mxSwimlaneModel(
            this,
            tmp,
            this.roots,
            parent,
            this.tightenToSource
          );
          this.cycleStage(parent);
          this.layeringStage();
          this.crossingStage(parent);
          this.placementStage(0, parent);
        };
        mxSwimlaneLayout.prototype.filterDescendants = function(cell2, result2) {
          var model = this.graph.model;
          if (model.isVertex(cell2) && cell2 != this.parent && model.getParent(cell2) != this.parent && this.graph.isCellVisible(cell2)) {
            result2[mxObjectIdentity.get(cell2)] = cell2;
          }
          if (this.traverseAncestors || cell2 == this.parent && this.graph.isCellVisible(cell2)) {
            var childCount = model.getChildCount(cell2);
            for (var i = 0; i < childCount; i++) {
              var child = model.getChildAt(cell2, i);
              if (!this.isPort(child)) {
                this.filterDescendants(child, result2);
              }
            }
          }
        };
        mxSwimlaneLayout.prototype.isPort = function(cell2) {
          if (cell2.geometry.relative) {
            return true;
          }
          return false;
        };
        mxSwimlaneLayout.prototype.getEdgesBetween = function(source, target, directed) {
          directed = directed != null ? directed : false;
          var edges = this.getEdges(source);
          var result2 = [];
          for (var i = 0; i < edges.length; i++) {
            var src = this.getVisibleTerminal(edges[i], true);
            var trg = this.getVisibleTerminal(edges[i], false);
            if (src == source && trg == target || !directed && src == target && trg == source) {
              result2.push(edges[i]);
            }
          }
          return result2;
        };
        mxSwimlaneLayout.prototype.traverse = function(vertex, directed, edge, allVertices, currentComp, hierarchyVertices, filledVertexSet, swimlaneIndex) {
          if (vertex != null && allVertices != null) {
            var vertexID = mxObjectIdentity.get(vertex);
            if (allVertices[vertexID] == null && (filledVertexSet == null ? true : filledVertexSet[vertexID] != null)) {
              if (currentComp[vertexID] == null) {
                currentComp[vertexID] = vertex;
              }
              if (allVertices[vertexID] == null) {
                allVertices[vertexID] = vertex;
              }
              if (filledVertexSet !== null) {
                delete filledVertexSet[vertexID];
              }
              var edges = this.getEdges(vertex);
              var model = this.graph.model;
              for (var i = 0; i < edges.length; i++) {
                var otherVertex = this.getVisibleTerminal(edges[i], true);
                var isSource = otherVertex == vertex;
                if (isSource) {
                  otherVertex = this.getVisibleTerminal(edges[i], false);
                }
                var otherIndex = 0;
                for (otherIndex = 0; otherIndex < this.swimlanes.length; otherIndex++) {
                  if (model.isAncestor(this.swimlanes[otherIndex], otherVertex)) {
                    break;
                  }
                }
                if (otherIndex >= this.swimlanes.length) {
                  continue;
                }
                if (otherIndex > swimlaneIndex || (!directed || isSource) && otherIndex == swimlaneIndex) {
                  currentComp = this.traverse(
                    otherVertex,
                    directed,
                    edges[i],
                    allVertices,
                    currentComp,
                    hierarchyVertices,
                    filledVertexSet,
                    otherIndex
                  );
                }
              }
            } else {
              if (currentComp[vertexID] == null) {
                for (var i = 0; i < hierarchyVertices.length; i++) {
                  var comp = hierarchyVertices[i];
                  if (comp[vertexID] != null) {
                    for (var key in comp) {
                      currentComp[key] = comp[key];
                    }
                    hierarchyVertices.splice(i, 1);
                    return currentComp;
                  }
                }
              }
            }
          }
          return currentComp;
        };
        mxSwimlaneLayout.prototype.cycleStage = function(parent) {
          var cycleStage = new mxSwimlaneOrdering(this);
          cycleStage.execute(parent);
        };
        mxSwimlaneLayout.prototype.layeringStage = function() {
          this.model.initialRank();
          this.model.fixRanks();
        };
        mxSwimlaneLayout.prototype.crossingStage = function(parent) {
          var crossingStage = new mxMedianHybridCrossingReduction(this);
          crossingStage.execute(parent);
        };
        mxSwimlaneLayout.prototype.placementStage = function(initialX, parent) {
          var placementStage = new mxCoordinateAssignment(
            this,
            this.intraCellSpacing,
            this.interRankCellSpacing,
            this.orientation,
            initialX,
            this.parallelEdgeSpacing
          );
          placementStage.fineTuning = this.fineTuning;
          placementStage.execute(parent);
          return placementStage.limitX + this.interHierarchySpacing;
        };
        __mxOutput.mxSwimlaneLayout = typeof mxSwimlaneLayout !== "undefined" ? mxSwimlaneLayout : void 0;
        function mxGraphModel(root) {
          this.currentEdit = this.createUndoableEdit();
          if (root != null) {
            this.setRoot(root);
          } else {
            this.clear();
          }
        }
        ;
        mxGraphModel.prototype = new mxEventSource();
        mxGraphModel.prototype.constructor = mxGraphModel;
        mxGraphModel.prototype.root = null;
        mxGraphModel.prototype.cells = null;
        mxGraphModel.prototype.maintainEdgeParent = true;
        mxGraphModel.prototype.ignoreRelativeEdgeParent = true;
        mxGraphModel.prototype.createIds = true;
        mxGraphModel.prototype.prefix = "";
        mxGraphModel.prototype.postfix = "";
        mxGraphModel.prototype.nextId = 0;
        mxGraphModel.prototype.currentEdit = null;
        mxGraphModel.prototype.updateLevel = 0;
        mxGraphModel.prototype.endingUpdate = false;
        mxGraphModel.prototype.clear = function() {
          this.setRoot(this.createRoot());
        };
        mxGraphModel.prototype.isCreateIds = function() {
          return this.createIds;
        };
        mxGraphModel.prototype.setCreateIds = function(value) {
          this.createIds = value;
        };
        mxGraphModel.prototype.createRoot = function() {
          var cell2 = new mxCell();
          cell2.insert(new mxCell());
          return cell2;
        };
        mxGraphModel.prototype.getCell = function(id) {
          return this.cells != null ? this.cells[id] : null;
        };
        mxGraphModel.prototype.filterCells = function(cells, filter) {
          var result2 = null;
          if (cells != null) {
            result2 = [];
            for (var i = 0; i < cells.length; i++) {
              if (filter(cells[i])) {
                result2.push(cells[i]);
              }
            }
          }
          return result2;
        };
        mxGraphModel.prototype.getDescendants = function(parent) {
          return this.filterDescendants(null, parent);
        };
        mxGraphModel.prototype.filterDescendants = function(filter, parent) {
          var result2 = [];
          parent = parent || this.getRoot();
          if (filter == null || filter(parent)) {
            result2.push(parent);
          }
          var childCount = this.getChildCount(parent);
          for (var i = 0; i < childCount; i++) {
            var child = this.getChildAt(parent, i);
            result2 = result2.concat(this.filterDescendants(filter, child));
          }
          return result2;
        };
        mxGraphModel.prototype.getRoot = function(cell2) {
          var root = cell2 || this.root;
          if (cell2 != null) {
            while (cell2 != null) {
              root = cell2;
              cell2 = this.getParent(cell2);
            }
          }
          return root;
        };
        mxGraphModel.prototype.setRoot = function(root) {
          this.execute(new mxRootChange(this, root));
          return root;
        };
        mxGraphModel.prototype.rootChanged = function(root) {
          var oldRoot = this.root;
          this.root = root;
          this.nextId = 0;
          this.cells = null;
          this.cellAdded(root);
          return oldRoot;
        };
        mxGraphModel.prototype.isRoot = function(cell2) {
          return cell2 != null && this.root == cell2;
        };
        mxGraphModel.prototype.isLayer = function(cell2) {
          return this.isRoot(this.getParent(cell2));
        };
        mxGraphModel.prototype.isAncestor = function(parent, child) {
          while (child != null && child != parent) {
            child = this.getParent(child);
          }
          return child == parent;
        };
        mxGraphModel.prototype.contains = function(cell2) {
          return this.isAncestor(this.root, cell2);
        };
        mxGraphModel.prototype.getParent = function(cell2) {
          return cell2 != null ? cell2.getParent() : null;
        };
        mxGraphModel.prototype.add = function(parent, child, index) {
          if (child != parent && parent != null && child != null) {
            if (index == null) {
              index = this.getChildCount(parent);
            }
            var parentChanged = parent != this.getParent(child);
            this.execute(new mxChildChange(this, parent, child, index));
            if (this.maintainEdgeParent && parentChanged) {
              this.updateEdgeParents(child);
            }
          }
          return child;
        };
        mxGraphModel.prototype.cellAdded = function(cell2) {
          if (cell2 != null) {
            if (cell2.getId() == null && this.createIds) {
              cell2.setId(this.createId(cell2));
            }
            if (cell2.getId() != null) {
              var collision = this.getCell(cell2.getId());
              if (collision != cell2) {
                while (collision != null) {
                  cell2.setId(this.createId(cell2));
                  collision = this.getCell(cell2.getId());
                }
                if (this.cells == null) {
                  this.cells = new Object();
                }
                this.cells[cell2.getId()] = cell2;
              }
            }
            if (mxUtils.isNumeric(cell2.getId())) {
              this.nextId = Math.max(this.nextId, cell2.getId());
            }
            var childCount = this.getChildCount(cell2);
            for (var i = 0; i < childCount; i++) {
              this.cellAdded(this.getChildAt(cell2, i));
            }
          }
        };
        mxGraphModel.prototype.createId = function(cell2) {
          var id = this.nextId;
          this.nextId++;
          return this.prefix + id + this.postfix;
        };
        mxGraphModel.prototype.updateEdgeParents = function(cell2, root) {
          root = root || this.getRoot(cell2);
          var childCount = this.getChildCount(cell2);
          for (var i = 0; i < childCount; i++) {
            var child = this.getChildAt(cell2, i);
            this.updateEdgeParents(child, root);
          }
          var edgeCount = this.getEdgeCount(cell2);
          var edges = [];
          for (var i = 0; i < edgeCount; i++) {
            edges.push(this.getEdgeAt(cell2, i));
          }
          for (var i = 0; i < edges.length; i++) {
            var edge = edges[i];
            if (this.isAncestor(root, edge)) {
              this.updateEdgeParent(edge, root);
            }
          }
        };
        mxGraphModel.prototype.updateEdgeParent = function(edge, root) {
          var source = this.getTerminal(edge, true);
          var target = this.getTerminal(edge, false);
          var cell2 = null;
          while (source != null && !this.isEdge(source) && source.geometry != null && source.geometry.relative) {
            source = this.getParent(source);
          }
          while (target != null && this.ignoreRelativeEdgeParent && !this.isEdge(target) && target.geometry != null && target.geometry.relative) {
            target = this.getParent(target);
          }
          if (this.isAncestor(root, source) && this.isAncestor(root, target)) {
            if (source == target) {
              cell2 = this.getParent(source);
            } else {
              cell2 = this.getNearestCommonAncestor(source, target);
            }
            if (cell2 != null && (this.getParent(cell2) != this.root || this.isAncestor(cell2, edge)) && this.getParent(edge) != cell2) {
              var geo = this.getGeometry(edge);
              if (geo != null) {
                var origin1 = this.getOrigin(this.getParent(edge));
                var origin2 = this.getOrigin(cell2);
                var dx = origin2.x - origin1.x;
                var dy = origin2.y - origin1.y;
                geo = geo.clone();
                geo.translate(-dx, -dy);
                this.setGeometry(edge, geo);
              }
              this.add(cell2, edge, this.getChildCount(cell2));
            }
          }
        };
        mxGraphModel.prototype.getOrigin = function(cell2) {
          var result2 = null;
          if (cell2 != null) {
            result2 = this.getOrigin(this.getParent(cell2));
            if (!this.isEdge(cell2)) {
              var geo = this.getGeometry(cell2);
              if (geo != null) {
                result2.x += geo.x;
                result2.y += geo.y;
              }
            }
          } else {
            result2 = new mxPoint();
          }
          return result2;
        };
        mxGraphModel.prototype.getNearestCommonAncestor = function(cell1, cell2) {
          if (cell1 != null && cell2 != null) {
            var path = mxCellPath.create(cell2);
            if (path != null && path.length > 0) {
              var cell3 = cell1;
              var current = mxCellPath.create(cell3);
              if (path.length < current.length) {
                cell3 = cell2;
                var tmp = current;
                current = path;
                path = tmp;
              }
              while (cell3 != null) {
                var parent = this.getParent(cell3);
                if (path.indexOf(current + mxCellPath.PATH_SEPARATOR) == 0 && parent != null) {
                  return cell3;
                }
                current = mxCellPath.getParentPath(current);
                cell3 = parent;
              }
            }
          }
          return null;
        };
        mxGraphModel.prototype.remove = function(cell2) {
          if (cell2 == this.root) {
            this.setRoot(null);
          } else if (this.getParent(cell2) != null) {
            this.execute(new mxChildChange(this, null, cell2));
          }
          return cell2;
        };
        mxGraphModel.prototype.cellRemoved = function(cell2) {
          if (cell2 != null && this.cells != null) {
            var childCount = this.getChildCount(cell2);
            for (var i = childCount - 1; i >= 0; i--) {
              this.cellRemoved(this.getChildAt(cell2, i));
            }
            if (this.cells != null && cell2.getId() != null) {
              delete this.cells[cell2.getId()];
            }
          }
        };
        mxGraphModel.prototype.parentForCellChanged = function(cell2, parent, index) {
          var previous = this.getParent(cell2);
          if (parent != null) {
            if (parent != previous || previous.getIndex(cell2) != index) {
              parent.insert(cell2, index);
            }
          } else if (previous != null) {
            var oldIndex = previous.getIndex(cell2);
            previous.remove(oldIndex);
          }
          var par = this.contains(parent);
          var pre = this.contains(previous);
          if (par && !pre) {
            this.cellAdded(cell2);
          } else if (pre && !par) {
            this.cellRemoved(cell2);
          }
          return previous;
        };
        mxGraphModel.prototype.getChildCount = function(cell2) {
          return cell2 != null ? cell2.getChildCount() : 0;
        };
        mxGraphModel.prototype.getChildAt = function(cell2, index) {
          return cell2 != null ? cell2.getChildAt(index) : null;
        };
        mxGraphModel.prototype.getChildren = function(cell2) {
          return cell2 != null ? cell2.children : null;
        };
        mxGraphModel.prototype.getChildVertices = function(parent) {
          return this.getChildCells(parent, true, false);
        };
        mxGraphModel.prototype.getChildEdges = function(parent) {
          return this.getChildCells(parent, false, true);
        };
        mxGraphModel.prototype.getChildCells = function(parent, vertices, edges) {
          vertices = vertices != null ? vertices : false;
          edges = edges != null ? edges : false;
          var childCount = this.getChildCount(parent);
          var result2 = [];
          for (var i = 0; i < childCount; i++) {
            var child = this.getChildAt(parent, i);
            if (!edges && !vertices || edges && this.isEdge(child) || vertices && this.isVertex(child)) {
              result2.push(child);
            }
          }
          return result2;
        };
        mxGraphModel.prototype.getTerminal = function(edge, isSource) {
          return edge != null ? edge.getTerminal(isSource) : null;
        };
        mxGraphModel.prototype.setTerminal = function(edge, terminal, isSource) {
          var terminalChanged = terminal != this.getTerminal(edge, isSource);
          this.execute(new mxTerminalChange(this, edge, terminal, isSource));
          if (this.maintainEdgeParent && terminalChanged) {
            this.updateEdgeParent(edge, this.getRoot());
          }
          return terminal;
        };
        mxGraphModel.prototype.setTerminals = function(edge, source, target) {
          this.beginUpdate();
          try {
            this.setTerminal(edge, source, true);
            this.setTerminal(edge, target, false);
          } finally {
            this.endUpdate();
          }
        };
        mxGraphModel.prototype.terminalForCellChanged = function(edge, terminal, isSource) {
          var previous = this.getTerminal(edge, isSource);
          if (terminal != null) {
            terminal.insertEdge(edge, isSource);
          } else if (previous != null) {
            previous.removeEdge(edge, isSource);
          }
          return previous;
        };
        mxGraphModel.prototype.getEdgeCount = function(cell2) {
          return cell2 != null ? cell2.getEdgeCount() : 0;
        };
        mxGraphModel.prototype.getEdgeAt = function(cell2, index) {
          return cell2 != null ? cell2.getEdgeAt(index) : null;
        };
        mxGraphModel.prototype.getDirectedEdgeCount = function(cell2, outgoing, ignoredEdge) {
          var count = 0;
          var edgeCount = this.getEdgeCount(cell2);
          for (var i = 0; i < edgeCount; i++) {
            var edge = this.getEdgeAt(cell2, i);
            if (edge != ignoredEdge && this.getTerminal(edge, outgoing) == cell2) {
              count++;
            }
          }
          return count;
        };
        mxGraphModel.prototype.getConnections = function(cell2) {
          return this.getEdges(cell2, true, true, false);
        };
        mxGraphModel.prototype.getIncomingEdges = function(cell2) {
          return this.getEdges(cell2, true, false, false);
        };
        mxGraphModel.prototype.getOutgoingEdges = function(cell2) {
          return this.getEdges(cell2, false, true, false);
        };
        mxGraphModel.prototype.getEdges = function(cell2, incoming, outgoing, includeLoops) {
          incoming = incoming != null ? incoming : true;
          outgoing = outgoing != null ? outgoing : true;
          includeLoops = includeLoops != null ? includeLoops : true;
          var edgeCount = this.getEdgeCount(cell2);
          var result2 = [];
          for (var i = 0; i < edgeCount; i++) {
            var edge = this.getEdgeAt(cell2, i);
            var source = this.getTerminal(edge, true);
            var target = this.getTerminal(edge, false);
            if (includeLoops && source == target || source != target && (incoming && target == cell2 || outgoing && source == cell2)) {
              result2.push(edge);
            }
          }
          return result2;
        };
        mxGraphModel.prototype.getEdgesBetween = function(source, target, directed) {
          directed = directed != null ? directed : false;
          var tmp1 = this.getEdgeCount(source);
          var tmp2 = this.getEdgeCount(target);
          var terminal = source;
          var edgeCount = tmp1;
          if (tmp2 < tmp1) {
            edgeCount = tmp2;
            terminal = target;
          }
          var result2 = [];
          for (var i = 0; i < edgeCount; i++) {
            var edge = this.getEdgeAt(terminal, i);
            var src = this.getTerminal(edge, true);
            var trg = this.getTerminal(edge, false);
            var directedMatch = src == source && trg == target;
            var oppositeMatch = trg == source && src == target;
            if (directedMatch || !directed && oppositeMatch) {
              result2.push(edge);
            }
          }
          return result2;
        };
        mxGraphModel.prototype.getOpposites = function(edges, terminal, sources, targets) {
          sources = sources != null ? sources : true;
          targets = targets != null ? targets : true;
          var terminals = [];
          if (edges != null) {
            for (var i = 0; i < edges.length; i++) {
              var source = this.getTerminal(edges[i], true);
              var target = this.getTerminal(edges[i], false);
              if (source == terminal && target != null && target != terminal && targets) {
                terminals.push(target);
              } else if (target == terminal && source != null && source != terminal && sources) {
                terminals.push(source);
              }
            }
          }
          return terminals;
        };
        mxGraphModel.prototype.getTopmostCells = function(cells) {
          var dict = new mxDictionary();
          var tmp = [];
          for (var i = 0; i < cells.length; i++) {
            dict.put(cells[i], true);
          }
          for (var i = 0; i < cells.length; i++) {
            var cell2 = cells[i];
            var topmost = true;
            var parent = this.getParent(cell2);
            while (parent != null) {
              if (dict.get(parent)) {
                topmost = false;
                break;
              }
              parent = this.getParent(parent);
            }
            if (topmost) {
              tmp.push(cell2);
            }
          }
          return tmp;
        };
        mxGraphModel.prototype.isVertex = function(cell2) {
          return cell2 != null ? cell2.isVertex() : false;
        };
        mxGraphModel.prototype.isEdge = function(cell2) {
          return cell2 != null ? cell2.isEdge() : false;
        };
        mxGraphModel.prototype.isConnectable = function(cell2) {
          return cell2 != null ? cell2.isConnectable() : false;
        };
        mxGraphModel.prototype.getValue = function(cell2) {
          return cell2 != null ? cell2.getValue() : null;
        };
        mxGraphModel.prototype.setValue = function(cell2, value) {
          this.execute(new mxValueChange(this, cell2, value));
          return value;
        };
        mxGraphModel.prototype.valueForCellChanged = function(cell2, value) {
          return cell2.valueChanged(value);
        };
        mxGraphModel.prototype.getGeometry = function(cell2) {
          return cell2 != null ? cell2.getGeometry() : null;
        };
        mxGraphModel.prototype.setGeometry = function(cell2, geometry) {
          if (geometry != this.getGeometry(cell2)) {
            this.execute(new mxGeometryChange(this, cell2, geometry));
          }
          return geometry;
        };
        mxGraphModel.prototype.geometryForCellChanged = function(cell2, geometry) {
          var previous = this.getGeometry(cell2);
          cell2.setGeometry(geometry);
          return previous;
        };
        mxGraphModel.prototype.getStyle = function(cell2) {
          return cell2 != null ? cell2.getStyle() : null;
        };
        mxGraphModel.prototype.setStyle = function(cell2, style) {
          if (style != this.getStyle(cell2)) {
            this.execute(new mxStyleChange(this, cell2, style));
          }
          return style;
        };
        mxGraphModel.prototype.styleForCellChanged = function(cell2, style) {
          var previous = this.getStyle(cell2);
          cell2.setStyle(style);
          return previous;
        };
        mxGraphModel.prototype.isCollapsed = function(cell2) {
          return cell2 != null ? cell2.isCollapsed() : false;
        };
        mxGraphModel.prototype.setCollapsed = function(cell2, collapsed) {
          if (collapsed != this.isCollapsed(cell2)) {
            this.execute(new mxCollapseChange(this, cell2, collapsed));
          }
          return collapsed;
        };
        mxGraphModel.prototype.collapsedStateForCellChanged = function(cell2, collapsed) {
          var previous = this.isCollapsed(cell2);
          cell2.setCollapsed(collapsed);
          return previous;
        };
        mxGraphModel.prototype.isVisible = function(cell2) {
          return cell2 != null ? cell2.isVisible() : false;
        };
        mxGraphModel.prototype.setVisible = function(cell2, visible) {
          if (visible != this.isVisible(cell2)) {
            this.execute(new mxVisibleChange(this, cell2, visible));
          }
          return visible;
        };
        mxGraphModel.prototype.visibleStateForCellChanged = function(cell2, visible) {
          var previous = this.isVisible(cell2);
          cell2.setVisible(visible);
          return previous;
        };
        mxGraphModel.prototype.execute = function(change) {
          change.execute();
          this.beginUpdate();
          this.currentEdit.add(change);
          this.fireEvent(new mxEventObject(mxEvent.EXECUTE, "change", change));
          this.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", change));
          this.endUpdate();
        };
        mxGraphModel.prototype.beginUpdate = function() {
          this.updateLevel++;
          this.fireEvent(new mxEventObject(mxEvent.BEGIN_UPDATE));
          if (this.updateLevel == 1) {
            this.fireEvent(new mxEventObject(mxEvent.START_EDIT));
          }
        };
        mxGraphModel.prototype.endUpdate = function() {
          this.updateLevel--;
          if (this.updateLevel == 0) {
            this.fireEvent(new mxEventObject(mxEvent.END_EDIT));
          }
          if (!this.endingUpdate) {
            this.endingUpdate = this.updateLevel == 0;
            this.fireEvent(new mxEventObject(mxEvent.END_UPDATE, "edit", this.currentEdit));
            try {
              if (this.endingUpdate && !this.currentEdit.isEmpty()) {
                this.fireEvent(new mxEventObject(mxEvent.BEFORE_UNDO, "edit", this.currentEdit));
                var tmp = this.currentEdit;
                this.currentEdit = this.createUndoableEdit();
                tmp.notify();
                this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", tmp));
              }
            } finally {
              this.endingUpdate = false;
            }
          }
        };
        mxGraphModel.prototype.createUndoableEdit = function(significant) {
          var edit = new mxUndoableEdit(this, significant != null ? significant : true);
          edit.notify = function() {
            edit.source.fireEvent(new mxEventObject(
              mxEvent.CHANGE,
              "edit",
              edit,
              "changes",
              edit.changes
            ));
            edit.source.fireEvent(new mxEventObject(
              mxEvent.NOTIFY,
              "edit",
              edit,
              "changes",
              edit.changes
            ));
          };
          return edit;
        };
        mxGraphModel.prototype.mergeChildren = function(from, to, cloneAllEdges) {
          cloneAllEdges = cloneAllEdges != null ? cloneAllEdges : true;
          this.beginUpdate();
          try {
            var mapping = new Object();
            this.mergeChildrenImpl(from, to, cloneAllEdges, mapping);
            for (var key in mapping) {
              var cell2 = mapping[key];
              var terminal = this.getTerminal(cell2, true);
              if (terminal != null) {
                terminal = mapping[mxCellPath.create(terminal)];
                this.setTerminal(cell2, terminal, true);
              }
              terminal = this.getTerminal(cell2, false);
              if (terminal != null) {
                terminal = mapping[mxCellPath.create(terminal)];
                this.setTerminal(cell2, terminal, false);
              }
            }
          } finally {
            this.endUpdate();
          }
        };
        mxGraphModel.prototype.mergeChildrenImpl = function(from, to, cloneAllEdges, mapping) {
          this.beginUpdate();
          try {
            var childCount = from.getChildCount();
            for (var i = 0; i < childCount; i++) {
              var cell2 = from.getChildAt(i);
              if (typeof cell2.getId == "function") {
                var id = cell2.getId();
                var target = id != null && (!this.isEdge(cell2) || !cloneAllEdges) ? this.getCell(id) : null;
                if (target == null) {
                  var clone = cell2.clone();
                  clone.setId(id);
                  clone.setTerminal(cell2.getTerminal(true), true);
                  clone.setTerminal(cell2.getTerminal(false), false);
                  target = to.insert(clone);
                  this.cellAdded(target);
                }
                mapping[mxCellPath.create(cell2)] = target;
                this.mergeChildrenImpl(cell2, target, cloneAllEdges, mapping);
              }
            }
          } finally {
            this.endUpdate();
          }
        };
        mxGraphModel.prototype.getParents = function(cells) {
          var parents = [];
          if (cells != null) {
            var dict = new mxDictionary();
            for (var i = 0; i < cells.length; i++) {
              var parent = this.getParent(cells[i]);
              if (parent != null && !dict.get(parent)) {
                dict.put(parent, true);
                parents.push(parent);
              }
            }
          }
          return parents;
        };
        mxGraphModel.prototype.cloneCell = function(cell2, includeChildren) {
          if (cell2 != null) {
            return this.cloneCells([cell2], includeChildren)[0];
          }
          return null;
        };
        mxGraphModel.prototype.cloneCells = function(cells, includeChildren, mapping) {
          includeChildren = includeChildren != null ? includeChildren : true;
          mapping = mapping != null ? mapping : new Object();
          var clones = [];
          for (var i = 0; i < cells.length; i++) {
            if (cells[i] != null) {
              clones.push(this.cloneCellImpl(cells[i], mapping, includeChildren));
            } else {
              clones.push(null);
            }
          }
          for (var i = 0; i < clones.length; i++) {
            if (clones[i] != null) {
              this.restoreClone(clones[i], cells[i], mapping);
            }
          }
          return clones;
        };
        mxGraphModel.prototype.cloneCellImpl = function(cell2, mapping, includeChildren) {
          var ident = mxObjectIdentity.get(cell2);
          var clone = mapping[ident];
          if (clone == null) {
            clone = this.cellCloned(cell2);
            mapping[ident] = clone;
            if (includeChildren) {
              var childCount = this.getChildCount(cell2);
              for (var i = 0; i < childCount; i++) {
                var cloneChild = this.cloneCellImpl(
                  this.getChildAt(cell2, i),
                  mapping,
                  true
                );
                clone.insert(cloneChild);
              }
            }
          }
          return clone;
        };
        mxGraphModel.prototype.cellCloned = function(cell2) {
          return cell2.clone();
        };
        mxGraphModel.prototype.restoreClone = function(clone, cell2, mapping) {
          var source = this.getTerminal(cell2, true);
          if (source != null) {
            var tmp = mapping[mxObjectIdentity.get(source)];
            if (tmp != null) {
              tmp.insertEdge(clone, true);
            }
          }
          var target = this.getTerminal(cell2, false);
          if (target != null) {
            var tmp = mapping[mxObjectIdentity.get(target)];
            if (tmp != null) {
              tmp.insertEdge(clone, false);
            }
          }
          var childCount = this.getChildCount(clone);
          for (var i = 0; i < childCount; i++) {
            this.restoreClone(
              this.getChildAt(clone, i),
              this.getChildAt(cell2, i),
              mapping
            );
          }
        };
        function mxRootChange(model, root) {
          this.model = model;
          this.root = root;
          this.previous = root;
        }
        ;
        mxRootChange.prototype.execute = function() {
          this.root = this.previous;
          this.previous = this.model.rootChanged(this.previous);
        };
        function mxChildChange(model, parent, child, index) {
          this.model = model;
          this.parent = parent;
          this.previous = parent;
          this.child = child;
          this.index = index;
          this.previousIndex = index;
        }
        ;
        mxChildChange.prototype.execute = function() {
          if (this.child != null) {
            var tmp = this.model.getParent(this.child);
            var tmp2 = tmp != null ? tmp.getIndex(this.child) : 0;
            if (this.previous == null) {
              this.connect(this.child, false);
            }
            tmp = this.model.parentForCellChanged(
              this.child,
              this.previous,
              this.previousIndex
            );
            if (this.previous != null) {
              this.connect(this.child, true);
            }
            this.parent = this.previous;
            this.previous = tmp;
            this.index = this.previousIndex;
            this.previousIndex = tmp2;
          }
        };
        mxChildChange.prototype.connect = function(cell2, isConnect) {
          isConnect = isConnect != null ? isConnect : true;
          var source = cell2.getTerminal(true);
          var target = cell2.getTerminal(false);
          if (source != null) {
            if (isConnect) {
              this.model.terminalForCellChanged(cell2, source, true);
            } else {
              this.model.terminalForCellChanged(cell2, null, true);
            }
          }
          if (target != null) {
            if (isConnect) {
              this.model.terminalForCellChanged(cell2, target, false);
            } else {
              this.model.terminalForCellChanged(cell2, null, false);
            }
          }
          cell2.setTerminal(source, true);
          cell2.setTerminal(target, false);
          var childCount = this.model.getChildCount(cell2);
          for (var i = 0; i < childCount; i++) {
            this.connect(this.model.getChildAt(cell2, i), isConnect);
          }
        };
        function mxTerminalChange(model, cell2, terminal, source) {
          this.model = model;
          this.cell = cell2;
          this.terminal = terminal;
          this.previous = terminal;
          this.source = source;
        }
        ;
        mxTerminalChange.prototype.execute = function() {
          if (this.cell != null) {
            this.terminal = this.previous;
            this.previous = this.model.terminalForCellChanged(
              this.cell,
              this.previous,
              this.source
            );
          }
        };
        function mxValueChange(model, cell2, value) {
          this.model = model;
          this.cell = cell2;
          this.value = value;
          this.previous = value;
        }
        ;
        mxValueChange.prototype.execute = function() {
          if (this.cell != null) {
            this.value = this.previous;
            this.previous = this.model.valueForCellChanged(
              this.cell,
              this.previous
            );
          }
        };
        function mxStyleChange(model, cell2, style) {
          this.model = model;
          this.cell = cell2;
          this.style = style;
          this.previous = style;
        }
        ;
        mxStyleChange.prototype.execute = function() {
          if (this.cell != null) {
            this.style = this.previous;
            this.previous = this.model.styleForCellChanged(
              this.cell,
              this.previous
            );
          }
        };
        function mxGeometryChange(model, cell2, geometry) {
          this.model = model;
          this.cell = cell2;
          this.geometry = geometry;
          this.previous = geometry;
        }
        ;
        mxGeometryChange.prototype.execute = function() {
          if (this.cell != null) {
            this.geometry = this.previous;
            this.previous = this.model.geometryForCellChanged(
              this.cell,
              this.previous
            );
          }
        };
        function mxCollapseChange(model, cell2, collapsed) {
          this.model = model;
          this.cell = cell2;
          this.collapsed = collapsed;
          this.previous = collapsed;
        }
        ;
        mxCollapseChange.prototype.execute = function() {
          if (this.cell != null) {
            this.collapsed = this.previous;
            this.previous = this.model.collapsedStateForCellChanged(
              this.cell,
              this.previous
            );
          }
        };
        function mxVisibleChange(model, cell2, visible) {
          this.model = model;
          this.cell = cell2;
          this.visible = visible;
          this.previous = visible;
        }
        ;
        mxVisibleChange.prototype.execute = function() {
          if (this.cell != null) {
            this.visible = this.previous;
            this.previous = this.model.visibleStateForCellChanged(
              this.cell,
              this.previous
            );
          }
        };
        function mxCellAttributeChange(cell2, attribute, value) {
          this.cell = cell2;
          this.attribute = attribute;
          this.value = value;
          this.previous = value;
        }
        ;
        mxCellAttributeChange.prototype.execute = function() {
          if (this.cell != null) {
            var tmp = this.cell.getAttribute(this.attribute);
            if (this.previous == null) {
              this.cell.value.removeAttribute(this.attribute);
            } else {
              this.cell.setAttribute(this.attribute, this.previous);
            }
            this.previous = tmp;
          }
        };
        __mxOutput.mxGraphModel = typeof mxGraphModel !== "undefined" ? mxGraphModel : void 0;
        function mxCell(value, geometry, style) {
          this.value = value;
          this.setGeometry(geometry);
          this.setStyle(style);
          if (this.onInit != null) {
            this.onInit();
          }
        }
        ;
        mxCell.prototype.id = null;
        mxCell.prototype.value = null;
        mxCell.prototype.geometry = null;
        mxCell.prototype.style = null;
        mxCell.prototype.vertex = false;
        mxCell.prototype.edge = false;
        mxCell.prototype.connectable = true;
        mxCell.prototype.visible = true;
        mxCell.prototype.collapsed = false;
        mxCell.prototype.parent = null;
        mxCell.prototype.source = null;
        mxCell.prototype.target = null;
        mxCell.prototype.children = null;
        mxCell.prototype.edges = null;
        mxCell.prototype.mxTransient = [
          "id",
          "value",
          "parent",
          "source",
          "target",
          "children",
          "edges"
        ];
        mxCell.prototype.getId = function() {
          return this.id;
        };
        mxCell.prototype.setId = function(id) {
          this.id = id;
        };
        mxCell.prototype.getValue = function() {
          return this.value;
        };
        mxCell.prototype.setValue = function(value) {
          this.value = value;
        };
        mxCell.prototype.valueChanged = function(newValue) {
          var previous = this.getValue();
          this.setValue(newValue);
          return previous;
        };
        mxCell.prototype.getGeometry = function() {
          return this.geometry;
        };
        mxCell.prototype.setGeometry = function(geometry) {
          this.geometry = geometry;
        };
        mxCell.prototype.getStyle = function() {
          return this.style;
        };
        mxCell.prototype.setStyle = function(style) {
          this.style = style;
        };
        mxCell.prototype.isVertex = function() {
          return this.vertex != 0;
        };
        mxCell.prototype.setVertex = function(vertex) {
          this.vertex = vertex;
        };
        mxCell.prototype.isEdge = function() {
          return this.edge != 0;
        };
        mxCell.prototype.setEdge = function(edge) {
          this.edge = edge;
        };
        mxCell.prototype.isConnectable = function() {
          return this.connectable != 0;
        };
        mxCell.prototype.setConnectable = function(connectable) {
          this.connectable = connectable;
        };
        mxCell.prototype.isVisible = function() {
          return this.visible != 0;
        };
        mxCell.prototype.setVisible = function(visible) {
          this.visible = visible;
        };
        mxCell.prototype.isCollapsed = function() {
          return this.collapsed != 0;
        };
        mxCell.prototype.setCollapsed = function(collapsed) {
          this.collapsed = collapsed;
        };
        mxCell.prototype.getParent = function() {
          return this.parent;
        };
        mxCell.prototype.setParent = function(parent) {
          this.parent = parent;
        };
        mxCell.prototype.getTerminal = function(source) {
          return source ? this.source : this.target;
        };
        mxCell.prototype.setTerminal = function(terminal, isSource) {
          if (isSource) {
            this.source = terminal;
          } else {
            this.target = terminal;
          }
          return terminal;
        };
        mxCell.prototype.getChildCount = function() {
          return this.children == null ? 0 : this.children.length;
        };
        mxCell.prototype.getIndex = function(child) {
          return mxUtils.indexOf(this.children, child);
        };
        mxCell.prototype.getChildAt = function(index) {
          return this.children == null ? null : this.children[index];
        };
        mxCell.prototype.insert = function(child, index) {
          if (child != null) {
            if (index == null) {
              index = this.getChildCount();
              if (child.getParent() == this) {
                index--;
              }
            }
            child.removeFromParent();
            child.setParent(this);
            if (this.children == null) {
              this.children = [];
              this.children.push(child);
            } else {
              this.children.splice(index, 0, child);
            }
          }
          return child;
        };
        mxCell.prototype.remove = function(index) {
          var child = null;
          if (this.children != null && index >= 0) {
            child = this.getChildAt(index);
            if (child != null) {
              this.children.splice(index, 1);
              child.setParent(null);
            }
          }
          return child;
        };
        mxCell.prototype.removeFromParent = function() {
          if (this.parent != null) {
            var index = this.parent.getIndex(this);
            this.parent.remove(index);
          }
        };
        mxCell.prototype.getEdgeCount = function() {
          return this.edges == null ? 0 : this.edges.length;
        };
        mxCell.prototype.getEdgeIndex = function(edge) {
          return mxUtils.indexOf(this.edges, edge);
        };
        mxCell.prototype.getEdgeAt = function(index) {
          return this.edges == null ? null : this.edges[index];
        };
        mxCell.prototype.insertEdge = function(edge, isOutgoing) {
          if (edge != null) {
            edge.removeFromTerminal(isOutgoing);
            edge.setTerminal(this, isOutgoing);
            if (this.edges == null || edge.getTerminal(!isOutgoing) != this || mxUtils.indexOf(this.edges, edge) < 0) {
              if (this.edges == null) {
                this.edges = [];
              }
              this.edges.push(edge);
            }
          }
          return edge;
        };
        mxCell.prototype.removeEdge = function(edge, isOutgoing) {
          if (edge != null) {
            if (edge.getTerminal(!isOutgoing) != this && this.edges != null) {
              var index = this.getEdgeIndex(edge);
              if (index >= 0) {
                this.edges.splice(index, 1);
              }
            }
            edge.setTerminal(null, isOutgoing);
          }
          return edge;
        };
        mxCell.prototype.removeFromTerminal = function(isSource) {
          var terminal = this.getTerminal(isSource);
          if (terminal != null) {
            terminal.removeEdge(this, isSource);
          }
        };
        mxCell.prototype.hasAttribute = function(name2) {
          var userObject = this.getValue();
          return userObject != null && userObject.nodeType == mxConstants.NODETYPE_ELEMENT && userObject.hasAttribute ? userObject.hasAttribute(name2) : userObject.getAttribute(name2) != null;
        };
        mxCell.prototype.getAttribute = function(name2, defaultValue) {
          var userObject = this.getValue();
          var val = userObject != null && userObject.nodeType == mxConstants.NODETYPE_ELEMENT ? userObject.getAttribute(name2) : null;
          return val != null ? val : defaultValue;
        };
        mxCell.prototype.setAttribute = function(name2, value) {
          var userObject = this.getValue();
          if (userObject != null && userObject.nodeType == mxConstants.NODETYPE_ELEMENT) {
            userObject.setAttribute(name2, value);
          }
        };
        mxCell.prototype.clone = function() {
          var clone = mxUtils.clone(this, this.mxTransient);
          clone.setValue(this.cloneValue());
          return clone;
        };
        mxCell.prototype.cloneValue = function() {
          var value = this.getValue();
          if (value != null) {
            if (typeof value.clone == "function") {
              value = value.clone();
            } else if (!isNaN(value.nodeType)) {
              value = value.cloneNode(true);
            }
          }
          return value;
        };
        __mxOutput.mxCell = typeof mxCell !== "undefined" ? mxCell : void 0;
        function mxGeometry(x, y, width, height) {
          mxRectangle.call(this, x, y, width, height);
        }
        ;
        mxGeometry.prototype = new mxRectangle();
        mxGeometry.prototype.constructor = mxGeometry;
        mxGeometry.prototype.TRANSLATE_CONTROL_POINTS = true;
        mxGeometry.prototype.alternateBounds = null;
        mxGeometry.prototype.sourcePoint = null;
        mxGeometry.prototype.targetPoint = null;
        mxGeometry.prototype.points = null;
        mxGeometry.prototype.offset = null;
        mxGeometry.prototype.relative = false;
        mxGeometry.prototype.swap = function() {
          if (this.alternateBounds != null) {
            var old = new mxRectangle(
              this.x,
              this.y,
              this.width,
              this.height
            );
            this.x = this.alternateBounds.x;
            this.y = this.alternateBounds.y;
            this.width = this.alternateBounds.width;
            this.height = this.alternateBounds.height;
            this.alternateBounds = old;
          }
        };
        mxGeometry.prototype.getTerminalPoint = function(isSource) {
          return isSource ? this.sourcePoint : this.targetPoint;
        };
        mxGeometry.prototype.setTerminalPoint = function(point, isSource) {
          if (isSource) {
            this.sourcePoint = point;
          } else {
            this.targetPoint = point;
          }
          return point;
        };
        mxGeometry.prototype.rotate = function(angle, cx) {
          var rad = mxUtils.toRadians(angle);
          var cos = Math.cos(rad);
          var sin = Math.sin(rad);
          if (!this.relative) {
            var ct = new mxPoint(this.getCenterX(), this.getCenterY());
            var pt = mxUtils.getRotatedPoint(ct, cos, sin, cx);
            this.x = Math.round(pt.x - this.width / 2);
            this.y = Math.round(pt.y - this.height / 2);
          }
          if (this.sourcePoint != null) {
            var pt = mxUtils.getRotatedPoint(this.sourcePoint, cos, sin, cx);
            this.sourcePoint.x = Math.round(pt.x);
            this.sourcePoint.y = Math.round(pt.y);
          }
          if (this.targetPoint != null) {
            var pt = mxUtils.getRotatedPoint(this.targetPoint, cos, sin, cx);
            this.targetPoint.x = Math.round(pt.x);
            this.targetPoint.y = Math.round(pt.y);
          }
          if (this.points != null) {
            for (var i = 0; i < this.points.length; i++) {
              if (this.points[i] != null) {
                var pt = mxUtils.getRotatedPoint(this.points[i], cos, sin, cx);
                this.points[i].x = Math.round(pt.x);
                this.points[i].y = Math.round(pt.y);
              }
            }
          }
        };
        mxGeometry.prototype.translate = function(dx, dy) {
          dx = parseFloat(dx);
          dy = parseFloat(dy);
          if (!this.relative) {
            this.x = parseFloat(this.x) + dx;
            this.y = parseFloat(this.y) + dy;
          }
          if (this.sourcePoint != null) {
            this.sourcePoint.x = parseFloat(this.sourcePoint.x) + dx;
            this.sourcePoint.y = parseFloat(this.sourcePoint.y) + dy;
          }
          if (this.targetPoint != null) {
            this.targetPoint.x = parseFloat(this.targetPoint.x) + dx;
            this.targetPoint.y = parseFloat(this.targetPoint.y) + dy;
          }
          if (this.TRANSLATE_CONTROL_POINTS && this.points != null) {
            for (var i = 0; i < this.points.length; i++) {
              if (this.points[i] != null) {
                this.points[i].x = parseFloat(this.points[i].x) + dx;
                this.points[i].y = parseFloat(this.points[i].y) + dy;
              }
            }
          }
        };
        mxGeometry.prototype.scale = function(sx, sy, fixedAspect) {
          sx = parseFloat(sx);
          sy = parseFloat(sy);
          if (this.sourcePoint != null) {
            this.sourcePoint.x = parseFloat(this.sourcePoint.x) * sx;
            this.sourcePoint.y = parseFloat(this.sourcePoint.y) * sy;
          }
          if (this.targetPoint != null) {
            this.targetPoint.x = parseFloat(this.targetPoint.x) * sx;
            this.targetPoint.y = parseFloat(this.targetPoint.y) * sy;
          }
          if (this.points != null) {
            for (var i = 0; i < this.points.length; i++) {
              if (this.points[i] != null) {
                this.points[i].x = parseFloat(this.points[i].x) * sx;
                this.points[i].y = parseFloat(this.points[i].y) * sy;
              }
            }
          }
          if (!this.relative) {
            this.x = parseFloat(this.x) * sx;
            this.y = parseFloat(this.y) * sy;
            if (fixedAspect) {
              sy = sx = Math.min(sx, sy);
            }
            this.width = parseFloat(this.width) * sx;
            this.height = parseFloat(this.height) * sy;
          }
        };
        mxGeometry.prototype.equals = function(obj) {
          return mxRectangle.prototype.equals.apply(this, arguments) && this.relative == obj.relative && (this.sourcePoint == null && obj.sourcePoint == null || this.sourcePoint != null && this.sourcePoint.equals(obj.sourcePoint)) && (this.targetPoint == null && obj.targetPoint == null || this.targetPoint != null && this.targetPoint.equals(obj.targetPoint)) && (this.points == null && obj.points == null || this.points != null && mxUtils.equalPoints(this.points, obj.points)) && (this.alternateBounds == null && obj.alternateBounds == null || this.alternateBounds != null && this.alternateBounds.equals(obj.alternateBounds)) && (this.offset == null && obj.offset == null || this.offset != null && this.offset.equals(obj.offset));
        };
        __mxOutput.mxGeometry = typeof mxGeometry !== "undefined" ? mxGeometry : void 0;
        var mxCellPath = {
          /**
           * Class: mxCellPath
           * 
           * Implements a mechanism for temporary cell Ids.
           * 
           * Variable: PATH_SEPARATOR
           * 
           * Defines the separator between the path components. Default is ".".
           */
          PATH_SEPARATOR: ".",
          /**
           * Function: create
           * 
           * Creates the cell path for the given cell. The cell path is a
           * concatenation of the indices of all ancestors on the (finite) path to
           * the root, eg. "0.0.0.1".
           * 
           * Parameters:
           * 
           * cell - Cell whose path should be returned.
           */
          create: function(cell2) {
            var result2 = "";
            if (cell2 != null) {
              var parent = cell2.getParent();
              while (parent != null) {
                var index = parent.getIndex(cell2);
                result2 = index + mxCellPath.PATH_SEPARATOR + result2;
                cell2 = parent;
                parent = cell2.getParent();
              }
            }
            var n = result2.length;
            if (n > 1) {
              result2 = result2.substring(0, n - 1);
            }
            return result2;
          },
          /**
           * Function: getParentPath
           * 
           * Returns the path for the parent of the cell represented by the given
           * path. Returns null if the given path has no parent.
           * 
           * Parameters:
           * 
           * path - Path whose parent path should be returned.
           */
          getParentPath: function(path) {
            if (path != null) {
              var index = path.lastIndexOf(mxCellPath.PATH_SEPARATOR);
              if (index >= 0) {
                return path.substring(0, index);
              } else if (path.length > 0) {
                return "";
              }
            }
            return null;
          },
          /**
           * Function: resolve
           * 
           * Returns the cell for the specified cell path using the given root as the
           * root of the path.
           * 
           * Parameters:
           * 
           * root - Root cell of the path to be resolved.
           * path - String that defines the path.
           */
          resolve: function(root, path) {
            var parent = root;
            if (path != null) {
              var tokens = path.split(mxCellPath.PATH_SEPARATOR);
              for (var i = 0; i < tokens.length; i++) {
                parent = parent.getChildAt(parseInt(tokens[i]));
              }
            }
            return parent;
          },
          /**
           * Function: compare
           * 
           * Compares the given cell paths and returns -1 if p1 is smaller, 0 if
           * p1 is equal and 1 if p1 is greater than p2.
           */
          compare: function(p1, p2) {
            var min = Math.min(p1.length, p2.length);
            var comp = 0;
            for (var i = 0; i < min; i++) {
              if (p1[i] != p2[i]) {
                if (p1[i].length == 0 || p2[i].length == 0) {
                  comp = p1[i] == p2[i] ? 0 : p1[i] > p2[i] ? 1 : -1;
                } else {
                  var t1 = parseInt(p1[i]);
                  var t2 = parseInt(p2[i]);
                  comp = t1 == t2 ? 0 : t1 > t2 ? 1 : -1;
                }
                break;
              }
            }
            if (comp == 0) {
              var t1 = p1.length;
              var t2 = p2.length;
              if (t1 != t2) {
                comp = t1 > t2 ? 1 : -1;
              }
            }
            return comp;
          }
        };
        __mxOutput.mxCellPath = typeof mxCellPath !== "undefined" ? mxCellPath : void 0;
        var mxPerimeter = {
          /**
           * Class: mxPerimeter
           * 
           * Provides various perimeter functions to be used in a style
           * as the value of <mxConstants.STYLE_PERIMETER>. Perimeters for
           * rectangle, circle, rhombus and triangle are available.
           *
           * Example:
           * 
           * (code)
           * <add as="perimeter">mxPerimeter.RectanglePerimeter</add>
           * (end)
           * 
           * Or programmatically:
           * 
           * (code)
           * style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;
           * (end)
           * 
           * When adding new perimeter functions, it is recommended to use the 
           * mxPerimeter-namespace as follows:
           * 
           * (code)
           * mxPerimeter.CustomPerimeter = function (bounds, vertex, next, orthogonal)
           * {
           *   var x = 0; // Calculate x-coordinate
           *   var y = 0; // Calculate y-coordainte
           *   
           *   return new mxPoint(x, y);
           * }
           * (end)
           * 
           * The new perimeter should then be registered in the <mxStyleRegistry> as follows:
           * (code)
           * mxStyleRegistry.putValue('customPerimeter', mxPerimeter.CustomPerimeter);
           * (end)
           * 
           * The custom perimeter above can now be used in a specific vertex as follows:
           * 
           * (code)
           * model.setStyle(vertex, 'perimeter=customPerimeter');
           * (end)
           * 
           * Note that the key of the <mxStyleRegistry> entry for the function should
           * be used in string values, unless <mxGraphView.allowEval> is true, in
           * which case you can also use mxPerimeter.CustomPerimeter for the value in
           * the cell style above.
           * 
           * Or it can be used for all vertices in the graph as follows:
           * 
           * (code)
           * var style = graph.getStylesheet().getDefaultVertexStyle();
           * style[mxConstants.STYLE_PERIMETER] = mxPerimeter.CustomPerimeter;
           * (end)
           * 
           * Note that the object can be used directly when programmatically setting
           * the value, but the key in the <mxStyleRegistry> should be used when
           * setting the value via a key, value pair in a cell style.
           * 
           * The parameters are explained in <RectanglePerimeter>.
           * 
           * Function: RectanglePerimeter
           * 
           * Describes a rectangular perimeter for the given bounds.
           *
           * Parameters:
           * 
           * bounds - <mxRectangle> that represents the absolute bounds of the
           * vertex.
           * vertex - <mxCellState> that represents the vertex.
           * next - <mxPoint> that represents the nearest neighbour point on the
           * given edge.
           * orthogonal - Boolean that specifies if the orthogonal projection onto
           * the perimeter should be returned. If this is false then the intersection
           * of the perimeter and the line between the next and the center point is
           * returned.
           */
          RectanglePerimeter: function(bounds, vertex, next, orthogonal) {
            var cx = bounds.getCenterX();
            var cy = bounds.getCenterY();
            var dx = next.x - cx;
            var dy = next.y - cy;
            var alpha = Math.atan2(dy, dx);
            var p = new mxPoint(0, 0);
            var pi = Math.PI;
            var pi2 = Math.PI / 2;
            var beta = pi2 - alpha;
            var t = Math.atan2(bounds.height, bounds.width);
            if (alpha < -pi + t || alpha > pi - t) {
              p.x = bounds.x;
              p.y = cy - bounds.width * Math.tan(alpha) / 2;
            } else if (alpha < -t) {
              p.y = bounds.y;
              p.x = cx - bounds.height * Math.tan(beta) / 2;
            } else if (alpha < t) {
              p.x = bounds.x + bounds.width;
              p.y = cy + bounds.width * Math.tan(alpha) / 2;
            } else {
              p.y = bounds.y + bounds.height;
              p.x = cx + bounds.height * Math.tan(beta) / 2;
            }
            if (orthogonal) {
              if (next.x >= bounds.x && next.x <= bounds.x + bounds.width) {
                p.x = next.x;
              } else if (next.y >= bounds.y && next.y <= bounds.y + bounds.height) {
                p.y = next.y;
              }
              if (next.x < bounds.x) {
                p.x = bounds.x;
              } else if (next.x > bounds.x + bounds.width) {
                p.x = bounds.x + bounds.width;
              }
              if (next.y < bounds.y) {
                p.y = bounds.y;
              } else if (next.y > bounds.y + bounds.height) {
                p.y = bounds.y + bounds.height;
              }
            }
            return p;
          },
          /**
           * Function: EllipsePerimeter
           * 
           * Describes an elliptic perimeter. See <RectanglePerimeter>
           * for a description of the parameters.
           */
          EllipsePerimeter: function(bounds, vertex, next, orthogonal) {
            var x = bounds.x;
            var y = bounds.y;
            var a = bounds.width / 2;
            var b = bounds.height / 2;
            var cx = x + a;
            var cy = y + b;
            var px2 = next.x;
            var py = next.y;
            var dx = parseInt(px2 - cx);
            var dy = parseInt(py - cy);
            if (dx == 0 && dy != 0) {
              return new mxPoint(cx, cy + b * dy / Math.abs(dy));
            } else if (dx == 0 && dy == 0) {
              return new mxPoint(px2, py);
            }
            if (orthogonal) {
              if (py >= y && py <= y + bounds.height) {
                var ty = py - cy;
                var tx = Math.sqrt(a * a * (1 - ty * ty / (b * b))) || 0;
                if (px2 <= x) {
                  tx = -tx;
                }
                return new mxPoint(cx + tx, py);
              }
              if (px2 >= x && px2 <= x + bounds.width) {
                var tx = px2 - cx;
                var ty = Math.sqrt(b * b * (1 - tx * tx / (a * a))) || 0;
                if (py <= y) {
                  ty = -ty;
                }
                return new mxPoint(px2, cy + ty);
              }
            }
            var d = dy / dx;
            var h2 = cy - d * cx;
            var e = a * a * d * d + b * b;
            var f = -2 * cx * e;
            var g = a * a * d * d * cx * cx + b * b * cx * cx - a * a * b * b;
            var det = Math.sqrt(f * f - 4 * e * g);
            var xout1 = (-f + det) / (2 * e);
            var xout2 = (-f - det) / (2 * e);
            var yout1 = d * xout1 + h2;
            var yout2 = d * xout2 + h2;
            var dist1 = Math.sqrt(Math.pow(xout1 - px2, 2) + Math.pow(yout1 - py, 2));
            var dist2 = Math.sqrt(Math.pow(xout2 - px2, 2) + Math.pow(yout2 - py, 2));
            var xout = 0;
            var yout = 0;
            if (dist1 < dist2) {
              xout = xout1;
              yout = yout1;
            } else {
              xout = xout2;
              yout = yout2;
            }
            return new mxPoint(xout, yout);
          },
          /**
           * Function: RhombusPerimeter
           * 
           * Describes a rhombus (aka diamond) perimeter. See <RectanglePerimeter>
           * for a description of the parameters.
           */
          RhombusPerimeter: function(bounds, vertex, next, orthogonal) {
            var x = bounds.x;
            var y = bounds.y;
            var w2 = bounds.width;
            var h2 = bounds.height;
            var cx = x + w2 / 2;
            var cy = y + h2 / 2;
            var px2 = next.x;
            var py = next.y;
            if (cx == px2) {
              if (cy > py) {
                return new mxPoint(cx, y);
              } else {
                return new mxPoint(cx, y + h2);
              }
            } else if (cy == py) {
              if (cx > px2) {
                return new mxPoint(x, cy);
              } else {
                return new mxPoint(x + w2, cy);
              }
            }
            var tx = cx;
            var ty = cy;
            if (orthogonal) {
              if (px2 >= x && px2 <= x + w2) {
                tx = px2;
              } else if (py >= y && py <= y + h2) {
                ty = py;
              }
            }
            if (px2 < cx) {
              if (py < cy) {
                return mxUtils.intersection(px2, py, tx, ty, cx, y, x, cy);
              } else {
                return mxUtils.intersection(px2, py, tx, ty, cx, y + h2, x, cy);
              }
            } else if (py < cy) {
              return mxUtils.intersection(px2, py, tx, ty, cx, y, x + w2, cy);
            } else {
              return mxUtils.intersection(px2, py, tx, ty, cx, y + h2, x + w2, cy);
            }
          },
          /**
           * Function: TrianglePerimeter
           * 
           * Describes a triangle perimeter. See <RectanglePerimeter>
           * for a description of the parameters.
           */
          TrianglePerimeter: function(bounds, vertex, next, orthogonal) {
            var direction = vertex != null ? vertex.style[mxConstants.STYLE_DIRECTION] : null;
            var vertical = direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH;
            var x = bounds.x;
            var y = bounds.y;
            var w2 = bounds.width;
            var h2 = bounds.height;
            var cx = x + w2 / 2;
            var cy = y + h2 / 2;
            var start = new mxPoint(x, y);
            var corner = new mxPoint(x + w2, cy);
            var end = new mxPoint(x, y + h2);
            if (direction == mxConstants.DIRECTION_NORTH) {
              start = end;
              corner = new mxPoint(cx, y);
              end = new mxPoint(x + w2, y + h2);
            } else if (direction == mxConstants.DIRECTION_SOUTH) {
              corner = new mxPoint(cx, y + h2);
              end = new mxPoint(x + w2, y);
            } else if (direction == mxConstants.DIRECTION_WEST) {
              start = new mxPoint(x + w2, y);
              corner = new mxPoint(x, cy);
              end = new mxPoint(x + w2, y + h2);
            }
            var dx = next.x - cx;
            var dy = next.y - cy;
            var alpha = vertical ? Math.atan2(dx, dy) : Math.atan2(dy, dx);
            var t = vertical ? Math.atan2(w2, h2) : Math.atan2(h2, w2);
            var base = false;
            if (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_WEST) {
              base = alpha > -t && alpha < t;
            } else {
              base = alpha < -Math.PI + t || alpha > Math.PI - t;
            }
            var result2 = null;
            if (base) {
              if (orthogonal && (vertical && next.x >= start.x && next.x <= end.x || !vertical && next.y >= start.y && next.y <= end.y)) {
                if (vertical) {
                  result2 = new mxPoint(next.x, start.y);
                } else {
                  result2 = new mxPoint(start.x, next.y);
                }
              } else {
                if (direction == mxConstants.DIRECTION_NORTH) {
                  result2 = new mxPoint(
                    x + w2 / 2 + h2 * Math.tan(alpha) / 2,
                    y + h2
                  );
                } else if (direction == mxConstants.DIRECTION_SOUTH) {
                  result2 = new mxPoint(
                    x + w2 / 2 - h2 * Math.tan(alpha) / 2,
                    y
                  );
                } else if (direction == mxConstants.DIRECTION_WEST) {
                  result2 = new mxPoint(x + w2, y + h2 / 2 + w2 * Math.tan(alpha) / 2);
                } else {
                  result2 = new mxPoint(x, y + h2 / 2 - w2 * Math.tan(alpha) / 2);
                }
              }
            } else {
              if (orthogonal) {
                var pt = new mxPoint(cx, cy);
                if (next.y >= y && next.y <= y + h2) {
                  pt.x = vertical ? cx : direction == mxConstants.DIRECTION_WEST ? x + w2 : x;
                  pt.y = next.y;
                } else if (next.x >= x && next.x <= x + w2) {
                  pt.x = next.x;
                  pt.y = !vertical ? cy : direction == mxConstants.DIRECTION_NORTH ? y + h2 : y;
                }
                dx = next.x - pt.x;
                dy = next.y - pt.y;
                cx = pt.x;
                cy = pt.y;
              }
              if (vertical && next.x <= x + w2 / 2 || !vertical && next.y <= y + h2 / 2) {
                result2 = mxUtils.intersection(
                  next.x,
                  next.y,
                  cx,
                  cy,
                  start.x,
                  start.y,
                  corner.x,
                  corner.y
                );
              } else {
                result2 = mxUtils.intersection(
                  next.x,
                  next.y,
                  cx,
                  cy,
                  corner.x,
                  corner.y,
                  end.x,
                  end.y
                );
              }
            }
            if (result2 == null) {
              result2 = new mxPoint(cx, cy);
            }
            return result2;
          },
          /**
           * Function: HexagonPerimeter
           * 
           * Describes a hexagon perimeter. See <RectanglePerimeter>
           * for a description of the parameters.
           */
          HexagonPerimeter: function(bounds, vertex, next, orthogonal) {
            var x = bounds.x;
            var y = bounds.y;
            var w2 = bounds.width;
            var h2 = bounds.height;
            var cx = bounds.getCenterX();
            var cy = bounds.getCenterY();
            var px2 = next.x;
            var py = next.y;
            var dx = px2 - cx;
            var dy = py - cy;
            var alpha = -Math.atan2(dy, dx);
            var pi = Math.PI;
            var pi2 = Math.PI / 2;
            var result2 = new mxPoint(cx, cy);
            var direction = vertex != null ? mxUtils.getValue(
              vertex.style,
              mxConstants.STYLE_DIRECTION,
              mxConstants.DIRECTION_EAST
            ) : mxConstants.DIRECTION_EAST;
            var vertical = direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH;
            var a = new mxPoint();
            var b = new mxPoint();
            if (px2 < x && py < y || px2 < x && py > y + h2 || px2 > x + w2 && py < y || px2 > x + w2 && py > y + h2) {
              orthogonal = false;
            }
            if (orthogonal) {
              if (vertical) {
                if (px2 == cx) {
                  if (py <= y) {
                    return new mxPoint(cx, y);
                  } else if (py >= y + h2) {
                    return new mxPoint(cx, y + h2);
                  }
                } else if (px2 < x) {
                  if (py == y + h2 / 4) {
                    return new mxPoint(x, y + h2 / 4);
                  } else if (py == y + 3 * h2 / 4) {
                    return new mxPoint(x, y + 3 * h2 / 4);
                  }
                } else if (px2 > x + w2) {
                  if (py == y + h2 / 4) {
                    return new mxPoint(x + w2, y + h2 / 4);
                  } else if (py == y + 3 * h2 / 4) {
                    return new mxPoint(x + w2, y + 3 * h2 / 4);
                  }
                } else if (px2 == x) {
                  if (py < cy) {
                    return new mxPoint(x, y + h2 / 4);
                  } else if (py > cy) {
                    return new mxPoint(x, y + 3 * h2 / 4);
                  }
                } else if (px2 == x + w2) {
                  if (py < cy) {
                    return new mxPoint(x + w2, y + h2 / 4);
                  } else if (py > cy) {
                    return new mxPoint(x + w2, y + 3 * h2 / 4);
                  }
                }
                if (py == y) {
                  return new mxPoint(cx, y);
                } else if (py == y + h2) {
                  return new mxPoint(cx, y + h2);
                }
                if (px2 < cx) {
                  if (py > y + h2 / 4 && py < y + 3 * h2 / 4) {
                    a = new mxPoint(x, y);
                    b = new mxPoint(x, y + h2);
                  } else if (py < y + h2 / 4) {
                    a = new mxPoint(x - Math.floor(0.5 * w2), y + Math.floor(0.5 * h2));
                    b = new mxPoint(x + w2, y - Math.floor(0.25 * h2));
                  } else if (py > y + 3 * h2 / 4) {
                    a = new mxPoint(x - Math.floor(0.5 * w2), y + Math.floor(0.5 * h2));
                    b = new mxPoint(x + w2, y + Math.floor(1.25 * h2));
                  }
                } else if (px2 > cx) {
                  if (py > y + h2 / 4 && py < y + 3 * h2 / 4) {
                    a = new mxPoint(x + w2, y);
                    b = new mxPoint(x + w2, y + h2);
                  } else if (py < y + h2 / 4) {
                    a = new mxPoint(x, y - Math.floor(0.25 * h2));
                    b = new mxPoint(x + Math.floor(1.5 * w2), y + Math.floor(0.5 * h2));
                  } else if (py > y + 3 * h2 / 4) {
                    a = new mxPoint(x + Math.floor(1.5 * w2), y + Math.floor(0.5 * h2));
                    b = new mxPoint(x, y + Math.floor(1.25 * h2));
                  }
                }
              } else {
                if (py == cy) {
                  if (px2 <= x) {
                    return new mxPoint(x, y + h2 / 2);
                  } else if (px2 >= x + w2) {
                    return new mxPoint(x + w2, y + h2 / 2);
                  }
                } else if (py < y) {
                  if (px2 == x + w2 / 4) {
                    return new mxPoint(x + w2 / 4, y);
                  } else if (px2 == x + 3 * w2 / 4) {
                    return new mxPoint(x + 3 * w2 / 4, y);
                  }
                } else if (py > y + h2) {
                  if (px2 == x + w2 / 4) {
                    return new mxPoint(x + w2 / 4, y + h2);
                  } else if (px2 == x + 3 * w2 / 4) {
                    return new mxPoint(x + 3 * w2 / 4, y + h2);
                  }
                } else if (py == y) {
                  if (px2 < cx) {
                    return new mxPoint(x + w2 / 4, y);
                  } else if (px2 > cx) {
                    return new mxPoint(x + 3 * w2 / 4, y);
                  }
                } else if (py == y + h2) {
                  if (px2 < cx) {
                    return new mxPoint(x + w2 / 4, y + h2);
                  } else if (py > cy) {
                    return new mxPoint(x + 3 * w2 / 4, y + h2);
                  }
                }
                if (px2 == x) {
                  return new mxPoint(x, cy);
                } else if (px2 == x + w2) {
                  return new mxPoint(x + w2, cy);
                }
                if (py < cy) {
                  if (px2 > x + w2 / 4 && px2 < x + 3 * w2 / 4) {
                    a = new mxPoint(x, y);
                    b = new mxPoint(x + w2, y);
                  } else if (px2 < x + w2 / 4) {
                    a = new mxPoint(x - Math.floor(0.25 * w2), y + h2);
                    b = new mxPoint(x + Math.floor(0.5 * w2), y - Math.floor(0.5 * h2));
                  } else if (px2 > x + 3 * w2 / 4) {
                    a = new mxPoint(x + Math.floor(0.5 * w2), y - Math.floor(0.5 * h2));
                    b = new mxPoint(x + Math.floor(1.25 * w2), y + h2);
                  }
                } else if (py > cy) {
                  if (px2 > x + w2 / 4 && px2 < x + 3 * w2 / 4) {
                    a = new mxPoint(x, y + h2);
                    b = new mxPoint(x + w2, y + h2);
                  } else if (px2 < x + w2 / 4) {
                    a = new mxPoint(x - Math.floor(0.25 * w2), y);
                    b = new mxPoint(x + Math.floor(0.5 * w2), y + Math.floor(1.5 * h2));
                  } else if (px2 > x + 3 * w2 / 4) {
                    a = new mxPoint(x + Math.floor(0.5 * w2), y + Math.floor(1.5 * h2));
                    b = new mxPoint(x + Math.floor(1.25 * w2), y);
                  }
                }
              }
              var tx = cx;
              var ty = cy;
              if (px2 >= x && px2 <= x + w2) {
                tx = px2;
                if (py < cy) {
                  ty = y + h2;
                } else {
                  ty = y;
                }
              } else if (py >= y && py <= y + h2) {
                ty = py;
                if (px2 < cx) {
                  tx = x + w2;
                } else {
                  tx = x;
                }
              }
              result2 = mxUtils.intersection(tx, ty, next.x, next.y, a.x, a.y, b.x, b.y);
            } else {
              if (vertical) {
                var beta = Math.atan2(h2 / 4, w2 / 2);
                if (alpha == beta) {
                  return new mxPoint(x + w2, y + Math.floor(0.25 * h2));
                } else if (alpha == pi2) {
                  return new mxPoint(x + Math.floor(0.5 * w2), y);
                } else if (alpha == pi - beta) {
                  return new mxPoint(x, y + Math.floor(0.25 * h2));
                } else if (alpha == -beta) {
                  return new mxPoint(x + w2, y + Math.floor(0.75 * h2));
                } else if (alpha == -pi2) {
                  return new mxPoint(x + Math.floor(0.5 * w2), y + h2);
                } else if (alpha == -pi + beta) {
                  return new mxPoint(x, y + Math.floor(0.75 * h2));
                }
                if (alpha < beta && alpha > -beta) {
                  a = new mxPoint(x + w2, y);
                  b = new mxPoint(x + w2, y + h2);
                } else if (alpha > beta && alpha < pi2) {
                  a = new mxPoint(x, y - Math.floor(0.25 * h2));
                  b = new mxPoint(x + Math.floor(1.5 * w2), y + Math.floor(0.5 * h2));
                } else if (alpha > pi2 && alpha < pi - beta) {
                  a = new mxPoint(x - Math.floor(0.5 * w2), y + Math.floor(0.5 * h2));
                  b = new mxPoint(x + w2, y - Math.floor(0.25 * h2));
                } else if (alpha > pi - beta && alpha <= pi || alpha < -pi + beta && alpha >= -pi) {
                  a = new mxPoint(x, y);
                  b = new mxPoint(x, y + h2);
                } else if (alpha < -beta && alpha > -pi2) {
                  a = new mxPoint(x + Math.floor(1.5 * w2), y + Math.floor(0.5 * h2));
                  b = new mxPoint(x, y + Math.floor(1.25 * h2));
                } else if (alpha < -pi2 && alpha > -pi + beta) {
                  a = new mxPoint(x - Math.floor(0.5 * w2), y + Math.floor(0.5 * h2));
                  b = new mxPoint(x + w2, y + Math.floor(1.25 * h2));
                }
              } else {
                var beta = Math.atan2(h2 / 2, w2 / 4);
                if (alpha == beta) {
                  return new mxPoint(x + Math.floor(0.75 * w2), y);
                } else if (alpha == pi - beta) {
                  return new mxPoint(x + Math.floor(0.25 * w2), y);
                } else if (alpha == pi || alpha == -pi) {
                  return new mxPoint(x, y + Math.floor(0.5 * h2));
                } else if (alpha == 0) {
                  return new mxPoint(x + w2, y + Math.floor(0.5 * h2));
                } else if (alpha == -beta) {
                  return new mxPoint(x + Math.floor(0.75 * w2), y + h2);
                } else if (alpha == -pi + beta) {
                  return new mxPoint(x + Math.floor(0.25 * w2), y + h2);
                }
                if (alpha > 0 && alpha < beta) {
                  a = new mxPoint(x + Math.floor(0.5 * w2), y - Math.floor(0.5 * h2));
                  b = new mxPoint(x + Math.floor(1.25 * w2), y + h2);
                } else if (alpha > beta && alpha < pi - beta) {
                  a = new mxPoint(x, y);
                  b = new mxPoint(x + w2, y);
                } else if (alpha > pi - beta && alpha < pi) {
                  a = new mxPoint(x - Math.floor(0.25 * w2), y + h2);
                  b = new mxPoint(x + Math.floor(0.5 * w2), y - Math.floor(0.5 * h2));
                } else if (alpha < 0 && alpha > -beta) {
                  a = new mxPoint(x + Math.floor(0.5 * w2), y + Math.floor(1.5 * h2));
                  b = new mxPoint(x + Math.floor(1.25 * w2), y);
                } else if (alpha < -beta && alpha > -pi + beta) {
                  a = new mxPoint(x, y + h2);
                  b = new mxPoint(x + w2, y + h2);
                } else if (alpha < -pi + beta && alpha > -pi) {
                  a = new mxPoint(x - Math.floor(0.25 * w2), y);
                  b = new mxPoint(x + Math.floor(0.5 * w2), y + Math.floor(1.5 * h2));
                }
              }
              result2 = mxUtils.intersection(cx, cy, next.x, next.y, a.x, a.y, b.x, b.y);
            }
            if (result2 == null) {
              return new mxPoint(cx, cy);
            }
            return result2;
          }
        };
        __mxOutput.mxPerimeter = typeof mxPerimeter !== "undefined" ? mxPerimeter : void 0;
        function mxPrintPreview(graph, scale, pageFormat, border, x0, y0, borderColor, title, pageSelector) {
          this.graph = graph;
          this.scale = scale != null ? scale : 1 / graph.pageScale;
          this.border = border != null ? border : 0;
          this.pageFormat = mxRectangle.fromRectangle(pageFormat != null ? pageFormat : graph.pageFormat);
          this.title = title != null ? title : "Printer-friendly version";
          this.x0 = x0 != null ? x0 : 0;
          this.y0 = y0 != null ? y0 : 0;
          this.borderColor = borderColor;
          this.pageSelector = pageSelector != null ? pageSelector : true;
        }
        ;
        mxPrintPreview.prototype.graph = null;
        mxPrintPreview.prototype.pageFormat = null;
        mxPrintPreview.prototype.scale = null;
        mxPrintPreview.prototype.border = 0;
        mxPrintPreview.prototype.marginTop = 0;
        mxPrintPreview.prototype.marginBottom = 0;
        mxPrintPreview.prototype.x0 = 0;
        mxPrintPreview.prototype.y0 = 0;
        mxPrintPreview.prototype.autoOrigin = true;
        mxPrintPreview.prototype.printOverlays = false;
        mxPrintPreview.prototype.printControls = false;
        mxPrintPreview.prototype.printBackgroundImage = false;
        mxPrintPreview.prototype.backgroundColor = "#ffffff";
        mxPrintPreview.prototype.borderColor = null;
        mxPrintPreview.prototype.title = null;
        mxPrintPreview.prototype.pageSelector = null;
        mxPrintPreview.prototype.wnd = null;
        mxPrintPreview.prototype.targetWindow = null;
        mxPrintPreview.prototype.pageCount = 0;
        mxPrintPreview.prototype.clipping = true;
        mxPrintPreview.prototype.getWindow = function() {
          return this.wnd;
        };
        mxPrintPreview.prototype.getDoctype = function() {
          var dt = "";
          if (document.documentMode == 5) {
            dt = '<meta http-equiv="X-UA-Compatible" content="IE=5">';
          } else if (document.documentMode == 8) {
            dt = '<meta http-equiv="X-UA-Compatible" content="IE=8">';
          } else if (document.documentMode > 8) {
            dt = '<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->';
          }
          return dt;
        };
        mxPrintPreview.prototype.appendGraph = function(graph, scale, x0, y0, forcePageBreaks, keepOpen) {
          this.graph = graph;
          this.scale = scale != null ? scale : 1 / graph.pageScale;
          this.x0 = x0;
          this.y0 = y0;
          this.open(null, null, forcePageBreaks, keepOpen);
        };
        mxPrintPreview.prototype.open = function(css, targetWindow, forcePageBreaks, keepOpen) {
          var previousInitializeOverlay = this.graph.cellRenderer.initializeOverlay;
          var div = null;
          try {
            if (this.printOverlays) {
              this.graph.cellRenderer.initializeOverlay = function(state, overlay) {
                overlay.init(state.view.getDrawPane());
              };
            }
            if (this.printControls) {
              this.graph.cellRenderer.initControl = function(state, control, handleEvents, clickHandler) {
                control.dialect = state.view.graph.dialect;
                control.init(state.view.getDrawPane());
              };
            }
            this.wnd = targetWindow != null ? targetWindow : this.wnd;
            var isNewWindow = false;
            if (this.wnd == null) {
              isNewWindow = true;
              this.wnd = window.open();
            }
            var doc = this.wnd.document;
            if (isNewWindow) {
              var dt = this.getDoctype();
              if (dt != null && dt.length > 0) {
                doc.writeln(dt);
              }
              if (mxClient.IS_VML) {
                doc.writeln('<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">');
              } else {
                if (document.compatMode === "CSS1Compat") {
                  doc.writeln("<!DOCTYPE html>");
                }
                doc.writeln("<html>");
              }
              doc.writeln("<head>");
              this.writeHead(doc, css);
              doc.writeln("</head>");
              doc.writeln('<body class="mxPage">');
            }
            var bounds = this.graph.getGraphBounds().clone();
            var currentScale = this.graph.getView().getScale();
            var sc = currentScale / this.scale;
            var tr = this.graph.getView().getTranslate();
            if (!this.autoOrigin) {
              this.x0 -= tr.x * this.scale;
              this.y0 -= tr.y * this.scale;
              bounds.width += bounds.x;
              bounds.height += bounds.y;
              bounds.x = 0;
              bounds.y = 0;
              this.border = 0;
            }
            var availableWidth = this.pageFormat.width - this.border * 2;
            var availableHeight = this.pageFormat.height - this.border * 2;
            this.pageFormat.height += this.marginTop + this.marginBottom;
            bounds.width /= sc;
            bounds.height /= sc;
            var hpages = Math.max(1, Math.ceil((bounds.width + this.x0) / availableWidth));
            var vpages = Math.max(1, Math.ceil((bounds.height + this.y0) / availableHeight));
            this.pageCount = hpages * vpages;
            var writePageSelector = mxUtils.bind(this, function() {
              if (this.pageSelector && (vpages > 1 || hpages > 1)) {
                var table = this.createPageSelector(vpages, hpages);
                doc.body.appendChild(table);
                if (mxClient.IS_IE && doc.documentMode == null || doc.documentMode == 5 || doc.documentMode == 8 || doc.documentMode == 7) {
                  table.style.position = "absolute";
                  var update = function() {
                    table.style.top = (doc.body.scrollTop || doc.documentElement.scrollTop) + 10 + "px";
                  };
                  mxEvent.addListener(this.wnd, "scroll", function(evt) {
                    update();
                  });
                  mxEvent.addListener(this.wnd, "resize", function(evt) {
                    update();
                  });
                }
              }
            });
            var addPage = mxUtils.bind(this, function(div2, addBreak) {
              if (this.borderColor != null) {
                div2.style.borderColor = this.borderColor;
                div2.style.borderStyle = "solid";
                div2.style.borderWidth = "1px";
              }
              div2.style.background = this.backgroundColor;
              if (forcePageBreaks || addBreak) {
                div2.style.pageBreakAfter = "always";
              }
              if (isNewWindow && (mxClient.IS_IE || document.documentMode >= 11 || mxClient.IS_EDGE)) {
                doc.writeln(div2.outerHTML);
                div2.parentNode.removeChild(div2);
              } else if (mxClient.IS_IE || document.documentMode >= 11 || mxClient.IS_EDGE) {
                var clone = doc.createElement("div");
                clone.innerHTML = div2.outerHTML;
                clone = clone.getElementsByTagName("div")[0];
                doc.body.appendChild(clone);
                div2.parentNode.removeChild(div2);
              } else {
                div2.parentNode.removeChild(div2);
                doc.body.appendChild(div2);
              }
              if (forcePageBreaks || addBreak) {
                this.addPageBreak(doc);
              }
            });
            var cov = this.getCoverPages(this.pageFormat.width, this.pageFormat.height);
            if (cov != null) {
              for (var i = 0; i < cov.length; i++) {
                addPage(cov[i], true);
              }
            }
            var apx = this.getAppendices(this.pageFormat.width, this.pageFormat.height);
            for (var i = 0; i < vpages; i++) {
              var dy = i * availableHeight / this.scale - this.y0 / this.scale + (bounds.y - tr.y * currentScale) / currentScale;
              for (var j = 0; j < hpages; j++) {
                if (this.wnd == null) {
                  return null;
                }
                var dx = j * availableWidth / this.scale - this.x0 / this.scale + (bounds.x - tr.x * currentScale) / currentScale;
                var pageNum = i * hpages + j + 1;
                var clip2 = new mxRectangle(dx, dy, availableWidth, availableHeight);
                div = this.renderPage(this.pageFormat.width, this.pageFormat.height, 0, 0, mxUtils.bind(this, function(div2) {
                  this.addGraphFragment(-dx, -dy, this.scale, pageNum, div2, clip2);
                  if (this.printBackgroundImage) {
                    this.insertBackgroundImage(div2, -dx, -dy);
                  }
                }), pageNum);
                div.setAttribute("id", "mxPage-" + pageNum);
                addPage(div, apx != null || i < vpages - 1 || j < hpages - 1);
              }
            }
            if (apx != null) {
              for (var i = 0; i < apx.length; i++) {
                addPage(apx[i], i < apx.length - 1);
              }
            }
            if (isNewWindow && !keepOpen) {
              this.closeDocument();
              writePageSelector();
            }
            this.wnd.focus();
          } catch (e) {
            if (div != null && div.parentNode != null) {
              div.parentNode.removeChild(div);
            }
          } finally {
            this.graph.cellRenderer.initializeOverlay = previousInitializeOverlay;
          }
          return this.wnd;
        };
        mxPrintPreview.prototype.addPageBreak = function(doc) {
          var hr = doc.createElement("hr");
          hr.className = "mxPageBreak";
          doc.body.appendChild(hr);
        };
        mxPrintPreview.prototype.closeDocument = function() {
          try {
            if (this.wnd != null && this.wnd.document != null) {
              var doc = this.wnd.document;
              this.writePostfix(doc);
              doc.writeln("</body>");
              doc.writeln("</html>");
              doc.close();
              mxEvent.release(doc.body);
            }
          } catch (e) {
          }
        };
        mxPrintPreview.prototype.writeHead = function(doc, css) {
          if (this.title != null) {
            doc.writeln("<title>" + this.title + "</title>");
          }
          if (mxClient.IS_VML) {
            doc.writeln('<style type="text/css">v\\:*{behavior:url(#default#VML)}o\\:*{behavior:url(#default#VML)}</style>');
          }
          mxClient.link("stylesheet", mxClient.basePath + "/css/common.css", doc);
          doc.writeln('<style type="text/css">');
          doc.writeln("@media print {");
          doc.writeln("  * { -webkit-print-color-adjust: exact; }");
          doc.writeln("  table.mxPageSelector { display: none; }");
          doc.writeln("  hr.mxPageBreak { display: none; }");
          doc.writeln("}");
          doc.writeln("@media screen {");
          doc.writeln("  table.mxPageSelector { position: fixed; right: 10px; top: 10px;font-family: Arial; font-size:10pt; border: solid 1px darkgray;background: white; border-collapse:collapse; }");
          doc.writeln("  table.mxPageSelector td { border: solid 1px gray; padding:4px; }");
          doc.writeln("  body.mxPage { background: gray; }");
          doc.writeln("}");
          if (css != null) {
            doc.writeln(css);
          }
          doc.writeln("</style>");
        };
        mxPrintPreview.prototype.writePostfix = function(doc) {
        };
        mxPrintPreview.prototype.createPageSelector = function(vpages, hpages) {
          var doc = this.wnd.document;
          var table = doc.createElement("table");
          table.className = "mxPageSelector";
          table.setAttribute("border", "0");
          var tbody = doc.createElement("tbody");
          for (var i = 0; i < vpages; i++) {
            var row = doc.createElement("tr");
            for (var j = 0; j < hpages; j++) {
              var pageNum = i * hpages + j + 1;
              var cell2 = doc.createElement("td");
              var a = doc.createElement("a");
              a.setAttribute("href", "#mxPage-" + pageNum);
              if (mxClient.IS_NS && !mxClient.IS_SF && !mxClient.IS_GC) {
                var js = "var page = document.getElementById('mxPage-" + pageNum + "');page.scrollIntoView(true);event.preventDefault();";
                a.setAttribute("onclick", js);
              }
              mxUtils.write(a, pageNum, doc);
              cell2.appendChild(a);
              row.appendChild(cell2);
            }
            tbody.appendChild(row);
          }
          table.appendChild(tbody);
          return table;
        };
        mxPrintPreview.prototype.renderPage = function(w2, h2, dx, dy, content, pageNumber) {
          var doc = this.wnd.document;
          var div = document.createElement("div");
          var arg = null;
          try {
            if (dx != 0 || dy != 0) {
              div.style.position = "relative";
              div.style.width = w2 + "px";
              div.style.height = h2 + "px";
              div.style.pageBreakInside = "avoid";
              var innerDiv = document.createElement("div");
              innerDiv.style.position = "relative";
              innerDiv.style.top = this.border + "px";
              innerDiv.style.left = this.border + "px";
              innerDiv.style.width = w2 - 2 * this.border + "px";
              innerDiv.style.height = h2 - 2 * this.border + "px";
              innerDiv.style.overflow = "hidden";
              var viewport = document.createElement("div");
              viewport.style.position = "relative";
              viewport.style.marginLeft = dx + "px";
              viewport.style.marginTop = dy + "px";
              if (doc.documentMode == 8) {
                innerDiv.style.position = "absolute";
                viewport.style.position = "absolute";
              }
              if (doc.documentMode == 10) {
                viewport.style.width = "100%";
                viewport.style.height = "100%";
              }
              innerDiv.appendChild(viewport);
              div.appendChild(innerDiv);
              document.body.appendChild(div);
              arg = viewport;
            } else {
              div.style.width = w2 + "px";
              div.style.height = h2 + "px";
              div.style.overflow = "hidden";
              div.style.pageBreakInside = "avoid";
              if (doc.documentMode == 8) {
                div.style.position = "relative";
              }
              var innerDiv = document.createElement("div");
              innerDiv.style.width = w2 - 2 * this.border + "px";
              innerDiv.style.height = h2 - 2 * this.border + "px";
              innerDiv.style.overflow = "hidden";
              if (mxClient.IS_IE && (doc.documentMode == null || doc.documentMode == 5 || doc.documentMode == 8 || doc.documentMode == 7)) {
                innerDiv.style.marginTop = this.border + "px";
                innerDiv.style.marginLeft = this.border + "px";
              } else {
                innerDiv.style.top = this.border + "px";
                innerDiv.style.left = this.border + "px";
              }
              if (this.graph.dialect == mxConstants.DIALECT_VML) {
                innerDiv.style.position = "absolute";
              }
              div.appendChild(innerDiv);
              document.body.appendChild(div);
              arg = innerDiv;
            }
          } catch (e) {
            div.parentNode.removeChild(div);
            div = null;
            throw e;
          }
          content(arg);
          return div;
        };
        mxPrintPreview.prototype.getRoot = function() {
          var root = this.graph.view.currentRoot;
          if (root == null) {
            root = this.graph.getModel().getRoot();
          }
          return root;
        };
        mxPrintPreview.prototype.useCssTransforms = function() {
          return !mxClient.NO_FO && !mxClient.IS_SF;
        };
        mxPrintPreview.prototype.addGraphFragment = function(dx, dy, scale, pageNumber, div, clip2) {
          var view = this.graph.getView();
          var previousContainer = this.graph.container;
          this.graph.container = div;
          var canvas = view.getCanvas();
          var backgroundPane = view.getBackgroundPane();
          var drawPane = view.getDrawPane();
          var overlayPane = view.getOverlayPane();
          var realScale = scale;
          if (this.graph.dialect == mxConstants.DIALECT_SVG) {
            view.createSvg();
            if (this.useCssTransforms()) {
              var g = view.getDrawPane().parentNode;
              var prev = g.getAttribute("transform");
              g.setAttribute("transformOrigin", "0 0");
              g.setAttribute("transform", "scale(" + scale + "," + scale + ")translate(" + dx + "," + dy + ")");
              scale = 1;
              dx = 0;
              dy = 0;
            }
          } else if (this.graph.dialect == mxConstants.DIALECT_VML) {
            view.createVml();
          } else {
            view.createHtml();
          }
          var eventsEnabled = view.isEventsEnabled();
          view.setEventsEnabled(false);
          var graphEnabled = this.graph.isEnabled();
          this.graph.setEnabled(false);
          var translate = view.getTranslate();
          view.translate = new mxPoint(dx, dy);
          var redraw = this.graph.cellRenderer.redraw;
          var states = view.states;
          var s = view.scale;
          if (this.clipping) {
            var tempClip = new mxRectangle(
              (clip2.x + translate.x) * s,
              (clip2.y + translate.y) * s,
              clip2.width * s / realScale,
              clip2.height * s / realScale
            );
            this.graph.cellRenderer.redraw = function(state, force, rendering) {
              if (state != null) {
                var orig = states.get(state.cell);
                if (orig != null) {
                  var bbox = view.getBoundingBox(orig, false);
                  if (bbox != null && bbox.width > 0 && bbox.height > 0 && !mxUtils.intersects(tempClip, bbox)) {
                    return;
                  }
                }
              }
              redraw.apply(this, arguments);
            };
          }
          var temp = null;
          try {
            var cells = [this.getRoot()];
            temp = new mxTemporaryCellStates(view, scale, cells, null, mxUtils.bind(this, function(state) {
              return this.getLinkForCellState(state);
            }));
          } finally {
            if (mxClient.IS_IE) {
              view.overlayPane.innerHTML = "";
              view.canvas.style.overflow = "hidden";
              view.canvas.style.position = "relative";
              view.canvas.style.top = this.marginTop + "px";
              view.canvas.style.width = clip2.width + "px";
              view.canvas.style.height = clip2.height + "px";
            } else {
              var tmp = div.firstChild;
              while (tmp != null) {
                var next = tmp.nextSibling;
                var name2 = tmp.nodeName.toLowerCase();
                if (name2 == "svg") {
                  tmp.style.overflow = "hidden";
                  tmp.style.position = "relative";
                  tmp.style.top = this.marginTop + "px";
                  tmp.setAttribute("width", clip2.width);
                  tmp.setAttribute("height", clip2.height);
                  tmp.style.width = "";
                  tmp.style.height = "";
                } else if (tmp.style.cursor != "default" && name2 != "div") {
                  tmp.parentNode.removeChild(tmp);
                }
                tmp = next;
              }
            }
            if (this.printBackgroundImage) {
              var svgs = div.getElementsByTagName("svg");
              if (svgs.length > 0) {
                svgs[0].style.position = "absolute";
              }
            }
            view.overlayPane.parentNode.removeChild(view.overlayPane);
            this.graph.setEnabled(graphEnabled);
            this.graph.container = previousContainer;
            this.graph.cellRenderer.redraw = redraw;
            view.canvas = canvas;
            view.backgroundPane = backgroundPane;
            view.drawPane = drawPane;
            view.overlayPane = overlayPane;
            view.translate = translate;
            temp.destroy();
            view.setEventsEnabled(eventsEnabled);
          }
        };
        mxPrintPreview.prototype.getLinkForCellState = function(state) {
          return this.graph.getLinkForCell(state.cell);
        };
        mxPrintPreview.prototype.insertBackgroundImage = function(div, dx, dy) {
          var bg = this.graph.backgroundImage;
          if (bg != null) {
            var img = document.createElement("img");
            img.style.position = "absolute";
            img.style.marginLeft = Math.round(dx * this.scale) + "px";
            img.style.marginTop = Math.round(dy * this.scale) + "px";
            img.setAttribute("width", Math.round(this.scale * bg.width));
            img.setAttribute("height", Math.round(this.scale * bg.height));
            img.src = bg.src;
            div.insertBefore(img, div.firstChild);
          }
        };
        mxPrintPreview.prototype.getCoverPages = function() {
          return null;
        };
        mxPrintPreview.prototype.getAppendices = function() {
          return null;
        };
        mxPrintPreview.prototype.print = function(css) {
          var wnd = this.open(css);
          if (wnd != null) {
            wnd.print();
          }
        };
        mxPrintPreview.prototype.close = function() {
          if (this.wnd != null) {
            this.wnd.close();
            this.wnd = null;
          }
        };
        __mxOutput.mxPrintPreview = typeof mxPrintPreview !== "undefined" ? mxPrintPreview : void 0;
        function mxStylesheet() {
          this.styles = new Object();
          this.putDefaultVertexStyle(this.createDefaultVertexStyle());
          this.putDefaultEdgeStyle(this.createDefaultEdgeStyle());
        }
        ;
        mxStylesheet.prototype.styles;
        mxStylesheet.prototype.createDefaultVertexStyle = function() {
          var style = new Object();
          style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
          style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;
          style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;
          style[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
          style[mxConstants.STYLE_FILLCOLOR] = "#C3D9FF";
          style[mxConstants.STYLE_STROKECOLOR] = "#6482B9";
          style[mxConstants.STYLE_FONTCOLOR] = "#774400";
          return style;
        };
        mxStylesheet.prototype.createDefaultEdgeStyle = function() {
          var style = new Object();
          style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_CONNECTOR;
          style[mxConstants.STYLE_ENDARROW] = mxConstants.ARROW_CLASSIC;
          style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;
          style[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
          style[mxConstants.STYLE_STROKECOLOR] = "#6482B9";
          style[mxConstants.STYLE_FONTCOLOR] = "#446299";
          return style;
        };
        mxStylesheet.prototype.putDefaultVertexStyle = function(style) {
          this.putCellStyle("defaultVertex", style);
        };
        mxStylesheet.prototype.putDefaultEdgeStyle = function(style) {
          this.putCellStyle("defaultEdge", style);
        };
        mxStylesheet.prototype.getDefaultVertexStyle = function() {
          return this.styles["defaultVertex"];
        };
        mxStylesheet.prototype.getDefaultEdgeStyle = function() {
          return this.styles["defaultEdge"];
        };
        mxStylesheet.prototype.putCellStyle = function(name2, style) {
          this.styles[name2] = style;
        };
        mxStylesheet.prototype.getCellStyle = function(name2, defaultStyle) {
          var style = defaultStyle;
          if (name2 != null && name2.length > 0) {
            var pairs = name2.split(";");
            if (style != null && name2.charAt(0) != ";") {
              style = mxUtils.clone(style);
            } else {
              style = new Object();
            }
            for (var i = 0; i < pairs.length; i++) {
              var tmp = pairs[i];
              var pos = tmp.indexOf("=");
              if (pos >= 0) {
                var key = tmp.substring(0, pos);
                var value = tmp.substring(pos + 1);
                if (value == mxConstants.NONE) {
                  delete style[key];
                } else if (mxUtils.isNumeric(value)) {
                  style[key] = parseFloat(value);
                } else {
                  style[key] = value;
                }
              } else {
                var tmpStyle = this.styles[tmp];
                if (tmpStyle != null) {
                  for (var key in tmpStyle) {
                    style[key] = tmpStyle[key];
                  }
                }
              }
            }
          }
          return style;
        };
        __mxOutput.mxStylesheet = typeof mxStylesheet !== "undefined" ? mxStylesheet : void 0;
        function mxCellState(view, cell2, style) {
          this.view = view;
          this.cell = cell2;
          this.style = style != null ? style : {};
          this.origin = new mxPoint();
          this.absoluteOffset = new mxPoint();
        }
        ;
        mxCellState.prototype = new mxRectangle();
        mxCellState.prototype.constructor = mxCellState;
        mxCellState.prototype.view = null;
        mxCellState.prototype.cell = null;
        mxCellState.prototype.style = null;
        mxCellState.prototype.invalidStyle = false;
        mxCellState.prototype.invalid = true;
        mxCellState.prototype.origin = null;
        mxCellState.prototype.absolutePoints = null;
        mxCellState.prototype.absoluteOffset = null;
        mxCellState.prototype.visibleSourceState = null;
        mxCellState.prototype.visibleTargetState = null;
        mxCellState.prototype.terminalDistance = 0;
        mxCellState.prototype.length = 0;
        mxCellState.prototype.segments = null;
        mxCellState.prototype.shape = null;
        mxCellState.prototype.text = null;
        mxCellState.prototype.unscaledWidth = null;
        mxCellState.prototype.unscaledHeight = null;
        mxCellState.prototype.getPerimeterBounds = function(border, bounds) {
          border = border || 0;
          bounds = bounds != null ? bounds : new mxRectangle(this.x, this.y, this.width, this.height);
          if (this.shape != null && this.shape.stencil != null && this.shape.stencil.aspect == "fixed") {
            var aspect = this.shape.stencil.computeAspect(this.style, bounds.x, bounds.y, bounds.width, bounds.height);
            bounds.x = aspect.x;
            bounds.y = aspect.y;
            bounds.width = this.shape.stencil.w0 * aspect.width;
            bounds.height = this.shape.stencil.h0 * aspect.height;
          }
          if (border != 0) {
            bounds.grow(border);
          }
          return bounds;
        };
        mxCellState.prototype.setAbsoluteTerminalPoint = function(point, isSource) {
          if (isSource) {
            if (this.absolutePoints == null) {
              this.absolutePoints = [];
            }
            if (this.absolutePoints.length == 0) {
              this.absolutePoints.push(point);
            } else {
              this.absolutePoints[0] = point;
            }
          } else {
            if (this.absolutePoints == null) {
              this.absolutePoints = [];
              this.absolutePoints.push(null);
              this.absolutePoints.push(point);
            } else if (this.absolutePoints.length == 1) {
              this.absolutePoints.push(point);
            } else {
              this.absolutePoints[this.absolutePoints.length - 1] = point;
            }
          }
        };
        mxCellState.prototype.setCursor = function(cursor) {
          if (this.shape != null) {
            this.shape.setCursor(cursor);
          }
          if (this.text != null) {
            this.text.setCursor(cursor);
          }
        };
        mxCellState.prototype.getVisibleTerminal = function(source) {
          var tmp = this.getVisibleTerminalState(source);
          return tmp != null ? tmp.cell : null;
        };
        mxCellState.prototype.getVisibleTerminalState = function(source) {
          return source ? this.visibleSourceState : this.visibleTargetState;
        };
        mxCellState.prototype.setVisibleTerminalState = function(terminalState, source) {
          if (source) {
            this.visibleSourceState = terminalState;
          } else {
            this.visibleTargetState = terminalState;
          }
        };
        mxCellState.prototype.getCellBounds = function() {
          return this.cellBounds;
        };
        mxCellState.prototype.getPaintBounds = function() {
          return this.paintBounds;
        };
        mxCellState.prototype.updateCachedBounds = function() {
          var tr = this.view.translate;
          var s = this.view.scale;
          this.cellBounds = new mxRectangle(this.x / s - tr.x, this.y / s - tr.y, this.width / s, this.height / s);
          this.paintBounds = mxRectangle.fromRectangle(this.cellBounds);
          if (this.shape != null && this.shape.isPaintBoundsInverted()) {
            this.paintBounds.rotate90();
          }
        };
        mxCellState.prototype.setState = function(state) {
          this.view = state.view;
          this.cell = state.cell;
          this.style = state.style;
          this.absolutePoints = state.absolutePoints;
          this.origin = state.origin;
          this.absoluteOffset = state.absoluteOffset;
          this.boundingBox = state.boundingBox;
          this.terminalDistance = state.terminalDistance;
          this.segments = state.segments;
          this.length = state.length;
          this.x = state.x;
          this.y = state.y;
          this.width = state.width;
          this.height = state.height;
          this.unscaledWidth = state.unscaledWidth;
          this.unscaledHeight = state.unscaledHeight;
        };
        mxCellState.prototype.clone = function() {
          var clone = new mxCellState(this.view, this.cell, this.style);
          if (this.absolutePoints != null) {
            clone.absolutePoints = [];
            for (var i = 0; i < this.absolutePoints.length; i++) {
              clone.absolutePoints[i] = this.absolutePoints[i].clone();
            }
          }
          if (this.origin != null) {
            clone.origin = this.origin.clone();
          }
          if (this.absoluteOffset != null) {
            clone.absoluteOffset = this.absoluteOffset.clone();
          }
          if (this.boundingBox != null) {
            clone.boundingBox = this.boundingBox.clone();
          }
          clone.terminalDistance = this.terminalDistance;
          clone.segments = this.segments;
          clone.length = this.length;
          clone.x = this.x;
          clone.y = this.y;
          clone.width = this.width;
          clone.height = this.height;
          clone.unscaledWidth = this.unscaledWidth;
          clone.unscaledHeight = this.unscaledHeight;
          return clone;
        };
        mxCellState.prototype.destroy = function() {
          this.view.graph.cellRenderer.destroy(this);
        };
        __mxOutput.mxCellState = typeof mxCellState !== "undefined" ? mxCellState : void 0;
        function mxGraphSelectionModel(graph) {
          this.graph = graph;
          this.cells = [];
        }
        ;
        mxGraphSelectionModel.prototype = new mxEventSource();
        mxGraphSelectionModel.prototype.constructor = mxGraphSelectionModel;
        mxGraphSelectionModel.prototype.doneResource = mxClient.language != "none" ? "done" : "";
        mxGraphSelectionModel.prototype.updatingSelectionResource = mxClient.language != "none" ? "updatingSelection" : "";
        mxGraphSelectionModel.prototype.graph = null;
        mxGraphSelectionModel.prototype.singleSelection = false;
        mxGraphSelectionModel.prototype.isSingleSelection = function() {
          return this.singleSelection;
        };
        mxGraphSelectionModel.prototype.setSingleSelection = function(singleSelection) {
          this.singleSelection = singleSelection;
        };
        mxGraphSelectionModel.prototype.isSelected = function(cell2) {
          if (cell2 != null) {
            return mxUtils.indexOf(this.cells, cell2) >= 0;
          }
          return false;
        };
        mxGraphSelectionModel.prototype.isEmpty = function() {
          return this.cells.length == 0;
        };
        mxGraphSelectionModel.prototype.clear = function() {
          this.changeSelection(null, this.cells);
        };
        mxGraphSelectionModel.prototype.setCell = function(cell2) {
          if (cell2 != null) {
            this.setCells([cell2]);
          }
        };
        mxGraphSelectionModel.prototype.setCells = function(cells) {
          if (cells != null) {
            if (this.singleSelection) {
              cells = [this.getFirstSelectableCell(cells)];
            }
            var tmp = [];
            for (var i = 0; i < cells.length; i++) {
              if (this.graph.isCellSelectable(cells[i])) {
                tmp.push(cells[i]);
              }
            }
            this.changeSelection(tmp, this.cells);
          }
        };
        mxGraphSelectionModel.prototype.getFirstSelectableCell = function(cells) {
          if (cells != null) {
            for (var i = 0; i < cells.length; i++) {
              if (this.graph.isCellSelectable(cells[i])) {
                return cells[i];
              }
            }
          }
          return null;
        };
        mxGraphSelectionModel.prototype.addCell = function(cell2) {
          if (cell2 != null) {
            this.addCells([cell2]);
          }
        };
        mxGraphSelectionModel.prototype.addCells = function(cells) {
          if (cells != null) {
            var remove = null;
            if (this.singleSelection) {
              remove = this.cells;
              cells = [this.getFirstSelectableCell(cells)];
            }
            var tmp = [];
            for (var i = 0; i < cells.length; i++) {
              if (!this.isSelected(cells[i]) && this.graph.isCellSelectable(cells[i])) {
                tmp.push(cells[i]);
              }
            }
            this.changeSelection(tmp, remove);
          }
        };
        mxGraphSelectionModel.prototype.removeCell = function(cell2) {
          if (cell2 != null) {
            this.removeCells([cell2]);
          }
        };
        mxGraphSelectionModel.prototype.removeCells = function(cells) {
          if (cells != null) {
            var tmp = [];
            for (var i = 0; i < cells.length; i++) {
              if (this.isSelected(cells[i])) {
                tmp.push(cells[i]);
              }
            }
            this.changeSelection(null, tmp);
          }
        };
        mxGraphSelectionModel.prototype.changeSelection = function(added, removed) {
          if (added != null && added.length > 0 && added[0] != null || removed != null && removed.length > 0 && removed[0] != null) {
            var change = new mxSelectionChange(this, added, removed);
            change.execute();
            var edit = new mxUndoableEdit(this, false);
            edit.add(change);
            this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", edit));
          }
        };
        mxGraphSelectionModel.prototype.cellAdded = function(cell2) {
          if (cell2 != null && !this.isSelected(cell2)) {
            this.cells.push(cell2);
          }
        };
        mxGraphSelectionModel.prototype.cellRemoved = function(cell2) {
          if (cell2 != null) {
            var index = mxUtils.indexOf(this.cells, cell2);
            if (index >= 0) {
              this.cells.splice(index, 1);
            }
          }
        };
        function mxSelectionChange(selectionModel, added, removed) {
          this.selectionModel = selectionModel;
          this.added = added != null ? added.slice() : null;
          this.removed = removed != null ? removed.slice() : null;
        }
        ;
        mxSelectionChange.prototype.execute = function() {
          var t0 = mxLog.enter("mxSelectionChange.execute");
          window.status = mxResources.get(
            this.selectionModel.updatingSelectionResource
          ) || this.selectionModel.updatingSelectionResource;
          if (this.removed != null) {
            for (var i = 0; i < this.removed.length; i++) {
              this.selectionModel.cellRemoved(this.removed[i]);
            }
          }
          if (this.added != null) {
            for (var i = 0; i < this.added.length; i++) {
              this.selectionModel.cellAdded(this.added[i]);
            }
          }
          var tmp = this.added;
          this.added = this.removed;
          this.removed = tmp;
          window.status = mxResources.get(this.selectionModel.doneResource) || this.selectionModel.doneResource;
          mxLog.leave("mxSelectionChange.execute", t0);
          this.selectionModel.fireEvent(new mxEventObject(
            mxEvent.CHANGE,
            "added",
            this.added,
            "removed",
            this.removed
          ));
        };
        __mxOutput.mxGraphSelectionModel = typeof mxGraphSelectionModel !== "undefined" ? mxGraphSelectionModel : void 0;
        function mxCellEditor(graph) {
          this.graph = graph;
          this.zoomHandler = mxUtils.bind(this, function() {
            if (this.graph.isEditing()) {
              this.resize();
            }
          });
          this.graph.view.addListener(mxEvent.SCALE, this.zoomHandler);
          this.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.zoomHandler);
          this.changeHandler = mxUtils.bind(this, function(sender) {
            if (this.editingCell != null && this.graph.getView().getState(this.editingCell) == null) {
              this.stopEditing(true);
            }
          });
          this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
        }
        ;
        mxCellEditor.prototype.graph = null;
        mxCellEditor.prototype.textarea = null;
        mxCellEditor.prototype.editingCell = null;
        mxCellEditor.prototype.trigger = null;
        mxCellEditor.prototype.modified = false;
        mxCellEditor.prototype.autoSize = true;
        mxCellEditor.prototype.selectText = true;
        mxCellEditor.prototype.emptyLabelText = mxClient.IS_FF ? "<br>" : "";
        mxCellEditor.prototype.escapeCancelsEditing = true;
        mxCellEditor.prototype.textNode = "";
        mxCellEditor.prototype.zIndex = 5;
        mxCellEditor.prototype.minResize = new mxRectangle(0, 20);
        mxCellEditor.prototype.wordWrapPadding = mxClient.IS_QUIRKS ? 2 : !mxClient.IS_IE11 ? 1 : 0;
        mxCellEditor.prototype.blurEnabled = false;
        mxCellEditor.prototype.initialValue = null;
        mxCellEditor.prototype.align = null;
        mxCellEditor.prototype.init = function() {
          this.textarea = document.createElement("div");
          this.textarea.className = "mxCellEditor mxPlainTextEditor";
          this.textarea.contentEditable = true;
          if (mxClient.IS_GC) {
            this.textarea.style.minHeight = "1em";
          }
          this.textarea.style.position = this.isLegacyEditor() ? "absolute" : "relative";
          this.installListeners(this.textarea);
        };
        mxCellEditor.prototype.applyValue = function(state, value) {
          this.graph.labelChanged(state.cell, value, this.trigger);
        };
        mxCellEditor.prototype.setAlign = function(align) {
          if (this.textarea != null) {
            this.textarea.style.textAlign = align;
          }
          this.align = align;
          this.resize();
        };
        mxCellEditor.prototype.getInitialValue = function(state, trigger) {
          var result2 = mxUtils.htmlEntities(this.graph.getEditingValue(state.cell, trigger), false);
          if (!mxClient.IS_QUIRKS && document.documentMode != 8 && document.documentMode != 9 && document.documentMode != 10) {
            result2 = mxUtils.replaceTrailingNewlines(result2, "<div><br></div>");
          }
          return result2.replace(/\n/g, "<br>");
        };
        mxCellEditor.prototype.getCurrentValue = function(state) {
          return mxUtils.extractTextWithWhitespace(this.textarea.childNodes);
        };
        mxCellEditor.prototype.isCancelEditingKeyEvent = function(evt) {
          return this.escapeCancelsEditing || mxEvent.isShiftDown(evt) || mxEvent.isControlDown(evt) || mxEvent.isMetaDown(evt);
        };
        mxCellEditor.prototype.installListeners = function(elt) {
          mxEvent.addListener(elt, "dragstart", mxUtils.bind(this, function(evt) {
            this.graph.stopEditing(false);
            mxEvent.consume(evt);
          }));
          mxEvent.addListener(elt, "blur", mxUtils.bind(this, function(evt) {
            if (this.blurEnabled) {
              this.focusLost(evt);
            }
          }));
          mxEvent.addListener(elt, "keydown", mxUtils.bind(this, function(evt) {
            if (!mxEvent.isConsumed(evt)) {
              if (this.isStopEditingEvent(evt)) {
                this.graph.stopEditing(false);
                mxEvent.consume(evt);
              } else if (evt.keyCode == 27) {
                this.graph.stopEditing(this.isCancelEditingKeyEvent(evt));
                mxEvent.consume(evt);
              }
            }
          }));
          var keypressHandler = mxUtils.bind(this, function(evt) {
            if (this.editingCell != null) {
              if (this.clearOnChange && elt.innerHTML == this.getEmptyLabelText() && (!mxClient.IS_FF || evt.keyCode != 8 && evt.keyCode != 46)) {
                this.clearOnChange = false;
                elt.innerHTML = "";
              }
            }
          });
          mxEvent.addListener(elt, "keypress", keypressHandler);
          mxEvent.addListener(elt, "paste", keypressHandler);
          var keyupHandler = mxUtils.bind(this, function(evt) {
            if (this.editingCell != null) {
              if (this.textarea.innerHTML.length == 0 || this.textarea.innerHTML == "<br>") {
                this.textarea.innerHTML = this.getEmptyLabelText();
                this.clearOnChange = this.textarea.innerHTML.length > 0;
              } else {
                this.clearOnChange = false;
              }
            }
          });
          mxEvent.addListener(elt, !mxClient.IS_IE11 && !mxClient.IS_IE ? "input" : "keyup", keyupHandler);
          mxEvent.addListener(elt, "cut", keyupHandler);
          mxEvent.addListener(elt, "paste", keyupHandler);
          var evtName = !mxClient.IS_IE11 && !mxClient.IS_IE ? "input" : "keydown";
          var resizeHandler = mxUtils.bind(this, function(evt) {
            if (this.editingCell != null && this.autoSize && !mxEvent.isConsumed(evt)) {
              if (this.resizeThread != null) {
                window.clearTimeout(this.resizeThread);
              }
              this.resizeThread = window.setTimeout(mxUtils.bind(this, function() {
                this.resizeThread = null;
                this.resize();
              }), 0);
            }
          });
          mxEvent.addListener(elt, evtName, resizeHandler);
          mxEvent.addListener(window, "resize", resizeHandler);
          if (document.documentMode >= 9) {
            mxEvent.addListener(elt, "DOMNodeRemoved", resizeHandler);
            mxEvent.addListener(elt, "DOMNodeInserted", resizeHandler);
          } else {
            mxEvent.addListener(elt, "cut", resizeHandler);
            mxEvent.addListener(elt, "paste", resizeHandler);
          }
        };
        mxCellEditor.prototype.isStopEditingEvent = function(evt) {
          return evt.keyCode == 113 || this.graph.isEnterStopsCellEditing() && evt.keyCode == 13 && !mxEvent.isControlDown(evt) && !mxEvent.isShiftDown(evt);
        };
        mxCellEditor.prototype.isEventSource = function(evt) {
          return mxEvent.getSource(evt) == this.textarea;
        };
        mxCellEditor.prototype.resize = function() {
          var state = this.graph.getView().getState(this.editingCell);
          if (state == null) {
            this.stopEditing(true);
          } else if (this.textarea != null) {
            var isEdge = this.graph.getModel().isEdge(state.cell);
            var scale = this.graph.getView().scale;
            var m = null;
            if (!this.autoSize || state.style[mxConstants.STYLE_OVERFLOW] == "fill") {
              this.bounds = this.getEditorBounds(state);
              this.textarea.style.width = Math.round(this.bounds.width / scale) + "px";
              this.textarea.style.height = Math.round(this.bounds.height / scale) + "px";
              if (document.documentMode == 8 || mxClient.IS_QUIRKS) {
                this.textarea.style.left = Math.round(this.bounds.x) + "px";
                this.textarea.style.top = Math.round(this.bounds.y) + "px";
              } else {
                this.textarea.style.left = Math.max(0, Math.round(this.bounds.x + 1)) + "px";
                this.textarea.style.top = Math.max(0, Math.round(this.bounds.y + 1)) + "px";
              }
              if (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML != this.getEmptyLabelText()) {
                this.textarea.style.wordWrap = mxConstants.WORD_WRAP;
                this.textarea.style.whiteSpace = "normal";
                if (state.style[mxConstants.STYLE_OVERFLOW] != "fill") {
                  this.textarea.style.width = Math.round(this.bounds.width / scale) + this.wordWrapPadding + "px";
                }
              } else {
                this.textarea.style.whiteSpace = "nowrap";
                if (state.style[mxConstants.STYLE_OVERFLOW] != "fill") {
                  this.textarea.style.width = "";
                }
              }
            } else {
              var lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);
              m = state.text != null && this.align == null ? state.text.margin : null;
              if (m == null) {
                m = mxUtils.getAlignmentAsPoint(
                  this.align || mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER),
                  mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE)
                );
              }
              if (isEdge) {
                this.bounds = new mxRectangle(state.absoluteOffset.x, state.absoluteOffset.y, 0, 0);
                if (lw != null) {
                  var tmp = (parseFloat(lw) + 2) * scale;
                  this.bounds.width = tmp;
                  this.bounds.x += m.x * tmp;
                }
              } else {
                var bds = mxRectangle.fromRectangle(state);
                var hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
                var vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
                bds = state.shape != null && hpos == mxConstants.ALIGN_CENTER && vpos == mxConstants.ALIGN_MIDDLE ? state.shape.getLabelBounds(bds) : bds;
                if (lw != null) {
                  bds.width = parseFloat(lw) * scale;
                }
                if (!state.view.graph.cellRenderer.legacySpacing || state.style[mxConstants.STYLE_OVERFLOW] != "width") {
                  var spacing = parseInt(state.style[mxConstants.STYLE_SPACING] || 2) * scale;
                  var spacingTop = (parseInt(state.style[mxConstants.STYLE_SPACING_TOP] || 0) + mxText.prototype.baseSpacingTop) * scale + spacing;
                  var spacingRight = (parseInt(state.style[mxConstants.STYLE_SPACING_RIGHT] || 0) + mxText.prototype.baseSpacingRight) * scale + spacing;
                  var spacingBottom = (parseInt(state.style[mxConstants.STYLE_SPACING_BOTTOM] || 0) + mxText.prototype.baseSpacingBottom) * scale + spacing;
                  var spacingLeft = (parseInt(state.style[mxConstants.STYLE_SPACING_LEFT] || 0) + mxText.prototype.baseSpacingLeft) * scale + spacing;
                  var hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
                  var vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
                  bds = new mxRectangle(
                    bds.x + spacingLeft,
                    bds.y + spacingTop,
                    bds.width - (hpos == mxConstants.ALIGN_CENTER && lw == null ? spacingLeft + spacingRight : 0),
                    bds.height - (vpos == mxConstants.ALIGN_MIDDLE ? spacingTop + spacingBottom : 0)
                  );
                }
                this.bounds = new mxRectangle(bds.x + state.absoluteOffset.x, bds.y + state.absoluteOffset.y, bds.width, bds.height);
              }
              if (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML != this.getEmptyLabelText()) {
                this.textarea.style.wordWrap = mxConstants.WORD_WRAP;
                this.textarea.style.whiteSpace = "normal";
                var tmp = Math.round(this.bounds.width / (document.documentMode == 8 ? scale : scale)) + this.wordWrapPadding;
                if (this.textarea.style.position != "relative") {
                  this.textarea.style.width = tmp + "px";
                  if (this.textarea.scrollWidth > tmp) {
                    this.textarea.style.width = this.textarea.scrollWidth + "px";
                  }
                } else {
                  this.textarea.style.maxWidth = tmp + "px";
                }
              } else {
                this.textarea.style.whiteSpace = "nowrap";
                this.textarea.style.width = "";
              }
              if (document.documentMode == 8) {
                this.textarea.style.zoom = "1";
                this.textarea.style.height = "auto";
              }
              var ow = this.textarea.scrollWidth;
              var oh = this.textarea.scrollHeight;
              if (document.documentMode == 8) {
                this.textarea.style.left = Math.max(0, Math.ceil((this.bounds.x - m.x * (this.bounds.width - (ow + 1) * scale) + ow * (scale - 1) * 0 + (m.x + 0.5) * 2) / scale)) + "px";
                this.textarea.style.top = Math.max(0, Math.ceil((this.bounds.y - m.y * (this.bounds.height - (oh + 0.5) * scale) + oh * (scale - 1) * 0 + Math.abs(m.y + 0.5) * 1) / scale)) + "px";
                this.textarea.style.width = Math.round(ow * scale) + "px";
                this.textarea.style.height = Math.round(oh * scale) + "px";
              } else if (mxClient.IS_QUIRKS) {
                this.textarea.style.left = Math.max(0, Math.ceil(this.bounds.x - m.x * (this.bounds.width - (ow + 1) * scale) + ow * (scale - 1) * 0 + (m.x + 0.5) * 2)) + "px";
                this.textarea.style.top = Math.max(0, Math.ceil(this.bounds.y - m.y * (this.bounds.height - (oh + 0.5) * scale) + oh * (scale - 1) * 0 + Math.abs(m.y + 0.5) * 1)) + "px";
              } else {
                this.textarea.style.left = Math.max(0, Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1) + "px";
                this.textarea.style.top = Math.max(0, Math.round(this.bounds.y - m.y * (this.bounds.height - 4) + (m.y == -1 ? 3 : 0)) + 1) + "px";
              }
            }
            if (mxClient.IS_VML) {
              this.textarea.style.zoom = scale;
            } else {
              mxUtils.setPrefixedStyle(this.textarea.style, "transformOrigin", "0px 0px");
              mxUtils.setPrefixedStyle(
                this.textarea.style,
                "transform",
                "scale(" + scale + "," + scale + ")" + (m == null ? "" : " translate(" + m.x * 100 + "%," + m.y * 100 + "%)")
              );
            }
          }
        };
        mxCellEditor.prototype.focusLost = function() {
          this.stopEditing(!this.graph.isInvokesStopCellEditing());
        };
        mxCellEditor.prototype.getBackgroundColor = function(state) {
          return null;
        };
        mxCellEditor.prototype.isLegacyEditor = function() {
          if (mxClient.IS_VML) {
            return true;
          } else {
            var absoluteRoot = false;
            if (mxClient.IS_SVG) {
              var root = this.graph.view.getDrawPane().ownerSVGElement;
              if (root != null) {
                var css = mxUtils.getCurrentStyle(root);
                if (css != null) {
                  absoluteRoot = css.position == "absolute";
                }
              }
            }
            return !absoluteRoot;
          }
        };
        mxCellEditor.prototype.startEditing = function(cell2, trigger) {
          this.stopEditing(true);
          this.align = null;
          if (this.textarea == null) {
            this.init();
          }
          if (this.graph.tooltipHandler != null) {
            this.graph.tooltipHandler.hideTooltip();
          }
          var state = this.graph.getView().getState(cell2);
          if (state != null) {
            var scale = this.graph.getView().scale;
            var size = mxUtils.getValue(state.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE);
            var family = mxUtils.getValue(state.style, mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY);
            var color = mxUtils.getValue(state.style, mxConstants.STYLE_FONTCOLOR, "black");
            var align = mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_LEFT);
            var bold = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD;
            var italic = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC;
            var txtDecor = [];
            if ((mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {
              txtDecor.push("underline");
            }
            if ((mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH) {
              txtDecor.push("line-through");
            }
            this.textarea.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? Math.round(size * mxConstants.LINE_HEIGHT) + "px" : mxConstants.LINE_HEIGHT;
            this.textarea.style.backgroundColor = this.getBackgroundColor(state);
            this.textarea.style.textDecoration = txtDecor.join(" ");
            this.textarea.style.fontWeight = bold ? "bold" : "normal";
            this.textarea.style.fontStyle = italic ? "italic" : "";
            this.textarea.style.fontSize = Math.round(size) + "px";
            this.textarea.style.zIndex = this.zIndex;
            this.textarea.style.fontFamily = family;
            this.textarea.style.textAlign = align;
            this.textarea.style.outline = "none";
            this.textarea.style.color = color;
            var dir = this.textDirection = mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);
            if (dir == mxConstants.TEXT_DIRECTION_AUTO) {
              if (state != null && state.text != null && state.text.dialect != mxConstants.DIALECT_STRICTHTML && !mxUtils.isNode(state.text.value)) {
                dir = state.text.getAutoDirection();
              }
            }
            if (dir == mxConstants.TEXT_DIRECTION_LTR || dir == mxConstants.TEXT_DIRECTION_RTL) {
              this.textarea.setAttribute("dir", dir);
            } else {
              this.textarea.removeAttribute("dir");
            }
            this.textarea.innerHTML = this.getInitialValue(state, trigger) || "";
            this.initialValue = this.textarea.innerHTML;
            if (this.textarea.innerHTML.length == 0 || this.textarea.innerHTML == "<br>") {
              this.textarea.innerHTML = this.getEmptyLabelText();
              this.clearOnChange = true;
            } else {
              this.clearOnChange = this.textarea.innerHTML == this.getEmptyLabelText();
            }
            this.graph.container.appendChild(this.textarea);
            this.editingCell = cell2;
            this.trigger = trigger;
            this.textNode = null;
            if (state.text != null && this.isHideLabel(state)) {
              this.textNode = state.text.node;
              this.textNode.style.visibility = "hidden";
            }
            if (this.autoSize && (this.graph.model.isEdge(state.cell) || state.style[mxConstants.STYLE_OVERFLOW] != "fill")) {
              window.setTimeout(mxUtils.bind(this, function() {
                this.resize();
              }), 0);
            }
            this.resize();
            try {
              this.textarea.focus();
              if (this.isSelectText() && this.textarea.innerHTML.length > 0 && (this.textarea.innerHTML != this.getEmptyLabelText() || !this.clearOnChange)) {
                document.execCommand("selectAll", false, null);
              }
            } catch (e) {
            }
          }
        };
        mxCellEditor.prototype.isSelectText = function() {
          return this.selectText;
        };
        mxCellEditor.prototype.clearSelection = function() {
          var selection = null;
          if (window.getSelection) {
            selection = window.getSelection();
          } else if (document.selection) {
            selection = document.selection;
          }
          if (selection != null) {
            if (selection.empty) {
              selection.empty();
            } else if (selection.removeAllRanges) {
              selection.removeAllRanges();
            }
          }
        };
        mxCellEditor.prototype.stopEditing = function(cancel) {
          cancel = cancel || false;
          if (this.editingCell != null) {
            if (this.textNode != null) {
              this.textNode.style.visibility = "visible";
              this.textNode = null;
            }
            var state = !cancel ? this.graph.view.getState(this.editingCell) : null;
            var initial = this.initialValue;
            this.initialValue = null;
            this.editingCell = null;
            this.trigger = null;
            this.bounds = null;
            this.textarea.blur();
            this.clearSelection();
            if (this.textarea.parentNode != null) {
              this.textarea.parentNode.removeChild(this.textarea);
            }
            if (this.clearOnChange && this.textarea.innerHTML == this.getEmptyLabelText()) {
              this.textarea.innerHTML = "";
              this.clearOnChange = false;
            }
            if (state != null && (this.textarea.innerHTML != initial || this.align != null)) {
              this.prepareTextarea();
              var value = this.getCurrentValue(state);
              this.graph.getModel().beginUpdate();
              try {
                if (value != null) {
                  this.applyValue(state, value);
                }
                if (this.align != null) {
                  this.graph.setCellStyles(mxConstants.STYLE_ALIGN, this.align, [state.cell]);
                }
              } finally {
                this.graph.getModel().endUpdate();
              }
            }
            mxEvent.release(this.textarea);
            this.textarea = null;
            this.align = null;
          }
        };
        mxCellEditor.prototype.prepareTextarea = function() {
          if (this.textarea.lastChild != null && this.textarea.lastChild.nodeName == "BR") {
            this.textarea.removeChild(this.textarea.lastChild);
          }
        };
        mxCellEditor.prototype.isHideLabel = function(state) {
          return true;
        };
        mxCellEditor.prototype.getMinimumSize = function(state) {
          var scale = this.graph.getView().scale;
          return new mxRectangle(
            0,
            0,
            state.text == null ? 30 : state.text.size * scale + 20,
            this.textarea.style.textAlign == "left" ? 120 : 40
          );
        };
        mxCellEditor.prototype.getEditorBounds = function(state) {
          var isEdge = this.graph.getModel().isEdge(state.cell);
          var scale = this.graph.getView().scale;
          var minSize = this.getMinimumSize(state);
          var minWidth = minSize.width;
          var minHeight = minSize.height;
          var result2 = null;
          if (!isEdge && state.view.graph.cellRenderer.legacySpacing && state.style[mxConstants.STYLE_OVERFLOW] == "fill") {
            result2 = state.shape.getLabelBounds(mxRectangle.fromRectangle(state));
          } else {
            var spacing = parseInt(state.style[mxConstants.STYLE_SPACING] || 0) * scale;
            var spacingTop = (parseInt(state.style[mxConstants.STYLE_SPACING_TOP] || 0) + mxText.prototype.baseSpacingTop) * scale + spacing;
            var spacingRight = (parseInt(state.style[mxConstants.STYLE_SPACING_RIGHT] || 0) + mxText.prototype.baseSpacingRight) * scale + spacing;
            var spacingBottom = (parseInt(state.style[mxConstants.STYLE_SPACING_BOTTOM] || 0) + mxText.prototype.baseSpacingBottom) * scale + spacing;
            var spacingLeft = (parseInt(state.style[mxConstants.STYLE_SPACING_LEFT] || 0) + mxText.prototype.baseSpacingLeft) * scale + spacing;
            result2 = new mxRectangle(
              state.x,
              state.y,
              Math.max(minWidth, state.width - spacingLeft - spacingRight),
              Math.max(minHeight, state.height - spacingTop - spacingBottom)
            );
            var hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
            var vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
            result2 = state.shape != null && hpos == mxConstants.ALIGN_CENTER && vpos == mxConstants.ALIGN_MIDDLE ? state.shape.getLabelBounds(result2) : result2;
            if (isEdge) {
              result2.x = state.absoluteOffset.x;
              result2.y = state.absoluteOffset.y;
              if (state.text != null && state.text.boundingBox != null) {
                if (state.text.boundingBox.x > 0) {
                  result2.x = state.text.boundingBox.x;
                }
                if (state.text.boundingBox.y > 0) {
                  result2.y = state.text.boundingBox.y;
                }
              }
            } else if (state.text != null && state.text.boundingBox != null) {
              result2.x = Math.min(result2.x, state.text.boundingBox.x);
              result2.y = Math.min(result2.y, state.text.boundingBox.y);
            }
            result2.x += spacingLeft;
            result2.y += spacingTop;
            if (state.text != null && state.text.boundingBox != null) {
              if (!isEdge) {
                result2.width = Math.max(result2.width, state.text.boundingBox.width);
                result2.height = Math.max(result2.height, state.text.boundingBox.height);
              } else {
                result2.width = Math.max(minWidth, state.text.boundingBox.width);
                result2.height = Math.max(minHeight, state.text.boundingBox.height);
              }
            }
            if (this.graph.getModel().isVertex(state.cell)) {
              var horizontal = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
              if (horizontal == mxConstants.ALIGN_LEFT) {
                result2.x -= state.width;
              } else if (horizontal == mxConstants.ALIGN_RIGHT) {
                result2.x += state.width;
              }
              var vertical = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
              if (vertical == mxConstants.ALIGN_TOP) {
                result2.y -= state.height;
              } else if (vertical == mxConstants.ALIGN_BOTTOM) {
                result2.y += state.height;
              }
            }
          }
          return new mxRectangle(Math.round(result2.x), Math.round(result2.y), Math.round(result2.width), Math.round(result2.height));
        };
        mxCellEditor.prototype.getEmptyLabelText = function(cell2) {
          return this.emptyLabelText;
        };
        mxCellEditor.prototype.getEditingCell = function() {
          return this.editingCell;
        };
        mxCellEditor.prototype.destroy = function() {
          if (this.textarea != null) {
            mxEvent.release(this.textarea);
            if (this.textarea.parentNode != null) {
              this.textarea.parentNode.removeChild(this.textarea);
            }
            this.textarea = null;
          }
          if (this.changeHandler != null) {
            this.graph.getModel().removeListener(this.changeHandler);
            this.changeHandler = null;
          }
          if (this.zoomHandler) {
            this.graph.view.removeListener(this.zoomHandler);
            this.zoomHandler = null;
          }
        };
        __mxOutput.mxCellEditor = typeof mxCellEditor !== "undefined" ? mxCellEditor : void 0;
        function mxCellRenderer() {
        }
        ;
        mxCellRenderer.defaultShapes = new Object();
        mxCellRenderer.prototype.defaultEdgeShape = mxConnector;
        mxCellRenderer.prototype.defaultVertexShape = mxRectangleShape;
        mxCellRenderer.prototype.defaultTextShape = mxText;
        mxCellRenderer.prototype.legacyControlPosition = true;
        mxCellRenderer.prototype.legacySpacing = true;
        mxCellRenderer.prototype.antiAlias = true;
        mxCellRenderer.prototype.minSvgStrokeWidth = 1;
        mxCellRenderer.prototype.forceControlClickHandler = false;
        mxCellRenderer.registerShape = function(key, shape2) {
          mxCellRenderer.defaultShapes[key] = shape2;
        };
        mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);
        mxCellRenderer.registerShape(mxConstants.SHAPE_ELLIPSE, mxEllipse);
        mxCellRenderer.registerShape(mxConstants.SHAPE_RHOMBUS, mxRhombus);
        mxCellRenderer.registerShape(mxConstants.SHAPE_CYLINDER, mxCylinder);
        mxCellRenderer.registerShape(mxConstants.SHAPE_CONNECTOR, mxConnector);
        mxCellRenderer.registerShape(mxConstants.SHAPE_ACTOR, mxActor);
        mxCellRenderer.registerShape(mxConstants.SHAPE_TRIANGLE, mxTriangle);
        mxCellRenderer.registerShape(mxConstants.SHAPE_HEXAGON, mxHexagon);
        mxCellRenderer.registerShape(mxConstants.SHAPE_CLOUD, mxCloud);
        mxCellRenderer.registerShape(mxConstants.SHAPE_LINE, mxLine);
        mxCellRenderer.registerShape(mxConstants.SHAPE_ARROW, mxArrow);
        mxCellRenderer.registerShape(mxConstants.SHAPE_ARROW_CONNECTOR, mxArrowConnector);
        mxCellRenderer.registerShape(mxConstants.SHAPE_DOUBLE_ELLIPSE, mxDoubleEllipse);
        mxCellRenderer.registerShape(mxConstants.SHAPE_SWIMLANE, mxSwimlane);
        mxCellRenderer.registerShape(mxConstants.SHAPE_IMAGE, mxImageShape);
        mxCellRenderer.registerShape(mxConstants.SHAPE_LABEL, mxLabel);
        mxCellRenderer.prototype.initializeShape = function(state) {
          state.shape.dialect = state.view.graph.dialect;
          this.configureShape(state);
          state.shape.init(state.view.getDrawPane());
        };
        mxCellRenderer.prototype.createShape = function(state) {
          var shape2 = null;
          if (state.style != null) {
            var stencil = mxStencilRegistry.getStencil(state.style[mxConstants.STYLE_SHAPE]);
            if (stencil != null) {
              shape2 = new mxShape(stencil);
            } else {
              var ctor = this.getShapeConstructor(state);
              shape2 = new ctor();
            }
          }
          return shape2;
        };
        mxCellRenderer.prototype.createIndicatorShape = function(state) {
          state.shape.indicatorShape = this.getShape(state.view.graph.getIndicatorShape(state));
        };
        mxCellRenderer.prototype.getShape = function(name2) {
          return name2 != null ? mxCellRenderer.defaultShapes[name2] : null;
        };
        mxCellRenderer.prototype.getShapeConstructor = function(state) {
          var ctor = this.getShape(state.style[mxConstants.STYLE_SHAPE]);
          if (ctor == null) {
            ctor = state.view.graph.getModel().isEdge(state.cell) ? this.defaultEdgeShape : this.defaultVertexShape;
          }
          return ctor;
        };
        mxCellRenderer.prototype.configureShape = function(state) {
          state.shape.apply(state);
          state.shape.image = state.view.graph.getImage(state);
          state.shape.indicatorColor = state.view.graph.getIndicatorColor(state);
          state.shape.indicatorStrokeColor = state.style[mxConstants.STYLE_INDICATOR_STROKECOLOR];
          state.shape.indicatorGradientColor = state.view.graph.getIndicatorGradientColor(state);
          state.shape.indicatorDirection = state.style[mxConstants.STYLE_INDICATOR_DIRECTION];
          state.shape.indicatorImage = state.view.graph.getIndicatorImage(state);
          this.postConfigureShape(state);
        };
        mxCellRenderer.prototype.postConfigureShape = function(state) {
          if (state.shape != null) {
            this.resolveColor(state, "indicatorGradientColor", mxConstants.STYLE_GRADIENTCOLOR);
            this.resolveColor(state, "indicatorColor", mxConstants.STYLE_FILLCOLOR);
            this.resolveColor(state, "gradient", mxConstants.STYLE_GRADIENTCOLOR);
            this.resolveColor(state, "stroke", mxConstants.STYLE_STROKECOLOR);
            this.resolveColor(state, "fill", mxConstants.STYLE_FILLCOLOR);
          }
        };
        mxCellRenderer.prototype.checkPlaceholderStyles = function(state) {
          if (state.style != null) {
            var values = ["inherit", "swimlane", "indicated"];
            var styles = [
              mxConstants.STYLE_FILLCOLOR,
              mxConstants.STYLE_STROKECOLOR,
              mxConstants.STYLE_GRADIENTCOLOR,
              mxConstants.STYLE_FONTCOLOR
            ];
            for (var i = 0; i < styles.length; i++) {
              if (mxUtils.indexOf(values, state.style[styles[i]]) >= 0) {
                return true;
              }
            }
          }
          return false;
        };
        mxCellRenderer.prototype.resolveColor = function(state, field, key) {
          var shape2 = key == mxConstants.STYLE_FONTCOLOR ? state.text : state.shape;
          if (shape2 != null) {
            var graph = state.view.graph;
            var value = shape2[field];
            var referenced = null;
            if (value == "inherit") {
              referenced = graph.model.getParent(state.cell);
            } else if (value == "swimlane") {
              shape2[field] = key == mxConstants.STYLE_STROKECOLOR || key == mxConstants.STYLE_FONTCOLOR ? "#000000" : "#ffffff";
              if (graph.model.getTerminal(state.cell, false) != null) {
                referenced = graph.model.getTerminal(state.cell, false);
              } else {
                referenced = state.cell;
              }
              referenced = graph.getSwimlane(referenced);
              key = graph.swimlaneIndicatorColorAttribute;
            } else if (value == "indicated" && state.shape != null) {
              shape2[field] = state.shape.indicatorColor;
            } else if (key != mxConstants.STYLE_FILLCOLOR && value == mxConstants.STYLE_FILLCOLOR && state.shape != null) {
              shape2[field] = state.style[mxConstants.STYLE_FILLCOLOR];
            } else if (key != mxConstants.STYLE_STROKECOLOR && value == mxConstants.STYLE_STROKECOLOR && state.shape != null) {
              shape2[field] = state.style[mxConstants.STYLE_STROKECOLOR];
            }
            if (referenced != null) {
              var rstate = graph.getView().getState(referenced);
              shape2[field] = null;
              if (rstate != null) {
                var rshape = key == mxConstants.STYLE_FONTCOLOR ? rstate.text : rstate.shape;
                if (rshape != null && field != "indicatorColor") {
                  shape2[field] = rshape[field];
                } else {
                  shape2[field] = rstate.style[key];
                }
              }
            }
          }
        };
        mxCellRenderer.prototype.getLabelValue = function(state) {
          return state.view.graph.getLabel(state.cell);
        };
        mxCellRenderer.prototype.createLabel = function(state, value) {
          var graph = state.view.graph;
          var isEdge = graph.getModel().isEdge(state.cell);
          if (state.style[mxConstants.STYLE_FONTSIZE] > 0 || state.style[mxConstants.STYLE_FONTSIZE] == null) {
            var isForceHtml = graph.isHtmlLabel(state.cell) || value != null && mxUtils.isNode(value);
            state.text = new this.defaultTextShape(
              value,
              new mxRectangle(),
              state.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER,
              graph.getVerticalAlign(state),
              state.style[mxConstants.STYLE_FONTCOLOR],
              state.style[mxConstants.STYLE_FONTFAMILY],
              state.style[mxConstants.STYLE_FONTSIZE],
              state.style[mxConstants.STYLE_FONTSTYLE],
              state.style[mxConstants.STYLE_SPACING],
              state.style[mxConstants.STYLE_SPACING_TOP],
              state.style[mxConstants.STYLE_SPACING_RIGHT],
              state.style[mxConstants.STYLE_SPACING_BOTTOM],
              state.style[mxConstants.STYLE_SPACING_LEFT],
              state.style[mxConstants.STYLE_HORIZONTAL],
              state.style[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR],
              state.style[mxConstants.STYLE_LABEL_BORDERCOLOR],
              graph.isWrapping(state.cell) && graph.isHtmlLabel(state.cell),
              graph.isLabelClipped(state.cell),
              state.style[mxConstants.STYLE_OVERFLOW],
              state.style[mxConstants.STYLE_LABEL_PADDING],
              mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION)
            );
            state.text.opacity = mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_OPACITY, 100);
            state.text.dialect = isForceHtml ? mxConstants.DIALECT_STRICTHTML : state.view.graph.dialect;
            state.text.style = state.style;
            state.text.state = state;
            this.initializeLabel(state, state.text);
            var forceGetCell = false;
            var getState = function(evt) {
              var result2 = state;
              if (mxClient.IS_TOUCH || forceGetCell) {
                var x = mxEvent.getClientX(evt);
                var y = mxEvent.getClientY(evt);
                var pt = mxUtils.convertPoint(graph.container, x, y);
                result2 = graph.view.getState(graph.getCellAt(pt.x, pt.y));
              }
              return result2;
            };
            mxEvent.addGestureListeners(
              state.text.node,
              mxUtils.bind(this, function(evt) {
                if (this.isLabelEvent(state, evt)) {
                  graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));
                  forceGetCell = graph.dialect != mxConstants.DIALECT_SVG && mxEvent.getSource(evt).nodeName == "IMG";
                }
              }),
              mxUtils.bind(this, function(evt) {
                if (this.isLabelEvent(state, evt)) {
                  graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));
                }
              }),
              mxUtils.bind(this, function(evt) {
                if (this.isLabelEvent(state, evt)) {
                  graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, getState(evt)));
                  forceGetCell = false;
                }
              })
            );
            if (graph.nativeDblClickEnabled) {
              mxEvent.addListener(
                state.text.node,
                "dblclick",
                mxUtils.bind(this, function(evt) {
                  if (this.isLabelEvent(state, evt)) {
                    graph.dblClick(evt, state.cell);
                    mxEvent.consume(evt);
                  }
                })
              );
            }
          }
        };
        mxCellRenderer.prototype.initializeLabel = function(state, shape2) {
          if (mxClient.IS_SVG && mxClient.NO_FO && shape2.dialect != mxConstants.DIALECT_SVG) {
            shape2.init(state.view.graph.container);
          } else {
            shape2.init(state.view.getDrawPane());
          }
        };
        mxCellRenderer.prototype.createCellOverlays = function(state) {
          var graph = state.view.graph;
          var overlays = graph.getCellOverlays(state.cell);
          var dict = null;
          if (overlays != null) {
            dict = new mxDictionary();
            for (var i = 0; i < overlays.length; i++) {
              var shape2 = state.overlays != null ? state.overlays.remove(overlays[i]) : null;
              if (shape2 == null) {
                var tmp = new mxImageShape(new mxRectangle(), overlays[i].image.src);
                tmp.dialect = state.view.graph.dialect;
                tmp.preserveImageAspect = false;
                tmp.overlay = overlays[i];
                this.initializeOverlay(state, tmp);
                this.installCellOverlayListeners(state, overlays[i], tmp);
                if (overlays[i].cursor != null) {
                  tmp.node.style.cursor = overlays[i].cursor;
                }
                dict.put(overlays[i], tmp);
              } else {
                dict.put(overlays[i], shape2);
              }
            }
          }
          if (state.overlays != null) {
            state.overlays.visit(function(id, shape3) {
              shape3.destroy();
            });
          }
          state.overlays = dict;
        };
        mxCellRenderer.prototype.initializeOverlay = function(state, overlay) {
          overlay.init(state.view.getOverlayPane());
        };
        mxCellRenderer.prototype.installCellOverlayListeners = function(state, overlay, shape2) {
          var graph = state.view.graph;
          mxEvent.addListener(shape2.node, "click", function(evt) {
            if (graph.isEditing()) {
              graph.stopEditing(!graph.isInvokesStopCellEditing());
            }
            overlay.fireEvent(new mxEventObject(
              mxEvent.CLICK,
              "event",
              evt,
              "cell",
              state.cell
            ));
          });
          mxEvent.addGestureListeners(
            shape2.node,
            function(evt) {
              mxEvent.consume(evt);
            },
            function(evt) {
              graph.fireMouseEvent(
                mxEvent.MOUSE_MOVE,
                new mxMouseEvent(evt, state)
              );
            }
          );
          if (mxClient.IS_TOUCH) {
            mxEvent.addListener(shape2.node, "touchend", function(evt) {
              overlay.fireEvent(new mxEventObject(
                mxEvent.CLICK,
                "event",
                evt,
                "cell",
                state.cell
              ));
            });
          }
        };
        mxCellRenderer.prototype.createControl = function(state) {
          var graph = state.view.graph;
          var image = graph.getFoldingImage(state);
          if (graph.foldingEnabled && image != null) {
            if (state.control == null) {
              var b = new mxRectangle(0, 0, image.width, image.height);
              state.control = new mxImageShape(b, image.src);
              state.control.preserveImageAspect = false;
              state.control.dialect = graph.dialect;
              this.initControl(state, state.control, true, this.createControlClickHandler(state));
            }
          } else if (state.control != null) {
            state.control.destroy();
            state.control = null;
          }
        };
        mxCellRenderer.prototype.createControlClickHandler = function(state) {
          var graph = state.view.graph;
          return mxUtils.bind(this, function(evt) {
            if (this.forceControlClickHandler || graph.isEnabled()) {
              var collapse = !graph.isCellCollapsed(state.cell);
              graph.foldCells(collapse, false, [state.cell], null, evt);
              mxEvent.consume(evt);
            }
          });
        };
        mxCellRenderer.prototype.initControl = function(state, control, handleEvents, clickHandler) {
          var graph = state.view.graph;
          var isForceHtml = graph.isHtmlLabel(state.cell) && mxClient.NO_FO && graph.dialect == mxConstants.DIALECT_SVG;
          if (isForceHtml) {
            control.dialect = mxConstants.DIALECT_PREFERHTML;
            control.init(graph.container);
            control.node.style.zIndex = 1;
          } else {
            control.init(state.view.getOverlayPane());
          }
          var node = control.innerNode || control.node;
          if (clickHandler != null && !mxClient.IS_IOS) {
            if (graph.isEnabled()) {
              node.style.cursor = "pointer";
            }
            mxEvent.addListener(node, "click", clickHandler);
          }
          if (handleEvents) {
            var first = null;
            mxEvent.addGestureListeners(
              node,
              function(evt) {
                first = new mxPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt));
                graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));
                mxEvent.consume(evt);
              },
              function(evt) {
                graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, state));
              },
              function(evt) {
                graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, state));
                mxEvent.consume(evt);
              }
            );
            if (clickHandler != null && mxClient.IS_IOS) {
              node.addEventListener("touchend", function(evt) {
                if (first != null) {
                  var tol = graph.tolerance;
                  if (Math.abs(first.x - mxEvent.getClientX(evt)) < tol && Math.abs(first.y - mxEvent.getClientY(evt)) < tol) {
                    clickHandler.call(clickHandler, evt);
                    mxEvent.consume(evt);
                  }
                }
              }, true);
            }
          }
          return node;
        };
        mxCellRenderer.prototype.isShapeEvent = function(state, evt) {
          return true;
        };
        mxCellRenderer.prototype.isLabelEvent = function(state, evt) {
          return true;
        };
        mxCellRenderer.prototype.installListeners = function(state) {
          var graph = state.view.graph;
          var getState = function(evt) {
            var result2 = state;
            if (graph.dialect != mxConstants.DIALECT_SVG && mxEvent.getSource(evt).nodeName == "IMG" || mxClient.IS_TOUCH) {
              var x = mxEvent.getClientX(evt);
              var y = mxEvent.getClientY(evt);
              var pt = mxUtils.convertPoint(graph.container, x, y);
              result2 = graph.view.getState(graph.getCellAt(pt.x, pt.y));
            }
            return result2;
          };
          mxEvent.addGestureListeners(
            state.shape.node,
            mxUtils.bind(this, function(evt) {
              if (this.isShapeEvent(state, evt)) {
                graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));
              }
            }),
            mxUtils.bind(this, function(evt) {
              if (this.isShapeEvent(state, evt)) {
                graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));
              }
            }),
            mxUtils.bind(this, function(evt) {
              if (this.isShapeEvent(state, evt)) {
                graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, getState(evt)));
              }
            })
          );
          if (graph.nativeDblClickEnabled) {
            mxEvent.addListener(
              state.shape.node,
              "dblclick",
              mxUtils.bind(this, function(evt) {
                if (this.isShapeEvent(state, evt)) {
                  graph.dblClick(evt, state.cell);
                  mxEvent.consume(evt);
                }
              })
            );
          }
        };
        mxCellRenderer.prototype.redrawLabel = function(state, forced) {
          var graph = state.view.graph;
          var value = this.getLabelValue(state);
          var wrapping = graph.isWrapping(state.cell);
          var clipping = graph.isLabelClipped(state.cell);
          var isForceHtml = state.view.graph.isHtmlLabel(state.cell) || value != null && mxUtils.isNode(value);
          var dialect = isForceHtml ? mxConstants.DIALECT_STRICTHTML : state.view.graph.dialect;
          var overflow = state.style[mxConstants.STYLE_OVERFLOW] || "visible";
          if (state.text != null && (state.text.wrap != wrapping || state.text.clipped != clipping || state.text.overflow != overflow || state.text.dialect != dialect)) {
            state.text.destroy();
            state.text = null;
          }
          if (state.text == null && value != null && (mxUtils.isNode(value) || value.length > 0)) {
            this.createLabel(state, value);
          } else if (state.text != null && (value == null || value.length == 0)) {
            state.text.destroy();
            state.text = null;
          }
          if (state.text != null) {
            if (forced) {
              if (state.text.lastValue != null && this.isTextShapeInvalid(state, state.text)) {
                state.text.lastValue = null;
              }
              state.text.resetStyles();
              state.text.apply(state);
              state.text.valign = graph.getVerticalAlign(state);
            }
            var bounds = this.getLabelBounds(state);
            var nextScale = this.getTextScale(state);
            this.resolveColor(state, "color", mxConstants.STYLE_FONTCOLOR);
            if (forced || state.text.value != value || state.text.isWrapping != wrapping || state.text.overflow != overflow || state.text.isClipping != clipping || state.text.scale != nextScale || state.text.dialect != dialect || state.text.bounds == null || !state.text.bounds.equals(bounds)) {
              state.text.dialect = dialect;
              state.text.value = value;
              state.text.bounds = bounds;
              state.text.scale = nextScale;
              state.text.wrap = wrapping;
              state.text.clipped = clipping;
              state.text.overflow = overflow;
              var vis = state.text.node.style.visibility;
              this.redrawLabelShape(state.text);
              state.text.node.style.visibility = vis;
            }
          }
        };
        mxCellRenderer.prototype.isTextShapeInvalid = function(state, shape2) {
          function check(property, stylename, defaultValue) {
            var result2 = false;
            if (stylename == "spacingTop" || stylename == "spacingRight" || stylename == "spacingBottom" || stylename == "spacingLeft") {
              result2 = parseFloat(shape2[property]) - parseFloat(shape2.spacing) != (state.style[stylename] || defaultValue);
            } else {
              result2 = shape2[property] != (state.style[stylename] || defaultValue);
            }
            return result2;
          }
          ;
          return check("fontStyle", mxConstants.STYLE_FONTSTYLE, mxConstants.DEFAULT_FONTSTYLE) || check("family", mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY) || check("size", mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE) || check("color", mxConstants.STYLE_FONTCOLOR, "black") || check("align", mxConstants.STYLE_ALIGN, "") || check("valign", mxConstants.STYLE_VERTICAL_ALIGN, "") || check("spacing", mxConstants.STYLE_SPACING, 2) || check("spacingTop", mxConstants.STYLE_SPACING_TOP, 0) || check("spacingRight", mxConstants.STYLE_SPACING_RIGHT, 0) || check("spacingBottom", mxConstants.STYLE_SPACING_BOTTOM, 0) || check("spacingLeft", mxConstants.STYLE_SPACING_LEFT, 0) || check("horizontal", mxConstants.STYLE_HORIZONTAL, true) || check("background", mxConstants.STYLE_LABEL_BACKGROUNDCOLOR) || check("border", mxConstants.STYLE_LABEL_BORDERCOLOR) || check("opacity", mxConstants.STYLE_TEXT_OPACITY, 100) || check("textDirection", mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);
        };
        mxCellRenderer.prototype.redrawLabelShape = function(shape2) {
          shape2.redraw();
        };
        mxCellRenderer.prototype.getTextScale = function(state) {
          return state.view.scale;
        };
        mxCellRenderer.prototype.getLabelBounds = function(state) {
          var graph = state.view.graph;
          var scale = state.view.scale;
          var isEdge = graph.getModel().isEdge(state.cell);
          var bounds = new mxRectangle(state.absoluteOffset.x, state.absoluteOffset.y);
          if (isEdge) {
            var spacing = state.text.getSpacing();
            bounds.x += spacing.x * scale;
            bounds.y += spacing.y * scale;
            var geo = graph.getCellGeometry(state.cell);
            if (geo != null) {
              bounds.width = Math.max(0, geo.width * scale);
              bounds.height = Math.max(0, geo.height * scale);
            }
          } else {
            if (state.text.isPaintBoundsInverted()) {
              var tmp = bounds.x;
              bounds.x = bounds.y;
              bounds.y = tmp;
            }
            bounds.x += state.x;
            bounds.y += state.y;
            bounds.width = Math.max(1, state.width);
            bounds.height = Math.max(1, state.height);
          }
          if (state.text.isPaintBoundsInverted()) {
            var t = (state.width - state.height) / 2;
            bounds.x += t;
            bounds.y -= t;
            var tmp = bounds.width;
            bounds.width = bounds.height;
            bounds.height = tmp;
          }
          if (state.shape != null) {
            var hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
            var vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
            if (hpos == mxConstants.ALIGN_CENTER && vpos == mxConstants.ALIGN_MIDDLE) {
              bounds = state.shape.getLabelBounds(bounds);
            }
          }
          var lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);
          if (lw != null) {
            bounds.width = parseFloat(lw) * scale;
          }
          if (!isEdge) {
            this.rotateLabelBounds(state, bounds);
          }
          return bounds;
        };
        mxCellRenderer.prototype.rotateLabelBounds = function(state, bounds) {
          bounds.y -= state.text.margin.y * bounds.height;
          bounds.x -= state.text.margin.x * bounds.width;
          if (!this.legacySpacing || state.style[mxConstants.STYLE_OVERFLOW] != "fill" && state.style[mxConstants.STYLE_OVERFLOW] != "width") {
            var s = state.view.scale;
            var spacing = state.text.getSpacing();
            bounds.x += spacing.x * s;
            bounds.y += spacing.y * s;
            var hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
            var vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
            var lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);
            bounds.width = Math.max(0, bounds.width - (hpos == mxConstants.ALIGN_CENTER && lw == null ? state.text.spacingLeft * s + state.text.spacingRight * s : 0));
            bounds.height = Math.max(0, bounds.height - (vpos == mxConstants.ALIGN_MIDDLE ? state.text.spacingTop * s + state.text.spacingBottom * s : 0));
          }
          var theta = state.text.getTextRotation();
          if (theta != 0 && state != null && state.view.graph.model.isVertex(state.cell)) {
            var cx = state.getCenterX();
            var cy = state.getCenterY();
            if (bounds.x != cx || bounds.y != cy) {
              var rad = theta * (Math.PI / 180);
              var pt = mxUtils.getRotatedPoint(
                new mxPoint(bounds.x, bounds.y),
                Math.cos(rad),
                Math.sin(rad),
                new mxPoint(cx, cy)
              );
              bounds.x = pt.x;
              bounds.y = pt.y;
            }
          }
        };
        mxCellRenderer.prototype.redrawCellOverlays = function(state, forced) {
          this.createCellOverlays(state);
          if (state.overlays != null) {
            var rot = mxUtils.mod(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0), 90);
            var rad = mxUtils.toRadians(rot);
            var cos = Math.cos(rad);
            var sin = Math.sin(rad);
            state.overlays.visit(function(id, shape2) {
              var bounds = shape2.overlay.getBounds(state);
              if (!state.view.graph.getModel().isEdge(state.cell)) {
                if (state.shape != null && rot != 0) {
                  var cx = bounds.getCenterX();
                  var cy = bounds.getCenterY();
                  var point = mxUtils.getRotatedPoint(
                    new mxPoint(cx, cy),
                    cos,
                    sin,
                    new mxPoint(state.getCenterX(), state.getCenterY())
                  );
                  cx = point.x;
                  cy = point.y;
                  bounds.x = Math.round(cx - bounds.width / 2);
                  bounds.y = Math.round(cy - bounds.height / 2);
                }
              }
              if (forced || shape2.bounds == null || shape2.scale != state.view.scale || !shape2.bounds.equals(bounds)) {
                shape2.bounds = bounds;
                shape2.scale = state.view.scale;
                shape2.redraw();
              }
            });
          }
        };
        mxCellRenderer.prototype.redrawControl = function(state, forced) {
          var image = state.view.graph.getFoldingImage(state);
          if (state.control != null && image != null) {
            var bounds = this.getControlBounds(state, image.width, image.height);
            var r = this.legacyControlPosition ? mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0) : state.shape.getTextRotation();
            var s = state.view.scale;
            if (forced || state.control.scale != s || !state.control.bounds.equals(bounds) || state.control.rotation != r) {
              state.control.rotation = r;
              state.control.bounds = bounds;
              state.control.scale = s;
              state.control.redraw();
            }
          }
        };
        mxCellRenderer.prototype.getControlBounds = function(state, w2, h2) {
          if (state.control != null) {
            var s = state.view.scale;
            var cx = state.getCenterX();
            var cy = state.getCenterY();
            if (!state.view.graph.getModel().isEdge(state.cell)) {
              cx = state.x + w2 * s;
              cy = state.y + h2 * s;
              if (state.shape != null) {
                var rot = state.shape.getShapeRotation();
                if (this.legacyControlPosition) {
                  rot = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0);
                } else {
                  if (state.shape.isPaintBoundsInverted()) {
                    var t = (state.width - state.height) / 2;
                    cx += t;
                    cy -= t;
                  }
                }
                if (rot != 0) {
                  var rad = mxUtils.toRadians(rot);
                  var cos = Math.cos(rad);
                  var sin = Math.sin(rad);
                  var point = mxUtils.getRotatedPoint(
                    new mxPoint(cx, cy),
                    cos,
                    sin,
                    new mxPoint(state.getCenterX(), state.getCenterY())
                  );
                  cx = point.x;
                  cy = point.y;
                }
              }
            }
            return state.view.graph.getModel().isEdge(state.cell) ? new mxRectangle(Math.round(cx - w2 / 2 * s), Math.round(cy - h2 / 2 * s), Math.round(w2 * s), Math.round(h2 * s)) : new mxRectangle(Math.round(cx - w2 / 2 * s), Math.round(cy - h2 / 2 * s), Math.round(w2 * s), Math.round(h2 * s));
          }
          return null;
        };
        mxCellRenderer.prototype.insertStateAfter = function(state, node, htmlNode) {
          var shapes = this.getShapesForState(state);
          for (var i = 0; i < shapes.length; i++) {
            if (shapes[i] != null && shapes[i].node != null) {
              var html = shapes[i].node.parentNode != state.view.getDrawPane() && shapes[i].node.parentNode != state.view.getOverlayPane();
              var temp = html ? htmlNode : node;
              if (temp != null && temp.nextSibling != shapes[i].node) {
                if (temp.nextSibling == null) {
                  temp.parentNode.appendChild(shapes[i].node);
                } else {
                  temp.parentNode.insertBefore(shapes[i].node, temp.nextSibling);
                }
              } else if (temp == null) {
                if (shapes[i].node.parentNode == state.view.graph.container) {
                  var canvas = state.view.canvas;
                  while (canvas != null && canvas.parentNode != state.view.graph.container) {
                    canvas = canvas.parentNode;
                  }
                  if (canvas != null && canvas.nextSibling != null) {
                    if (canvas.nextSibling != shapes[i].node) {
                      shapes[i].node.parentNode.insertBefore(shapes[i].node, canvas.nextSibling);
                    }
                  } else {
                    shapes[i].node.parentNode.appendChild(shapes[i].node);
                  }
                } else if (shapes[i].node.parentNode != null && shapes[i].node.parentNode.firstChild != null && shapes[i].node.parentNode.firstChild != shapes[i].node) {
                  shapes[i].node.parentNode.insertBefore(shapes[i].node, shapes[i].node.parentNode.firstChild);
                }
              }
              if (html) {
                htmlNode = shapes[i].node;
              } else {
                node = shapes[i].node;
              }
            }
          }
          return [node, htmlNode];
        };
        mxCellRenderer.prototype.getShapesForState = function(state) {
          return [state.shape, state.text, state.control];
        };
        mxCellRenderer.prototype.redraw = function(state, force, rendering) {
          var shapeChanged = this.redrawShape(state, force, rendering);
          if (state.shape != null && (rendering == null || rendering)) {
            this.redrawLabel(state, shapeChanged);
            this.redrawCellOverlays(state, shapeChanged);
            this.redrawControl(state, shapeChanged);
          }
        };
        mxCellRenderer.prototype.redrawShape = function(state, force, rendering) {
          var model = state.view.graph.model;
          var shapeChanged = false;
          if (state.shape != null && state.shape.style != null && state.style != null && state.shape.style[mxConstants.STYLE_SHAPE] != state.style[mxConstants.STYLE_SHAPE]) {
            state.shape.destroy();
            state.shape = null;
          }
          if (state.shape == null && state.view.graph.container != null && state.cell != state.view.currentRoot && (model.isVertex(state.cell) || model.isEdge(state.cell))) {
            state.shape = this.createShape(state);
            if (state.shape != null) {
              state.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;
              state.shape.antiAlias = this.antiAlias;
              this.createIndicatorShape(state);
              this.initializeShape(state);
              this.createCellOverlays(state);
              this.installListeners(state);
              state.view.graph.selectionCellsHandler.updateHandler(state);
            }
          } else if (!force && state.shape != null && (!mxUtils.equalEntries(
            state.shape.style,
            state.style
          ) || this.checkPlaceholderStyles(state))) {
            state.shape.resetStyles();
            this.configureShape(state);
            state.view.graph.selectionCellsHandler.updateHandler(state);
            force = true;
          }
          if (state.shape != null && state.shape.indicatorShape != this.getShape(state.view.graph.getIndicatorShape(state))) {
            if (state.shape.indicator != null) {
              state.shape.indicator.destroy();
              state.shape.indicator = null;
            }
            this.createIndicatorShape(state);
            if (state.shape.indicatorShape != null) {
              state.shape.indicator = new state.shape.indicatorShape();
              state.shape.indicator.dialect = state.shape.dialect;
              state.shape.indicator.init(state.node);
              force = true;
            }
          }
          if (state.shape != null) {
            this.createControl(state);
            if (force || this.isShapeInvalid(state, state.shape)) {
              if (state.absolutePoints != null) {
                state.shape.points = state.absolutePoints.slice();
                state.shape.bounds = null;
              } else {
                state.shape.points = null;
                state.shape.bounds = new mxRectangle(state.x, state.y, state.width, state.height);
              }
              state.shape.scale = state.view.scale;
              if (rendering == null || rendering) {
                this.doRedrawShape(state);
              } else {
                state.shape.updateBoundingBox();
              }
              shapeChanged = true;
            }
          }
          return shapeChanged;
        };
        mxCellRenderer.prototype.doRedrawShape = function(state) {
          state.shape.redraw();
        };
        mxCellRenderer.prototype.isShapeInvalid = function(state, shape2) {
          return shape2.bounds == null || shape2.scale != state.view.scale || state.absolutePoints == null && !shape2.bounds.equals(state) || state.absolutePoints != null && !mxUtils.equalPoints(shape2.points, state.absolutePoints);
        };
        mxCellRenderer.prototype.destroy = function(state) {
          if (state.shape != null) {
            if (state.text != null) {
              state.text.destroy();
              state.text = null;
            }
            if (state.overlays != null) {
              state.overlays.visit(function(id, shape2) {
                shape2.destroy();
              });
              state.overlays = null;
            }
            if (state.control != null) {
              state.control.destroy();
              state.control = null;
            }
            state.shape.destroy();
            state.shape = null;
          }
        };
        __mxOutput.mxCellRenderer = typeof mxCellRenderer !== "undefined" ? mxCellRenderer : void 0;
        var mxEdgeStyle = {
          /**
           * Class: mxEdgeStyle
           * 
           * Provides various edge styles to be used as the values for
           * <mxConstants.STYLE_EDGE> in a cell style.
           *
           * Example:
           * 
           * (code)
           * var style = stylesheet.getDefaultEdgeStyle();
           * style[mxConstants.STYLE_EDGE] = mxEdgeStyle.ElbowConnector;
           * (end)
           * 
           * Sets the default edge style to <ElbowConnector>.
           * 
           * Custom edge style:
           * 
           * To write a custom edge style, a function must be added to the mxEdgeStyle
           * object as follows:
           * 
           * (code)
           * mxEdgeStyle.MyStyle = function(state, source, target, points, result)
           * {
           *   if (source != null && target != null)
           *   {
           *     var pt = new mxPoint(target.getCenterX(), source.getCenterY());
           * 
           *     if (mxUtils.contains(source, pt.x, pt.y))
           *     {
           *       pt.y = source.y + source.height;
           *     }
           * 
           *     result.push(pt);
           *   }
           * };
           * (end)
           * 
           * In the above example, a right angle is created using a point on the
           * horizontal center of the target vertex and the vertical center of the source
           * vertex. The code checks if that point intersects the source vertex and makes
           * the edge straight if it does. The point is then added into the result array,
           * which acts as the return value of the function.
           *
           * The new edge style should then be registered in the <mxStyleRegistry> as follows:
           * (code)
           * mxStyleRegistry.putValue('myEdgeStyle', mxEdgeStyle.MyStyle);
           * (end)
           * 
           * The custom edge style above can now be used in a specific edge as follows:
           * 
           * (code)
           * model.setStyle(edge, 'edgeStyle=myEdgeStyle');
           * (end)
           * 
           * Note that the key of the <mxStyleRegistry> entry for the function should
           * be used in string values, unless <mxGraphView.allowEval> is true, in
           * which case you can also use mxEdgeStyle.MyStyle for the value in the
           * cell style above.
           * 
           * Or it can be used for all edges in the graph as follows:
           * 
           * (code)
           * var style = graph.getStylesheet().getDefaultEdgeStyle();
           * style[mxConstants.STYLE_EDGE] = mxEdgeStyle.MyStyle;
           * (end)
           * 
           * Note that the object can be used directly when programmatically setting
           * the value, but the key in the <mxStyleRegistry> should be used when
           * setting the value via a key, value pair in a cell style.
           * 
           * Function: EntityRelation
           * 
           * Implements an entity relation style for edges (as used in database
           * schema diagrams). At the time the function is called, the result
           * array contains a placeholder (null) for the first absolute point,
           * that is, the point where the edge and source terminal are connected.
           * The implementation of the style then adds all intermediate waypoints
           * except for the last point, that is, the connection point between the
           * edge and the target terminal. The first ant the last point in the
           * result array are then replaced with mxPoints that take into account
           * the terminal's perimeter and next point on the edge.
           *
           * Parameters:
           * 
           * state - <mxCellState> that represents the edge to be updated.
           * source - <mxCellState> that represents the source terminal.
           * target - <mxCellState> that represents the target terminal.
           * points - List of relative control points.
           * result - Array of <mxPoints> that represent the actual points of the
           * edge.
           */
          EntityRelation: function(state, source, target, points, result2) {
            var view = state.view;
            var graph = view.graph;
            var segment = mxUtils.getValue(
              state.style,
              mxConstants.STYLE_SEGMENT,
              mxConstants.ENTITY_SEGMENT
            ) * view.scale;
            var pts = state.absolutePoints;
            var p0 = pts[0];
            var pe = pts[pts.length - 1];
            var isSourceLeft = false;
            if (source != null) {
              var sourceGeometry = graph.getCellGeometry(source.cell);
              if (sourceGeometry.relative) {
                isSourceLeft = sourceGeometry.x <= 0.5;
              } else if (target != null) {
                isSourceLeft = (pe != null ? pe.x : target.x + target.width) < (p0 != null ? p0.x : source.x);
              }
            }
            if (p0 != null) {
              source = new mxCellState();
              source.x = p0.x;
              source.y = p0.y;
            } else if (source != null) {
              var constraint = mxUtils.getPortConstraints(source, state, true, mxConstants.DIRECTION_MASK_NONE);
              if (constraint != mxConstants.DIRECTION_MASK_NONE && constraint != mxConstants.DIRECTION_MASK_WEST + mxConstants.DIRECTION_MASK_EAST) {
                isSourceLeft = constraint == mxConstants.DIRECTION_MASK_WEST;
              }
            } else {
              return;
            }
            var isTargetLeft = true;
            if (target != null) {
              var targetGeometry = graph.getCellGeometry(target.cell);
              if (targetGeometry.relative) {
                isTargetLeft = targetGeometry.x <= 0.5;
              } else if (source != null) {
                isTargetLeft = (p0 != null ? p0.x : source.x + source.width) < (pe != null ? pe.x : target.x);
              }
            }
            if (pe != null) {
              target = new mxCellState();
              target.x = pe.x;
              target.y = pe.y;
            } else if (target != null) {
              var constraint = mxUtils.getPortConstraints(target, state, false, mxConstants.DIRECTION_MASK_NONE);
              if (constraint != mxConstants.DIRECTION_MASK_NONE && constraint != mxConstants.DIRECTION_MASK_WEST + mxConstants.DIRECTION_MASK_EAST) {
                isTargetLeft = constraint == mxConstants.DIRECTION_MASK_WEST;
              }
            }
            if (source != null && target != null) {
              var x0 = isSourceLeft ? source.x : source.x + source.width;
              var y0 = view.getRoutingCenterY(source);
              var xe = isTargetLeft ? target.x : target.x + target.width;
              var ye = view.getRoutingCenterY(target);
              var seg = segment;
              var dx = isSourceLeft ? -seg : seg;
              var dep = new mxPoint(x0 + dx, y0);
              dx = isTargetLeft ? -seg : seg;
              var arr = new mxPoint(xe + dx, ye);
              if (isSourceLeft == isTargetLeft) {
                var x = isSourceLeft ? Math.min(x0, xe) - segment : Math.max(x0, xe) + segment;
                result2.push(new mxPoint(x, y0));
                result2.push(new mxPoint(x, ye));
              } else if (dep.x < arr.x == isSourceLeft) {
                var midY = y0 + (ye - y0) / 2;
                result2.push(dep);
                result2.push(new mxPoint(dep.x, midY));
                result2.push(new mxPoint(arr.x, midY));
                result2.push(arr);
              } else {
                result2.push(dep);
                result2.push(arr);
              }
            }
          },
          EntityRelationPerpendicular: function(state, source, target, points, result2) {
            var view = state.view;
            var graph = view.graph;
            var segment = mxUtils.getValue(
              state.style,
              mxConstants.STYLE_SEGMENT,
              mxConstants.ENTITY_SEGMENT
            ) * view.scale;
            var pts = state.absolutePoints;
            var p0 = pts[0];
            var pe = pts[pts.length - 1];
            var isSourceLeft = false;
            if (source != null) {
              var sourceGeometry = graph.getCellGeometry(source.cell);
              if (sourceGeometry.relative) {
                isSourceLeft = sourceGeometry.x <= 0.5;
              } else if (target != null) {
                isSourceLeft = (pe != null ? pe.x : target.x + target.width) < (p0 != null ? p0.x : source.x);
              }
            }
            if (p0 != null) {
              source = new mxCellState();
              source.x = p0.x;
              source.y = p0.y;
            } else if (source != null) {
              var constraint = mxUtils.getPortConstraints(source, state, true, mxConstants.DIRECTION_MASK_NONE);
              if (constraint != mxConstants.DIRECTION_MASK_NONE && constraint != mxConstants.DIRECTION_MASK_WEST + mxConstants.DIRECTION_MASK_EAST) {
                isSourceLeft = constraint == mxConstants.DIRECTION_MASK_WEST;
              }
            } else {
              return;
            }
            var isTargetLeft = true;
            if (target != null) {
              var targetGeometry = graph.getCellGeometry(target.cell);
              if (targetGeometry.relative) {
                isTargetLeft = targetGeometry.x <= 0.5;
              } else if (source != null) {
                isTargetLeft = (p0 != null ? p0.x : source.x + source.width) < (pe != null ? pe.x : target.x);
              }
            }
            if (pe != null) {
              target = new mxCellState();
              target.x = pe.x;
              target.y = pe.y;
            } else if (target != null) {
              var constraint = mxUtils.getPortConstraints(target, state, false, mxConstants.DIRECTION_MASK_NONE);
              if (constraint != mxConstants.DIRECTION_MASK_NONE && constraint != mxConstants.DIRECTION_MASK_WEST + mxConstants.DIRECTION_MASK_EAST) {
                isTargetLeft = constraint == mxConstants.DIRECTION_MASK_WEST;
              }
            }
            if (source != null && target != null) {
              var x0 = isSourceLeft ? source.x : source.x + source.width;
              var y0 = view.getRoutingCenterY(source);
              var xe = isTargetLeft ? target.x : target.x + target.width;
              var ye = view.getRoutingCenterY(target);
              var seg = segment;
              var dx = isSourceLeft ? -seg : seg;
              var dep = new mxPoint(x0 + dx, y0);
              dx = isTargetLeft ? -seg : seg;
              var arr = new mxPoint(xe + dx, ye);
              if (isSourceLeft == isTargetLeft) {
                var x = isSourceLeft ? Math.min(x0, xe) - segment : Math.max(x0, xe) + segment;
                result2.push(new mxPoint(x, y0));
                result2.push(new mxPoint(x, ye));
              } else if (dep.x < arr.x == isSourceLeft) {
                var midY = y0 + (ye - y0) / 2;
                result2.push(dep);
                result2.push(new mxPoint(dep.x, midY));
                result2.push(new mxPoint(arr.x, midY));
                result2.push(arr);
              } else {
                let randomDeltaX = Math.floor(Math.random() * 5) * 4 + 2;
                if (state?.cell?.source?.value?.name) {
                  const str = state.cell.source.value.name;
                  let hash = 0;
                  for (let i = 0; i < str.length; i++) {
                    hash = (hash * 31 + str.charCodeAt(i)) % 1e6;
                  }
                  randomDeltaX = (hash % 5 + 1) * 4;
                } else {
                  randomDeltaX = -10;
                }
                arr.x += (randomDeltaX - 10) * state.view.getScale();
                result2.push(new mxPoint(arr.x, dep.y));
                result2.push(arr);
              }
            }
          },
          /**
          * Function: Loop
          * 
          * Implements a self-reference, aka. loop.
          */
          Loop: function(state, source, target, points, result2) {
            var pts = state.absolutePoints;
            var p0 = pts[0];
            var pe = pts[pts.length - 1];
            if (p0 != null && pe != null) {
              if (points != null && points.length > 0) {
                for (var i = 0; i < points.length; i++) {
                  var pt = points[i];
                  pt = state.view.transformControlPoint(state, pt);
                  result2.push(new mxPoint(pt.x, pt.y));
                }
              }
              return;
            }
            if (source != null) {
              var view = state.view;
              var graph = view.graph;
              var pt = points != null && points.length > 0 ? points[0] : null;
              if (pt != null) {
                pt = view.transformControlPoint(state, pt);
                if (mxUtils.contains(source, pt.x, pt.y)) {
                  pt = null;
                }
              }
              var x = 0;
              var dx = 0;
              var y = 0;
              var dy = 0;
              var seg = mxUtils.getValue(
                state.style,
                mxConstants.STYLE_SEGMENT,
                graph.gridSize
              ) * view.scale;
              var dir = mxUtils.getValue(
                state.style,
                mxConstants.STYLE_DIRECTION,
                mxConstants.DIRECTION_WEST
              );
              if (dir == mxConstants.DIRECTION_NORTH || dir == mxConstants.DIRECTION_SOUTH) {
                x = view.getRoutingCenterX(source);
                dx = seg;
              } else {
                y = view.getRoutingCenterY(source);
                dy = seg;
              }
              if (pt == null || pt.x < source.x || pt.x > source.x + source.width) {
                if (pt != null) {
                  x = pt.x;
                  dy = Math.max(Math.abs(y - pt.y), dy);
                } else {
                  if (dir == mxConstants.DIRECTION_NORTH) {
                    y = source.y - 2 * dx;
                  } else if (dir == mxConstants.DIRECTION_SOUTH) {
                    y = source.y + source.height + 2 * dx;
                  } else if (dir == mxConstants.DIRECTION_EAST) {
                    x = source.x - 2 * dy;
                  } else {
                    x = source.x + source.width + 2 * dy;
                  }
                }
              } else if (pt != null) {
                x = view.getRoutingCenterX(source);
                dx = Math.max(Math.abs(x - pt.x), dy);
                y = pt.y;
                dy = 0;
              }
              result2.push(new mxPoint(x - dx, y - dy));
              result2.push(new mxPoint(x + dx, y + dy));
            }
          },
          /**
           * Function: ElbowConnector
           * 
           * Uses either <SideToSide> or <TopToBottom> depending on the horizontal
           * flag in the cell style. <SideToSide> is used if horizontal is true or
           * unspecified. See <EntityRelation> for a description of the
           * parameters.
           */
          ElbowConnector: function(state, source, target, points, result2) {
            var pt = points != null && points.length > 0 ? points[0] : null;
            var vertical = false;
            var horizontal = false;
            if (source != null && target != null) {
              if (pt != null) {
                var left = Math.min(source.x, target.x);
                var right = Math.max(
                  source.x + source.width,
                  target.x + target.width
                );
                var top = Math.min(source.y, target.y);
                var bottom = Math.max(
                  source.y + source.height,
                  target.y + target.height
                );
                pt = state.view.transformControlPoint(state, pt);
                vertical = pt.y < top || pt.y > bottom;
                horizontal = pt.x < left || pt.x > right;
              } else {
                var left = Math.max(source.x, target.x);
                var right = Math.min(
                  source.x + source.width,
                  target.x + target.width
                );
                vertical = left == right;
                if (!vertical) {
                  var top = Math.max(source.y, target.y);
                  var bottom = Math.min(
                    source.y + source.height,
                    target.y + target.height
                  );
                  horizontal = top == bottom;
                }
              }
            }
            if (!horizontal && (vertical || state.style[mxConstants.STYLE_ELBOW] == mxConstants.ELBOW_VERTICAL)) {
              mxEdgeStyle.TopToBottom(state, source, target, points, result2);
            } else {
              mxEdgeStyle.SideToSide(state, source, target, points, result2);
            }
          },
          /**
           * Function: SideToSide
           * 
           * Implements a vertical elbow edge. See <EntityRelation> for a description
           * of the parameters.
           */
          SideToSide: function(state, source, target, points, result2) {
            var view = state.view;
            var pt = points != null && points.length > 0 ? points[0] : null;
            var pts = state.absolutePoints;
            var p0 = pts[0];
            var pe = pts[pts.length - 1];
            if (pt != null) {
              pt = view.transformControlPoint(state, pt);
            }
            if (p0 != null) {
              source = new mxCellState();
              source.x = p0.x;
              source.y = p0.y;
            }
            if (pe != null) {
              target = new mxCellState();
              target.x = pe.x;
              target.y = pe.y;
            }
            if (source != null && target != null) {
              var l = Math.max(source.x, target.x);
              var r = Math.min(
                source.x + source.width,
                target.x + target.width
              );
              var x = pt != null ? pt.x : Math.round(r + (l - r) / 2);
              var y1 = view.getRoutingCenterY(source);
              var y2 = view.getRoutingCenterY(target);
              if (pt != null) {
                if (pt.y >= source.y && pt.y <= source.y + source.height) {
                  y1 = pt.y;
                }
                if (pt.y >= target.y && pt.y <= target.y + target.height) {
                  y2 = pt.y;
                }
              }
              if (!mxUtils.contains(target, x, y1) && !mxUtils.contains(source, x, y1)) {
                result2.push(new mxPoint(x, y1));
              }
              if (!mxUtils.contains(target, x, y2) && !mxUtils.contains(source, x, y2)) {
                result2.push(new mxPoint(x, y2));
              }
              if (result2.length == 1) {
                if (pt != null) {
                  if (!mxUtils.contains(target, x, pt.y) && !mxUtils.contains(source, x, pt.y)) {
                    result2.push(new mxPoint(x, pt.y));
                  }
                } else {
                  var t = Math.max(source.y, target.y);
                  var b = Math.min(
                    source.y + source.height,
                    target.y + target.height
                  );
                  result2.push(new mxPoint(x, t + (b - t) / 2));
                }
              }
            }
          },
          /**
           * Function: TopToBottom
           * 
           * Implements a horizontal elbow edge. See <EntityRelation> for a
           * description of the parameters.
           */
          TopToBottom: function(state, source, target, points, result2) {
            var view = state.view;
            var pt = points != null && points.length > 0 ? points[0] : null;
            var pts = state.absolutePoints;
            var p0 = pts[0];
            var pe = pts[pts.length - 1];
            if (pt != null) {
              pt = view.transformControlPoint(state, pt);
            }
            if (p0 != null) {
              source = new mxCellState();
              source.x = p0.x;
              source.y = p0.y;
            }
            if (pe != null) {
              target = new mxCellState();
              target.x = pe.x;
              target.y = pe.y;
            }
            if (source != null && target != null) {
              var t = Math.max(source.y, target.y);
              var b = Math.min(
                source.y + source.height,
                target.y + target.height
              );
              var x = view.getRoutingCenterX(source);
              if (pt != null && pt.x >= source.x && pt.x <= source.x + source.width) {
                x = pt.x;
              }
              var y = pt != null ? pt.y : Math.round(b + (t - b) / 2);
              if (!mxUtils.contains(target, x, y) && !mxUtils.contains(source, x, y)) {
                result2.push(new mxPoint(x, y));
              }
              if (pt != null && pt.x >= target.x && pt.x <= target.x + target.width) {
                x = pt.x;
              } else {
                x = view.getRoutingCenterX(target);
              }
              if (!mxUtils.contains(target, x, y) && !mxUtils.contains(source, x, y)) {
                result2.push(new mxPoint(x, y));
              }
              if (result2.length == 1) {
                if (pt != null && result2.length == 1) {
                  if (!mxUtils.contains(target, pt.x, y) && !mxUtils.contains(source, pt.x, y)) {
                    result2.push(new mxPoint(pt.x, y));
                  }
                } else {
                  var l = Math.max(source.x, target.x);
                  var r = Math.min(
                    source.x + source.width,
                    target.x + target.width
                  );
                  result2.push(new mxPoint(l + (r - l) / 2, y));
                }
              }
            }
          },
          /**
           * Function: SegmentConnector
           * 
           * Implements an orthogonal edge style. Use <mxEdgeSegmentHandler>
           * as an interactive handler for this style.
           * 
           * state - <mxCellState> that represents the edge to be updated.
           * sourceScaled - <mxCellState> that represents the source terminal.
           * targetScaled - <mxCellState> that represents the target terminal.
           * controlHints - List of relative control points.
           * result - Array of <mxPoints> that represent the actual points of the
           * edge.
           *
           */
          SegmentConnector: function(state, sourceScaled, targetScaled, controlHints, result2) {
            var pts = mxEdgeStyle.scalePointArray(state.absolutePoints, state.view.scale);
            var source = mxEdgeStyle.scaleCellState(sourceScaled, state.view.scale);
            var target = mxEdgeStyle.scaleCellState(targetScaled, state.view.scale);
            var tol = 1;
            var lastPushed = result2.length > 0 ? result2[0] : null;
            var horizontal = true;
            var hint = null;
            function pushPoint(pt2) {
              pt2.x = Math.round(pt2.x * state.view.scale * 10) / 10;
              pt2.y = Math.round(pt2.y * state.view.scale * 10) / 10;
              if (lastPushed == null || Math.abs(lastPushed.x - pt2.x) >= tol || Math.abs(lastPushed.y - pt2.y) >= Math.max(1, state.view.scale)) {
                result2.push(pt2);
                lastPushed = pt2;
              }
              return lastPushed;
            }
            ;
            var pt = pts[0];
            if (pt == null && source != null) {
              pt = new mxPoint(state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));
            } else if (pt != null) {
              pt = pt.clone();
            }
            var lastInx = pts.length - 1;
            if (controlHints != null && controlHints.length > 0) {
              var hints = [];
              for (var i = 0; i < controlHints.length; i++) {
                var tmp = state.view.transformControlPoint(state, controlHints[i], true);
                if (tmp != null) {
                  hints.push(tmp);
                }
              }
              if (hints.length == 0) {
                return;
              }
              if (pt != null && hints[0] != null) {
                if (Math.abs(hints[0].x - pt.x) < tol) {
                  hints[0].x = pt.x;
                }
                if (Math.abs(hints[0].y - pt.y) < tol) {
                  hints[0].y = pt.y;
                }
              }
              var pe = pts[lastInx];
              if (pe != null && hints[hints.length - 1] != null) {
                if (Math.abs(hints[hints.length - 1].x - pe.x) < tol) {
                  hints[hints.length - 1].x = pe.x;
                }
                if (Math.abs(hints[hints.length - 1].y - pe.y) < tol) {
                  hints[hints.length - 1].y = pe.y;
                }
              }
              hint = hints[0];
              var currentTerm = source;
              var currentPt = pts[0];
              var hozChan = false;
              var vertChan = false;
              var currentHint = hint;
              if (currentPt != null) {
                currentTerm = null;
              }
              for (var i = 0; i < 2; i++) {
                var fixedVertAlign = currentPt != null && currentPt.x == currentHint.x;
                var fixedHozAlign = currentPt != null && currentPt.y == currentHint.y;
                var inHozChan = currentTerm != null && (currentHint.y >= currentTerm.y && currentHint.y <= currentTerm.y + currentTerm.height);
                var inVertChan = currentTerm != null && (currentHint.x >= currentTerm.x && currentHint.x <= currentTerm.x + currentTerm.width);
                hozChan = fixedHozAlign || currentPt == null && inHozChan;
                vertChan = fixedVertAlign || currentPt == null && inVertChan;
                if (i == 0 && (hozChan && vertChan || fixedVertAlign && fixedHozAlign)) {
                } else {
                  if (currentPt != null && (!fixedHozAlign && !fixedVertAlign) && (inHozChan || inVertChan)) {
                    horizontal = inHozChan ? false : true;
                    break;
                  }
                  if (vertChan || hozChan) {
                    horizontal = hozChan;
                    if (i == 1) {
                      horizontal = hints.length % 2 == 0 ? hozChan : vertChan;
                    }
                    break;
                  }
                }
                currentTerm = target;
                currentPt = pts[lastInx];
                if (currentPt != null) {
                  currentTerm = null;
                }
                currentHint = hints[hints.length - 1];
                if (fixedVertAlign && fixedHozAlign) {
                  hints = hints.slice(1);
                }
              }
              if (horizontal && (pts[0] != null && pts[0].y != hint.y || pts[0] == null && source != null && (hint.y < source.y || hint.y > source.y + source.height))) {
                pushPoint(new mxPoint(pt.x, hint.y));
              } else if (!horizontal && (pts[0] != null && pts[0].x != hint.x || pts[0] == null && source != null && (hint.x < source.x || hint.x > source.x + source.width))) {
                pushPoint(new mxPoint(hint.x, pt.y));
              }
              if (horizontal) {
                pt.y = hint.y;
              } else {
                pt.x = hint.x;
              }
              for (var i = 0; i < hints.length; i++) {
                horizontal = !horizontal;
                hint = hints[i];
                if (horizontal) {
                  pt.y = hint.y;
                } else {
                  pt.x = hint.x;
                }
                pushPoint(pt.clone());
              }
            } else {
              hint = pt;
              horizontal = true;
            }
            pt = pts[lastInx];
            if (pt == null && target != null) {
              pt = new mxPoint(state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));
            }
            if (pt != null) {
              if (hint != null) {
                if (horizontal && (pts[lastInx] != null && pts[lastInx].y != hint.y || pts[lastInx] == null && target != null && (hint.y < target.y || hint.y > target.y + target.height))) {
                  pushPoint(new mxPoint(pt.x, hint.y));
                } else if (!horizontal && (pts[lastInx] != null && pts[lastInx].x != hint.x || pts[lastInx] == null && target != null && (hint.x < target.x || hint.x > target.x + target.width))) {
                  pushPoint(new mxPoint(hint.x, pt.y));
                }
              }
            }
            if (pts[0] == null && source != null) {
              while (result2.length > 1 && result2[1] != null && mxUtils.contains(source, result2[1].x, result2[1].y)) {
                result2.splice(1, 1);
              }
            }
            if (pts[lastInx] == null && target != null) {
              while (result2.length > 1 && result2[result2.length - 1] != null && mxUtils.contains(target, result2[result2.length - 1].x, result2[result2.length - 1].y)) {
                result2.splice(result2.length - 1, 1);
              }
            }
            if (pe != null && result2[result2.length - 1] != null && Math.abs(pe.x - result2[result2.length - 1].x) <= tol && Math.abs(pe.y - result2[result2.length - 1].y) <= tol) {
              result2.splice(result2.length - 1, 1);
              if (result2[result2.length - 1] != null) {
                if (Math.abs(result2[result2.length - 1].x - pe.x) < tol) {
                  result2[result2.length - 1].x = pe.x;
                }
                if (Math.abs(result2[result2.length - 1].y - pe.y) < tol) {
                  result2[result2.length - 1].y = pe.y;
                }
              }
            }
          },
          orthBuffer: 10,
          orthPointsFallback: true,
          dirVectors: [
            [-1, 0],
            [0, -1],
            [1, 0],
            [0, 1],
            [-1, 0],
            [0, -1],
            [1, 0]
          ],
          wayPoints1: [
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0]
          ],
          routePatterns: [
            [
              [513, 2308, 2081, 2562],
              [513, 1090, 514, 2184, 2114, 2561],
              [513, 1090, 514, 2564, 2184, 2562],
              [513, 2308, 2561, 1090, 514, 2568, 2308]
            ],
            [
              [514, 1057, 513, 2308, 2081, 2562],
              [514, 2184, 2114, 2561],
              [514, 2184, 2562, 1057, 513, 2564, 2184],
              [514, 1057, 513, 2568, 2308, 2561]
            ],
            [
              [1090, 514, 1057, 513, 2308, 2081, 2562],
              [2114, 2561],
              [1090, 2562, 1057, 513, 2564, 2184],
              [1090, 514, 1057, 513, 2308, 2561, 2568]
            ],
            [
              [2081, 2562],
              [1057, 513, 1090, 514, 2184, 2114, 2561],
              [1057, 513, 1090, 514, 2184, 2562, 2564],
              [1057, 2561, 1090, 514, 2568, 2308]
            ]
          ],
          inlineRoutePatterns: [
            [null, [2114, 2568], null, null],
            [null, [514, 2081, 2114, 2568], null, null],
            [null, [2114, 2561], null, null],
            [
              [2081, 2562],
              [1057, 2114, 2568],
              [2184, 2562],
              null
            ]
          ],
          vertexSeperations: [],
          limits: [
            [0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0]
          ],
          LEFT_MASK: 32,
          TOP_MASK: 64,
          RIGHT_MASK: 128,
          BOTTOM_MASK: 256,
          LEFT: 1,
          TOP: 2,
          RIGHT: 4,
          BOTTOM: 8,
          // TODO remove magic numbers
          SIDE_MASK: 480,
          //mxEdgeStyle.LEFT_MASK | mxEdgeStyle.TOP_MASK | mxEdgeStyle.RIGHT_MASK
          //| mxEdgeStyle.BOTTOM_MASK,
          CENTER_MASK: 512,
          SOURCE_MASK: 1024,
          TARGET_MASK: 2048,
          VERTEX_MASK: 3072,
          // mxEdgeStyle.SOURCE_MASK | mxEdgeStyle.TARGET_MASK,
          getJettySize: function(state, isSource) {
            var value = mxUtils.getValue(state.style, isSource ? mxConstants.STYLE_SOURCE_JETTY_SIZE : mxConstants.STYLE_TARGET_JETTY_SIZE, mxUtils.getValue(
              state.style,
              mxConstants.STYLE_JETTY_SIZE,
              mxEdgeStyle.orthBuffer
            ));
            if (value == "auto") {
              var type = mxUtils.getValue(state.style, isSource ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW, mxConstants.NONE);
              if (type != mxConstants.NONE) {
                var size = mxUtils.getNumber(state.style, isSource ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE);
                value = Math.max(2, Math.ceil((size + mxEdgeStyle.orthBuffer) / mxEdgeStyle.orthBuffer)) * mxEdgeStyle.orthBuffer;
              } else {
                value = 2 * mxEdgeStyle.orthBuffer;
              }
            }
            return value;
          },
          /**
           * Function: scalePointArray
           * 
           * Scales an array of <mxPoint>
           * 
           * Parameters:
           * 
           * points - array of <mxPoint> to scale
           * scale - the scaling to divide by
           * 
           */
          scalePointArray: function(points, scale) {
            var result2 = [];
            if (points != null) {
              for (var i = 0; i < points.length; i++) {
                if (points[i] != null) {
                  var pt = new mxPoint(
                    Math.round(points[i].x / scale * 10) / 10,
                    Math.round(points[i].y / scale * 10) / 10
                  );
                  result2[i] = pt;
                } else {
                  result2[i] = null;
                }
              }
            } else {
              result2 = null;
            }
            return result2;
          },
          /**
           * Function: scaleCellState
           * 
           * Scales an <mxCellState>
           * 
           * Parameters:
           * 
           * state - <mxCellState> to scale
           * scale - the scaling to divide by
           * 
           */
          scaleCellState: function(state, scale) {
            var result2 = null;
            if (state != null) {
              result2 = state.clone();
              result2.setRect(
                Math.round(state.x / scale * 10) / 10,
                Math.round(state.y / scale * 10) / 10,
                Math.round(state.width / scale * 10) / 10,
                Math.round(state.height / scale * 10) / 10
              );
            } else {
              result2 = null;
            }
            return result2;
          },
          /**
           * Function: OrthConnector
           * 
           * Implements a local orthogonal router between the given
           * cells.
           * 
           * Parameters:
           * 
           * state - <mxCellState> that represents the edge to be updated.
           * sourceScaled - <mxCellState> that represents the source terminal.
           * targetScaled - <mxCellState> that represents the target terminal.
           * controlHints - List of relative control points.
           * result - Array of <mxPoints> that represent the actual points of the
           * edge.
           * 
           */
          OrthConnector: function(state, sourceScaled, targetScaled, controlHints, result2) {
            var graph = state.view.graph;
            var sourceEdge = source == null ? false : graph.getModel().isEdge(source.cell);
            var targetEdge = target == null ? false : graph.getModel().isEdge(target.cell);
            var pts = mxEdgeStyle.scalePointArray(state.absolutePoints, state.view.scale);
            var source = mxEdgeStyle.scaleCellState(sourceScaled, state.view.scale);
            var target = mxEdgeStyle.scaleCellState(targetScaled, state.view.scale);
            var p0 = pts[0];
            var pe = pts[pts.length - 1];
            var sourceX = source != null ? source.x : p0.x;
            var sourceY = source != null ? source.y : p0.y;
            var sourceWidth = source != null ? source.width : 0;
            var sourceHeight = source != null ? source.height : 0;
            var targetX = target != null ? target.x : pe.x;
            var targetY = target != null ? target.y : pe.y;
            var targetWidth = target != null ? target.width : 0;
            var targetHeight = target != null ? target.height : 0;
            var sourceBuffer = mxEdgeStyle.getJettySize(state, true);
            var targetBuffer = mxEdgeStyle.getJettySize(state, false);
            if (source != null && target == source) {
              targetBuffer = Math.max(sourceBuffer, targetBuffer);
              sourceBuffer = targetBuffer;
            }
            var totalBuffer = targetBuffer + sourceBuffer;
            var tooShort = false;
            if (p0 != null && pe != null) {
              var dx = pe.x - p0.x;
              var dy = pe.y - p0.y;
              tooShort = dx * dx + dy * dy < totalBuffer * totalBuffer;
            }
            if (tooShort || mxEdgeStyle.orthPointsFallback && (controlHints != null && controlHints.length > 0) || sourceEdge || targetEdge) {
              mxEdgeStyle.SegmentConnector(state, sourceScaled, targetScaled, controlHints, result2);
              return;
            }
            var portConstraint = [mxConstants.DIRECTION_MASK_ALL, mxConstants.DIRECTION_MASK_ALL];
            var rotation = 0;
            if (source != null) {
              portConstraint[0] = mxUtils.getPortConstraints(
                source,
                state,
                true,
                mxConstants.DIRECTION_MASK_ALL
              );
              rotation = mxUtils.getValue(source.style, mxConstants.STYLE_ROTATION, 0);
              if (rotation != 0) {
                var newRect = mxUtils.getBoundingBox(new mxRectangle(sourceX, sourceY, sourceWidth, sourceHeight), rotation);
                sourceX = newRect.x;
                sourceY = newRect.y;
                sourceWidth = newRect.width;
                sourceHeight = newRect.height;
              }
            }
            if (target != null) {
              portConstraint[1] = mxUtils.getPortConstraints(
                target,
                state,
                false,
                mxConstants.DIRECTION_MASK_ALL
              );
              rotation = mxUtils.getValue(target.style, mxConstants.STYLE_ROTATION, 0);
              if (rotation != 0) {
                var newRect = mxUtils.getBoundingBox(new mxRectangle(targetX, targetY, targetWidth, targetHeight), rotation);
                targetX = newRect.x;
                targetY = newRect.y;
                targetWidth = newRect.width;
                targetHeight = newRect.height;
              }
            }
            var dir = [0, 0];
            var geo = [
              [sourceX, sourceY, sourceWidth, sourceHeight],
              [targetX, targetY, targetWidth, targetHeight]
            ];
            var buffer = [sourceBuffer, targetBuffer];
            for (var i = 0; i < 2; i++) {
              mxEdgeStyle.limits[i][1] = geo[i][0] - buffer[i];
              mxEdgeStyle.limits[i][2] = geo[i][1] - buffer[i];
              mxEdgeStyle.limits[i][4] = geo[i][0] + geo[i][2] + buffer[i];
              mxEdgeStyle.limits[i][8] = geo[i][1] + geo[i][3] + buffer[i];
            }
            var sourceCenX = geo[0][0] + geo[0][2] / 2;
            var sourceCenY = geo[0][1] + geo[0][3] / 2;
            var targetCenX = geo[1][0] + geo[1][2] / 2;
            var targetCenY = geo[1][1] + geo[1][3] / 2;
            var dx = sourceCenX - targetCenX;
            var dy = sourceCenY - targetCenY;
            var quad = 0;
            if (dx < 0) {
              if (dy < 0) {
                quad = 2;
              } else {
                quad = 1;
              }
            } else {
              if (dy <= 0) {
                quad = 3;
                if (dx == 0) {
                  quad = 2;
                }
              }
            }
            var currentTerm = null;
            if (source != null) {
              currentTerm = p0;
            }
            var constraint = [[0.5, 0.5], [0.5, 0.5]];
            for (var i = 0; i < 2; i++) {
              if (currentTerm != null) {
                constraint[i][0] = (currentTerm.x - geo[i][0]) / geo[i][2];
                if (Math.abs(currentTerm.x - geo[i][0]) <= 1) {
                  dir[i] = mxConstants.DIRECTION_MASK_WEST;
                } else if (Math.abs(currentTerm.x - geo[i][0] - geo[i][2]) <= 1) {
                  dir[i] = mxConstants.DIRECTION_MASK_EAST;
                }
                constraint[i][1] = (currentTerm.y - geo[i][1]) / geo[i][3];
                if (Math.abs(currentTerm.y - geo[i][1]) <= 1) {
                  dir[i] = mxConstants.DIRECTION_MASK_NORTH;
                } else if (Math.abs(currentTerm.y - geo[i][1] - geo[i][3]) <= 1) {
                  dir[i] = mxConstants.DIRECTION_MASK_SOUTH;
                }
              }
              currentTerm = null;
              if (target != null) {
                currentTerm = pe;
              }
            }
            var sourceTopDist = geo[0][1] - (geo[1][1] + geo[1][3]);
            var sourceLeftDist = geo[0][0] - (geo[1][0] + geo[1][2]);
            var sourceBottomDist = geo[1][1] - (geo[0][1] + geo[0][3]);
            var sourceRightDist = geo[1][0] - (geo[0][0] + geo[0][2]);
            mxEdgeStyle.vertexSeperations[1] = Math.max(sourceLeftDist - totalBuffer, 0);
            mxEdgeStyle.vertexSeperations[2] = Math.max(sourceTopDist - totalBuffer, 0);
            mxEdgeStyle.vertexSeperations[4] = Math.max(sourceBottomDist - totalBuffer, 0);
            mxEdgeStyle.vertexSeperations[3] = Math.max(sourceRightDist - totalBuffer, 0);
            var dirPref = [];
            var horPref = [];
            var vertPref = [];
            horPref[0] = sourceLeftDist >= sourceRightDist ? mxConstants.DIRECTION_MASK_WEST : mxConstants.DIRECTION_MASK_EAST;
            vertPref[0] = sourceTopDist >= sourceBottomDist ? mxConstants.DIRECTION_MASK_NORTH : mxConstants.DIRECTION_MASK_SOUTH;
            horPref[1] = mxUtils.reversePortConstraints(horPref[0]);
            vertPref[1] = mxUtils.reversePortConstraints(vertPref[0]);
            var preferredHorizDist = sourceLeftDist >= sourceRightDist ? sourceLeftDist : sourceRightDist;
            var preferredVertDist = sourceTopDist >= sourceBottomDist ? sourceTopDist : sourceBottomDist;
            var prefOrdering = [[0, 0], [0, 0]];
            var preferredOrderSet = false;
            for (var i = 0; i < 2; i++) {
              if (dir[i] != 0) {
                continue;
              }
              if ((horPref[i] & portConstraint[i]) == 0) {
                horPref[i] = mxUtils.reversePortConstraints(horPref[i]);
              }
              if ((vertPref[i] & portConstraint[i]) == 0) {
                vertPref[i] = mxUtils.reversePortConstraints(vertPref[i]);
              }
              prefOrdering[i][0] = vertPref[i];
              prefOrdering[i][1] = horPref[i];
            }
            if (preferredVertDist > 0 && preferredHorizDist > 0) {
              if ((horPref[0] & portConstraint[0]) > 0 && (vertPref[1] & portConstraint[1]) > 0) {
                prefOrdering[0][0] = horPref[0];
                prefOrdering[0][1] = vertPref[0];
                prefOrdering[1][0] = vertPref[1];
                prefOrdering[1][1] = horPref[1];
                preferredOrderSet = true;
              } else if ((vertPref[0] & portConstraint[0]) > 0 && (horPref[1] & portConstraint[1]) > 0) {
                prefOrdering[0][0] = vertPref[0];
                prefOrdering[0][1] = horPref[0];
                prefOrdering[1][0] = horPref[1];
                prefOrdering[1][1] = vertPref[1];
                preferredOrderSet = true;
              }
            }
            if (preferredVertDist > 0 && !preferredOrderSet) {
              prefOrdering[0][0] = vertPref[0];
              prefOrdering[0][1] = horPref[0];
              prefOrdering[1][0] = vertPref[1];
              prefOrdering[1][1] = horPref[1];
              preferredOrderSet = true;
            }
            if (preferredHorizDist > 0 && !preferredOrderSet) {
              prefOrdering[0][0] = horPref[0];
              prefOrdering[0][1] = vertPref[0];
              prefOrdering[1][0] = horPref[1];
              prefOrdering[1][1] = vertPref[1];
              preferredOrderSet = true;
            }
            for (var i = 0; i < 2; i++) {
              if (dir[i] != 0) {
                continue;
              }
              if ((prefOrdering[i][0] & portConstraint[i]) == 0) {
                prefOrdering[i][0] = prefOrdering[i][1];
              }
              dirPref[i] = prefOrdering[i][0] & portConstraint[i];
              dirPref[i] |= (prefOrdering[i][1] & portConstraint[i]) << 8;
              dirPref[i] |= (prefOrdering[1 - i][i] & portConstraint[i]) << 16;
              dirPref[i] |= (prefOrdering[1 - i][1 - i] & portConstraint[i]) << 24;
              if ((dirPref[i] & 15) == 0) {
                dirPref[i] = dirPref[i] << 8;
              }
              if ((dirPref[i] & 3840) == 0) {
                dirPref[i] = dirPref[i] & 15 | dirPref[i] >> 8;
              }
              if ((dirPref[i] & 983040) == 0) {
                dirPref[i] = dirPref[i] & 65535 | (dirPref[i] & 251658240) >> 8;
              }
              dir[i] = dirPref[i] & 15;
              if (portConstraint[i] == mxConstants.DIRECTION_MASK_WEST || portConstraint[i] == mxConstants.DIRECTION_MASK_NORTH || portConstraint[i] == mxConstants.DIRECTION_MASK_EAST || portConstraint[i] == mxConstants.DIRECTION_MASK_SOUTH) {
                dir[i] = portConstraint[i];
              }
            }
            var sourceIndex = dir[0] == mxConstants.DIRECTION_MASK_EAST ? 3 : dir[0];
            var targetIndex = dir[1] == mxConstants.DIRECTION_MASK_EAST ? 3 : dir[1];
            sourceIndex -= quad;
            targetIndex -= quad;
            if (sourceIndex < 1) {
              sourceIndex += 4;
            }
            if (targetIndex < 1) {
              targetIndex += 4;
            }
            var routePattern = mxEdgeStyle.routePatterns[sourceIndex - 1][targetIndex - 1];
            mxEdgeStyle.wayPoints1[0][0] = geo[0][0];
            mxEdgeStyle.wayPoints1[0][1] = geo[0][1];
            switch (dir[0]) {
              case mxConstants.DIRECTION_MASK_WEST:
                mxEdgeStyle.wayPoints1[0][0] -= sourceBuffer;
                mxEdgeStyle.wayPoints1[0][1] += constraint[0][1] * geo[0][3];
                break;
              case mxConstants.DIRECTION_MASK_SOUTH:
                mxEdgeStyle.wayPoints1[0][0] += constraint[0][0] * geo[0][2];
                mxEdgeStyle.wayPoints1[0][1] += geo[0][3] + sourceBuffer;
                break;
              case mxConstants.DIRECTION_MASK_EAST:
                mxEdgeStyle.wayPoints1[0][0] += geo[0][2] + sourceBuffer;
                mxEdgeStyle.wayPoints1[0][1] += constraint[0][1] * geo[0][3];
                break;
              case mxConstants.DIRECTION_MASK_NORTH:
                mxEdgeStyle.wayPoints1[0][0] += constraint[0][0] * geo[0][2];
                mxEdgeStyle.wayPoints1[0][1] -= sourceBuffer;
                break;
            }
            var currentIndex = 0;
            var lastOrientation = (dir[0] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) > 0 ? 0 : 1;
            var initialOrientation = lastOrientation;
            var currentOrientation = 0;
            for (var i = 0; i < routePattern.length; i++) {
              var nextDirection = routePattern[i] & 15;
              var directionIndex = nextDirection == mxConstants.DIRECTION_MASK_EAST ? 3 : nextDirection;
              directionIndex += quad;
              if (directionIndex > 4) {
                directionIndex -= 4;
              }
              var direction = mxEdgeStyle.dirVectors[directionIndex - 1];
              currentOrientation = directionIndex % 2 > 0 ? 0 : 1;
              if (currentOrientation != lastOrientation) {
                currentIndex++;
                mxEdgeStyle.wayPoints1[currentIndex][0] = mxEdgeStyle.wayPoints1[currentIndex - 1][0];
                mxEdgeStyle.wayPoints1[currentIndex][1] = mxEdgeStyle.wayPoints1[currentIndex - 1][1];
              }
              var tar = (routePattern[i] & mxEdgeStyle.TARGET_MASK) > 0;
              var sou = (routePattern[i] & mxEdgeStyle.SOURCE_MASK) > 0;
              var side = (routePattern[i] & mxEdgeStyle.SIDE_MASK) >> 5;
              side = side << quad;
              if (side > 15) {
                side = side >> 4;
              }
              var center = (routePattern[i] & mxEdgeStyle.CENTER_MASK) > 0;
              if ((sou || tar) && side < 9) {
                var limit = 0;
                var souTar = sou ? 0 : 1;
                if (center && currentOrientation == 0) {
                  limit = geo[souTar][0] + constraint[souTar][0] * geo[souTar][2];
                } else if (center) {
                  limit = geo[souTar][1] + constraint[souTar][1] * geo[souTar][3];
                } else {
                  limit = mxEdgeStyle.limits[souTar][side];
                }
                if (currentOrientation == 0) {
                  var lastX = mxEdgeStyle.wayPoints1[currentIndex][0];
                  var deltaX = (limit - lastX) * direction[0];
                  if (deltaX > 0) {
                    mxEdgeStyle.wayPoints1[currentIndex][0] += direction[0] * deltaX;
                  }
                } else {
                  var lastY = mxEdgeStyle.wayPoints1[currentIndex][1];
                  var deltaY = (limit - lastY) * direction[1];
                  if (deltaY > 0) {
                    mxEdgeStyle.wayPoints1[currentIndex][1] += direction[1] * deltaY;
                  }
                }
              } else if (center) {
                mxEdgeStyle.wayPoints1[currentIndex][0] += direction[0] * Math.abs(mxEdgeStyle.vertexSeperations[directionIndex] / 2);
                mxEdgeStyle.wayPoints1[currentIndex][1] += direction[1] * Math.abs(mxEdgeStyle.vertexSeperations[directionIndex] / 2);
              }
              if (currentIndex > 0 && mxEdgeStyle.wayPoints1[currentIndex][currentOrientation] == mxEdgeStyle.wayPoints1[currentIndex - 1][currentOrientation]) {
                currentIndex--;
              } else {
                lastOrientation = currentOrientation;
              }
            }
            for (var i = 0; i <= currentIndex; i++) {
              if (i == currentIndex) {
                var targetOrientation = (dir[1] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) > 0 ? 0 : 1;
                var sameOrient = targetOrientation == initialOrientation ? 0 : 1;
                if (sameOrient != (currentIndex + 1) % 2) {
                  break;
                }
              }
              result2.push(new mxPoint(
                Math.round(mxEdgeStyle.wayPoints1[i][0] * state.view.scale * 10) / 10,
                Math.round(mxEdgeStyle.wayPoints1[i][1] * state.view.scale * 10) / 10
              ));
            }
            var index = 1;
            while (index < result2.length) {
              if (result2[index - 1] == null || result2[index] == null || result2[index - 1].x != result2[index].x || result2[index - 1].y != result2[index].y) {
                index++;
              } else {
                result2.splice(index, 1);
              }
            }
          },
          getRoutePattern: function(dir, quad, dx, dy) {
            var sourceIndex = dir[0] == mxConstants.DIRECTION_MASK_EAST ? 3 : dir[0];
            var targetIndex = dir[1] == mxConstants.DIRECTION_MASK_EAST ? 3 : dir[1];
            sourceIndex -= quad;
            targetIndex -= quad;
            if (sourceIndex < 1) {
              sourceIndex += 4;
            }
            if (targetIndex < 1) {
              targetIndex += 4;
            }
            var result2 = routePatterns[sourceIndex - 1][targetIndex - 1];
            if (dx == 0 || dy == 0) {
              if (inlineRoutePatterns[sourceIndex - 1][targetIndex - 1] != null) {
                result2 = inlineRoutePatterns[sourceIndex - 1][targetIndex - 1];
              }
            }
            return result2;
          }
        };
        __mxOutput.mxEdgeStyle = typeof mxEdgeStyle !== "undefined" ? mxEdgeStyle : void 0;
        var mxStyleRegistry = {
          /**
           * Class: mxStyleRegistry
           *
           * Singleton class that acts as a global converter from string to object values
           * in a style. This is currently only used to perimeters and edge styles.
           * 
           * Variable: values
           *
           * Maps from strings to objects.
           */
          values: [],
          /**
           * Function: putValue
           *
           * Puts the given object into the registry under the given name.
           */
          putValue: function(name2, obj) {
            mxStyleRegistry.values[name2] = obj;
          },
          /**
           * Function: getValue
           *
           * Returns the value associated with the given name.
           */
          getValue: function(name2) {
            return mxStyleRegistry.values[name2];
          },
          /**
           * Function: getName
           * 
           * Returns the name for the given value.
           */
          getName: function(value) {
            for (var key in mxStyleRegistry.values) {
              if (mxStyleRegistry.values[key] == value) {
                return key;
              }
            }
            return null;
          }
        };
        mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ELBOW, mxEdgeStyle.ElbowConnector);
        mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ENTITY_RELATION, mxEdgeStyle.EntityRelation);
        mxStyleRegistry.putValue(mxConstants.EDGESTYLE_LOOP, mxEdgeStyle.Loop);
        mxStyleRegistry.putValue(mxConstants.EDGESTYLE_SIDETOSIDE, mxEdgeStyle.SideToSide);
        mxStyleRegistry.putValue(mxConstants.EDGESTYLE_TOPTOBOTTOM, mxEdgeStyle.TopToBottom);
        mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ORTHOGONAL, mxEdgeStyle.OrthConnector);
        mxStyleRegistry.putValue(mxConstants.EDGESTYLE_SEGMENT, mxEdgeStyle.SegmentConnector);
        mxStyleRegistry.putValue(mxConstants.PERIMETER_ELLIPSE, mxPerimeter.EllipsePerimeter);
        mxStyleRegistry.putValue(mxConstants.PERIMETER_RECTANGLE, mxPerimeter.RectanglePerimeter);
        mxStyleRegistry.putValue(mxConstants.PERIMETER_RHOMBUS, mxPerimeter.RhombusPerimeter);
        mxStyleRegistry.putValue(mxConstants.PERIMETER_TRIANGLE, mxPerimeter.TrianglePerimeter);
        mxStyleRegistry.putValue(mxConstants.PERIMETER_HEXAGON, mxPerimeter.HexagonPerimeter);
        __mxOutput.mxStyleRegistry = typeof mxStyleRegistry !== "undefined" ? mxStyleRegistry : void 0;
        function mxGraphView(graph) {
          this.graph = graph;
          this.translate = new mxPoint();
          this.graphBounds = new mxRectangle();
          this.states = new mxDictionary();
        }
        ;
        mxGraphView.prototype = new mxEventSource();
        mxGraphView.prototype.constructor = mxGraphView;
        mxGraphView.prototype.EMPTY_POINT = new mxPoint();
        mxGraphView.prototype.doneResource = mxClient.language != "none" ? "done" : "";
        mxGraphView.prototype.updatingDocumentResource = mxClient.language != "none" ? "updatingDocument" : "";
        mxGraphView.prototype.allowEval = false;
        mxGraphView.prototype.captureDocumentGesture = true;
        mxGraphView.prototype.optimizeVmlReflows = true;
        mxGraphView.prototype.rendering = true;
        mxGraphView.prototype.graph = null;
        mxGraphView.prototype.currentRoot = null;
        mxGraphView.prototype.graphBounds = null;
        mxGraphView.prototype.scale = 1;
        mxGraphView.prototype.translate = null;
        mxGraphView.prototype.states = null;
        mxGraphView.prototype.updateStyle = false;
        mxGraphView.prototype.lastNode = null;
        mxGraphView.prototype.lastHtmlNode = null;
        mxGraphView.prototype.lastForegroundNode = null;
        mxGraphView.prototype.lastForegroundHtmlNode = null;
        mxGraphView.prototype.getGraphBounds = function() {
          return this.graphBounds;
        };
        mxGraphView.prototype.setGraphBounds = function(value) {
          this.graphBounds = value;
        };
        mxGraphView.prototype.getBounds = function(cells) {
          var result2 = null;
          if (cells != null && cells.length > 0) {
            var model = this.graph.getModel();
            for (var i = 0; i < cells.length; i++) {
              if (model.isVertex(cells[i]) || model.isEdge(cells[i])) {
                var state = this.getState(cells[i]);
                if (state != null) {
                  if (result2 == null) {
                    result2 = mxRectangle.fromRectangle(state);
                  } else {
                    result2.add(state);
                  }
                }
              }
            }
          }
          return result2;
        };
        mxGraphView.prototype.setCurrentRoot = function(root) {
          if (this.currentRoot != root) {
            var change = new mxCurrentRootChange(this, root);
            change.execute();
            var edit = new mxUndoableEdit(this, true);
            edit.add(change);
            this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", edit));
            this.graph.sizeDidChange();
          }
          return root;
        };
        mxGraphView.prototype.scaleAndTranslate = function(scale, dx, dy) {
          var previousScale = this.scale;
          var previousTranslate = new mxPoint(this.translate.x, this.translate.y);
          if (this.scale != scale || this.translate.x != dx || this.translate.y != dy) {
            this.scale = scale;
            this.translate.x = dx;
            this.translate.y = dy;
            if (this.isEventsEnabled()) {
              this.viewStateChanged();
            }
          }
          this.fireEvent(new mxEventObject(
            mxEvent.SCALE_AND_TRANSLATE,
            "scale",
            scale,
            "previousScale",
            previousScale,
            "translate",
            this.translate,
            "previousTranslate",
            previousTranslate
          ));
        };
        mxGraphView.prototype.getScale = function() {
          return this.scale;
        };
        mxGraphView.prototype.setScale = function(value) {
          this.graph.container.style.display = "none";
          var previousScale = this.scale;
          if (this.scale != value) {
            this.scale = value;
            if (this.isEventsEnabled()) {
              this.viewStateChanged();
            }
          }
          this.fireEvent(new mxEventObject(
            mxEvent.SCALE,
            "scale",
            value,
            "previousScale",
            previousScale
          ));
          this.graph.container.style.display = "";
        };
        mxGraphView.prototype.getTranslate = function() {
          return this.translate;
        };
        mxGraphView.prototype.setTranslate = function(dx, dy) {
          var previousTranslate = new mxPoint(this.translate.x, this.translate.y);
          if (this.translate.x != dx || this.translate.y != dy) {
            this.translate.x = dx;
            this.translate.y = dy;
            if (this.isEventsEnabled()) {
              this.viewStateChanged();
            }
          }
          this.fireEvent(new mxEventObject(
            mxEvent.TRANSLATE,
            "translate",
            this.translate,
            "previousTranslate",
            previousTranslate
          ));
        };
        mxGraphView.prototype.viewStateChanged = function() {
          this.revalidate();
          this.graph.sizeDidChange();
        };
        mxGraphView.prototype.refresh = function() {
          if (this.currentRoot != null) {
            this.clear();
          }
          this.revalidate();
        };
        mxGraphView.prototype.revalidate = function() {
          this.invalidate();
          this.validate();
        };
        mxGraphView.prototype.clear = function(cell2, force, recurse) {
          var model = this.graph.getModel();
          cell2 = cell2 || model.getRoot();
          force = force != null ? force : false;
          recurse = recurse != null ? recurse : true;
          this.removeState(cell2);
          if (recurse && (force || cell2 != this.currentRoot)) {
            var childCount = model.getChildCount(cell2);
            for (var i = 0; i < childCount; i++) {
              this.clear(model.getChildAt(cell2, i), force);
            }
          } else {
            this.invalidate(cell2);
          }
        };
        mxGraphView.prototype.invalidate = function(cell2, recurse, includeEdges) {
          var model = this.graph.getModel();
          cell2 = cell2 || model.getRoot();
          recurse = recurse != null ? recurse : true;
          includeEdges = includeEdges != null ? includeEdges : true;
          var state = this.getState(cell2);
          if (state != null) {
            state.invalid = true;
          }
          if (!cell2.invalidating) {
            cell2.invalidating = true;
            if (recurse) {
              var childCount = model.getChildCount(cell2);
              for (var i = 0; i < childCount; i++) {
                var child = model.getChildAt(cell2, i);
                this.invalidate(child, recurse, includeEdges);
              }
            }
            if (includeEdges) {
              var edgeCount = model.getEdgeCount(cell2);
              for (var i = 0; i < edgeCount; i++) {
                this.invalidate(model.getEdgeAt(cell2, i), recurse, includeEdges);
              }
            }
            delete cell2.invalidating;
          }
        };
        mxGraphView.prototype.validate = function(cell2) {
          var t0 = mxLog.enter("mxGraphView.validate");
          window.status = mxResources.get(this.updatingDocumentResource) || this.updatingDocumentResource;
          this.resetValidationState();
          var prevDisplay = null;
          if (this.optimizeVmlReflows && this.canvas != null && this.textDiv == null && (document.documentMode == 8 && !mxClient.IS_EM || mxClient.IS_QUIRKS)) {
            this.placeholder = document.createElement("div");
            this.placeholder.style.position = "absolute";
            this.placeholder.style.width = this.canvas.clientWidth + "px";
            this.placeholder.style.height = this.canvas.clientHeight + "px";
            this.canvas.parentNode.appendChild(this.placeholder);
            prevDisplay = this.drawPane.style.display;
            this.canvas.style.display = "none";
            this.textDiv = document.createElement("div");
            this.textDiv.style.position = "absolute";
            this.textDiv.style.whiteSpace = "nowrap";
            this.textDiv.style.visibility = "hidden";
            this.textDiv.style.display = mxClient.IS_QUIRKS ? "inline" : "inline-block";
            this.textDiv.style.zoom = "1";
            document.body.appendChild(this.textDiv);
          }
          var graphBounds = this.getBoundingBox(this.validateCellState(
            this.validateCell(cell2 || (this.currentRoot != null ? this.currentRoot : this.graph.getModel().getRoot()))
          ));
          this.setGraphBounds(graphBounds != null ? graphBounds : this.getEmptyBounds());
          this.validateBackground();
          if (prevDisplay != null) {
            this.canvas.style.display = prevDisplay;
            this.textDiv.parentNode.removeChild(this.textDiv);
            if (this.placeholder != null) {
              this.placeholder.parentNode.removeChild(this.placeholder);
            }
            this.textDiv = null;
          }
          this.resetValidationState();
          window.status = mxResources.get(this.doneResource) || this.doneResource;
          mxLog.leave("mxGraphView.validate", t0);
        };
        mxGraphView.prototype.getEmptyBounds = function() {
          return new mxRectangle(this.translate.x * this.scale, this.translate.y * this.scale);
        };
        mxGraphView.prototype.getBoundingBox = function(state, recurse) {
          recurse = recurse != null ? recurse : true;
          var bbox = null;
          if (state != null) {
            if (state.shape != null && state.shape.boundingBox != null) {
              bbox = state.shape.boundingBox.clone();
            }
            if (state.text != null && state.text.boundingBox != null) {
              if (bbox != null) {
                bbox.add(state.text.boundingBox);
              } else {
                bbox = state.text.boundingBox.clone();
              }
            }
            if (recurse) {
              var model = this.graph.getModel();
              var childCount = model.getChildCount(state.cell);
              for (var i = 0; i < childCount; i++) {
                var bounds = this.getBoundingBox(this.getState(model.getChildAt(state.cell, i)));
                if (bounds != null) {
                  if (bbox == null) {
                    bbox = bounds;
                  } else {
                    bbox.add(bounds);
                  }
                }
              }
            }
          }
          return bbox;
        };
        mxGraphView.prototype.createBackgroundPageShape = function(bounds) {
          return new mxRectangleShape(bounds, "white", "black");
        };
        mxGraphView.prototype.validateBackground = function() {
          this.validateBackgroundImage();
          this.validateBackgroundPage();
        };
        mxGraphView.prototype.validateBackgroundImage = function() {
          var bg = this.graph.getBackgroundImage();
          if (bg != null) {
            if (this.backgroundImage == null || this.backgroundImage.image != bg.src) {
              if (this.backgroundImage != null) {
                this.backgroundImage.destroy();
              }
              var bounds = new mxRectangle(0, 0, 1, 1);
              this.backgroundImage = new mxImageShape(bounds, bg.src);
              this.backgroundImage.dialect = this.graph.dialect;
              this.backgroundImage.init(this.backgroundPane);
              this.backgroundImage.redraw();
              if (document.documentMode == 8 && !mxClient.IS_EM) {
                mxEvent.addGestureListeners(
                  this.backgroundImage.node,
                  mxUtils.bind(this, function(evt) {
                    this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
                  }),
                  mxUtils.bind(this, function(evt) {
                    this.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
                  }),
                  mxUtils.bind(this, function(evt) {
                    this.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
                  })
                );
              }
            }
            this.redrawBackgroundImage(this.backgroundImage, bg);
          } else if (this.backgroundImage != null) {
            this.backgroundImage.destroy();
            this.backgroundImage = null;
          }
        };
        mxGraphView.prototype.validateBackgroundPage = function() {
          if (this.graph.pageVisible) {
            var bounds = this.getBackgroundPageBounds();
            if (this.backgroundPageShape == null) {
              this.backgroundPageShape = this.createBackgroundPageShape(bounds);
              this.backgroundPageShape.scale = this.scale;
              this.backgroundPageShape.isShadow = true;
              this.backgroundPageShape.dialect = this.graph.dialect;
              this.backgroundPageShape.init(this.backgroundPane);
              this.backgroundPageShape.redraw();
              if (this.graph.nativeDblClickEnabled) {
                mxEvent.addListener(this.backgroundPageShape.node, "dblclick", mxUtils.bind(this, function(evt) {
                  this.graph.dblClick(evt);
                }));
              }
              mxEvent.addGestureListeners(
                this.backgroundPageShape.node,
                mxUtils.bind(this, function(evt) {
                  this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
                }),
                mxUtils.bind(this, function(evt) {
                  if (this.graph.tooltipHandler != null && this.graph.tooltipHandler.isHideOnHover()) {
                    this.graph.tooltipHandler.hide();
                  }
                  if (this.graph.isMouseDown && !mxEvent.isConsumed(evt)) {
                    this.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
                  }
                }),
                mxUtils.bind(this, function(evt) {
                  this.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
                })
              );
            } else {
              this.backgroundPageShape.scale = this.scale;
              this.backgroundPageShape.bounds = bounds;
              this.backgroundPageShape.redraw();
            }
          } else if (this.backgroundPageShape != null) {
            this.backgroundPageShape.destroy();
            this.backgroundPageShape = null;
          }
        };
        mxGraphView.prototype.getBackgroundPageBounds = function() {
          var fmt = this.graph.pageFormat;
          var ps = this.scale * this.graph.pageScale;
          var bounds = new mxRectangle(
            this.scale * this.translate.x,
            this.scale * this.translate.y,
            fmt.width * ps,
            fmt.height * ps
          );
          return bounds;
        };
        mxGraphView.prototype.redrawBackgroundImage = function(backgroundImage, bg) {
          backgroundImage.scale = this.scale;
          backgroundImage.bounds.x = this.scale * this.translate.x;
          backgroundImage.bounds.y = this.scale * this.translate.y;
          backgroundImage.bounds.width = this.scale * bg.width;
          backgroundImage.bounds.height = this.scale * bg.height;
          backgroundImage.redraw();
        };
        mxGraphView.prototype.validateCell = function(cell2, visible) {
          visible = visible != null ? visible : true;
          if (cell2 != null) {
            visible = visible && this.graph.isCellVisible(cell2);
            var state = this.getState(cell2, visible);
            if (state != null && !visible) {
              this.removeState(cell2);
            } else {
              var model = this.graph.getModel();
              var childCount = model.getChildCount(cell2);
              for (var i = 0; i < childCount; i++) {
                this.validateCell(model.getChildAt(cell2, i), visible && (!this.isCellCollapsed(cell2) || cell2 == this.currentRoot));
              }
            }
          }
          return cell2;
        };
        mxGraphView.prototype.validateCellState = function(cell2, recurse) {
          recurse = recurse != null ? recurse : true;
          var state = null;
          if (cell2 != null) {
            state = this.getState(cell2);
            if (state != null) {
              var model = this.graph.getModel();
              if (state.invalid) {
                state.invalid = false;
                if (state.style == null || state.invalidStyle) {
                  state.style = this.graph.getCellStyle(state.cell);
                  state.invalidStyle = false;
                }
                if (cell2 != this.currentRoot) {
                  this.validateCellState(model.getParent(cell2), false);
                }
                state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell2, true), false), true);
                state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell2, false), false), false);
                this.updateCellState(state);
                if (cell2 != this.currentRoot && !state.invalid) {
                  this.graph.cellRenderer.redraw(state, false, this.isRendering());
                  state.updateCachedBounds();
                }
              }
              if (recurse && !state.invalid) {
                if (state.shape != null) {
                  this.stateValidated(state);
                }
                var childCount = model.getChildCount(cell2);
                for (var i = 0; i < childCount; i++) {
                  this.validateCellState(model.getChildAt(cell2, i));
                }
              }
            }
          }
          return state;
        };
        mxGraphView.prototype.updateCellState = function(state) {
          state.absoluteOffset.x = 0;
          state.absoluteOffset.y = 0;
          state.origin.x = 0;
          state.origin.y = 0;
          state.length = 0;
          if (state.cell != this.currentRoot) {
            var model = this.graph.getModel();
            var pState = this.getState(model.getParent(state.cell));
            if (pState != null && pState.cell != this.currentRoot) {
              state.origin.x += pState.origin.x;
              state.origin.y += pState.origin.y;
            }
            var offset = this.graph.getChildOffsetForCell(state.cell);
            if (offset != null) {
              state.origin.x += offset.x;
              state.origin.y += offset.y;
            }
            var geo = this.graph.getCellGeometry(state.cell);
            if (geo != null) {
              if (!model.isEdge(state.cell)) {
                offset = geo.offset != null ? geo.offset : this.EMPTY_POINT;
                if (geo.relative && pState != null) {
                  if (model.isEdge(pState.cell)) {
                    var origin = this.getPoint(pState, geo);
                    if (origin != null) {
                      state.origin.x += origin.x / this.scale - pState.origin.x - this.translate.x;
                      state.origin.y += origin.y / this.scale - pState.origin.y - this.translate.y;
                    }
                  } else {
                    state.origin.x += geo.x * pState.unscaledWidth + offset.x;
                    state.origin.y += geo.y * pState.unscaledHeight + offset.y;
                  }
                } else {
                  state.absoluteOffset.x = this.scale * offset.x;
                  state.absoluteOffset.y = this.scale * offset.y;
                  state.origin.x += geo.x;
                  state.origin.y += geo.y;
                }
              }
              state.x = this.scale * (this.translate.x + state.origin.x);
              state.y = this.scale * (this.translate.y + state.origin.y);
              state.width = this.scale * geo.width;
              state.unscaledWidth = geo.width;
              state.height = this.scale * geo.height;
              state.unscaledHeight = geo.height;
              if (model.isVertex(state.cell)) {
                this.updateVertexState(state, geo);
              }
              if (model.isEdge(state.cell)) {
                this.updateEdgeState(state, geo);
              }
            }
          }
          state.updateCachedBounds();
        };
        mxGraphView.prototype.isCellCollapsed = function(cell2) {
          return this.graph.isCellCollapsed(cell2);
        };
        mxGraphView.prototype.updateVertexState = function(state, geo) {
          var model = this.graph.getModel();
          var pState = this.getState(model.getParent(state.cell));
          if (geo.relative && pState != null && !model.isEdge(pState.cell)) {
            var alpha = mxUtils.toRadians(pState.style[mxConstants.STYLE_ROTATION] || "0");
            if (alpha != 0) {
              var cos = Math.cos(alpha);
              var sin = Math.sin(alpha);
              var ct = new mxPoint(state.getCenterX(), state.getCenterY());
              var cx = new mxPoint(pState.getCenterX(), pState.getCenterY());
              var pt = mxUtils.getRotatedPoint(ct, cos, sin, cx);
              state.x = pt.x - state.width / 2;
              state.y = pt.y - state.height / 2;
            }
          }
          this.updateVertexLabelOffset(state);
        };
        mxGraphView.prototype.updateEdgeState = function(state, geo) {
          var source = state.getVisibleTerminalState(true);
          var target = state.getVisibleTerminalState(false);
          if (this.graph.model.getTerminal(state.cell, true) != null && source == null || source == null && geo.getTerminalPoint(true) == null || this.graph.model.getTerminal(state.cell, false) != null && target == null || target == null && geo.getTerminalPoint(false) == null) {
            this.clear(state.cell, true);
          } else {
            this.updateFixedTerminalPoints(state, source, target);
            this.updatePoints(state, geo.points, source, target);
            this.updateFloatingTerminalPoints(state, source, target);
            var pts = state.absolutePoints;
            if (state.cell != this.currentRoot && (pts == null || pts.length < 2 || pts[0] == null || pts[pts.length - 1] == null)) {
              this.clear(state.cell, true);
            } else {
              this.updateEdgeBounds(state);
              this.updateEdgeLabelOffset(state);
            }
          }
        };
        mxGraphView.prototype.updateVertexLabelOffset = function(state) {
          var h2 = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
          if (h2 == mxConstants.ALIGN_LEFT) {
            var lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);
            if (lw != null) {
              lw *= this.scale;
            } else {
              lw = state.width;
            }
            state.absoluteOffset.x -= lw;
          } else if (h2 == mxConstants.ALIGN_RIGHT) {
            state.absoluteOffset.x += state.width;
          } else if (h2 == mxConstants.ALIGN_CENTER) {
            var lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);
            if (lw != null) {
              var align = mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER);
              var dx = 0;
              if (align == mxConstants.ALIGN_CENTER) {
                dx = 0.5;
              } else if (align == mxConstants.ALIGN_RIGHT) {
                dx = 1;
              }
              if (dx != 0) {
                state.absoluteOffset.x -= (lw * this.scale - state.width) * dx;
              }
            }
          }
          var v = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
          if (v == mxConstants.ALIGN_TOP) {
            state.absoluteOffset.y -= state.height;
          } else if (v == mxConstants.ALIGN_BOTTOM) {
            state.absoluteOffset.y += state.height;
          }
        };
        mxGraphView.prototype.resetValidationState = function() {
          this.lastNode = null;
          this.lastHtmlNode = null;
          this.lastForegroundNode = null;
          this.lastForegroundHtmlNode = null;
        };
        mxGraphView.prototype.stateValidated = function(state) {
          var fg = this.graph.getModel().isEdge(state.cell) && this.graph.keepEdgesInForeground || this.graph.getModel().isVertex(state.cell) && this.graph.keepEdgesInBackground;
          var htmlNode = fg ? this.lastForegroundHtmlNode || this.lastHtmlNode : this.lastHtmlNode;
          var node = fg ? this.lastForegroundNode || this.lastNode : this.lastNode;
          var result2 = this.graph.cellRenderer.insertStateAfter(state, node, htmlNode);
          if (fg) {
            this.lastForegroundHtmlNode = result2[1];
            this.lastForegroundNode = result2[0];
          } else {
            this.lastHtmlNode = result2[1];
            this.lastNode = result2[0];
          }
        };
        mxGraphView.prototype.updateFixedTerminalPoints = function(edge, source, target) {
          this.updateFixedTerminalPoint(
            edge,
            source,
            true,
            this.graph.getConnectionConstraint(edge, source, true)
          );
          this.updateFixedTerminalPoint(
            edge,
            target,
            false,
            this.graph.getConnectionConstraint(edge, target, false)
          );
        };
        mxGraphView.prototype.updateFixedTerminalPoint = function(edge, terminal, source, constraint) {
          edge.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(edge, terminal, source, constraint), source);
        };
        mxGraphView.prototype.getFixedTerminalPoint = function(edge, terminal, source, constraint) {
          var pt = null;
          if (constraint != null) {
            pt = this.graph.getConnectionPoint(terminal, constraint, false);
          }
          if (pt == null && terminal == null) {
            var s = this.scale;
            var tr = this.translate;
            var orig = edge.origin;
            var geo = this.graph.getCellGeometry(edge.cell);
            pt = geo.getTerminalPoint(source);
            if (pt != null) {
              pt = new mxPoint(
                s * (tr.x + pt.x + orig.x),
                s * (tr.y + pt.y + orig.y)
              );
            }
          }
          return pt;
        };
        mxGraphView.prototype.updateBoundsFromStencil = function(state) {
          var previous = null;
          if (state != null && state.shape != null && state.shape.stencil != null && state.shape.stencil.aspect == "fixed") {
            previous = mxRectangle.fromRectangle(state);
            var asp = state.shape.stencil.computeAspect(state.style, state.x, state.y, state.width, state.height);
            state.setRect(asp.x, asp.y, state.shape.stencil.w0 * asp.width, state.shape.stencil.h0 * asp.height);
          }
          return previous;
        };
        mxGraphView.prototype.updatePoints = function(edge, points, source, target) {
          if (edge != null) {
            var pts = [];
            pts.push(edge.absolutePoints[0]);
            var edgeStyle = this.getEdgeStyle(edge, points, source, target);
            if (edgeStyle != null) {
              var src = this.getTerminalPort(edge, source, true);
              var trg = this.getTerminalPort(edge, target, false);
              var srcBounds = this.updateBoundsFromStencil(src);
              var trgBounds = this.updateBoundsFromStencil(trg);
              edgeStyle(edge, src, trg, points, pts);
              if (srcBounds != null) {
                src.setRect(srcBounds.x, srcBounds.y, srcBounds.width, srcBounds.height);
              }
              if (trgBounds != null) {
                trg.setRect(trgBounds.x, trgBounds.y, trgBounds.width, trgBounds.height);
              }
            } else if (points != null) {
              for (var i = 0; i < points.length; i++) {
                if (points[i] != null) {
                  var pt = mxUtils.clone(points[i]);
                  pts.push(this.transformControlPoint(edge, pt));
                }
              }
            }
            var tmp = edge.absolutePoints;
            pts.push(tmp[tmp.length - 1]);
            edge.absolutePoints = pts;
          }
        };
        mxGraphView.prototype.transformControlPoint = function(state, pt, ignoreScale) {
          if (state != null && pt != null) {
            var orig = state.origin;
            var scale = ignoreScale ? 1 : this.scale;
            return new mxPoint(
              scale * (pt.x + this.translate.x + orig.x),
              scale * (pt.y + this.translate.y + orig.y)
            );
          }
          return null;
        };
        mxGraphView.prototype.isLoopStyleEnabled = function(edge, points, source, target) {
          var sc = this.graph.getConnectionConstraint(edge, source, true);
          var tc = this.graph.getConnectionConstraint(edge, target, false);
          if ((points == null || points.length < 2) && (!mxUtils.getValue(edge.style, mxConstants.STYLE_ORTHOGONAL_LOOP, false) || (sc == null || sc.point == null) && (tc == null || tc.point == null))) {
            return source != null && source == target;
          }
          return false;
        };
        mxGraphView.prototype.getEdgeStyle = function(edge, points, source, target) {
          var edgeStyle = this.isLoopStyleEnabled(edge, points, source, target) ? mxUtils.getValue(edge.style, mxConstants.STYLE_LOOP, this.graph.defaultLoopStyle) : !mxUtils.getValue(edge.style, mxConstants.STYLE_NOEDGESTYLE, false) ? edge.style[mxConstants.STYLE_EDGE] : null;
          if (typeof edgeStyle == "string") {
            var tmp = mxStyleRegistry.getValue(edgeStyle);
            if (tmp == null && this.isAllowEval()) {
              tmp = mxUtils.eval(edgeStyle);
            }
            edgeStyle = tmp;
          }
          if (typeof edgeStyle == "function") {
            return edgeStyle;
          }
          return null;
        };
        mxGraphView.prototype.updateFloatingTerminalPoints = function(state, source, target) {
          var pts = state.absolutePoints;
          var p0 = pts[0];
          var pe = pts[pts.length - 1];
          if (pe == null && target != null) {
            this.updateFloatingTerminalPoint(state, target, source, false);
          }
          if (p0 == null && source != null) {
            this.updateFloatingTerminalPoint(state, source, target, true);
          }
        };
        mxGraphView.prototype.updateFloatingTerminalPoint = function(edge, start, end, source) {
          edge.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge, start, end, source), source);
        };
        mxGraphView.prototype.getFloatingTerminalPoint = function(edge, start, end, source) {
          start = this.getTerminalPort(edge, start, source);
          var next = this.getNextPoint(edge, end, source);
          var orth = this.graph.isOrthogonal(edge);
          var alpha = mxUtils.toRadians(Number(start.style[mxConstants.STYLE_ROTATION] || "0"));
          var center = new mxPoint(start.getCenterX(), start.getCenterY());
          if (alpha != 0) {
            var cos = Math.cos(-alpha);
            var sin = Math.sin(-alpha);
            next = mxUtils.getRotatedPoint(next, cos, sin, center);
          }
          var border = parseFloat(edge.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);
          border += parseFloat(edge.style[source ? mxConstants.STYLE_SOURCE_PERIMETER_SPACING : mxConstants.STYLE_TARGET_PERIMETER_SPACING] || 0);
          var pt = this.getPerimeterPoint(start, next, alpha == 0 && orth, border);
          if (alpha != 0) {
            var cos = Math.cos(alpha);
            var sin = Math.sin(alpha);
            pt = mxUtils.getRotatedPoint(pt, cos, sin, center);
          }
          return pt;
        };
        mxGraphView.prototype.getTerminalPort = function(state, terminal, source) {
          var key = source ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT;
          var id = mxUtils.getValue(state.style, key);
          if (id != null) {
            var tmp = this.getState(this.graph.getModel().getCell(id));
            if (tmp != null) {
              terminal = tmp;
            }
          }
          return terminal;
        };
        mxGraphView.prototype.getPerimeterPoint = function(terminal, next, orthogonal, border) {
          var point = null;
          if (terminal != null) {
            var perimeter = this.getPerimeterFunction(terminal);
            if (perimeter != null && next != null) {
              var bounds = this.getPerimeterBounds(terminal, border);
              if (bounds.width > 0 || bounds.height > 0) {
                point = new mxPoint(next.x, next.y);
                var flipH = false;
                var flipV = false;
                if (this.graph.model.isVertex(terminal.cell)) {
                  flipH = mxUtils.getValue(terminal.style, mxConstants.STYLE_FLIPH, 0) == 1;
                  flipV = mxUtils.getValue(terminal.style, mxConstants.STYLE_FLIPV, 0) == 1;
                  if (terminal.shape != null && terminal.shape.stencil != null) {
                    flipH = mxUtils.getValue(terminal.style, "stencilFlipH", 0) == 1 || flipH;
                    flipV = mxUtils.getValue(terminal.style, "stencilFlipV", 0) == 1 || flipV;
                  }
                  if (flipH) {
                    point.x = 2 * bounds.getCenterX() - point.x;
                  }
                  if (flipV) {
                    point.y = 2 * bounds.getCenterY() - point.y;
                  }
                }
                point = perimeter(bounds, terminal, point, orthogonal);
                if (point != null) {
                  if (flipH) {
                    point.x = 2 * bounds.getCenterX() - point.x;
                  }
                  if (flipV) {
                    point.y = 2 * bounds.getCenterY() - point.y;
                  }
                }
              }
            }
            if (point == null) {
              point = this.getPoint(terminal);
            }
          }
          return point;
        };
        mxGraphView.prototype.getRoutingCenterX = function(state) {
          var f = state.style != null ? parseFloat(state.style[mxConstants.STYLE_ROUTING_CENTER_X]) || 0 : 0;
          return state.getCenterX() + f * state.width;
        };
        mxGraphView.prototype.getRoutingCenterY = function(state) {
          var f = state.style != null ? parseFloat(state.style[mxConstants.STYLE_ROUTING_CENTER_Y]) || 0 : 0;
          return state.getCenterY() + f * state.height;
        };
        mxGraphView.prototype.getPerimeterBounds = function(terminal, border) {
          border = border != null ? border : 0;
          if (terminal != null) {
            border += parseFloat(terminal.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);
          }
          return terminal.getPerimeterBounds(border * this.scale);
        };
        mxGraphView.prototype.getPerimeterFunction = function(state) {
          var perimeter = state.style[mxConstants.STYLE_PERIMETER];
          if (typeof perimeter == "string") {
            var tmp = mxStyleRegistry.getValue(perimeter);
            if (tmp == null && this.isAllowEval()) {
              tmp = mxUtils.eval(perimeter);
            }
            perimeter = tmp;
          }
          if (typeof perimeter == "function") {
            return perimeter;
          }
          return null;
        };
        mxGraphView.prototype.getNextPoint = function(edge, opposite, source) {
          var pts = edge.absolutePoints;
          var point = null;
          if (pts != null && pts.length >= 2) {
            var count = pts.length;
            point = pts[source ? Math.min(1, count - 1) : Math.max(0, count - 2)];
          }
          if (point == null && opposite != null) {
            point = new mxPoint(opposite.getCenterX(), opposite.getCenterY());
          }
          return point;
        };
        mxGraphView.prototype.getVisibleTerminal = function(edge, source) {
          var model = this.graph.getModel();
          var result2 = model.getTerminal(edge, source);
          var best = result2;
          while (result2 != null && result2 != this.currentRoot) {
            if (!this.graph.isCellVisible(best) || this.isCellCollapsed(result2)) {
              best = result2;
            }
            result2 = model.getParent(result2);
          }
          if (best != null && (!model.contains(best) || model.getParent(best) == model.getRoot() || best == this.currentRoot)) {
            best = null;
          }
          return best;
        };
        mxGraphView.prototype.updateEdgeBounds = function(state) {
          var points = state.absolutePoints;
          var p0 = points[0];
          var pe = points[points.length - 1];
          if (p0.x != pe.x || p0.y != pe.y) {
            var dx = pe.x - p0.x;
            var dy = pe.y - p0.y;
            state.terminalDistance = Math.sqrt(dx * dx + dy * dy);
          } else {
            state.terminalDistance = 0;
          }
          var length = 0;
          var segments = [];
          var pt = p0;
          if (pt != null) {
            var minX = pt.x;
            var minY = pt.y;
            var maxX = minX;
            var maxY = minY;
            for (var i = 1; i < points.length; i++) {
              var tmp = points[i];
              if (tmp != null) {
                var dx = pt.x - tmp.x;
                var dy = pt.y - tmp.y;
                var segment = Math.sqrt(dx * dx + dy * dy);
                segments.push(segment);
                length += segment;
                pt = tmp;
                minX = Math.min(pt.x, minX);
                minY = Math.min(pt.y, minY);
                maxX = Math.max(pt.x, maxX);
                maxY = Math.max(pt.y, maxY);
              }
            }
            state.length = length;
            state.segments = segments;
            var markerSize = 1;
            state.x = minX;
            state.y = minY;
            state.width = Math.max(markerSize, maxX - minX);
            state.height = Math.max(markerSize, maxY - minY);
          }
        };
        mxGraphView.prototype.getPoint = function(state, geometry) {
          var x = state.getCenterX();
          var y = state.getCenterY();
          if (state.segments != null && (geometry == null || geometry.relative)) {
            var gx = geometry != null ? geometry.x / 2 : 0;
            var pointCount = state.absolutePoints.length;
            var dist = Math.round((gx + 0.5) * state.length);
            var segment = state.segments[0];
            var length = 0;
            var index = 1;
            while (dist >= Math.round(length + segment) && index < pointCount - 1) {
              length += segment;
              segment = state.segments[index++];
            }
            var factor = segment == 0 ? 0 : (dist - length) / segment;
            var p0 = state.absolutePoints[index - 1];
            var pe = state.absolutePoints[index];
            if (p0 != null && pe != null) {
              var gy = 0;
              var offsetX = 0;
              var offsetY = 0;
              if (geometry != null) {
                gy = geometry.y;
                var offset = geometry.offset;
                if (offset != null) {
                  offsetX = offset.x;
                  offsetY = offset.y;
                }
              }
              var dx = pe.x - p0.x;
              var dy = pe.y - p0.y;
              var nx = segment == 0 ? 0 : dy / segment;
              var ny = segment == 0 ? 0 : dx / segment;
              x = p0.x + dx * factor + (nx * gy + offsetX) * this.scale;
              y = p0.y + dy * factor - (ny * gy - offsetY) * this.scale;
            }
          } else if (geometry != null) {
            var offset = geometry.offset;
            if (offset != null) {
              x += offset.x;
              y += offset.y;
            }
          }
          return new mxPoint(x, y);
        };
        mxGraphView.prototype.getRelativePoint = function(edgeState, x, y) {
          var model = this.graph.getModel();
          var geometry = model.getGeometry(edgeState.cell);
          if (geometry != null) {
            var pointCount = edgeState.absolutePoints.length;
            if (geometry.relative && pointCount > 1) {
              var totalLength = edgeState.length;
              var segments = edgeState.segments;
              var p0 = edgeState.absolutePoints[0];
              var pe = edgeState.absolutePoints[1];
              var minDist = mxUtils.ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);
              var length = 0;
              var index = 0;
              var tmp = 0;
              for (var i = 2; i < pointCount; i++) {
                p0 = pe;
                pe = edgeState.absolutePoints[i];
                var dist = mxUtils.ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);
                tmp += segments[i - 2];
                if (dist <= minDist) {
                  minDist = dist;
                  index = i - 1;
                  length = tmp;
                }
              }
              var seg = segments[index];
              p0 = edgeState.absolutePoints[index];
              pe = edgeState.absolutePoints[index + 1];
              var x2 = p0.x;
              var y2 = p0.y;
              var x1 = pe.x;
              var y1 = pe.y;
              var px2 = x;
              var py = y;
              var xSegment = x2 - x1;
              var ySegment = y2 - y1;
              px2 -= x1;
              py -= y1;
              var projlenSq = 0;
              px2 = xSegment - px2;
              py = ySegment - py;
              var dotprod = px2 * xSegment + py * ySegment;
              if (dotprod <= 0) {
                projlenSq = 0;
              } else {
                projlenSq = dotprod * dotprod / (xSegment * xSegment + ySegment * ySegment);
              }
              var projlen = Math.sqrt(projlenSq);
              if (projlen > seg) {
                projlen = seg;
              }
              var yDistance = Math.sqrt(mxUtils.ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y));
              var direction = mxUtils.relativeCcw(p0.x, p0.y, pe.x, pe.y, x, y);
              if (direction == -1) {
                yDistance = -yDistance;
              }
              return new mxPoint(
                (totalLength / 2 - length - projlen) / totalLength * -2,
                yDistance / this.scale
              );
            }
          }
          return new mxPoint();
        };
        mxGraphView.prototype.updateEdgeLabelOffset = function(state) {
          var points = state.absolutePoints;
          state.absoluteOffset.x = state.getCenterX();
          state.absoluteOffset.y = state.getCenterY();
          if (points != null && points.length > 0 && state.segments != null) {
            var geometry = this.graph.getCellGeometry(state.cell);
            if (geometry.relative) {
              var offset = this.getPoint(state, geometry);
              if (offset != null) {
                state.absoluteOffset = offset;
              }
            } else {
              var p0 = points[0];
              var pe = points[points.length - 1];
              if (p0 != null && pe != null) {
                var dx = pe.x - p0.x;
                var dy = pe.y - p0.y;
                var x0 = 0;
                var y0 = 0;
                var off = geometry.offset;
                if (off != null) {
                  x0 = off.x;
                  y0 = off.y;
                }
                var x = p0.x + dx / 2 + x0 * this.scale;
                var y = p0.y + dy / 2 + y0 * this.scale;
                state.absoluteOffset.x = x;
                state.absoluteOffset.y = y;
              }
            }
          }
        };
        mxGraphView.prototype.getState = function(cell2, create) {
          create = create || false;
          var state = null;
          if (cell2 != null) {
            state = this.states.get(cell2);
            if (create && (state == null || this.updateStyle) && this.graph.isCellVisible(cell2)) {
              if (state == null) {
                state = this.createState(cell2);
                this.states.put(cell2, state);
              } else {
                state.style = this.graph.getCellStyle(cell2);
              }
            }
          }
          return state;
        };
        mxGraphView.prototype.isRendering = function() {
          return this.rendering;
        };
        mxGraphView.prototype.setRendering = function(value) {
          this.rendering = value;
        };
        mxGraphView.prototype.isAllowEval = function() {
          return this.allowEval;
        };
        mxGraphView.prototype.setAllowEval = function(value) {
          this.allowEval = value;
        };
        mxGraphView.prototype.getStates = function() {
          return this.states;
        };
        mxGraphView.prototype.setStates = function(value) {
          this.states = value;
        };
        mxGraphView.prototype.getCellStates = function(cells) {
          if (cells == null) {
            return this.states;
          } else {
            var result2 = [];
            for (var i = 0; i < cells.length; i++) {
              var state = this.getState(cells[i]);
              if (state != null) {
                result2.push(state);
              }
            }
            return result2;
          }
        };
        mxGraphView.prototype.removeState = function(cell2) {
          var state = null;
          if (cell2 != null) {
            state = this.states.remove(cell2);
            if (state != null) {
              this.graph.cellRenderer.destroy(state);
              state.invalid = true;
              state.destroy();
            }
          }
          return state;
        };
        mxGraphView.prototype.createState = function(cell2) {
          return new mxCellState(this, cell2, this.graph.getCellStyle(cell2));
        };
        mxGraphView.prototype.getCanvas = function() {
          return this.canvas;
        };
        mxGraphView.prototype.getBackgroundPane = function() {
          return this.backgroundPane;
        };
        mxGraphView.prototype.getDrawPane = function() {
          return this.drawPane;
        };
        mxGraphView.prototype.getOverlayPane = function() {
          return this.overlayPane;
        };
        mxGraphView.prototype.getDecoratorPane = function() {
          return this.decoratorPane;
        };
        mxGraphView.prototype.isContainerEvent = function(evt) {
          var source = mxEvent.getSource(evt);
          return source == this.graph.container || source.parentNode == this.backgroundPane || source.parentNode != null && source.parentNode.parentNode == this.backgroundPane || source == this.canvas.parentNode || source == this.canvas || source == this.backgroundPane || source == this.drawPane || source == this.overlayPane || source == this.decoratorPane;
        };
        mxGraphView.prototype.isScrollEvent = function(evt) {
          var offset = mxUtils.getOffset(this.graph.container);
          var pt = new mxPoint(evt.clientX - offset.x, evt.clientY - offset.y);
          var outWidth = this.graph.container.offsetWidth;
          var inWidth = this.graph.container.clientWidth;
          if (outWidth > inWidth && pt.x > inWidth + 2 && pt.x <= outWidth) {
            return true;
          }
          var outHeight = this.graph.container.offsetHeight;
          var inHeight = this.graph.container.clientHeight;
          if (outHeight > inHeight && pt.y > inHeight + 2 && pt.y <= outHeight) {
            return true;
          }
          return false;
        };
        mxGraphView.prototype.init = function() {
          this.installListeners();
          var graph = this.graph;
          if (graph.dialect == mxConstants.DIALECT_SVG) {
            this.createSvg();
          } else if (graph.dialect == mxConstants.DIALECT_VML) {
            this.createVml();
          } else {
            this.createHtml();
          }
        };
        mxGraphView.prototype.installListeners = function() {
          var graph = this.graph;
          var container = graph.container;
          if (container != null) {
            if (mxClient.IS_TOUCH) {
              mxEvent.addListener(container, "gesturestart", mxUtils.bind(this, function(evt) {
                graph.fireGestureEvent(evt);
                mxEvent.consume(evt);
              }));
              mxEvent.addListener(container, "gesturechange", mxUtils.bind(this, function(evt) {
                graph.fireGestureEvent(evt);
                mxEvent.consume(evt);
              }));
              mxEvent.addListener(container, "gestureend", mxUtils.bind(this, function(evt) {
                graph.fireGestureEvent(evt);
                mxEvent.consume(evt);
              }));
            }
            var pointerId = null;
            mxEvent.addGestureListeners(
              container,
              mxUtils.bind(this, function(evt) {
                if (this.isContainerEvent(evt) && (!mxClient.IS_IE && !mxClient.IS_IE11 && !mxClient.IS_GC && !mxClient.IS_OP && !mxClient.IS_SF || !this.isScrollEvent(evt))) {
                  graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
                  pointerId = evt.pointerId;
                }
              }),
              mxUtils.bind(this, function(evt) {
                if (this.isContainerEvent(evt) && (pointerId == null || evt.pointerId == pointerId)) {
                  graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
                }
              }),
              mxUtils.bind(this, function(evt) {
                if (this.isContainerEvent(evt)) {
                  graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
                }
                pointerId = null;
              })
            );
            mxEvent.addListener(container, "dblclick", mxUtils.bind(this, function(evt) {
              if (this.isContainerEvent(evt)) {
                graph.dblClick(evt);
              }
            }));
            var getState = function(evt) {
              var state = null;
              if (mxClient.IS_TOUCH) {
                var x = mxEvent.getClientX(evt);
                var y = mxEvent.getClientY(evt);
                var pt = mxUtils.convertPoint(container, x, y);
                state = graph.view.getState(graph.getCellAt(pt.x, pt.y));
              }
              return state;
            };
            graph.addMouseListener(
              {
                mouseDown: function(sender, me) {
                  graph.popupMenuHandler.hideMenu();
                },
                mouseMove: function() {
                },
                mouseUp: function() {
                }
              }
            );
            this.moveHandler = mxUtils.bind(this, function(evt) {
              if (graph.tooltipHandler != null && graph.tooltipHandler.isHideOnHover()) {
                graph.tooltipHandler.hide();
              }
              if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt) && graph.container.style.display != "none" && graph.container.style.visibility != "hidden" && !mxEvent.isConsumed(evt)) {
                graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));
              }
            });
            this.endHandler = mxUtils.bind(this, function(evt) {
              if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt) && graph.container.style.display != "none" && graph.container.style.visibility != "hidden") {
                graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
              }
            });
            mxEvent.addGestureListeners(document, null, this.moveHandler, this.endHandler);
          }
        };
        mxGraphView.prototype.createHtml = function() {
          var container = this.graph.container;
          if (container != null) {
            this.canvas = this.createHtmlPane("100%", "100%");
            this.canvas.style.overflow = "hidden";
            this.backgroundPane = this.createHtmlPane("1px", "1px");
            this.drawPane = this.createHtmlPane("1px", "1px");
            this.overlayPane = this.createHtmlPane("1px", "1px");
            this.decoratorPane = this.createHtmlPane("1px", "1px");
            this.canvas.appendChild(this.backgroundPane);
            this.canvas.appendChild(this.drawPane);
            this.canvas.appendChild(this.overlayPane);
            this.canvas.appendChild(this.decoratorPane);
            container.appendChild(this.canvas);
            this.updateContainerStyle(container);
            if (mxClient.IS_QUIRKS) {
              var onResize = mxUtils.bind(this, function(evt) {
                var bounds = this.getGraphBounds();
                var width = bounds.x + bounds.width + this.graph.border;
                var height = bounds.y + bounds.height + this.graph.border;
                this.updateHtmlCanvasSize(width, height);
              });
              mxEvent.addListener(window, "resize", onResize);
            }
          }
        };
        mxGraphView.prototype.updateHtmlCanvasSize = function(width, height) {
          if (this.graph.container != null) {
            var ow = this.graph.container.offsetWidth;
            var oh = this.graph.container.offsetHeight;
            if (ow < width) {
              this.canvas.style.width = width + "px";
            } else {
              this.canvas.style.width = "100%";
            }
            if (oh < height) {
              this.canvas.style.height = height + "px";
            } else {
              this.canvas.style.height = "100%";
            }
          }
        };
        mxGraphView.prototype.createHtmlPane = function(width, height) {
          var pane = document.createElement("DIV");
          if (width != null && height != null) {
            pane.style.position = "absolute";
            pane.style.left = "0px";
            pane.style.top = "0px";
            pane.style.width = width;
            pane.style.height = height;
          } else {
            pane.style.position = "relative";
          }
          return pane;
        };
        mxGraphView.prototype.createVml = function() {
          var container = this.graph.container;
          if (container != null) {
            var width = container.offsetWidth;
            var height = container.offsetHeight;
            this.canvas = this.createVmlPane(width, height);
            this.canvas.style.overflow = "hidden";
            this.backgroundPane = this.createVmlPane(width, height);
            this.drawPane = this.createVmlPane(width, height);
            this.overlayPane = this.createVmlPane(width, height);
            this.decoratorPane = this.createVmlPane(width, height);
            this.canvas.appendChild(this.backgroundPane);
            this.canvas.appendChild(this.drawPane);
            this.canvas.appendChild(this.overlayPane);
            this.canvas.appendChild(this.decoratorPane);
            container.appendChild(this.canvas);
          }
        };
        mxGraphView.prototype.createVmlPane = function(width, height) {
          var pane = document.createElement(mxClient.VML_PREFIX + ":group");
          pane.style.position = "absolute";
          pane.style.left = "0px";
          pane.style.top = "0px";
          pane.style.width = width + "px";
          pane.style.height = height + "px";
          pane.setAttribute("coordsize", width + "," + height);
          pane.setAttribute("coordorigin", "0,0");
          return pane;
        };
        mxGraphView.prototype.createSvg = function() {
          var container = this.graph.container;
          this.canvas = document.createElementNS(mxConstants.NS_SVG, "g");
          this.backgroundPane = document.createElementNS(mxConstants.NS_SVG, "g");
          this.canvas.appendChild(this.backgroundPane);
          this.drawPane = document.createElementNS(mxConstants.NS_SVG, "g");
          this.canvas.appendChild(this.drawPane);
          this.overlayPane = document.createElementNS(mxConstants.NS_SVG, "g");
          this.canvas.appendChild(this.overlayPane);
          this.decoratorPane = document.createElementNS(mxConstants.NS_SVG, "g");
          this.canvas.appendChild(this.decoratorPane);
          var root = document.createElementNS(mxConstants.NS_SVG, "svg");
          root.style.left = "0px";
          root.style.top = "0px";
          root.style.width = "100%";
          root.style.height = "100%";
          root.style.display = "block";
          root.appendChild(this.canvas);
          if (mxClient.IS_IE || mxClient.IS_IE11) {
            root.style.overflow = "hidden";
          }
          if (container != null) {
            container.appendChild(root);
            this.updateContainerStyle(container);
          }
        };
        mxGraphView.prototype.updateContainerStyle = function(container) {
          var style = mxUtils.getCurrentStyle(container);
          if (style != null && style.position == "static") {
            container.style.position = "relative";
          }
          if (mxClient.IS_POINTER) {
            container.style.touchAction = "none";
          }
        };
        mxGraphView.prototype.destroy = function() {
          var root = this.canvas != null ? this.canvas.ownerSVGElement : null;
          if (root == null) {
            root = this.canvas;
          }
          if (root != null && root.parentNode != null) {
            this.clear(this.currentRoot, true);
            mxEvent.removeGestureListeners(document, null, this.moveHandler, this.endHandler);
            mxEvent.release(this.graph.container);
            root.parentNode.removeChild(root);
            this.moveHandler = null;
            this.endHandler = null;
            this.canvas = null;
            this.backgroundPane = null;
            this.drawPane = null;
            this.overlayPane = null;
            this.decoratorPane = null;
          }
        };
        function mxCurrentRootChange(view, root) {
          this.view = view;
          this.root = root;
          this.previous = root;
          this.isUp = root == null;
          if (!this.isUp) {
            var tmp = this.view.currentRoot;
            var model = this.view.graph.getModel();
            while (tmp != null) {
              if (tmp == root) {
                this.isUp = true;
                break;
              }
              tmp = model.getParent(tmp);
            }
          }
        }
        ;
        mxCurrentRootChange.prototype.execute = function() {
          var tmp = this.view.currentRoot;
          this.view.currentRoot = this.previous;
          this.previous = tmp;
          var translate = this.view.graph.getTranslateForRoot(this.view.currentRoot);
          if (translate != null) {
            this.view.translate = new mxPoint(-translate.x, -translate.y);
          }
          if (this.isUp) {
            this.view.clear(this.view.currentRoot, true);
            this.view.validate();
          } else {
            this.view.refresh();
          }
          var name2 = this.isUp ? mxEvent.UP : mxEvent.DOWN;
          this.view.fireEvent(new mxEventObject(
            name2,
            "root",
            this.view.currentRoot,
            "previous",
            this.previous
          ));
          this.isUp = !this.isUp;
        };
        __mxOutput.mxGraphView = typeof mxGraphView !== "undefined" ? mxGraphView : void 0;
        function mxGraph(container, model, renderHint, stylesheet) {
          this.mouseListeners = null;
          this.renderHint = renderHint;
          if (mxClient.IS_SVG) {
            this.dialect = mxConstants.DIALECT_SVG;
          } else if (renderHint == mxConstants.RENDERING_HINT_EXACT && mxClient.IS_VML) {
            this.dialect = mxConstants.DIALECT_VML;
          } else if (renderHint == mxConstants.RENDERING_HINT_FASTEST) {
            this.dialect = mxConstants.DIALECT_STRICTHTML;
          } else if (renderHint == mxConstants.RENDERING_HINT_FASTER) {
            this.dialect = mxConstants.DIALECT_PREFERHTML;
          } else {
            this.dialect = mxConstants.DIALECT_MIXEDHTML;
          }
          this.model = model != null ? model : new mxGraphModel();
          this.multiplicities = [];
          this.imageBundles = [];
          this.cellRenderer = this.createCellRenderer();
          this.setSelectionModel(this.createSelectionModel());
          this.setStylesheet(stylesheet != null ? stylesheet : this.createStylesheet());
          this.view = this.createGraphView();
          this.graphModelChangeListener = mxUtils.bind(this, function(sender, evt) {
            this.graphModelChanged(evt.getProperty("edit").changes);
          });
          this.model.addListener(mxEvent.CHANGE, this.graphModelChangeListener);
          this.createHandlers();
          if (container != null) {
            this.init(container);
          }
          this.view.revalidate();
        }
        ;
        mxGraph.prototype = new mxEventSource();
        mxGraph.prototype.constructor = mxGraph;
        mxGraph.prototype.mouseListeners = null;
        mxGraph.prototype.isMouseDown = false;
        mxGraph.prototype.model = null;
        mxGraph.prototype.view = null;
        mxGraph.prototype.stylesheet = null;
        mxGraph.prototype.selectionModel = null;
        mxGraph.prototype.cellEditor = null;
        mxGraph.prototype.cellRenderer = null;
        mxGraph.prototype.multiplicities = null;
        mxGraph.prototype.renderHint = null;
        mxGraph.prototype.dialect = null;
        mxGraph.prototype.gridSize = 10;
        mxGraph.prototype.gridEnabled = true;
        mxGraph.prototype.portsEnabled = true;
        mxGraph.prototype.nativeDblClickEnabled = true;
        mxGraph.prototype.doubleTapEnabled = true;
        mxGraph.prototype.doubleTapTimeout = 500;
        mxGraph.prototype.doubleTapTolerance = 25;
        mxGraph.prototype.lastTouchY = 0;
        mxGraph.prototype.lastTouchY = 0;
        mxGraph.prototype.lastTouchTime = 0;
        mxGraph.prototype.tapAndHoldEnabled = true;
        mxGraph.prototype.tapAndHoldDelay = 500;
        mxGraph.prototype.tapAndHoldInProgress = false;
        mxGraph.prototype.tapAndHoldValid = false;
        mxGraph.prototype.initialTouchX = 0;
        mxGraph.prototype.initialTouchY = 0;
        mxGraph.prototype.tolerance = 4;
        mxGraph.prototype.defaultOverlap = 0.5;
        mxGraph.prototype.defaultParent = null;
        mxGraph.prototype.alternateEdgeStyle = null;
        mxGraph.prototype.backgroundImage = null;
        mxGraph.prototype.pageVisible = false;
        mxGraph.prototype.pageBreaksVisible = false;
        mxGraph.prototype.pageBreakColor = "gray";
        mxGraph.prototype.pageBreakDashed = true;
        mxGraph.prototype.minPageBreakDist = 20;
        mxGraph.prototype.preferPageSize = false;
        mxGraph.prototype.pageFormat = mxConstants.PAGE_FORMAT_A4_PORTRAIT;
        mxGraph.prototype.pageScale = 1.5;
        mxGraph.prototype.enabled = true;
        mxGraph.prototype.escapeEnabled = true;
        mxGraph.prototype.invokesStopCellEditing = true;
        mxGraph.prototype.enterStopsCellEditing = false;
        mxGraph.prototype.useScrollbarsForPanning = true;
        mxGraph.prototype.exportEnabled = true;
        mxGraph.prototype.importEnabled = true;
        mxGraph.prototype.cellsLocked = false;
        mxGraph.prototype.cellsCloneable = true;
        mxGraph.prototype.foldingEnabled = true;
        mxGraph.prototype.cellsEditable = true;
        mxGraph.prototype.cellsDeletable = true;
        mxGraph.prototype.cellsMovable = true;
        mxGraph.prototype.edgeLabelsMovable = true;
        mxGraph.prototype.vertexLabelsMovable = false;
        mxGraph.prototype.dropEnabled = false;
        mxGraph.prototype.splitEnabled = true;
        mxGraph.prototype.cellsResizable = true;
        mxGraph.prototype.cellsBendable = true;
        mxGraph.prototype.cellsSelectable = true;
        mxGraph.prototype.cellsDisconnectable = true;
        mxGraph.prototype.autoSizeCells = false;
        mxGraph.prototype.autoSizeCellsOnAdd = false;
        mxGraph.prototype.autoScroll = true;
        mxGraph.prototype.ignoreScrollbars = false;
        mxGraph.prototype.translateToScrollPosition = false;
        mxGraph.prototype.timerAutoScroll = false;
        mxGraph.prototype.allowAutoPanning = false;
        mxGraph.prototype.autoExtend = true;
        mxGraph.prototype.maximumGraphBounds = null;
        mxGraph.prototype.minimumGraphSize = null;
        mxGraph.prototype.minimumContainerSize = null;
        mxGraph.prototype.maximumContainerSize = null;
        mxGraph.prototype.resizeContainer = false;
        mxGraph.prototype.border = 0;
        mxGraph.prototype.keepEdgesInForeground = false;
        mxGraph.prototype.keepEdgesInBackground = false;
        mxGraph.prototype.allowNegativeCoordinates = true;
        mxGraph.prototype.constrainChildren = true;
        mxGraph.prototype.constrainRelativeChildren = false;
        mxGraph.prototype.extendParents = true;
        mxGraph.prototype.extendParentsOnAdd = true;
        mxGraph.prototype.extendParentsOnMove = false;
        mxGraph.prototype.recursiveResize = false;
        mxGraph.prototype.collapseToPreferredSize = true;
        mxGraph.prototype.zoomFactor = 1.2;
        mxGraph.prototype.keepSelectionVisibleOnZoom = false;
        mxGraph.prototype.centerZoom = true;
        mxGraph.prototype.resetViewOnRootChange = true;
        mxGraph.prototype.resetEdgesOnResize = false;
        mxGraph.prototype.resetEdgesOnMove = false;
        mxGraph.prototype.resetEdgesOnConnect = true;
        mxGraph.prototype.allowLoops = false;
        mxGraph.prototype.defaultLoopStyle = mxEdgeStyle.Loop;
        mxGraph.prototype.multigraph = true;
        mxGraph.prototype.connectableEdges = false;
        mxGraph.prototype.allowDanglingEdges = true;
        mxGraph.prototype.cloneInvalidEdges = false;
        mxGraph.prototype.disconnectOnMove = true;
        mxGraph.prototype.labelsVisible = true;
        mxGraph.prototype.htmlLabels = false;
        mxGraph.prototype.swimlaneSelectionEnabled = true;
        mxGraph.prototype.swimlaneNesting = true;
        mxGraph.prototype.swimlaneIndicatorColorAttribute = mxConstants.STYLE_FILLCOLOR;
        mxGraph.prototype.imageBundles = null;
        mxGraph.prototype.minFitScale = 0.1;
        mxGraph.prototype.maxFitScale = 8;
        mxGraph.prototype.panDx = 0;
        mxGraph.prototype.panDy = 0;
        mxGraph.prototype.collapsedImage = new mxImage(mxClient.imageBasePath + "/collapsed.gif", 9, 9);
        mxGraph.prototype.expandedImage = new mxImage(mxClient.imageBasePath + "/expanded.gif", 9, 9);
        mxGraph.prototype.warningImage = new mxImage(mxClient.imageBasePath + "/warning" + (mxClient.IS_MAC ? ".png" : ".gif"), 16, 16);
        mxGraph.prototype.alreadyConnectedResource = mxClient.language != "none" ? "alreadyConnected" : "";
        mxGraph.prototype.containsValidationErrorsResource = mxClient.language != "none" ? "containsValidationErrors" : "";
        mxGraph.prototype.collapseExpandResource = mxClient.language != "none" ? "collapse-expand" : "";
        mxGraph.prototype.init = function(container) {
          this.container = container;
          this.cellEditor = this.createCellEditor();
          this.view.init();
          this.sizeDidChange();
          mxEvent.addListener(container, "mouseleave", mxUtils.bind(this, function(evt) {
            if (this.tooltipHandler != null && this.tooltipHandler.div != null && this.tooltipHandler.div != evt.relatedTarget) {
            }
          }));
          if (mxClient.IS_IE) {
            mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
              this.destroy();
            }));
            mxEvent.addListener(
              container,
              "selectstart",
              mxUtils.bind(this, function(evt) {
                return this.isEditing() || !this.isMouseDown && !mxEvent.isShiftDown(evt);
              })
            );
          }
          if (document.documentMode == 8) {
            container.insertAdjacentHTML("beforeend", "<" + mxClient.VML_PREFIX + ':group style="DISPLAY: none;"></' + mxClient.VML_PREFIX + ":group>");
          }
        };
        mxGraph.prototype.createHandlers = function() {
          this.tooltipHandler = this.createTooltipHandler();
          this.tooltipHandler.setEnabled(false);
          this.selectionCellsHandler = this.createSelectionCellsHandler();
          this.connectionHandler = this.createConnectionHandler();
          this.connectionHandler.setEnabled(false);
          this.graphHandler = this.createGraphHandler();
          this.panningHandler = this.createPanningHandler();
          this.panningHandler.panningEnabled = false;
          this.popupMenuHandler = this.createPopupMenuHandler();
        };
        mxGraph.prototype.createTooltipHandler = function() {
          return new mxTooltipHandler(this);
        };
        mxGraph.prototype.createSelectionCellsHandler = function() {
          return new mxSelectionCellsHandler(this);
        };
        mxGraph.prototype.createConnectionHandler = function() {
          return new mxConnectionHandler(this);
        };
        mxGraph.prototype.createGraphHandler = function() {
          return new mxGraphHandler(this);
        };
        mxGraph.prototype.createPanningHandler = function() {
          return new mxPanningHandler(this);
        };
        mxGraph.prototype.createPopupMenuHandler = function() {
          return new mxPopupMenuHandler(this);
        };
        mxGraph.prototype.createSelectionModel = function() {
          return new mxGraphSelectionModel(this);
        };
        mxGraph.prototype.createStylesheet = function() {
          return new mxStylesheet();
        };
        mxGraph.prototype.createGraphView = function() {
          return new mxGraphView(this);
        };
        mxGraph.prototype.createCellRenderer = function() {
          return new mxCellRenderer();
        };
        mxGraph.prototype.createCellEditor = function() {
          return new mxCellEditor(this);
        };
        mxGraph.prototype.getModel = function() {
          return this.model;
        };
        mxGraph.prototype.getView = function() {
          return this.view;
        };
        mxGraph.prototype.getStylesheet = function() {
          return this.stylesheet;
        };
        mxGraph.prototype.setStylesheet = function(stylesheet) {
          this.stylesheet = stylesheet;
        };
        mxGraph.prototype.getSelectionModel = function() {
          return this.selectionModel;
        };
        mxGraph.prototype.setSelectionModel = function(selectionModel) {
          this.selectionModel = selectionModel;
        };
        mxGraph.prototype.getSelectionCellsForChanges = function(changes, ignoreFn) {
          var dict = new mxDictionary();
          var cells = [];
          var addCell = mxUtils.bind(this, function(cell3) {
            if (!dict.get(cell3) && this.model.contains(cell3)) {
              if (this.model.isEdge(cell3) || this.model.isVertex(cell3)) {
                dict.put(cell3, true);
                cells.push(cell3);
              } else {
                var childCount = this.model.getChildCount(cell3);
                for (var i2 = 0; i2 < childCount; i2++) {
                  addCell(this.model.getChildAt(cell3, i2));
                }
              }
            }
          });
          for (var i = 0; i < changes.length; i++) {
            var change = changes[i];
            if (change.constructor != mxRootChange && (ignoreFn == null || !ignoreFn(change))) {
              var cell2 = null;
              if (change instanceof mxChildChange) {
                cell2 = change.child;
              } else if (change.cell != null && change.cell instanceof mxCell) {
                cell2 = change.cell;
              }
              if (cell2 != null) {
                addCell(cell2);
              }
            }
          }
          return cells;
        };
        mxGraph.prototype.graphModelChanged = function(changes) {
          for (var i = 0; i < changes.length; i++) {
            this.processChange(changes[i]);
          }
          this.updateSelection();
          this.view.validate();
          this.sizeDidChange();
        };
        mxGraph.prototype.updateSelection = function() {
          var cells = this.getSelectionCells();
          var removed = [];
          for (var i = 0; i < cells.length; i++) {
            if (!this.model.contains(cells[i]) || !this.isCellVisible(cells[i])) {
              removed.push(cells[i]);
            } else {
              var par = this.model.getParent(cells[i]);
              while (par != null && par != this.view.currentRoot) {
                if (this.isCellCollapsed(par) || !this.isCellVisible(par)) {
                  removed.push(cells[i]);
                  break;
                }
                par = this.model.getParent(par);
              }
            }
          }
          this.removeSelectionCells(removed);
        };
        mxGraph.prototype.processChange = function(change) {
          if (change instanceof mxRootChange) {
            this.clearSelection();
            this.setDefaultParent(null);
            this.removeStateForCell(change.previous);
            if (this.resetViewOnRootChange) {
              this.view.scale = 1;
              this.view.translate.x = 0;
              this.view.translate.y = 0;
            }
            this.fireEvent(new mxEventObject(mxEvent.ROOT));
          } else if (change instanceof mxChildChange) {
            var newParent = this.model.getParent(change.child);
            this.view.invalidate(change.child, true, true);
            if (!this.model.contains(newParent) || this.isCellCollapsed(newParent)) {
              this.view.invalidate(change.child, true, true);
              this.removeStateForCell(change.child);
              if (this.view.currentRoot == change.child) {
                this.home();
              }
            }
            if (newParent != change.previous) {
              if (newParent != null) {
                this.view.invalidate(newParent, false, false);
              }
              if (change.previous != null) {
                this.view.invalidate(change.previous, false, false);
              }
            }
          } else if (change instanceof mxTerminalChange || change instanceof mxGeometryChange) {
            if (change instanceof mxTerminalChange || (change.previous == null && change.geometry != null || change.previous != null && !change.previous.equals(change.geometry))) {
              this.view.invalidate(change.cell);
            }
          } else if (change instanceof mxValueChange) {
            this.view.invalidate(change.cell, false, false);
          } else if (change instanceof mxStyleChange) {
            this.view.invalidate(change.cell, true, true);
            var state = this.view.getState(change.cell);
            if (state != null) {
              state.invalidStyle = true;
            }
          } else if (change.cell != null && change.cell instanceof mxCell) {
            this.removeStateForCell(change.cell);
          }
        };
        mxGraph.prototype.removeStateForCell = function(cell2) {
          var childCount = this.model.getChildCount(cell2);
          for (var i = 0; i < childCount; i++) {
            this.removeStateForCell(this.model.getChildAt(cell2, i));
          }
          this.view.invalidate(cell2, false, true);
          this.view.removeState(cell2);
        };
        mxGraph.prototype.addCellOverlay = function(cell2, overlay) {
          if (cell2.overlays == null) {
            cell2.overlays = [];
          }
          cell2.overlays.push(overlay);
          var state = this.view.getState(cell2);
          if (state != null) {
            this.cellRenderer.redraw(state);
          }
          this.fireEvent(new mxEventObject(
            mxEvent.ADD_OVERLAY,
            "cell",
            cell2,
            "overlay",
            overlay
          ));
          return overlay;
        };
        mxGraph.prototype.getCellOverlays = function(cell2) {
          return cell2.overlays;
        };
        mxGraph.prototype.removeCellOverlay = function(cell2, overlay) {
          if (overlay == null) {
            this.removeCellOverlays(cell2);
          } else {
            var index = mxUtils.indexOf(cell2.overlays, overlay);
            if (index >= 0) {
              cell2.overlays.splice(index, 1);
              if (cell2.overlays.length == 0) {
                cell2.overlays = null;
              }
              var state = this.view.getState(cell2);
              if (state != null) {
                this.cellRenderer.redraw(state);
              }
              this.fireEvent(new mxEventObject(
                mxEvent.REMOVE_OVERLAY,
                "cell",
                cell2,
                "overlay",
                overlay
              ));
            } else {
              overlay = null;
            }
          }
          return overlay;
        };
        mxGraph.prototype.removeCellOverlays = function(cell2) {
          var overlays = cell2.overlays;
          if (overlays != null) {
            cell2.overlays = null;
            var state = this.view.getState(cell2);
            if (state != null) {
              this.cellRenderer.redraw(state);
            }
            for (var i = 0; i < overlays.length; i++) {
              this.fireEvent(new mxEventObject(
                mxEvent.REMOVE_OVERLAY,
                "cell",
                cell2,
                "overlay",
                overlays[i]
              ));
            }
          }
          return overlays;
        };
        mxGraph.prototype.clearCellOverlays = function(cell2) {
          cell2 = cell2 != null ? cell2 : this.model.getRoot();
          this.removeCellOverlays(cell2);
          var childCount = this.model.getChildCount(cell2);
          for (var i = 0; i < childCount; i++) {
            var child = this.model.getChildAt(cell2, i);
            this.clearCellOverlays(child);
          }
        };
        mxGraph.prototype.setCellWarning = function(cell2, warning, img, isSelect) {
          if (warning != null && warning.length > 0) {
            img = img != null ? img : this.warningImage;
            var overlay = new mxCellOverlay(
              img,
              "<font color=red>" + warning + "</font>"
            );
            if (isSelect) {
              overlay.addListener(
                mxEvent.CLICK,
                mxUtils.bind(this, function(sender, evt) {
                  if (this.isEnabled()) {
                    this.setSelectionCell(cell2);
                  }
                })
              );
            }
            return this.addCellOverlay(cell2, overlay);
          } else {
            this.removeCellOverlays(cell2);
          }
          return null;
        };
        mxGraph.prototype.startEditing = function(evt) {
          this.startEditingAtCell(null, evt);
        };
        mxGraph.prototype.startEditingAtCell = function(cell2, evt) {
          if (evt == null || !mxEvent.isMultiTouchEvent(evt)) {
            if (cell2 == null) {
              cell2 = this.getSelectionCell();
              if (cell2 != null && !this.isCellEditable(cell2)) {
                cell2 = null;
              }
            }
            if (cell2 != null) {
              this.fireEvent(new mxEventObject(
                mxEvent.START_EDITING,
                "cell",
                cell2,
                "event",
                evt
              ));
              this.cellEditor.startEditing(cell2, evt);
              this.fireEvent(new mxEventObject(
                mxEvent.EDITING_STARTED,
                "cell",
                cell2,
                "event",
                evt
              ));
            }
          }
        };
        mxGraph.prototype.getEditingValue = function(cell2, evt) {
          return this.convertValueToString(cell2);
        };
        mxGraph.prototype.stopEditing = function(cancel) {
          this.cellEditor.stopEditing(cancel);
          this.fireEvent(new mxEventObject(mxEvent.EDITING_STOPPED, "cancel", cancel));
        };
        mxGraph.prototype.labelChanged = function(cell2, value, evt) {
          this.model.beginUpdate();
          try {
            var old = cell2.value;
            this.cellLabelChanged(cell2, value, this.isAutoSizeCell(cell2));
            this.fireEvent(new mxEventObject(
              mxEvent.LABEL_CHANGED,
              "cell",
              cell2,
              "value",
              value,
              "old",
              old,
              "event",
              evt
            ));
          } finally {
            this.model.endUpdate();
          }
          return cell2;
        };
        mxGraph.prototype.cellLabelChanged = function(cell2, value, autoSize) {
          this.model.beginUpdate();
          try {
            this.model.setValue(cell2, value);
            if (autoSize) {
              this.cellSizeUpdated(cell2, false);
            }
          } finally {
            this.model.endUpdate();
          }
        };
        mxGraph.prototype.escape = function(evt) {
          this.fireEvent(new mxEventObject(mxEvent.ESCAPE, "event", evt));
        };
        mxGraph.prototype.click = function(me) {
          var evt = me.getEvent();
          var cell2 = me.getCell();
          var mxe = new mxEventObject(mxEvent.CLICK, "event", evt, "cell", cell2);
          if (me.isConsumed()) {
            mxe.consume();
          }
          this.fireEvent(mxe);
          if (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed()) {
            if (cell2 != null) {
              if (this.isTransparentClickEvent(evt)) {
                var active2 = false;
                var tmp = this.getCellAt(
                  me.graphX,
                  me.graphY,
                  null,
                  null,
                  null,
                  mxUtils.bind(this, function(state2) {
                    var selected = this.isCellSelected(state2.cell);
                    active2 = active2 || selected;
                    return !active2 || selected || state2.cell != cell2 && this.model.isAncestor(state2.cell, cell2);
                  })
                );
                if (tmp != null) {
                  cell2 = tmp;
                }
              }
            } else if (this.isSwimlaneSelectionEnabled()) {
              cell2 = this.getSwimlaneAt(me.getGraphX(), me.getGraphY());
              if (cell2 != null && (!this.isToggleEvent(evt) || !mxEvent.isAltDown(evt))) {
                var temp = cell2;
                var swimlanes = [];
                while (temp != null) {
                  temp = this.model.getParent(temp);
                  var state = this.view.getState(temp);
                  if (this.isSwimlane(temp) && state != null) {
                    swimlanes.push(temp);
                  }
                }
                if (swimlanes.length > 0) {
                  swimlanes = swimlanes.reverse();
                  swimlanes.splice(0, 0, cell2);
                  swimlanes.push(cell2);
                  for (var i = 0; i < swimlanes.length - 1; i++) {
                    if (this.isCellSelected(swimlanes[i])) {
                      cell2 = swimlanes[this.isToggleEvent(evt) ? i : i + 1];
                    }
                  }
                }
              }
            }
            if (cell2 != null) {
              this.selectCellForEvent(cell2, evt);
            } else if (!this.isToggleEvent(evt)) {
              this.clearSelection();
            }
          }
        };
        mxGraph.prototype.isSiblingSelected = function(cell2) {
          var model = this.model;
          var parent = model.getParent(cell2);
          var childCount = model.getChildCount(parent);
          for (var i = 0; i < childCount; i++) {
            var child = model.getChildAt(parent, i);
            if (cell2 != child && this.isCellSelected(child)) {
              return true;
            }
          }
          return false;
        };
        mxGraph.prototype.dblClick = function(evt, cell2) {
          var mxe = new mxEventObject(mxEvent.DOUBLE_CLICK, "event", evt, "cell", cell2);
          this.fireEvent(mxe);
          if (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed() && cell2 != null && this.isCellEditable(cell2) && !this.isEditing(cell2)) {
            this.startEditingAtCell(cell2, evt);
            mxEvent.consume(evt);
          }
        };
        mxGraph.prototype.tapAndHold = function(me) {
          var evt = me.getEvent();
          var mxe = new mxEventObject(mxEvent.TAP_AND_HOLD, "event", evt, "cell", me.getCell());
          this.fireEvent(mxe);
          if (mxe.isConsumed()) {
            this.panningHandler.panningTrigger = false;
          }
          if (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed() && this.connectionHandler.isEnabled()) {
            var state = this.view.getState(this.connectionHandler.marker.getCell(me));
            if (state != null) {
              this.connectionHandler.marker.currentColor = this.connectionHandler.marker.validColor;
              this.connectionHandler.marker.markedState = state;
              this.connectionHandler.marker.mark();
              this.connectionHandler.first = new mxPoint(me.getGraphX(), me.getGraphY());
              this.connectionHandler.edgeState = this.connectionHandler.createEdgeState(me);
              this.connectionHandler.previous = state;
              this.connectionHandler.fireEvent(new mxEventObject(mxEvent.START, "state", this.connectionHandler.previous));
            }
          }
        };
        mxGraph.prototype.scrollPointToVisible = function(x, y, extend, border) {
          if (!this.timerAutoScroll && (this.ignoreScrollbars || mxUtils.hasScrollbars(this.container))) {
            var c = this.container;
            border = border != null ? border : 20;
            if (x >= c.scrollLeft && y >= c.scrollTop && x <= c.scrollLeft + c.clientWidth && y <= c.scrollTop + c.clientHeight) {
              var dx = c.scrollLeft + c.clientWidth - x;
              if (dx < border) {
                var old = c.scrollLeft;
                c.scrollLeft += border - dx;
                if (extend && old == c.scrollLeft) {
                  if (this.dialect == mxConstants.DIALECT_SVG) {
                    var root = this.view.getDrawPane().ownerSVGElement;
                    var width = this.container.scrollWidth + border - dx;
                    root.style.width = width + "px";
                  } else {
                    var width = Math.max(c.clientWidth, c.scrollWidth) + border - dx;
                    var canvas = this.view.getCanvas();
                    canvas.style.width = width + "px";
                  }
                  c.scrollLeft += border - dx;
                }
              } else {
                dx = x - c.scrollLeft;
                if (dx < border) {
                  c.scrollLeft -= border - dx;
                }
              }
              var dy = c.scrollTop + c.clientHeight - y;
              if (dy < border) {
                var old = c.scrollTop;
                c.scrollTop += border - dy;
                if (old == c.scrollTop && extend) {
                  if (this.dialect == mxConstants.DIALECT_SVG) {
                    var root = this.view.getDrawPane().ownerSVGElement;
                    var height = this.container.scrollHeight + border - dy;
                    root.style.height = height + "px";
                  } else {
                    var height = Math.max(c.clientHeight, c.scrollHeight) + border - dy;
                    var canvas = this.view.getCanvas();
                    canvas.style.height = height + "px";
                  }
                  c.scrollTop += border - dy;
                }
              } else {
                dy = y - c.scrollTop;
                if (dy < border) {
                  c.scrollTop -= border - dy;
                }
              }
            }
          } else if (this.allowAutoPanning && !this.panningHandler.isActive()) {
            if (this.panningManager == null) {
              this.panningManager = this.createPanningManager();
            }
            this.panningManager.panTo(x + this.panDx, y + this.panDy);
          }
        };
        mxGraph.prototype.createPanningManager = function() {
          return new mxPanningManager(this);
        };
        mxGraph.prototype.getBorderSizes = function() {
          var css = mxUtils.getCurrentStyle(this.container);
          return new mxRectangle(
            mxUtils.parseCssNumber(css.paddingLeft) + (css.borderLeftStyle != "none" ? mxUtils.parseCssNumber(css.borderLeftWidth) : 0),
            mxUtils.parseCssNumber(css.paddingTop) + (css.borderTopStyle != "none" ? mxUtils.parseCssNumber(css.borderTopWidth) : 0),
            mxUtils.parseCssNumber(css.paddingRight) + (css.borderRightStyle != "none" ? mxUtils.parseCssNumber(css.borderRightWidth) : 0),
            mxUtils.parseCssNumber(css.paddingBottom) + (css.borderBottomStyle != "none" ? mxUtils.parseCssNumber(css.borderBottomWidth) : 0)
          );
        };
        mxGraph.prototype.getPreferredPageSize = function(bounds, width, height) {
          var scale = this.view.scale;
          var tr = this.view.translate;
          var fmt = this.pageFormat;
          var ps = this.pageScale;
          var page = new mxRectangle(0, 0, Math.ceil(fmt.width * ps), Math.ceil(fmt.height * ps));
          var hCount = this.pageBreaksVisible ? Math.ceil(width / page.width) : 1;
          var vCount = this.pageBreaksVisible ? Math.ceil(height / page.height) : 1;
          return new mxRectangle(0, 0, hCount * page.width + 2 + tr.x, vCount * page.height + 2 + tr.y);
        };
        mxGraph.prototype.fit = function(border, keepOrigin, margin, enabled, ignoreWidth, ignoreHeight, maxHeight) {
          if (this.container != null) {
            border = border != null ? border : this.getBorder();
            keepOrigin = keepOrigin != null ? keepOrigin : false;
            margin = margin != null ? margin : 0;
            enabled = enabled != null ? enabled : true;
            ignoreWidth = ignoreWidth != null ? ignoreWidth : false;
            ignoreHeight = ignoreHeight != null ? ignoreHeight : false;
            var cssBorder = this.getBorderSizes();
            var w1 = this.container.offsetWidth - cssBorder.x - cssBorder.width - 1;
            var h1 = maxHeight != null ? maxHeight : this.container.offsetHeight - cssBorder.y - cssBorder.height - 1;
            var bounds = this.view.getGraphBounds();
            if (bounds.width > 0 && bounds.height > 0) {
              if (keepOrigin && bounds.x != null && bounds.y != null) {
                bounds = bounds.clone();
                bounds.width += bounds.x;
                bounds.height += bounds.y;
                bounds.x = 0;
                bounds.y = 0;
              }
              var s = this.view.scale;
              var w2 = bounds.width / s;
              var h2 = bounds.height / s;
              if (this.backgroundImage != null) {
                w2 = Math.max(w2, this.backgroundImage.width - bounds.x / s);
                h2 = Math.max(h2, this.backgroundImage.height - bounds.y / s);
              }
              var b = (keepOrigin ? border : 2 * border) + margin + 1;
              w1 -= b;
              h1 -= b;
              var s2 = ignoreWidth ? h1 / h2 : ignoreHeight ? w1 / w2 : Math.min(w1 / w2, h1 / h2);
              if (this.minFitScale != null) {
                s2 = Math.max(s2, this.minFitScale);
              }
              if (this.maxFitScale != null) {
                s2 = Math.min(s2, this.maxFitScale);
              }
              if (enabled) {
                if (!keepOrigin) {
                  if (!mxUtils.hasScrollbars(this.container)) {
                    var x0 = bounds.x != null ? Math.floor(this.view.translate.x - bounds.x / s + border / s2 + margin / 2) : border;
                    var y0 = bounds.y != null ? Math.floor(this.view.translate.y - bounds.y / s + border / s2 + margin / 2) : border;
                    this.view.scaleAndTranslate(s2, x0, y0);
                  } else {
                    this.view.setScale(s2);
                    var b2 = this.getGraphBounds();
                    if (b2.x != null) {
                      this.container.scrollLeft = b2.x;
                    }
                    if (b2.y != null) {
                      this.container.scrollTop = b2.y;
                    }
                  }
                } else if (this.view.scale != s2) {
                  this.view.setScale(s2);
                }
              } else {
                return s2;
              }
            }
          }
          return this.view.scale;
        };
        mxGraph.prototype.sizeDidChange = function() {
          var bounds = this.getGraphBounds();
          if (this.container != null) {
            var border = this.getBorder();
            var width = Math.max(0, bounds.x) + bounds.width + 2 * border;
            var height = Math.max(0, bounds.y) + bounds.height + 2 * border;
            if (this.minimumContainerSize != null) {
              width = Math.max(width, this.minimumContainerSize.width);
              height = Math.max(height, this.minimumContainerSize.height);
            }
            if (this.resizeContainer) {
              this.doResizeContainer(width, height);
            }
            if (this.preferPageSize || !mxClient.IS_IE && this.pageVisible) {
              var size = this.getPreferredPageSize(bounds, Math.max(1, width), Math.max(1, height));
              if (size != null) {
                width = size.width * this.view.scale;
                height = size.height * this.view.scale;
              }
            }
            if (this.minimumGraphSize != null) {
              width = Math.max(width, this.minimumGraphSize.width * this.view.scale);
              height = Math.max(height, this.minimumGraphSize.height * this.view.scale);
            }
            width = Math.ceil(width);
            height = Math.ceil(height);
            if (this.dialect == mxConstants.DIALECT_SVG) {
              var root = this.view.getDrawPane().ownerSVGElement;
              if (root != null) {
                root.style.minWidth = Math.max(1, width) + "px";
                root.style.minHeight = Math.max(1, height) + "px";
                root.style.width = "100%";
                root.style.height = "100%";
              }
            } else {
              if (mxClient.IS_QUIRKS) {
                this.view.updateHtmlCanvasSize(Math.max(1, width), Math.max(1, height));
              } else {
                this.view.canvas.style.minWidth = Math.max(1, width) + "px";
                this.view.canvas.style.minHeight = Math.max(1, height) + "px";
              }
            }
            this.updatePageBreaks(this.pageBreaksVisible, width, height);
          }
          this.fireEvent(new mxEventObject(mxEvent.SIZE, "bounds", bounds));
        };
        mxGraph.prototype.doResizeContainer = function(width, height) {
          if (this.maximumContainerSize != null) {
            width = Math.min(this.maximumContainerSize.width, width);
            height = Math.min(this.maximumContainerSize.height, height);
          }
          this.container.style.width = Math.ceil(width) + "px";
          this.container.style.height = Math.ceil(height) + "px";
        };
        mxGraph.prototype.updatePageBreaks = function(visible, width, height) {
          var scale = this.view.scale;
          var tr = this.view.translate;
          var fmt = this.pageFormat;
          var ps = scale * this.pageScale;
          var bounds = new mxRectangle(0, 0, fmt.width * ps, fmt.height * ps);
          var gb = mxRectangle.fromRectangle(this.getGraphBounds());
          gb.width = Math.max(1, gb.width);
          gb.height = Math.max(1, gb.height);
          bounds.x = Math.floor((gb.x - tr.x * scale) / bounds.width) * bounds.width + tr.x * scale;
          bounds.y = Math.floor((gb.y - tr.y * scale) / bounds.height) * bounds.height + tr.y * scale;
          gb.width = Math.ceil((gb.width + (gb.x - bounds.x)) / bounds.width) * bounds.width;
          gb.height = Math.ceil((gb.height + (gb.y - bounds.y)) / bounds.height) * bounds.height;
          visible = visible && Math.min(bounds.width, bounds.height) > this.minPageBreakDist;
          var horizontalCount = visible ? Math.ceil(gb.height / bounds.height) + 1 : 0;
          var verticalCount = visible ? Math.ceil(gb.width / bounds.width) + 1 : 0;
          var right = (verticalCount - 1) * bounds.width;
          var bottom = (horizontalCount - 1) * bounds.height;
          if (this.horizontalPageBreaks == null && horizontalCount > 0) {
            this.horizontalPageBreaks = [];
          }
          if (this.verticalPageBreaks == null && verticalCount > 0) {
            this.verticalPageBreaks = [];
          }
          var drawPageBreaks = mxUtils.bind(this, function(breaks) {
            if (breaks != null) {
              var count = breaks == this.horizontalPageBreaks ? horizontalCount : verticalCount;
              for (var i = 0; i <= count; i++) {
                var pts = breaks == this.horizontalPageBreaks ? [
                  new mxPoint(Math.round(bounds.x), Math.round(bounds.y + i * bounds.height)),
                  new mxPoint(Math.round(bounds.x + right), Math.round(bounds.y + i * bounds.height))
                ] : [
                  new mxPoint(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y)),
                  new mxPoint(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y + bottom))
                ];
                if (breaks[i] != null) {
                  breaks[i].points = pts;
                  breaks[i].redraw();
                } else {
                  var pageBreak = new mxPolyline(pts, this.pageBreakColor);
                  pageBreak.dialect = this.dialect;
                  pageBreak.pointerEvents = false;
                  pageBreak.isDashed = this.pageBreakDashed;
                  pageBreak.init(this.view.backgroundPane);
                  pageBreak.redraw();
                  breaks[i] = pageBreak;
                }
              }
              for (var i = count; i < breaks.length; i++) {
                breaks[i].destroy();
              }
              breaks.splice(count, breaks.length - count);
            }
          });
          drawPageBreaks(this.horizontalPageBreaks);
          drawPageBreaks(this.verticalPageBreaks);
        };
        mxGraph.prototype.getCurrentCellStyle = function(cell2, ignoreState) {
          var state = ignoreState ? null : this.view.getState(cell2);
          return state != null ? state.style : this.getCellStyle(cell2);
        };
        mxGraph.prototype.getCellStyle = function(cell2) {
          var stylename = this.model.getStyle(cell2);
          var style = null;
          if (this.model.isEdge(cell2)) {
            style = this.stylesheet.getDefaultEdgeStyle();
          } else {
            style = this.stylesheet.getDefaultVertexStyle();
          }
          if (stylename != null) {
            style = this.postProcessCellStyle(this.stylesheet.getCellStyle(stylename, style));
          }
          if (style == null) {
            style = new Object();
          }
          return style;
        };
        mxGraph.prototype.postProcessCellStyle = function(style) {
          if (style != null) {
            var key = style[mxConstants.STYLE_IMAGE];
            var image = this.getImageFromBundles(key);
            if (image != null) {
              style[mxConstants.STYLE_IMAGE] = image;
            } else {
              image = key;
            }
            if (image != null && image.substring(0, 11) == "data:image/") {
              if (image.substring(0, 20) == "data:image/svg+xml,<") {
                image = image.substring(0, 19) + encodeURIComponent(image.substring(19));
              } else if (image.substring(0, 22) != "data:image/svg+xml,%3C") {
                var comma = image.indexOf(",");
                if (comma > 0 && image.substring(comma - 7, comma + 1) != ";base64,") {
                  image = image.substring(0, comma) + ";base64," + image.substring(comma + 1);
                }
              }
              style[mxConstants.STYLE_IMAGE] = image;
            }
          }
          return style;
        };
        mxGraph.prototype.setCellStyle = function(style, cells) {
          cells = cells || this.getSelectionCells();
          if (cells != null) {
            this.model.beginUpdate();
            try {
              for (var i = 0; i < cells.length; i++) {
                this.model.setStyle(cells[i], style);
              }
            } finally {
              this.model.endUpdate();
            }
          }
        };
        mxGraph.prototype.toggleCellStyle = function(key, defaultValue, cell2) {
          cell2 = cell2 || this.getSelectionCell();
          return this.toggleCellStyles(key, defaultValue, [cell2]);
        };
        mxGraph.prototype.toggleCellStyles = function(key, defaultValue, cells) {
          defaultValue = defaultValue != null ? defaultValue : false;
          cells = cells || this.getSelectionCells();
          var value = null;
          if (cells != null && cells.length > 0) {
            var style = this.getCurrentCellStyle(cells[0]);
            value = mxUtils.getValue(style, key, defaultValue) ? 0 : 1;
            this.setCellStyles(key, value, cells);
          }
          return value;
        };
        mxGraph.prototype.setCellStyles = function(key, value, cells) {
          cells = cells || this.getSelectionCells();
          mxUtils.setCellStyles(this.model, cells, key, value);
        };
        mxGraph.prototype.toggleCellStyleFlags = function(key, flag, cells) {
          this.setCellStyleFlags(key, flag, null, cells);
        };
        mxGraph.prototype.setCellStyleFlags = function(key, flag, value, cells) {
          cells = cells || this.getSelectionCells();
          if (cells != null && cells.length > 0) {
            if (value == null) {
              var style = this.getCurrentCellStyle(cells[0]);
              var current = parseInt(style[key] || 0);
              value = !((current & flag) == flag);
            }
            mxUtils.setCellStyleFlags(this.model, cells, key, flag, value);
          }
        };
        mxGraph.prototype.alignCells = function(align, cells, param) {
          if (cells == null) {
            cells = this.getSelectionCells();
          }
          if (cells != null && cells.length > 1) {
            if (param == null) {
              for (var i = 0; i < cells.length; i++) {
                var state = this.view.getState(cells[i]);
                if (state != null && !this.model.isEdge(cells[i])) {
                  if (param == null) {
                    if (align == mxConstants.ALIGN_CENTER) {
                      param = state.x + state.width / 2;
                      break;
                    } else if (align == mxConstants.ALIGN_RIGHT) {
                      param = state.x + state.width;
                    } else if (align == mxConstants.ALIGN_TOP) {
                      param = state.y;
                    } else if (align == mxConstants.ALIGN_MIDDLE) {
                      param = state.y + state.height / 2;
                      break;
                    } else if (align == mxConstants.ALIGN_BOTTOM) {
                      param = state.y + state.height;
                    } else {
                      param = state.x;
                    }
                  } else {
                    if (align == mxConstants.ALIGN_RIGHT) {
                      param = Math.max(param, state.x + state.width);
                    } else if (align == mxConstants.ALIGN_TOP) {
                      param = Math.min(param, state.y);
                    } else if (align == mxConstants.ALIGN_BOTTOM) {
                      param = Math.max(param, state.y + state.height);
                    } else {
                      param = Math.min(param, state.x);
                    }
                  }
                }
              }
            }
            if (param != null) {
              var s = this.view.scale;
              this.model.beginUpdate();
              try {
                for (var i = 0; i < cells.length; i++) {
                  var state = this.view.getState(cells[i]);
                  if (state != null) {
                    var geo = this.getCellGeometry(cells[i]);
                    if (geo != null && !this.model.isEdge(cells[i])) {
                      geo = geo.clone();
                      if (align == mxConstants.ALIGN_CENTER) {
                        geo.x += (param - state.x - state.width / 2) / s;
                      } else if (align == mxConstants.ALIGN_RIGHT) {
                        geo.x += (param - state.x - state.width) / s;
                      } else if (align == mxConstants.ALIGN_TOP) {
                        geo.y += (param - state.y) / s;
                      } else if (align == mxConstants.ALIGN_MIDDLE) {
                        geo.y += (param - state.y - state.height / 2) / s;
                      } else if (align == mxConstants.ALIGN_BOTTOM) {
                        geo.y += (param - state.y - state.height) / s;
                      } else {
                        geo.x += (param - state.x) / s;
                      }
                      this.resizeCell(cells[i], geo);
                    }
                  }
                }
                this.fireEvent(new mxEventObject(
                  mxEvent.ALIGN_CELLS,
                  "align",
                  align,
                  "cells",
                  cells
                ));
              } finally {
                this.model.endUpdate();
              }
            }
          }
          return cells;
        };
        mxGraph.prototype.flipEdge = function(edge) {
          if (edge != null && this.alternateEdgeStyle != null) {
            this.model.beginUpdate();
            try {
              var style = this.model.getStyle(edge);
              if (style == null || style.length == 0) {
                this.model.setStyle(edge, this.alternateEdgeStyle);
              } else {
                this.model.setStyle(edge, null);
              }
              this.resetEdge(edge);
              this.fireEvent(new mxEventObject(mxEvent.FLIP_EDGE, "edge", edge));
            } finally {
              this.model.endUpdate();
            }
          }
          return edge;
        };
        mxGraph.prototype.addImageBundle = function(bundle) {
          this.imageBundles.push(bundle);
        };
        mxGraph.prototype.removeImageBundle = function(bundle) {
          var tmp = [];
          for (var i = 0; i < this.imageBundles.length; i++) {
            if (this.imageBundles[i] != bundle) {
              tmp.push(this.imageBundles[i]);
            }
          }
          this.imageBundles = tmp;
        };
        mxGraph.prototype.getImageFromBundles = function(key) {
          if (key != null) {
            for (var i = 0; i < this.imageBundles.length; i++) {
              var image = this.imageBundles[i].getImage(key);
              if (image != null) {
                return image;
              }
            }
          }
          return null;
        };
        mxGraph.prototype.orderCells = function(back, cells) {
          if (cells == null) {
            cells = mxUtils.sortCells(this.getSelectionCells(), true);
          }
          this.model.beginUpdate();
          try {
            this.cellsOrdered(cells, back);
            this.fireEvent(new mxEventObject(
              mxEvent.ORDER_CELLS,
              "back",
              back,
              "cells",
              cells
            ));
          } finally {
            this.model.endUpdate();
          }
          return cells;
        };
        mxGraph.prototype.cellsOrdered = function(cells, back) {
          if (cells != null) {
            this.model.beginUpdate();
            try {
              for (var i = 0; i < cells.length; i++) {
                var parent = this.model.getParent(cells[i]);
                if (back) {
                  this.model.add(parent, cells[i], i);
                } else {
                  this.model.add(
                    parent,
                    cells[i],
                    this.model.getChildCount(parent) - 1
                  );
                }
              }
              this.fireEvent(new mxEventObject(
                mxEvent.CELLS_ORDERED,
                "back",
                back,
                "cells",
                cells
              ));
            } finally {
              this.model.endUpdate();
            }
          }
        };
        mxGraph.prototype.groupCells = function(group, border, cells) {
          if (cells == null) {
            cells = mxUtils.sortCells(this.getSelectionCells(), true);
          }
          cells = this.getCellsForGroup(cells);
          if (group == null) {
            group = this.createGroupCell(cells);
          }
          var bounds = this.getBoundsForGroup(group, cells, border);
          if (cells.length > 1 && bounds != null) {
            var parent = this.model.getParent(group);
            if (parent == null) {
              parent = this.model.getParent(cells[0]);
            }
            this.model.beginUpdate();
            try {
              if (this.getCellGeometry(group) == null) {
                this.model.setGeometry(group, new mxGeometry());
              }
              var index = this.model.getChildCount(parent);
              this.cellsAdded([group], parent, index, null, null, false, false, false);
              index = this.model.getChildCount(group);
              this.cellsAdded(cells, group, index, null, null, false, false, false);
              this.cellsMoved(cells, -bounds.x, -bounds.y, false, false, false);
              this.cellsResized([group], [bounds], false);
              this.fireEvent(new mxEventObject(
                mxEvent.GROUP_CELLS,
                "group",
                group,
                "border",
                border,
                "cells",
                cells
              ));
            } finally {
              this.model.endUpdate();
            }
          }
          return group;
        };
        mxGraph.prototype.getCellsForGroup = function(cells) {
          var result2 = [];
          if (cells != null && cells.length > 0) {
            var parent = this.model.getParent(cells[0]);
            result2.push(cells[0]);
            for (var i = 1; i < cells.length; i++) {
              if (this.model.getParent(cells[i]) == parent) {
                result2.push(cells[i]);
              }
            }
          }
          return result2;
        };
        mxGraph.prototype.getBoundsForGroup = function(group, children, border) {
          var result2 = this.getBoundingBoxFromGeometry(children, true);
          if (result2 != null) {
            if (this.isSwimlane(group)) {
              var size = this.getStartSize(group);
              result2.x -= size.width;
              result2.y -= size.height;
              result2.width += size.width;
              result2.height += size.height;
            }
            if (border != null) {
              result2.x -= border;
              result2.y -= border;
              result2.width += 2 * border;
              result2.height += 2 * border;
            }
          }
          return result2;
        };
        mxGraph.prototype.createGroupCell = function(cells) {
          var group = new mxCell("");
          group.setVertex(true);
          group.setConnectable(false);
          return group;
        };
        mxGraph.prototype.ungroupCells = function(cells) {
          var result2 = [];
          if (cells == null) {
            cells = this.getCellsForUngroup();
          }
          if (cells != null && cells.length > 0) {
            this.model.beginUpdate();
            try {
              for (var i = 0; i < cells.length; i++) {
                var children = this.model.getChildren(cells[i]);
                if (children != null && children.length > 0) {
                  children = children.slice();
                  var parent = this.model.getParent(cells[i]);
                  var index = this.model.getChildCount(parent);
                  this.cellsAdded(children, parent, index, null, null, true);
                  result2 = result2.concat(children);
                  for (var j = 0; j < children.length; j++) {
                    var state = this.view.getState(children[j]);
                    var geo = this.getCellGeometry(children[j]);
                    if (state != null && geo != null && geo.relative) {
                      geo = geo.clone();
                      geo.x = state.origin.x;
                      geo.y = state.origin.y;
                      geo.relative = false;
                      this.model.setGeometry(children[j], geo);
                    }
                  }
                }
              }
              this.removeCellsAfterUngroup(cells);
              this.fireEvent(new mxEventObject(mxEvent.UNGROUP_CELLS, "cells", cells));
            } finally {
              this.model.endUpdate();
            }
          }
          return result2;
        };
        mxGraph.prototype.getCellsForUngroup = function() {
          var cells = this.getSelectionCells();
          var tmp = [];
          for (var i = 0; i < cells.length; i++) {
            if (this.model.isVertex(cells[i]) && this.model.getChildCount(cells[i]) > 0) {
              tmp.push(cells[i]);
            }
          }
          return tmp;
        };
        mxGraph.prototype.removeCellsAfterUngroup = function(cells) {
          this.cellsRemoved(this.addAllEdges(cells));
        };
        mxGraph.prototype.removeCellsFromParent = function(cells) {
          if (cells == null) {
            cells = this.getSelectionCells();
          }
          this.model.beginUpdate();
          try {
            var parent = this.getDefaultParent();
            var index = this.model.getChildCount(parent);
            this.cellsAdded(cells, parent, index, null, null, true);
            this.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS_FROM_PARENT, "cells", cells));
          } finally {
            this.model.endUpdate();
          }
          return cells;
        };
        mxGraph.prototype.updateGroupBounds = function(cells, border, moveGroup, topBorder, rightBorder, bottomBorder, leftBorder) {
          if (cells == null) {
            cells = this.getSelectionCells();
          }
          border = border != null ? border : 0;
          moveGroup = moveGroup != null ? moveGroup : false;
          topBorder = topBorder != null ? topBorder : 0;
          rightBorder = rightBorder != null ? rightBorder : 0;
          bottomBorder = bottomBorder != null ? bottomBorder : 0;
          leftBorder = leftBorder != null ? leftBorder : 0;
          this.model.beginUpdate();
          try {
            for (var i = cells.length - 1; i >= 0; i--) {
              var geo = this.getCellGeometry(cells[i]);
              if (geo != null) {
                var children = this.getChildCells(cells[i]);
                if (children != null && children.length > 0) {
                  var bounds = this.getBoundingBoxFromGeometry(children, true);
                  if (bounds != null && bounds.width > 0 && bounds.height > 0) {
                    var size = this.isSwimlane(cells[i]) ? this.getActualStartSize(cells[i], true) : new mxRectangle();
                    geo = geo.clone();
                    if (moveGroup) {
                      geo.x = Math.round(geo.x + bounds.x - border - size.x - leftBorder);
                      geo.y = Math.round(geo.y + bounds.y - border - size.y - topBorder);
                    }
                    geo.width = Math.round(bounds.width + 2 * border + size.x + leftBorder + rightBorder + size.width);
                    geo.height = Math.round(bounds.height + 2 * border + size.y + topBorder + bottomBorder + size.height);
                    this.model.setGeometry(cells[i], geo);
                    this.moveCells(
                      children,
                      border + size.x - bounds.x + leftBorder,
                      border + size.y - bounds.y + topBorder
                    );
                  }
                }
              }
            }
          } finally {
            this.model.endUpdate();
          }
          return cells;
        };
        mxGraph.prototype.getBoundingBox = function(cells) {
          var result2 = null;
          if (cells != null && cells.length > 0) {
            for (var i = 0; i < cells.length; i++) {
              if (this.model.isVertex(cells[i]) || this.model.isEdge(cells[i])) {
                var bbox = this.view.getBoundingBox(this.view.getState(cells[i]), true);
                if (bbox != null) {
                  if (result2 == null) {
                    result2 = mxRectangle.fromRectangle(bbox);
                  } else {
                    result2.add(bbox);
                  }
                }
              }
            }
          }
          return result2;
        };
        mxGraph.prototype.cloneCell = function(cell2, allowInvalidEdges, mapping, keepPosition) {
          return this.cloneCells([cell2], allowInvalidEdges, mapping, keepPosition)[0];
        };
        mxGraph.prototype.cloneCells = function(cells, allowInvalidEdges, mapping, keepPosition) {
          allowInvalidEdges = allowInvalidEdges != null ? allowInvalidEdges : true;
          var clones = null;
          if (cells != null) {
            var dict = new mxDictionary();
            var tmp = [];
            for (var i = 0; i < cells.length; i++) {
              dict.put(cells[i], true);
              tmp.push(cells[i]);
            }
            if (tmp.length > 0) {
              var scale = this.view.scale;
              var trans = this.view.translate;
              clones = this.model.cloneCells(cells, true, mapping);
              for (var i = 0; i < cells.length; i++) {
                if (!allowInvalidEdges && this.model.isEdge(clones[i]) && this.getEdgeValidationError(
                  clones[i],
                  this.model.getTerminal(clones[i], true),
                  this.model.getTerminal(clones[i], false)
                ) != null) {
                  clones[i] = null;
                } else {
                  var g = this.model.getGeometry(clones[i]);
                  if (g != null) {
                    var state = this.view.getState(cells[i]);
                    var pstate = this.view.getState(this.model.getParent(cells[i]));
                    if (state != null && pstate != null) {
                      var dx = keepPosition ? 0 : pstate.origin.x;
                      var dy = keepPosition ? 0 : pstate.origin.y;
                      if (this.model.isEdge(clones[i])) {
                        var pts = state.absolutePoints;
                        if (pts != null) {
                          var src = this.model.getTerminal(cells[i], true);
                          while (src != null && !dict.get(src)) {
                            src = this.model.getParent(src);
                          }
                          if (src == null && pts[0] != null) {
                            g.setTerminalPoint(
                              new mxPoint(
                                pts[0].x / scale - trans.x,
                                pts[0].y / scale - trans.y
                              ),
                              true
                            );
                          }
                          var trg = this.model.getTerminal(cells[i], false);
                          while (trg != null && !dict.get(trg)) {
                            trg = this.model.getParent(trg);
                          }
                          var n = pts.length - 1;
                          if (trg == null && pts[n] != null) {
                            g.setTerminalPoint(
                              new mxPoint(
                                pts[n].x / scale - trans.x,
                                pts[n].y / scale - trans.y
                              ),
                              false
                            );
                          }
                          var points = g.points;
                          if (points != null) {
                            for (var j = 0; j < points.length; j++) {
                              points[j].x += dx;
                              points[j].y += dy;
                            }
                          }
                        }
                      } else {
                        g.translate(dx, dy);
                      }
                    }
                  }
                }
              }
            } else {
              clones = [];
            }
          }
          return clones;
        };
        mxGraph.prototype.insertVertex = function(parent, id, value, x, y, width, height, style, relative) {
          var vertex = this.createVertex(parent, id, value, x, y, width, height, style, relative);
          return this.addCell(vertex, parent);
        };
        mxGraph.prototype.createVertex = function(parent, id, value, x, y, width, height, style, relative) {
          var geometry = new mxGeometry(x, y, width, height);
          geometry.relative = relative != null ? relative : false;
          var vertex = new mxCell(value, geometry, style);
          vertex.setId(id);
          vertex.setVertex(true);
          vertex.setConnectable(true);
          return vertex;
        };
        mxGraph.prototype.insertEdge = function(parent, id, value, source, target, style) {
          var edge = this.createEdge(parent, id, value, source, target, style);
          return this.addEdge(edge, parent, source, target);
        };
        mxGraph.prototype.createEdge = function(parent, id, value, source, target, style) {
          var edge = new mxCell(value, new mxGeometry(), style);
          edge.setId(id);
          edge.setEdge(true);
          edge.geometry.relative = true;
          return edge;
        };
        mxGraph.prototype.addEdge = function(edge, parent, source, target, index) {
          return this.addCell(edge, parent, index, source, target);
        };
        mxGraph.prototype.addCell = function(cell2, parent, index, source, target) {
          return this.addCells([cell2], parent, index, source, target)[0];
        };
        mxGraph.prototype.addCells = function(cells, parent, index, source, target, absolute) {
          if (parent == null) {
            parent = this.getDefaultParent();
          }
          if (index == null) {
            index = this.model.getChildCount(parent);
          }
          this.model.beginUpdate();
          try {
            this.cellsAdded(cells, parent, index, source, target, absolute != null ? absolute : false, true);
            this.fireEvent(new mxEventObject(
              mxEvent.ADD_CELLS,
              "cells",
              cells,
              "parent",
              parent,
              "index",
              index,
              "source",
              source,
              "target",
              target
            ));
          } finally {
            this.model.endUpdate();
          }
          return cells;
        };
        mxGraph.prototype.cellsAdded = function(cells, parent, index, source, target, absolute, constrain, extend) {
          if (cells != null && parent != null && index != null) {
            this.model.beginUpdate();
            try {
              var parentState = absolute ? this.view.getState(parent) : null;
              var o1 = parentState != null ? parentState.origin : null;
              var zero = new mxPoint(0, 0);
              for (var i = 0; i < cells.length; i++) {
                if (cells[i] == null) {
                  index--;
                } else {
                  var previous = this.model.getParent(cells[i]);
                  if (o1 != null && cells[i] != parent && parent != previous) {
                    var oldState = this.view.getState(previous);
                    var o2 = oldState != null ? oldState.origin : zero;
                    var geo = this.model.getGeometry(cells[i]);
                    if (geo != null) {
                      var dx = o2.x - o1.x;
                      var dy = o2.y - o1.y;
                      geo = geo.clone();
                      geo.translate(dx, dy);
                      if (!geo.relative && this.model.isVertex(cells[i]) && !this.isAllowNegativeCoordinates()) {
                        geo.x = Math.max(0, geo.x);
                        geo.y = Math.max(0, geo.y);
                      }
                      this.model.setGeometry(cells[i], geo);
                    }
                  }
                  if (parent == previous && index + i > this.model.getChildCount(parent)) {
                    index--;
                  }
                  this.model.add(parent, cells[i], index + i);
                  if (this.autoSizeCellsOnAdd) {
                    this.autoSizeCell(cells[i], true);
                  }
                  if ((extend == null || extend) && this.isExtendParentsOnAdd(cells[i]) && this.isExtendParent(cells[i])) {
                    this.extendParent(cells[i]);
                  }
                  if (constrain == null || constrain) {
                    this.constrainChild(cells[i]);
                  }
                  if (source != null) {
                    this.cellConnected(cells[i], source, true);
                  }
                  if (target != null) {
                    this.cellConnected(cells[i], target, false);
                  }
                }
              }
              this.fireEvent(new mxEventObject(
                mxEvent.CELLS_ADDED,
                "cells",
                cells,
                "parent",
                parent,
                "index",
                index,
                "source",
                source,
                "target",
                target,
                "absolute",
                absolute
              ));
            } finally {
              this.model.endUpdate();
            }
          }
        };
        mxGraph.prototype.autoSizeCell = function(cell2, recurse) {
          recurse = recurse != null ? recurse : true;
          if (recurse) {
            var childCount = this.model.getChildCount(cell2);
            for (var i = 0; i < childCount; i++) {
              this.autoSizeCell(this.model.getChildAt(cell2, i));
            }
          }
          if (this.getModel().isVertex(cell2) && this.isAutoSizeCell(cell2)) {
            this.updateCellSize(cell2);
          }
        };
        mxGraph.prototype.removeCells = function(cells, includeEdges) {
          includeEdges = includeEdges != null ? includeEdges : true;
          if (cells == null) {
            cells = this.getDeletableCells(this.getSelectionCells());
          }
          if (includeEdges) {
            cells = this.getDeletableCells(this.addAllEdges(cells));
          } else {
            cells = cells.slice();
            var edges = this.getDeletableCells(this.getAllEdges(cells));
            var dict = new mxDictionary();
            for (var i = 0; i < cells.length; i++) {
              dict.put(cells[i], true);
            }
            for (var i = 0; i < edges.length; i++) {
              if (this.view.getState(edges[i]) == null && !dict.get(edges[i])) {
                dict.put(edges[i], true);
                cells.push(edges[i]);
              }
            }
          }
          this.model.beginUpdate();
          try {
            this.cellsRemoved(cells);
            this.fireEvent(new mxEventObject(
              mxEvent.REMOVE_CELLS,
              "cells",
              cells,
              "includeEdges",
              includeEdges
            ));
          } finally {
            this.model.endUpdate();
          }
          return cells;
        };
        mxGraph.prototype.cellsRemoved = function(cells) {
          if (cells != null && cells.length > 0) {
            var scale = this.view.scale;
            var tr = this.view.translate;
            this.model.beginUpdate();
            try {
              var dict = new mxDictionary();
              for (var i = 0; i < cells.length; i++) {
                dict.put(cells[i], true);
              }
              for (var i = 0; i < cells.length; i++) {
                var edges = this.getAllEdges([cells[i]]);
                var disconnectTerminal = mxUtils.bind(this, function(edge, source) {
                  var geo = this.model.getGeometry(edge);
                  if (geo != null) {
                    var terminal = this.model.getTerminal(edge, source);
                    var connected = false;
                    var tmp = terminal;
                    while (tmp != null) {
                      if (cells[i] == tmp) {
                        connected = true;
                        break;
                      }
                      tmp = this.model.getParent(tmp);
                    }
                    if (connected) {
                      geo = geo.clone();
                      var state = this.view.getState(edge);
                      if (state != null && state.absolutePoints != null) {
                        var pts = state.absolutePoints;
                        var n = source ? 0 : pts.length - 1;
                        geo.setTerminalPoint(new mxPoint(
                          pts[n].x / scale - tr.x - state.origin.x,
                          pts[n].y / scale - tr.y - state.origin.y
                        ), source);
                      } else {
                        var tstate = this.view.getState(terminal);
                        if (tstate != null) {
                          geo.setTerminalPoint(new mxPoint(
                            tstate.getCenterX() / scale - tr.x,
                            tstate.getCenterY() / scale - tr.y
                          ), source);
                        }
                      }
                      this.model.setGeometry(edge, geo);
                      this.model.setTerminal(edge, null, source);
                    }
                  }
                });
                for (var j = 0; j < edges.length; j++) {
                  if (!dict.get(edges[j])) {
                    dict.put(edges[j], true);
                    disconnectTerminal(edges[j], true);
                    disconnectTerminal(edges[j], false);
                  }
                }
                this.model.remove(cells[i]);
              }
              this.fireEvent(new mxEventObject(mxEvent.CELLS_REMOVED, "cells", cells));
            } finally {
              this.model.endUpdate();
            }
          }
        };
        mxGraph.prototype.splitEdge = function(edge, cells, newEdge, dx, dy, x, y, parent) {
          dx = dx || 0;
          dy = dy || 0;
          parent = parent != null ? parent : this.model.getParent(edge);
          var source = this.model.getTerminal(edge, true);
          this.model.beginUpdate();
          try {
            if (newEdge == null) {
              newEdge = this.cloneCell(edge);
              var state = this.view.getState(edge);
              var geo = this.getCellGeometry(newEdge);
              if (geo != null && geo.points != null && state != null) {
                var t = this.view.translate;
                var s = this.view.scale;
                var idx = mxUtils.findNearestSegment(state, (dx + t.x) * s, (dy + t.y) * s);
                geo.points = geo.points.slice(0, idx);
                geo = this.getCellGeometry(edge);
                if (geo != null && geo.points != null) {
                  geo = geo.clone();
                  geo.points = geo.points.slice(idx);
                  this.model.setGeometry(edge, geo);
                }
              }
            }
            this.cellsMoved(cells, dx, dy, false, false);
            this.cellsAdded(
              cells,
              parent,
              this.model.getChildCount(parent),
              null,
              null,
              true
            );
            this.cellsAdded(
              [newEdge],
              parent,
              this.model.getChildCount(parent),
              source,
              cells[0],
              false
            );
            this.cellConnected(edge, cells[0], true);
            this.fireEvent(new mxEventObject(
              mxEvent.SPLIT_EDGE,
              "edge",
              edge,
              "cells",
              cells,
              "newEdge",
              newEdge,
              "dx",
              dx,
              "dy",
              dy
            ));
          } finally {
            this.model.endUpdate();
          }
          return newEdge;
        };
        mxGraph.prototype.toggleCells = function(show, cells, includeEdges) {
          if (cells == null) {
            cells = this.getSelectionCells();
          }
          if (includeEdges) {
            cells = this.addAllEdges(cells);
          }
          this.model.beginUpdate();
          try {
            this.cellsToggled(cells, show);
            this.fireEvent(new mxEventObject(
              mxEvent.TOGGLE_CELLS,
              "show",
              show,
              "cells",
              cells,
              "includeEdges",
              includeEdges
            ));
          } finally {
            this.model.endUpdate();
          }
          return cells;
        };
        mxGraph.prototype.cellsToggled = function(cells, show) {
          if (cells != null && cells.length > 0) {
            this.model.beginUpdate();
            try {
              for (var i = 0; i < cells.length; i++) {
                this.model.setVisible(cells[i], show);
              }
            } finally {
              this.model.endUpdate();
            }
          }
        };
        mxGraph.prototype.foldCells = function(collapse, recurse, cells, checkFoldable, evt) {
          recurse = recurse != null ? recurse : false;
          if (cells == null) {
            cells = this.getFoldableCells(this.getSelectionCells(), collapse);
          }
          this.stopEditing(false);
          this.model.beginUpdate();
          try {
            this.cellsFolded(cells, collapse, recurse, checkFoldable);
            this.fireEvent(new mxEventObject(
              mxEvent.FOLD_CELLS,
              "collapse",
              collapse,
              "recurse",
              recurse,
              "cells",
              cells
            ));
          } finally {
            this.model.endUpdate();
          }
          if (cell?.cellDivs?.body) {
            cell.cellDivs.body.focus();
          }
          return cells;
        };
        mxGraph.prototype.cellsFolded = function(cells, collapse, recurse, checkFoldable) {
          if (cells != null && cells.length > 0) {
            this.model.beginUpdate();
            try {
              for (var i = 0; i < cells.length; i++) {
                if ((!checkFoldable || this.isCellFoldable(cells[i], collapse)) && collapse != this.isCellCollapsed(cells[i])) {
                  this.model.setCollapsed(cells[i], collapse);
                  this.swapBounds(cells[i], collapse);
                  if (this.isExtendParent(cells[i])) {
                    this.extendParent(cells[i]);
                  }
                  if (recurse) {
                    var children = this.model.getChildren(cells[i]);
                    this.cellsFolded(children, collapse, recurse);
                  }
                  this.constrainChild(cells[i]);
                }
              }
              this.fireEvent(new mxEventObject(
                mxEvent.CELLS_FOLDED,
                "cells",
                cells,
                "collapse",
                collapse,
                "recurse",
                recurse
              ));
            } finally {
              this.model.endUpdate();
            }
          }
        };
        mxGraph.prototype.swapBounds = function(cell2, willCollapse) {
          if (cell2 != null) {
            var geo = this.model.getGeometry(cell2);
            if (geo != null) {
              geo = geo.clone();
              this.updateAlternateBounds(cell2, geo, willCollapse);
              geo.swap();
              this.model.setGeometry(cell2, geo);
            }
          }
        };
        mxGraph.prototype.updateAlternateBounds = function(cell2, geo, willCollapse) {
          if (cell2 != null && geo != null) {
            var style = this.getCurrentCellStyle(cell2);
            if (geo.alternateBounds == null) {
              var bounds = geo;
              if (this.collapseToPreferredSize) {
                var tmp = this.getPreferredSizeForCell(cell2);
                if (tmp != null) {
                  bounds = tmp;
                  var startSize = mxUtils.getValue(style, mxConstants.STYLE_STARTSIZE);
                  if (startSize > 0) {
                    bounds.height = Math.max(bounds.height, startSize);
                  }
                }
              }
              geo.alternateBounds = new mxRectangle(0, 0, bounds.width, bounds.height);
            }
            if (geo.alternateBounds != null) {
              geo.alternateBounds.x = geo.x;
              geo.alternateBounds.y = geo.y;
              var alpha = mxUtils.toRadians(style[mxConstants.STYLE_ROTATION] || 0);
              if (alpha != 0) {
                var dx = geo.alternateBounds.getCenterX() - geo.getCenterX();
                var dy = geo.alternateBounds.getCenterY() - geo.getCenterY();
                var cos = Math.cos(alpha);
                var sin = Math.sin(alpha);
                var dx2 = cos * dx - sin * dy;
                var dy2 = sin * dx + cos * dy;
                geo.alternateBounds.x += dx2 - dx;
                geo.alternateBounds.y += dy2 - dy;
              }
            }
          }
        };
        mxGraph.prototype.addAllEdges = function(cells) {
          var allCells = cells.slice();
          return mxUtils.removeDuplicates(allCells.concat(this.getAllEdges(cells)));
        };
        mxGraph.prototype.getAllEdges = function(cells) {
          var edges = [];
          if (cells != null) {
            for (var i = 0; i < cells.length; i++) {
              var edgeCount = this.model.getEdgeCount(cells[i]);
              for (var j = 0; j < edgeCount; j++) {
                edges.push(this.model.getEdgeAt(cells[i], j));
              }
              var children = this.model.getChildren(cells[i]);
              edges = edges.concat(this.getAllEdges(children));
            }
          }
          return edges;
        };
        mxGraph.prototype.updateCellSize = function(cell2, ignoreChildren) {
          ignoreChildren = ignoreChildren != null ? ignoreChildren : false;
          this.model.beginUpdate();
          try {
            this.cellSizeUpdated(cell2, ignoreChildren);
            this.fireEvent(new mxEventObject(
              mxEvent.UPDATE_CELL_SIZE,
              "cell",
              cell2,
              "ignoreChildren",
              ignoreChildren
            ));
          } finally {
            this.model.endUpdate();
          }
          return cell2;
        };
        mxGraph.prototype.cellSizeUpdated = function(cell2, ignoreChildren) {
          if (cell2 != null) {
            this.model.beginUpdate();
            try {
              var size = this.getPreferredSizeForCell(cell2);
              var geo = this.model.getGeometry(cell2);
              if (size != null && geo != null) {
                var collapsed = this.isCellCollapsed(cell2);
                geo = geo.clone();
                if (this.isSwimlane(cell2)) {
                  var style = this.getCellStyle(cell2);
                  var cellStyle = this.model.getStyle(cell2);
                  if (cellStyle == null) {
                    cellStyle = "";
                  }
                  if (mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true)) {
                    cellStyle = mxUtils.setStyle(
                      cellStyle,
                      mxConstants.STYLE_STARTSIZE,
                      size.height + 8
                    );
                    if (collapsed) {
                      geo.height = size.height + 8;
                    }
                    geo.width = size.width;
                  } else {
                    cellStyle = mxUtils.setStyle(
                      cellStyle,
                      mxConstants.STYLE_STARTSIZE,
                      size.width + 8
                    );
                    if (collapsed) {
                      geo.width = size.width + 8;
                    }
                    geo.height = size.height;
                  }
                  this.model.setStyle(cell2, cellStyle);
                } else {
                  var state = this.view.createState(cell2);
                  var align = state.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER;
                  if (align == mxConstants.ALIGN_RIGHT) {
                    geo.x += geo.width - size.width;
                  } else if (align == mxConstants.ALIGN_CENTER) {
                    geo.x += Math.round((geo.width - size.width) / 2);
                  }
                  var valign = this.getVerticalAlign(state);
                  if (valign == mxConstants.ALIGN_BOTTOM) {
                    geo.y += geo.height - size.height;
                  } else if (valign == mxConstants.ALIGN_MIDDLE) {
                    geo.y += Math.round((geo.height - size.height) / 2);
                  }
                  geo.width = size.width;
                  geo.height = size.height;
                }
                if (!ignoreChildren && !collapsed) {
                  var bounds = this.view.getBounds(this.model.getChildren(cell2));
                  if (bounds != null) {
                    var tr = this.view.translate;
                    var scale = this.view.scale;
                    var width = (bounds.x + bounds.width) / scale - geo.x - tr.x;
                    var height = (bounds.y + bounds.height) / scale - geo.y - tr.y;
                    geo.width = Math.max(geo.width, width);
                    geo.height = Math.max(geo.height, height);
                  }
                }
                this.cellsResized([cell2], [geo], false);
              }
            } finally {
              this.model.endUpdate();
            }
          }
        };
        mxGraph.prototype.getPreferredSizeForCell = function(cell2, textWidth) {
          var result2 = null;
          if (cell2 != null) {
            var state = this.view.createState(cell2);
            var style = state.style;
            if (!this.model.isEdge(cell2)) {
              var fontSize = style[mxConstants.STYLE_FONTSIZE] || mxConstants.DEFAULT_FONTSIZE;
              var dx = 0;
              var dy = 0;
              if (this.getImage(state) != null || style[mxConstants.STYLE_IMAGE] != null) {
                if (style[mxConstants.STYLE_SHAPE] == mxConstants.SHAPE_LABEL) {
                  if (style[mxConstants.STYLE_VERTICAL_ALIGN] == mxConstants.ALIGN_MIDDLE) {
                    dx += parseFloat(style[mxConstants.STYLE_IMAGE_WIDTH]) || mxLabel.prototype.imageSize;
                  }
                  if (style[mxConstants.STYLE_ALIGN] != mxConstants.ALIGN_CENTER) {
                    dy += parseFloat(style[mxConstants.STYLE_IMAGE_HEIGHT]) || mxLabel.prototype.imageSize;
                  }
                }
              }
              dx += 2 * (style[mxConstants.STYLE_SPACING] || 0);
              dx += style[mxConstants.STYLE_SPACING_LEFT] || 0;
              dx += style[mxConstants.STYLE_SPACING_RIGHT] || 0;
              dy += 2 * (style[mxConstants.STYLE_SPACING] || 0);
              dy += style[mxConstants.STYLE_SPACING_TOP] || 0;
              dy += style[mxConstants.STYLE_SPACING_BOTTOM] || 0;
              var image = this.getFoldingImage(state);
              if (image != null) {
                dx += image.width + 8;
              }
              var value = this.cellRenderer.getLabelValue(state);
              if (value != null && value.length > 0) {
                if (!this.isHtmlLabel(state.cell)) {
                  value = mxUtils.htmlEntities(value, false);
                }
                value = value.replace(/\n/g, "<br>");
                var size = mxUtils.getSizeForString(
                  value,
                  fontSize,
                  style[mxConstants.STYLE_FONTFAMILY],
                  textWidth,
                  style[mxConstants.STYLE_FONTSTYLE]
                );
                var width = size.width + dx;
                var height = size.height + dy;
                if (!mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true)) {
                  var tmp = height;
                  height = width;
                  width = tmp;
                }
                if (this.gridEnabled) {
                  width = this.snap(width + this.gridSize / 2);
                  height = this.snap(height + this.gridSize / 2);
                }
                result2 = new mxRectangle(0, 0, width, height);
              } else {
                var gs2 = 4 * this.gridSize;
                result2 = new mxRectangle(0, 0, gs2, gs2);
              }
            }
          }
          return result2;
        };
        mxGraph.prototype.resizeCell = function(cell2, bounds, recurse) {
          return this.resizeCells([cell2], [bounds], recurse)[0];
        };
        mxGraph.prototype.resizeCells = function(cells, bounds, recurse) {
          recurse = recurse != null ? recurse : this.isRecursiveResize();
          this.model.beginUpdate();
          try {
            var prev = this.cellsResized(cells, bounds, recurse);
            this.fireEvent(new mxEventObject(
              mxEvent.RESIZE_CELLS,
              "cells",
              cells,
              "bounds",
              bounds,
              "previous",
              prev
            ));
          } finally {
            this.model.endUpdate();
          }
          return cells;
        };
        mxGraph.prototype.cellsResized = function(cells, bounds, recurse) {
          recurse = recurse != null ? recurse : false;
          var prev = [];
          if (cells != null && bounds != null && cells.length == bounds.length) {
            this.model.beginUpdate();
            try {
              for (var i = 0; i < cells.length; i++) {
                prev.push(this.cellResized(cells[i], bounds[i], false, recurse));
                if (this.isExtendParent(cells[i])) {
                  this.extendParent(cells[i]);
                }
                this.constrainChild(cells[i]);
              }
              if (this.resetEdgesOnResize) {
                this.resetEdges(cells);
              }
              this.fireEvent(new mxEventObject(
                mxEvent.CELLS_RESIZED,
                "cells",
                cells,
                "bounds",
                bounds,
                "previous",
                prev
              ));
            } finally {
              this.model.endUpdate();
            }
          }
          return prev;
        };
        mxGraph.prototype.cellResized = function(cell2, bounds, ignoreRelative, recurse) {
          var prev = this.model.getGeometry(cell2);
          if (prev != null && (prev.x != bounds.x || prev.y != bounds.y || prev.width != bounds.width || prev.height != bounds.height)) {
            var geo = prev.clone();
            if (!ignoreRelative && geo.relative) {
              var offset = geo.offset;
              if (offset != null) {
                offset.x += bounds.x - geo.x;
                offset.y += bounds.y - geo.y;
              }
            } else {
              geo.x = bounds.x;
              geo.y = bounds.y;
            }
            geo.width = bounds.width;
            geo.height = bounds.height;
            if (!geo.relative && this.model.isVertex(cell2) && !this.isAllowNegativeCoordinates()) {
              geo.x = Math.max(0, geo.x);
              geo.y = Math.max(0, geo.y);
            }
            this.model.beginUpdate();
            try {
              if (recurse) {
                this.resizeChildCells(cell2, geo);
              }
              this.model.setGeometry(cell2, geo);
              this.constrainChildCells(cell2);
            } finally {
              this.model.endUpdate();
            }
          }
          return prev;
        };
        mxGraph.prototype.resizeChildCells = function(cell2, newGeo) {
          var geo = this.model.getGeometry(cell2);
          var dx = geo.width != 0 ? newGeo.width / geo.width : 1;
          var dy = geo.height != 0 ? newGeo.height / geo.height : 1;
          var childCount = this.model.getChildCount(cell2);
          for (var i = 0; i < childCount; i++) {
            this.scaleCell(this.model.getChildAt(cell2, i), dx, dy, true);
          }
        };
        mxGraph.prototype.constrainChildCells = function(cell2) {
          var childCount = this.model.getChildCount(cell2);
          for (var i = 0; i < childCount; i++) {
            this.constrainChild(this.model.getChildAt(cell2, i));
          }
        };
        mxGraph.prototype.scaleCell = function(cell2, dx, dy, recurse) {
          var geo = this.model.getGeometry(cell2);
          if (geo != null) {
            var style = this.getCurrentCellStyle(cell2);
            geo = geo.clone();
            var x = geo.x;
            var y = geo.y;
            var w2 = geo.width;
            var h2 = geo.height;
            geo.scale(dx, dy, style[mxConstants.STYLE_ASPECT] == "fixed");
            if (style[mxConstants.STYLE_RESIZE_WIDTH] == "1") {
              geo.width = w2 * dx;
            } else if (style[mxConstants.STYLE_RESIZE_WIDTH] == "0") {
              geo.width = w2;
            }
            if (style[mxConstants.STYLE_RESIZE_HEIGHT] == "1") {
              geo.height = h2 * dy;
            } else if (style[mxConstants.STYLE_RESIZE_HEIGHT] == "0") {
              geo.height = h2;
            }
            if (!this.isCellMovable(cell2)) {
              geo.x = x;
              geo.y = y;
            }
            if (!this.isCellResizable(cell2)) {
              geo.width = w2;
              geo.height = h2;
            }
            if (this.model.isVertex(cell2)) {
              this.cellResized(cell2, geo, true, recurse);
            } else {
              this.model.setGeometry(cell2, geo);
            }
          }
        };
        mxGraph.prototype.extendParent = function(cell2) {
          if (cell2 != null) {
            var parent = this.model.getParent(cell2);
            var p = this.getCellGeometry(parent);
            if (parent != null && p != null && !this.isCellCollapsed(parent)) {
              var geo = this.getCellGeometry(cell2);
              if (geo != null && !geo.relative && (p.width < geo.x + geo.width || p.height < geo.y + geo.height)) {
                p = p.clone();
                p.width = Math.max(p.width, geo.x + geo.width);
                p.height = Math.max(p.height, geo.y + geo.height);
                this.cellsResized([parent], [p], false);
              }
            }
          }
        };
        mxGraph.prototype.importCells = function(cells, dx, dy, target, evt, mapping) {
          return this.moveCells(cells, dx, dy, true, target, evt, mapping);
        };
        mxGraph.prototype.moveCells = function(cells, dx, dy, clone, target, evt, mapping) {
          dx = dx != null ? dx : 0;
          dy = dy != null ? dy : 0;
          clone = clone != null ? clone : false;
          if (cells != null && (dx != 0 || dy != 0 || clone || target != null)) {
            cells = this.model.getTopmostCells(cells);
            var origCells = cells;
            this.model.beginUpdate();
            try {
              var dict = new mxDictionary();
              for (var i = 0; i < cells.length; i++) {
                dict.put(cells[i], true);
              }
              var isSelected = mxUtils.bind(this, function(cell2) {
                while (cell2 != null) {
                  if (dict.get(cell2)) {
                    return true;
                  }
                  cell2 = this.model.getParent(cell2);
                }
                return false;
              });
              var checked = [];
              for (var i = 0; i < cells.length; i++) {
                var geo = this.getCellGeometry(cells[i]);
                var parent = this.model.getParent(cells[i]);
                if (geo == null || !geo.relative || !this.model.isEdge(parent) || !isSelected(this.model.getTerminal(parent, true)) && !isSelected(this.model.getTerminal(parent, false))) {
                  checked.push(cells[i]);
                }
              }
              cells = checked;
              if (clone) {
                cells = this.cloneCells(cells, this.isCloneInvalidEdges(), mapping);
                if (target == null) {
                  target = this.getDefaultParent();
                }
              }
              var previous = this.isAllowNegativeCoordinates();
              if (target != null) {
                this.setAllowNegativeCoordinates(true);
              }
              this.cellsMoved(
                cells,
                dx,
                dy,
                !clone && this.isDisconnectOnMove() && this.isAllowDanglingEdges(),
                target == null,
                this.isExtendParentsOnMove() && target == null
              );
              this.setAllowNegativeCoordinates(previous);
              if (target != null) {
                var index = this.model.getChildCount(target);
                this.cellsAdded(cells, target, index, null, null, true);
                if (clone) {
                  for (var i = 0; i < cells.length; i++) {
                    var geo = this.getCellGeometry(cells[i]);
                    var parent = this.model.getParent(origCells[i]);
                    if (geo != null && geo.relative && this.model.isEdge(parent) && this.model.contains(parent)) {
                      this.model.add(parent, cells[i]);
                    }
                  }
                }
              }
              this.fireEvent(new mxEventObject(
                mxEvent.MOVE_CELLS,
                "cells",
                cells,
                "dx",
                dx,
                "dy",
                dy,
                "clone",
                clone,
                "target",
                target,
                "event",
                evt
              ));
            } finally {
              this.model.endUpdate();
            }
          }
          return cells;
        };
        mxGraph.prototype.cellsMoved = function(cells, dx, dy, disconnect, constrain, extend) {
          if (cells != null && (dx != 0 || dy != 0)) {
            extend = extend != null ? extend : false;
            this.model.beginUpdate();
            try {
              if (disconnect) {
                this.disconnectGraph(cells);
              }
              for (var i = 0; i < cells.length; i++) {
                this.translateCell(cells[i], dx, dy);
                if (extend && this.isExtendParent(cells[i])) {
                  this.extendParent(cells[i]);
                } else if (constrain) {
                  this.constrainChild(cells[i]);
                }
              }
              if (this.resetEdgesOnMove) {
                this.resetEdges(cells);
              }
              this.fireEvent(new mxEventObject(
                mxEvent.CELLS_MOVED,
                "cells",
                cells,
                "dx",
                dx,
                "dy",
                dy,
                "disconnect",
                disconnect
              ));
            } finally {
              this.model.endUpdate();
            }
          }
        };
        mxGraph.prototype.translateCell = function(cell2, dx, dy) {
          var geo = this.model.getGeometry(cell2);
          if (geo != null) {
            dx = parseFloat(dx);
            dy = parseFloat(dy);
            geo = geo.clone();
            geo.translate(dx, dy);
            if (!geo.relative && this.model.isVertex(cell2) && !this.isAllowNegativeCoordinates()) {
              geo.x = Math.max(0, parseFloat(geo.x));
              geo.y = Math.max(0, parseFloat(geo.y));
            }
            if (geo.relative && !this.model.isEdge(cell2)) {
              var parent = this.model.getParent(cell2);
              var angle = 0;
              if (this.model.isVertex(parent)) {
                var style = this.getCurrentCellStyle(parent);
                angle = mxUtils.getValue(style, mxConstants.STYLE_ROTATION, 0);
              }
              if (angle != 0) {
                var rad = mxUtils.toRadians(-angle);
                var cos = Math.cos(rad);
                var sin = Math.sin(rad);
                var pt = mxUtils.getRotatedPoint(new mxPoint(dx, dy), cos, sin, new mxPoint(0, 0));
                dx = pt.x;
                dy = pt.y;
              }
              if (geo.offset == null) {
                geo.offset = new mxPoint(dx, dy);
              } else {
                geo.offset.x = parseFloat(geo.offset.x) + dx;
                geo.offset.y = parseFloat(geo.offset.y) + dy;
              }
            }
            this.model.setGeometry(cell2, geo);
          }
        };
        mxGraph.prototype.getCellContainmentArea = function(cell2) {
          if (cell2 != null && !this.model.isEdge(cell2)) {
            var parent = this.model.getParent(cell2);
            if (parent != null && parent != this.getDefaultParent()) {
              var g = this.model.getGeometry(parent);
              if (g != null) {
                var x = 0;
                var y = 0;
                var w2 = g.width;
                var h2 = g.height;
                if (this.isSwimlane(parent)) {
                  var size = this.getStartSize(parent);
                  var style = this.getCurrentCellStyle(parent);
                  var dir = mxUtils.getValue(style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
                  var flipH = mxUtils.getValue(style, mxConstants.STYLE_FLIPH, 0) == 1;
                  var flipV = mxUtils.getValue(style, mxConstants.STYLE_FLIPV, 0) == 1;
                  if (dir == mxConstants.DIRECTION_SOUTH || dir == mxConstants.DIRECTION_NORTH) {
                    var tmp = size.width;
                    size.width = size.height;
                    size.height = tmp;
                  }
                  if (dir == mxConstants.DIRECTION_EAST && !flipV || dir == mxConstants.DIRECTION_NORTH && !flipH || dir == mxConstants.DIRECTION_WEST && flipV || dir == mxConstants.DIRECTION_SOUTH && flipH) {
                    x = size.width;
                    y = size.height;
                  }
                  w2 -= size.width;
                  h2 -= size.height;
                }
                return new mxRectangle(x, y, w2, h2);
              }
            }
          }
          return null;
        };
        mxGraph.prototype.getMaximumGraphBounds = function() {
          return this.maximumGraphBounds;
        };
        mxGraph.prototype.constrainChild = function(cell2, sizeFirst) {
          sizeFirst = sizeFirst != null ? sizeFirst : true;
          if (cell2 != null) {
            var geo = this.getCellGeometry(cell2);
            if (geo != null && (this.isConstrainRelativeChildren() || !geo.relative)) {
              var parent = this.model.getParent(cell2);
              var pgeo = this.getCellGeometry(parent);
              var max = this.getMaximumGraphBounds();
              if (max != null) {
                var off = this.getBoundingBoxFromGeometry([parent], false);
                if (off != null) {
                  max = mxRectangle.fromRectangle(max);
                  max.x -= off.x;
                  max.y -= off.y;
                }
              }
              if (this.isConstrainChild(cell2)) {
                var tmp = this.getCellContainmentArea(cell2);
                if (tmp != null) {
                  var overlap = this.getOverlap(cell2);
                  if (overlap > 0) {
                    tmp = mxRectangle.fromRectangle(tmp);
                    tmp.x -= tmp.width * overlap;
                    tmp.y -= tmp.height * overlap;
                    tmp.width += 2 * tmp.width * overlap;
                    tmp.height += 2 * tmp.height * overlap;
                  }
                  if (max == null) {
                    max = tmp;
                  } else {
                    max = mxRectangle.fromRectangle(max);
                    max.intersect(tmp);
                  }
                }
              }
              if (max != null) {
                var cells = [cell2];
                if (!this.isCellCollapsed(cell2)) {
                  var desc = this.model.getDescendants(cell2);
                  for (var i = 0; i < desc.length; i++) {
                    if (this.isCellVisible(desc[i])) {
                      cells.push(desc[i]);
                    }
                  }
                }
                var bbox = this.getBoundingBoxFromGeometry(cells, false);
                if (bbox != null) {
                  geo = geo.clone();
                  var dx = 0;
                  if (geo.width > max.width) {
                    dx = geo.width - max.width;
                    geo.width -= dx;
                  }
                  if (bbox.x + bbox.width > max.x + max.width) {
                    dx -= bbox.x + bbox.width - max.x - max.width - dx;
                  }
                  var dy = 0;
                  if (geo.height > max.height) {
                    dy = geo.height - max.height;
                    geo.height -= dy;
                  }
                  if (bbox.y + bbox.height > max.y + max.height) {
                    dy -= bbox.y + bbox.height - max.y - max.height - dy;
                  }
                  if (bbox.x < max.x) {
                    dx -= bbox.x - max.x;
                  }
                  if (bbox.y < max.y) {
                    dy -= bbox.y - max.y;
                  }
                  if (dx != 0 || dy != 0) {
                    if (geo.relative) {
                      if (geo.offset == null) {
                        geo.offset = new mxPoint();
                      }
                      geo.offset.x += dx;
                      geo.offset.y += dy;
                    } else {
                      geo.x += dx;
                      geo.y += dy;
                    }
                  }
                  this.model.setGeometry(cell2, geo);
                }
              }
            }
          }
        };
        mxGraph.prototype.resetEdges = function(cells) {
          if (cells != null) {
            var dict = new mxDictionary();
            for (var i = 0; i < cells.length; i++) {
              dict.put(cells[i], true);
            }
            this.model.beginUpdate();
            try {
              for (var i = 0; i < cells.length; i++) {
                var edges = this.model.getEdges(cells[i]);
                if (edges != null) {
                  for (var j = 0; j < edges.length; j++) {
                    var state = this.view.getState(edges[j]);
                    var source = state != null ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[j], true);
                    var target = state != null ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[j], false);
                    if (!dict.get(source) || !dict.get(target)) {
                      this.resetEdge(edges[j]);
                    }
                  }
                }
                this.resetEdges(this.model.getChildren(cells[i]));
              }
            } finally {
              this.model.endUpdate();
            }
          }
        };
        mxGraph.prototype.resetEdge = function(edge) {
          var geo = this.model.getGeometry(edge);
          if (geo != null && geo.points != null && geo.points.length > 0) {
            geo = geo.clone();
            geo.points = [];
            this.model.setGeometry(edge, geo);
          }
          return edge;
        };
        mxGraph.prototype.getOutlineConstraint = function(point, terminalState, me) {
          if (terminalState.shape != null) {
            var bounds = this.view.getPerimeterBounds(terminalState);
            var direction = terminalState.style[mxConstants.STYLE_DIRECTION];
            if (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH) {
              bounds.x += bounds.width / 2 - bounds.height / 2;
              bounds.y += bounds.height / 2 - bounds.width / 2;
              var tmp = bounds.width;
              bounds.width = bounds.height;
              bounds.height = tmp;
            }
            var alpha = mxUtils.toRadians(terminalState.shape.getShapeRotation());
            if (alpha != 0) {
              var cos = Math.cos(-alpha);
              var sin = Math.sin(-alpha);
              var ct = new mxPoint(bounds.getCenterX(), bounds.getCenterY());
              point = mxUtils.getRotatedPoint(point, cos, sin, ct);
            }
            var sx = 1;
            var sy = 1;
            var dx = 0;
            var dy = 0;
            if (this.getModel().isVertex(terminalState.cell)) {
              var flipH = terminalState.style[mxConstants.STYLE_FLIPH];
              var flipV = terminalState.style[mxConstants.STYLE_FLIPV];
              if (terminalState.shape != null && terminalState.shape.stencil != null) {
                flipH = mxUtils.getValue(terminalState.style, "stencilFlipH", 0) == 1 || flipH;
                flipV = mxUtils.getValue(terminalState.style, "stencilFlipV", 0) == 1 || flipV;
              }
              if (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH) {
                var tmp = flipH;
                flipH = flipV;
                flipV = tmp;
              }
              if (flipH) {
                sx = -1;
                dx = -bounds.width;
              }
              if (flipV) {
                sy = -1;
                dy = -bounds.height;
              }
            }
            point = new mxPoint((point.x - bounds.x) * sx - dx + bounds.x, (point.y - bounds.y) * sy - dy + bounds.y);
            var x = bounds.width == 0 ? 0 : Math.round((point.x - bounds.x) * 1e3 / bounds.width) / 1e3;
            var y = bounds.height == 0 ? 0 : Math.round((point.y - bounds.y) * 1e3 / bounds.height) / 1e3;
            return new mxConnectionConstraint(new mxPoint(x, y), false);
          }
          return null;
        };
        mxGraph.prototype.getAllConnectionConstraints = function(terminal, source) {
          if (terminal != null && terminal.shape != null && terminal.shape.stencil != null) {
            return terminal.shape.stencil.constraints;
          }
          return null;
        };
        mxGraph.prototype.getConnectionConstraint = function(edge, terminal, source) {
          var point = null;
          var x = edge.style[source ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];
          if (x != null) {
            var y = edge.style[source ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];
            if (y != null) {
              point = new mxPoint(parseFloat(x), parseFloat(y));
            }
          }
          var perimeter = false;
          var dx = 0, dy = 0;
          if (point != null) {
            perimeter = mxUtils.getValue(edge.style, source ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, true);
            dx = parseFloat(edge.style[source ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX]);
            dy = parseFloat(edge.style[source ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY]);
            dx = isFinite(dx) ? dx : 0;
            dy = isFinite(dy) ? dy : 0;
          }
          return new mxConnectionConstraint(point, perimeter, null, dx, dy);
        };
        mxGraph.prototype.setConnectionConstraint = function(edge, terminal, source, constraint) {
          if (constraint != null) {
            this.model.beginUpdate();
            try {
              if (constraint == null || constraint.point == null) {
                this.setCellStyles(source ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X, null, [edge]);
                this.setCellStyles(source ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y, null, [edge]);
                this.setCellStyles(source ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX, null, [edge]);
                this.setCellStyles(source ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY, null, [edge]);
                this.setCellStyles(source ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, null, [edge]);
              } else if (constraint.point != null) {
                this.setCellStyles(source ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X, constraint.point.x, [edge]);
                this.setCellStyles(source ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y, constraint.point.y, [edge]);
                this.setCellStyles(source ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX, constraint.dx, [edge]);
                this.setCellStyles(source ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY, constraint.dy, [edge]);
                if (!constraint.perimeter) {
                  this.setCellStyles(source ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, "0", [edge]);
                } else {
                  this.setCellStyles(source ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, null, [edge]);
                }
              }
            } finally {
              this.model.endUpdate();
            }
          }
        };
        mxGraph.prototype.getConnectionPoint = function(vertex, constraint, round) {
          round = round != null ? round : true;
          var point = null;
          if (vertex != null && constraint.point != null) {
            var bounds = this.view.getPerimeterBounds(vertex);
            var cx = new mxPoint(bounds.getCenterX(), bounds.getCenterY());
            var direction = vertex.style[mxConstants.STYLE_DIRECTION];
            var r1 = 0;
            if (direction != null && mxUtils.getValue(
              vertex.style,
              mxConstants.STYLE_ANCHOR_POINT_DIRECTION,
              1
            ) == 1) {
              if (direction == mxConstants.DIRECTION_NORTH) {
                r1 += 270;
              } else if (direction == mxConstants.DIRECTION_WEST) {
                r1 += 180;
              } else if (direction == mxConstants.DIRECTION_SOUTH) {
                r1 += 90;
              }
              if (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH) {
                bounds.rotate90();
              }
            }
            var scale = this.view.scale;
            point = new mxPoint(
              bounds.x + constraint.point.x * bounds.width + constraint.dx * scale,
              bounds.y + constraint.point.y * bounds.height + constraint.dy * scale
            );
            var r2 = vertex.style[mxConstants.STYLE_ROTATION] || 0;
            if (constraint.perimeter) {
              if (r1 != 0) {
                var cos = 0;
                var sin = 0;
                if (r1 == 90) {
                  sin = 1;
                } else if (r1 == 180) {
                  cos = -1;
                } else if (r1 == 270) {
                  sin = -1;
                }
                point = mxUtils.getRotatedPoint(point, cos, sin, cx);
              }
              point = this.view.getPerimeterPoint(vertex, point, false);
            } else {
              r2 += r1;
              if (this.getModel().isVertex(vertex.cell)) {
                var flipH = vertex.style[mxConstants.STYLE_FLIPH] == 1;
                var flipV = vertex.style[mxConstants.STYLE_FLIPV] == 1;
                if (vertex.shape != null && vertex.shape.stencil != null) {
                  flipH = mxUtils.getValue(vertex.style, "stencilFlipH", 0) == 1 || flipH;
                  flipV = mxUtils.getValue(vertex.style, "stencilFlipV", 0) == 1 || flipV;
                }
                if (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH) {
                  var temp = flipH;
                  flipH = flipV;
                  flipV = temp;
                }
                if (flipH) {
                  point.x = 2 * bounds.getCenterX() - point.x;
                }
                if (flipV) {
                  point.y = 2 * bounds.getCenterY() - point.y;
                }
              }
            }
            if (r2 != 0 && point != null) {
              var rad = mxUtils.toRadians(r2);
              var cos = Math.cos(rad);
              var sin = Math.sin(rad);
              point = mxUtils.getRotatedPoint(point, cos, sin, cx);
            }
          }
          if (round && point != null) {
            point.x = Math.round(point.x);
            point.y = Math.round(point.y);
          }
          return point;
        };
        mxGraph.prototype.connectCell = function(edge, terminal, source, constraint) {
          this.model.beginUpdate();
          try {
            var previous = this.model.getTerminal(edge, source);
            this.cellConnected(edge, terminal, source, constraint);
            this.fireEvent(new mxEventObject(
              mxEvent.CONNECT_CELL,
              "edge",
              edge,
              "terminal",
              terminal,
              "source",
              source,
              "previous",
              previous
            ));
          } finally {
            this.model.endUpdate();
          }
          return edge;
        };
        mxGraph.prototype.cellConnected = function(edge, terminal, source, constraint) {
          if (edge != null) {
            this.model.beginUpdate();
            try {
              var previous = this.model.getTerminal(edge, source);
              this.setConnectionConstraint(edge, terminal, source, constraint);
              if (this.isPortsEnabled()) {
                var id = null;
                if (this.isPort(terminal)) {
                  id = terminal.getId();
                  terminal = this.getTerminalForPort(terminal, source);
                }
                var key = source ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT;
                this.setCellStyles(key, id, [edge]);
              }
              this.model.setTerminal(edge, terminal, source);
              if (this.resetEdgesOnConnect) {
                this.resetEdge(edge);
              }
              this.fireEvent(new mxEventObject(
                mxEvent.CELL_CONNECTED,
                "edge",
                edge,
                "terminal",
                terminal,
                "source",
                source,
                "previous",
                previous
              ));
            } finally {
              this.model.endUpdate();
            }
          }
        };
        mxGraph.prototype.disconnectGraph = function(cells) {
          if (cells != null) {
            this.model.beginUpdate();
            try {
              var scale = this.view.scale;
              var tr = this.view.translate;
              var dict = new mxDictionary();
              for (var i = 0; i < cells.length; i++) {
                dict.put(cells[i], true);
              }
              for (var i = 0; i < cells.length; i++) {
                if (this.model.isEdge(cells[i])) {
                  var geo = this.model.getGeometry(cells[i]);
                  if (geo != null) {
                    var state = this.view.getState(cells[i]);
                    var pstate = this.view.getState(
                      this.model.getParent(cells[i])
                    );
                    if (state != null && pstate != null) {
                      geo = geo.clone();
                      var dx = -pstate.origin.x;
                      var dy = -pstate.origin.y;
                      var pts = state.absolutePoints;
                      var src = this.model.getTerminal(cells[i], true);
                      if (src != null && this.isCellDisconnectable(cells[i], src, true)) {
                        while (src != null && !dict.get(src)) {
                          src = this.model.getParent(src);
                        }
                        if (src == null) {
                          geo.setTerminalPoint(
                            new mxPoint(
                              pts[0].x / scale - tr.x + dx,
                              pts[0].y / scale - tr.y + dy
                            ),
                            true
                          );
                          this.model.setTerminal(cells[i], null, true);
                        }
                      }
                      var trg = this.model.getTerminal(cells[i], false);
                      if (trg != null && this.isCellDisconnectable(cells[i], trg, false)) {
                        while (trg != null && !dict.get(trg)) {
                          trg = this.model.getParent(trg);
                        }
                        if (trg == null) {
                          var n = pts.length - 1;
                          geo.setTerminalPoint(
                            new mxPoint(
                              pts[n].x / scale - tr.x + dx,
                              pts[n].y / scale - tr.y + dy
                            ),
                            false
                          );
                          this.model.setTerminal(cells[i], null, false);
                        }
                      }
                      this.model.setGeometry(cells[i], geo);
                    }
                  }
                }
              }
            } finally {
              this.model.endUpdate();
            }
          }
        };
        mxGraph.prototype.getCurrentRoot = function() {
          return this.view.currentRoot;
        };
        mxGraph.prototype.getTranslateForRoot = function(cell2) {
          return null;
        };
        mxGraph.prototype.isPort = function(cell2) {
          return false;
        };
        mxGraph.prototype.getTerminalForPort = function(cell2, source) {
          return this.model.getParent(cell2);
        };
        mxGraph.prototype.getChildOffsetForCell = function(cell2) {
          return null;
        };
        mxGraph.prototype.enterGroup = function(cell2) {
          cell2 = cell2 || this.getSelectionCell();
          if (cell2 != null && this.isValidRoot(cell2)) {
            this.view.setCurrentRoot(cell2);
            this.clearSelection();
          }
        };
        mxGraph.prototype.exitGroup = function() {
          var root = this.model.getRoot();
          var current = this.getCurrentRoot();
          if (current != null) {
            var next = this.model.getParent(current);
            while (next != root && !this.isValidRoot(next) && this.model.getParent(next) != root) {
              next = this.model.getParent(next);
            }
            if (next == root || this.model.getParent(next) == root) {
              this.view.setCurrentRoot(null);
            } else {
              this.view.setCurrentRoot(next);
            }
            var state = this.view.getState(current);
            if (state != null) {
              this.setSelectionCell(current);
            }
          }
        };
        mxGraph.prototype.home = function() {
          var current = this.getCurrentRoot();
          if (current != null) {
            this.view.setCurrentRoot(null);
            var state = this.view.getState(current);
            if (state != null) {
              this.setSelectionCell(current);
            }
          }
        };
        mxGraph.prototype.isValidRoot = function(cell2) {
          return cell2 != null;
        };
        mxGraph.prototype.getGraphBounds = function() {
          return this.view.getGraphBounds();
        };
        mxGraph.prototype.getCellBounds = function(cell2, includeEdges, includeDescendants) {
          var cells = [cell2];
          if (includeEdges) {
            cells = cells.concat(this.model.getEdges(cell2));
          }
          var result2 = this.view.getBounds(cells);
          if (includeDescendants) {
            var childCount = this.model.getChildCount(cell2);
            for (var i = 0; i < childCount; i++) {
              var tmp = this.getCellBounds(
                this.model.getChildAt(cell2, i),
                includeEdges,
                true
              );
              if (result2 != null) {
                result2.add(tmp);
              } else {
                result2 = tmp;
              }
            }
          }
          return result2;
        };
        mxGraph.prototype.getBoundingBoxFromGeometry = function(cells, includeEdges) {
          includeEdges = includeEdges != null ? includeEdges : false;
          var result2 = null;
          if (cells != null) {
            for (var i = 0; i < cells.length; i++) {
              if (includeEdges || this.model.isVertex(cells[i])) {
                var geo = this.getCellGeometry(cells[i]);
                if (geo != null) {
                  var bbox = null;
                  if (this.model.isEdge(cells[i])) {
                    var addPoint = function(pt) {
                      if (pt != null) {
                        if (tmp == null) {
                          tmp = new mxRectangle(pt.x, pt.y, 0, 0);
                        } else {
                          tmp.add(new mxRectangle(pt.x, pt.y, 0, 0));
                        }
                      }
                    };
                    if (this.model.getTerminal(cells[i], true) == null) {
                      addPoint(geo.getTerminalPoint(true));
                    }
                    if (this.model.getTerminal(cells[i], false) == null) {
                      addPoint(geo.getTerminalPoint(false));
                    }
                    var pts = geo.points;
                    if (pts != null && pts.length > 0) {
                      var tmp = new mxRectangle(pts[0].x, pts[0].y, 0, 0);
                      for (var j = 1; j < pts.length; j++) {
                        addPoint(pts[j]);
                      }
                    }
                    bbox = tmp;
                  } else {
                    var parent = this.model.getParent(cells[i]);
                    if (geo.relative) {
                      if (this.model.isVertex(parent) && parent != this.view.currentRoot) {
                        var tmp = this.getBoundingBoxFromGeometry([parent], false);
                        if (tmp != null) {
                          bbox = new mxRectangle(geo.x * tmp.width, geo.y * tmp.height, geo.width, geo.height);
                          if (mxUtils.indexOf(cells, parent) >= 0) {
                            bbox.x += tmp.x;
                            bbox.y += tmp.y;
                          }
                        }
                      }
                    } else {
                      bbox = mxRectangle.fromRectangle(geo);
                      if (this.model.isVertex(parent) && mxUtils.indexOf(cells, parent) >= 0) {
                        var tmp = this.getBoundingBoxFromGeometry([parent], false);
                        if (tmp != null) {
                          bbox.x += tmp.x;
                          bbox.y += tmp.y;
                        }
                      }
                    }
                    if (bbox != null && geo.offset != null) {
                      bbox.x += geo.offset.x;
                      bbox.y += geo.offset.y;
                    }
                    var style = this.getCurrentCellStyle(cells[i]);
                    if (bbox != null) {
                      var angle = mxUtils.getValue(style, mxConstants.STYLE_ROTATION, 0);
                      if (angle != 0) {
                        bbox = mxUtils.getBoundingBox(bbox, angle);
                      }
                    }
                  }
                  if (bbox != null) {
                    if (result2 == null) {
                      result2 = mxRectangle.fromRectangle(bbox);
                    } else {
                      result2.add(bbox);
                    }
                  }
                }
              }
            }
          }
          return result2;
        };
        mxGraph.prototype.refresh = function(cell2) {
          this.view.clear(cell2, cell2 == null);
          this.view.validate();
          this.sizeDidChange();
          this.fireEvent(new mxEventObject(mxEvent.REFRESH));
        };
        mxGraph.prototype.snap = function(value) {
          if (this.gridEnabled) {
            value = Math.round(value / this.gridSize) * this.gridSize;
          }
          return value;
        };
        mxGraph.prototype.snapDelta = function(delta, bounds, ignoreGrid, ignoreHorizontal, ignoreVertical) {
          var t = this.view.translate;
          var s = this.view.scale;
          if (!ignoreGrid && this.gridEnabled) {
            var tol = this.gridSize * s * 0.5;
            if (!ignoreHorizontal) {
              var tx = bounds.x - (this.snap(bounds.x / s - t.x) + t.x) * s;
              if (Math.abs(delta.x - tx) < tol) {
                delta.x = 0;
              } else {
                delta.x = this.snap(delta.x / s) * s - tx;
              }
            }
            if (!ignoreVertical) {
              var ty = bounds.y - (this.snap(bounds.y / s - t.y) + t.y) * s;
              if (Math.abs(delta.y - ty) < tol) {
                delta.y = 0;
              } else {
                delta.y = this.snap(delta.y / s) * s - ty;
              }
            }
          } else {
            var tol = 0.5 * s;
            if (!ignoreHorizontal) {
              var tx = bounds.x - (Math.round(bounds.x / s - t.x) + t.x) * s;
              if (Math.abs(delta.x - tx) < tol) {
                delta.x = 0;
              } else {
                delta.x = Math.round(delta.x / s) * s - tx;
              }
            }
            if (!ignoreVertical) {
              var ty = bounds.y - (Math.round(bounds.y / s - t.y) + t.y) * s;
              if (Math.abs(delta.y - ty) < tol) {
                delta.y = 0;
              } else {
                delta.y = Math.round(delta.y / s) * s - ty;
              }
            }
          }
          return delta;
        };
        mxGraph.prototype.panGraph = function(dx, dy) {
          if (this.useScrollbarsForPanning && mxUtils.hasScrollbars(this.container)) {
            this.container.scrollLeft = -dx;
            this.container.scrollTop = -dy;
          } else {
            var canvas = this.view.getCanvas();
            if (this.dialect == mxConstants.DIALECT_SVG) {
              if (dx == 0 && dy == 0) {
                if (mxClient.IS_IE) {
                  canvas.setAttribute("transform", "translate(" + dx + "," + dy + ")");
                } else {
                  canvas.removeAttribute("transform");
                }
                if (this.shiftPreview1 != null) {
                  var child = this.shiftPreview1.firstChild;
                  while (child != null) {
                    var next = child.nextSibling;
                    this.container.appendChild(child);
                    child = next;
                  }
                  if (this.shiftPreview1.parentNode != null) {
                    this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);
                  }
                  this.shiftPreview1 = null;
                  this.container.appendChild(canvas.parentNode);
                  child = this.shiftPreview2.firstChild;
                  while (child != null) {
                    var next = child.nextSibling;
                    this.container.appendChild(child);
                    child = next;
                  }
                  if (this.shiftPreview2.parentNode != null) {
                    this.shiftPreview2.parentNode.removeChild(this.shiftPreview2);
                  }
                  this.shiftPreview2 = null;
                }
              } else {
                canvas.setAttribute("transform", "translate(" + dx + "," + dy + ")");
                if (this.shiftPreview1 == null) {
                  this.shiftPreview1 = document.createElement("div");
                  this.shiftPreview1.style.position = "absolute";
                  this.shiftPreview1.style.overflow = "visible";
                  this.shiftPreview2 = document.createElement("div");
                  this.shiftPreview2.style.position = "absolute";
                  this.shiftPreview2.style.overflow = "visible";
                  var current = this.shiftPreview1;
                  var child = this.container.firstChild;
                  while (child != null) {
                    var next = child.nextSibling;
                    if (child != canvas.parentNode) {
                      current.appendChild(child);
                    } else {
                      current = this.shiftPreview2;
                    }
                    child = next;
                  }
                  if (this.shiftPreview1.firstChild != null) {
                    this.container.insertBefore(this.shiftPreview1, canvas.parentNode);
                  }
                  if (this.shiftPreview2.firstChild != null) {
                    this.container.appendChild(this.shiftPreview2);
                  }
                }
                this.shiftPreview1.style.left = dx + "px";
                this.shiftPreview1.style.top = dy + "px";
                this.shiftPreview2.style.left = dx + "px";
                this.shiftPreview2.style.top = dy + "px";
              }
            } else {
              canvas.style.left = dx + "px";
              canvas.style.top = dy + "px";
            }
            this.panDx = dx;
            this.panDy = dy;
            this.fireEvent(new mxEventObject(mxEvent.PAN));
          }
        };
        mxGraph.prototype.zoomIn = function() {
          this.zoom(this.zoomFactor);
        };
        mxGraph.prototype.zoomOut = function() {
          this.zoom(1 / this.zoomFactor);
        };
        mxGraph.prototype.zoomActual = function() {
          if (this.view.scale == 1) {
            this.view.setTranslate(0, 0);
          } else {
            this.view.translate.x = 0;
            this.view.translate.y = 0;
            this.view.setScale(1);
          }
        };
        mxGraph.prototype.zoomTo = function(scale, center) {
          this.zoom(scale / this.view.scale, center);
        };
        mxGraph.prototype.center = function(horizontal, vertical, cx, cy) {
          horizontal = horizontal != null ? horizontal : true;
          vertical = vertical != null ? vertical : true;
          cx = cx != null ? cx : 0.5;
          cy = cy != null ? cy : 0.5;
          var hasScrollbars = mxUtils.hasScrollbars(this.container);
          var padding = 2 * this.getBorder();
          var cw = this.container.clientWidth - padding;
          var ch = this.container.clientHeight - padding;
          var bounds = this.getGraphBounds();
          var t = this.view.translate;
          var s = this.view.scale;
          var dx = horizontal ? cw - bounds.width : 0;
          var dy = vertical ? ch - bounds.height : 0;
          if (!hasScrollbars) {
            this.view.setTranslate(
              horizontal ? Math.floor(t.x - bounds.x / s + dx * cx / s) : t.x,
              vertical ? Math.floor(t.y - bounds.y / s + dy * cy / s) : t.y
            );
          } else {
            bounds.x -= t.x;
            bounds.y -= t.y;
            var sw = this.container.scrollWidth;
            var sh = this.container.scrollHeight;
            if (sw > cw) {
              dx = 0;
            }
            if (sh > ch) {
              dy = 0;
            }
            this.view.setTranslate(Math.floor(dx / 2 - bounds.x), Math.floor(dy / 2 - bounds.y));
            this.container.scrollLeft = (sw - cw) / 2;
            this.container.scrollTop = (sh - ch) / 2;
          }
        };
        mxGraph.prototype.zoom = function(factor, center) {
          center = center != null ? center : this.centerZoom;
          var scale = Math.round(this.view.scale * factor * 100) / 100;
          var state = this.view.getState(this.getSelectionCell());
          factor = scale / this.view.scale;
          if (this.keepSelectionVisibleOnZoom && state != null) {
            var rect = new mxRectangle(
              state.x * factor,
              state.y * factor,
              state.width * factor,
              state.height * factor
            );
            this.view.scale = scale;
            if (!this.scrollRectToVisible(rect)) {
              this.view.revalidate();
              this.view.setScale(scale);
            }
          } else {
            var hasScrollbars = mxUtils.hasScrollbars(this.container);
            if (center && !hasScrollbars) {
              var dx = this.container.offsetWidth;
              var dy = this.container.offsetHeight;
              if (factor > 1) {
                var f = (factor - 1) / (scale * 2);
                dx *= -f;
                dy *= -f;
              } else {
                var f = (1 / factor - 1) / (this.view.scale * 2);
                dx *= f;
                dy *= f;
              }
              this.view.scaleAndTranslate(
                scale,
                this.view.translate.x + dx,
                this.view.translate.y + dy
              );
            } else {
              var tx = this.view.translate.x;
              var ty = this.view.translate.y;
              var sl = this.container.scrollLeft;
              var st = this.container.scrollTop;
              this.view.setScale(scale);
              if (hasScrollbars) {
                var dx = 0;
                var dy = 0;
                if (center) {
                  dx = this.container.offsetWidth * (factor - 1) / 2;
                  dy = this.container.offsetHeight * (factor - 1) / 2;
                }
                this.container.scrollLeft = (this.view.translate.x - tx) * this.view.scale + Math.round(sl * factor + dx);
                this.container.scrollTop = (this.view.translate.y - ty) * this.view.scale + Math.round(st * factor + dy);
              }
            }
          }
        };
        mxGraph.prototype.zoomToRect = function(rect) {
          var scaleX = this.container.clientWidth / rect.width;
          var scaleY = this.container.clientHeight / rect.height;
          var aspectFactor = scaleX / scaleY;
          rect.x = Math.max(0, rect.x);
          rect.y = Math.max(0, rect.y);
          var rectRight = Math.min(this.container.scrollWidth, rect.x + rect.width);
          var rectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);
          rect.width = rectRight - rect.x;
          rect.height = rectBottom - rect.y;
          if (aspectFactor < 1) {
            var newHeight = rect.height / aspectFactor;
            var deltaHeightBuffer = (newHeight - rect.height) / 2;
            rect.height = newHeight;
            var upperBuffer = Math.min(rect.y, deltaHeightBuffer);
            rect.y = rect.y - upperBuffer;
            rectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);
            rect.height = rectBottom - rect.y;
          } else {
            var newWidth = rect.width * aspectFactor;
            var deltaWidthBuffer = (newWidth - rect.width) / 2;
            rect.width = newWidth;
            var leftBuffer = Math.min(rect.x, deltaWidthBuffer);
            rect.x = rect.x - leftBuffer;
            rectRight = Math.min(this.container.scrollWidth, rect.x + rect.width);
            rect.width = rectRight - rect.x;
          }
          var scale = this.container.clientWidth / rect.width;
          var newScale = this.view.scale * scale;
          if (!mxUtils.hasScrollbars(this.container)) {
            this.view.scaleAndTranslate(newScale, this.view.translate.x - rect.x / this.view.scale, this.view.translate.y - rect.y / this.view.scale);
          } else {
            this.view.setScale(newScale);
            this.container.scrollLeft = Math.round(rect.x * scale);
            this.container.scrollTop = Math.round(rect.y * scale);
          }
        };
        mxGraph.prototype.scrollCellToVisible = function(cell2, center) {
          var x = -this.view.translate.x;
          var y = -this.view.translate.y;
          var state = this.view.getState(cell2);
          if (state != null) {
            var bounds = new mxRectangle(
              x + state.x,
              y + state.y,
              state.width,
              state.height
            );
            if (center && this.container != null) {
              var w2 = this.container.clientWidth;
              var h2 = this.container.clientHeight;
              bounds.x = bounds.getCenterX() - w2 / 2;
              bounds.width = w2;
              bounds.y = bounds.getCenterY() - h2 / 2;
              bounds.height = h2;
            }
            var tr = new mxPoint(this.view.translate.x, this.view.translate.y);
            if (this.scrollRectToVisible(bounds)) {
              var tr2 = new mxPoint(this.view.translate.x, this.view.translate.y);
              this.view.translate.x = tr.x;
              this.view.translate.y = tr.y;
              this.view.setTranslate(tr2.x, tr2.y);
            }
          }
        };
        mxGraph.prototype.scrollRectToVisible = function(rect) {
          var isChanged = false;
          if (rect != null) {
            var w2 = this.container.offsetWidth;
            var h2 = this.container.offsetHeight;
            var widthLimit = Math.min(w2, rect.width);
            var heightLimit = Math.min(h2, rect.height);
            if (mxUtils.hasScrollbars(this.container)) {
              var c = this.container;
              rect.x += this.view.translate.x;
              rect.y += this.view.translate.y;
              var dx = c.scrollLeft - rect.x;
              var ddx = Math.max(dx - c.scrollLeft, 0);
              if (dx > 0) {
                c.scrollLeft -= dx + 2;
              } else {
                dx = rect.x + widthLimit - c.scrollLeft - c.clientWidth;
                if (dx > 0) {
                  c.scrollLeft += dx + 2;
                }
              }
              var dy = c.scrollTop - rect.y;
              var ddy = Math.max(0, dy - c.scrollTop);
              if (dy > 0) {
                c.scrollTop -= dy + 2;
              } else {
                dy = rect.y + heightLimit - c.scrollTop - c.clientHeight;
                if (dy > 0) {
                  c.scrollTop += dy + 2;
                }
              }
              if (!this.useScrollbarsForPanning && (ddx != 0 || ddy != 0)) {
                this.view.setTranslate(ddx, ddy);
              }
            } else {
              var x = -this.view.translate.x;
              var y = -this.view.translate.y;
              var s = this.view.scale;
              if (rect.x + widthLimit > x + w2) {
                this.view.translate.x -= (rect.x + widthLimit - w2 - x) / s;
                isChanged = true;
              }
              if (rect.y + heightLimit > y + h2) {
                this.view.translate.y -= (rect.y + heightLimit - h2 - y) / s;
                isChanged = true;
              }
              if (rect.x < x) {
                this.view.translate.x += (x - rect.x) / s;
                isChanged = true;
              }
              if (rect.y < y) {
                this.view.translate.y += (y - rect.y) / s;
                isChanged = true;
              }
              if (isChanged) {
                this.view.refresh();
                if (this.selectionCellsHandler != null) {
                  this.selectionCellsHandler.refresh();
                }
              }
            }
          }
          return isChanged;
        };
        mxGraph.prototype.getCellGeometry = function(cell2) {
          return this.model.getGeometry(cell2);
        };
        mxGraph.prototype.isCellVisible = function(cell2) {
          return this.model.isVisible(cell2);
        };
        mxGraph.prototype.isCellCollapsed = function(cell2) {
          return this.model.isCollapsed(cell2);
        };
        mxGraph.prototype.isCellConnectable = function(cell2) {
          return this.model.isConnectable(cell2);
        };
        mxGraph.prototype.isOrthogonal = function(edge) {
          var orthogonal = edge.style[mxConstants.STYLE_ORTHOGONAL];
          if (orthogonal != null) {
            return orthogonal;
          }
          var tmp = this.view.getEdgeStyle(edge);
          return tmp == mxEdgeStyle.SegmentConnector || tmp == mxEdgeStyle.ElbowConnector || tmp == mxEdgeStyle.SideToSide || tmp == mxEdgeStyle.TopToBottom || tmp == mxEdgeStyle.EntityRelation || tmp == mxEdgeStyle.OrthConnector;
        };
        mxGraph.prototype.isLoop = function(state) {
          var src = state.getVisibleTerminalState(true);
          var trg = state.getVisibleTerminalState(false);
          return src != null && src == trg;
        };
        mxGraph.prototype.isCloneEvent = function(evt) {
          return mxEvent.isControlDown(evt);
        };
        mxGraph.prototype.isTransparentClickEvent = function(evt) {
          return false;
        };
        mxGraph.prototype.isToggleEvent = function(evt) {
          return mxClient.IS_MAC ? mxEvent.isMetaDown(evt) : mxEvent.isControlDown(evt);
        };
        mxGraph.prototype.isGridEnabledEvent = function(evt) {
          return evt != null && !mxEvent.isAltDown(evt);
        };
        mxGraph.prototype.isConstrainedEvent = function(evt) {
          return mxEvent.isShiftDown(evt);
        };
        mxGraph.prototype.isIgnoreTerminalEvent = function(evt) {
          return false;
        };
        mxGraph.prototype.validationAlert = function(message) {
          mxUtils.alert(message);
        };
        mxGraph.prototype.isEdgeValid = function(edge, source, target) {
          return this.getEdgeValidationError(edge, source, target) == null;
        };
        mxGraph.prototype.getEdgeValidationError = function(edge, source, target) {
          if (edge != null && !this.isAllowDanglingEdges() && (source == null || target == null)) {
            return "";
          }
          if (edge != null && this.model.getTerminal(edge, true) == null && this.model.getTerminal(edge, false) == null) {
            return null;
          }
          if (!this.allowLoops && source == target && source != null) {
            return "";
          }
          if (!this.isValidConnection(source, target)) {
            return "";
          }
          if (source != null && target != null) {
            var error = "";
            if (!this.multigraph) {
              var tmp = this.model.getEdgesBetween(source, target, true);
              if (tmp.length > 1 || tmp.length == 1 && tmp[0] != edge) {
                error += (mxResources.get(this.alreadyConnectedResource) || this.alreadyConnectedResource) + "\n";
              }
            }
            var sourceOut = this.model.getDirectedEdgeCount(source, true, edge);
            var targetIn = this.model.getDirectedEdgeCount(target, false, edge);
            if (this.multiplicities != null) {
              for (var i = 0; i < this.multiplicities.length; i++) {
                var err = this.multiplicities[i].check(
                  this,
                  edge,
                  source,
                  target,
                  sourceOut,
                  targetIn
                );
                if (err != null) {
                  error += err;
                }
              }
            }
            var err = this.validateEdge(edge, source, target);
            if (err != null) {
              error += err;
            }
            return error.length > 0 ? error : null;
          }
          return this.allowDanglingEdges ? null : "";
        };
        mxGraph.prototype.validateEdge = function(edge, source, target) {
          return null;
        };
        mxGraph.prototype.validateGraph = function(cell2, context) {
          cell2 = cell2 != null ? cell2 : this.model.getRoot();
          context = context != null ? context : new Object();
          var isValid = true;
          var childCount = this.model.getChildCount(cell2);
          for (var i = 0; i < childCount; i++) {
            var tmp = this.model.getChildAt(cell2, i);
            var ctx = context;
            if (this.isValidRoot(tmp)) {
              ctx = new Object();
            }
            var warn = this.validateGraph(tmp, ctx);
            if (warn != null) {
              this.setCellWarning(tmp, warn.replace(/\n/g, "<br>"));
            } else {
              this.setCellWarning(tmp, null);
            }
            isValid = isValid && warn == null;
          }
          var warning = "";
          if (this.isCellCollapsed(cell2) && !isValid) {
            warning += (mxResources.get(this.containsValidationErrorsResource) || this.containsValidationErrorsResource) + "\n";
          }
          if (this.model.isEdge(cell2)) {
            warning += this.getEdgeValidationError(
              cell2,
              this.model.getTerminal(cell2, true),
              this.model.getTerminal(cell2, false)
            ) || "";
          } else {
            warning += this.getCellValidationError(cell2) || "";
          }
          var err = this.validateCell(cell2, context);
          if (err != null) {
            warning += err;
          }
          if (this.model.getParent(cell2) == null) {
            this.view.validate();
          }
          return warning.length > 0 || !isValid ? warning : null;
        };
        mxGraph.prototype.getCellValidationError = function(cell2) {
          var outCount = this.model.getDirectedEdgeCount(cell2, true);
          var inCount = this.model.getDirectedEdgeCount(cell2, false);
          var value = this.model.getValue(cell2);
          var error = "";
          if (this.multiplicities != null) {
            for (var i = 0; i < this.multiplicities.length; i++) {
              var rule = this.multiplicities[i];
              if (rule.source && mxUtils.isNode(
                value,
                rule.type,
                rule.attr,
                rule.value
              ) && (outCount > rule.max || outCount < rule.min)) {
                error += rule.countError + "\n";
              } else if (!rule.source && mxUtils.isNode(
                value,
                rule.type,
                rule.attr,
                rule.value
              ) && (inCount > rule.max || inCount < rule.min)) {
                error += rule.countError + "\n";
              }
            }
          }
          return error.length > 0 ? error : null;
        };
        mxGraph.prototype.validateCell = function(cell2, context) {
          return null;
        };
        mxGraph.prototype.getBackgroundImage = function() {
          return this.backgroundImage;
        };
        mxGraph.prototype.setBackgroundImage = function(image) {
          this.backgroundImage = image;
        };
        mxGraph.prototype.getFoldingImage = function(state) {
          if (state != null && this.foldingEnabled && !this.getModel().isEdge(state.cell)) {
            var tmp = this.isCellCollapsed(state.cell);
            if (this.isCellFoldable(state.cell, !tmp)) {
              return tmp ? this.collapsedImage : this.expandedImage;
            }
          }
          return null;
        };
        mxGraph.prototype.convertValueToString = function(cell2) {
          var value = this.model.getValue(cell2);
          if (value != null) {
            if (mxUtils.isNode(value)) {
              return value.nodeName;
            } else if (typeof value.toString == "function") {
              return value.toString();
            }
          }
          return "";
        };
        mxGraph.prototype.getLabel = function(cell2) {
          var result2 = "";
          if (this.labelsVisible && cell2 != null) {
            var style = this.getCurrentCellStyle(cell2);
            if (!mxUtils.getValue(style, mxConstants.STYLE_NOLABEL, false)) {
              result2 = this.convertValueToString(cell2);
            }
          }
          return result2;
        };
        mxGraph.prototype.isHtmlLabel = function(cell2) {
          return this.isHtmlLabels();
        };
        mxGraph.prototype.isHtmlLabels = function() {
          return this.htmlLabels;
        };
        mxGraph.prototype.setHtmlLabels = function(value) {
          this.htmlLabels = value;
        };
        mxGraph.prototype.isWrapping = function(cell2) {
          return this.getCurrentCellStyle(cell2)[mxConstants.STYLE_WHITE_SPACE] == "wrap";
        };
        mxGraph.prototype.isLabelClipped = function(cell2) {
          return this.getCurrentCellStyle(cell2)[mxConstants.STYLE_OVERFLOW] == "hidden";
        };
        mxGraph.prototype.getTooltip = function(state, node, x, y) {
          var tip = null;
          if (state != null) {
            if (state.control != null && (node == state.control.node || node.parentNode == state.control.node)) {
              tip = this.collapseExpandResource;
              tip = mxUtils.htmlEntities(mxResources.get(tip) || tip).replace(/\\n/g, "<br>");
            }
            if (tip == null && state.overlays != null) {
              state.overlays.visit(function(id, shape2) {
                if (tip == null && (node == shape2.node || node.parentNode == shape2.node)) {
                  tip = shape2.overlay.toString();
                }
              });
            }
            if (tip == null) {
              var handler = this.selectionCellsHandler.getHandler(state.cell);
              if (handler != null && typeof handler.getTooltipForNode == "function") {
                tip = handler.getTooltipForNode(node);
              }
            }
            if (tip == null) {
              tip = this.getTooltipForCell(state.cell);
            }
          }
          return tip;
        };
        mxGraph.prototype.getTooltipForCell = function(cell2) {
          var tip = null;
          if (cell2 != null && cell2.getTooltip != null) {
            tip = cell2.getTooltip();
          } else {
            tip = this.convertValueToString(cell2);
          }
          return tip;
        };
        mxGraph.prototype.getLinkForCell = function(cell2) {
          return null;
        };
        mxGraph.prototype.getCursorForMouseEvent = function(me) {
          return this.getCursorForCell(me.getCell());
        };
        mxGraph.prototype.getCursorForCell = function(cell2) {
          return null;
        };
        mxGraph.prototype.getStartSize = function(swimlane, ignoreState) {
          var result2 = new mxRectangle();
          var style = this.getCurrentCellStyle(swimlane, ignoreState);
          var size = parseInt(mxUtils.getValue(
            style,
            mxConstants.STYLE_STARTSIZE,
            mxConstants.DEFAULT_STARTSIZE
          ));
          if (mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true)) {
            result2.height = size;
          } else {
            result2.width = size;
          }
          return result2;
        };
        mxGraph.prototype.getSwimlaneDirection = function(style) {
          var dir = mxUtils.getValue(style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
          var flipH = mxUtils.getValue(style, mxConstants.STYLE_FLIPH, 0) == 1;
          var flipV = mxUtils.getValue(style, mxConstants.STYLE_FLIPV, 0) == 1;
          var h2 = mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true);
          var n = h2 ? 0 : 3;
          if (dir == mxConstants.DIRECTION_NORTH) {
            n--;
          } else if (dir == mxConstants.DIRECTION_WEST) {
            n += 2;
          } else if (dir == mxConstants.DIRECTION_SOUTH) {
            n += 1;
          }
          var mod = mxUtils.mod(n, 2);
          if (flipH && mod == 1) {
            n += 2;
          }
          if (flipV && mod == 0) {
            n += 2;
          }
          return [
            mxConstants.DIRECTION_NORTH,
            mxConstants.DIRECTION_EAST,
            mxConstants.DIRECTION_SOUTH,
            mxConstants.DIRECTION_WEST
          ][mxUtils.mod(n, 4)];
        };
        mxGraph.prototype.getActualStartSize = function(swimlane, ignoreState) {
          var result2 = new mxRectangle();
          if (this.isSwimlane(swimlane, ignoreState)) {
            var style = this.getCurrentCellStyle(swimlane, ignoreState);
            var size = parseInt(mxUtils.getValue(
              style,
              mxConstants.STYLE_STARTSIZE,
              mxConstants.DEFAULT_STARTSIZE
            ));
            var dir = this.getSwimlaneDirection(style);
            if (dir == mxConstants.DIRECTION_NORTH) {
              result2.y = size;
            } else if (dir == mxConstants.DIRECTION_WEST) {
              result2.x = size;
            } else if (dir == mxConstants.DIRECTION_SOUTH) {
              result2.height = size;
            } else {
              result2.width = size;
            }
          }
          return result2;
        };
        mxGraph.prototype.getImage = function(state) {
          return state != null && state.style != null ? state.style[mxConstants.STYLE_IMAGE] : null;
        };
        mxGraph.prototype.isTransparentState = function(state) {
          var result2 = false;
          if (state != null) {
            var stroke = mxUtils.getValue(state.style, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE);
            var fill = mxUtils.getValue(state.style, mxConstants.STYLE_FILLCOLOR, mxConstants.NONE);
            result2 = stroke == mxConstants.NONE && fill == mxConstants.NONE && this.getImage(state) == null;
          }
          return result2;
        };
        mxGraph.prototype.getVerticalAlign = function(state) {
          return state != null && state.style != null ? state.style[mxConstants.STYLE_VERTICAL_ALIGN] || mxConstants.ALIGN_MIDDLE : null;
        };
        mxGraph.prototype.getIndicatorColor = function(state) {
          return state != null && state.style != null ? state.style[mxConstants.STYLE_INDICATOR_COLOR] : null;
        };
        mxGraph.prototype.getIndicatorGradientColor = function(state) {
          return state != null && state.style != null ? state.style[mxConstants.STYLE_INDICATOR_GRADIENTCOLOR] : null;
        };
        mxGraph.prototype.getIndicatorShape = function(state) {
          return state != null && state.style != null ? state.style[mxConstants.STYLE_INDICATOR_SHAPE] : null;
        };
        mxGraph.prototype.getIndicatorImage = function(state) {
          return state != null && state.style != null ? state.style[mxConstants.STYLE_INDICATOR_IMAGE] : null;
        };
        mxGraph.prototype.getBorder = function() {
          return this.border;
        };
        mxGraph.prototype.setBorder = function(value) {
          this.border = value;
        };
        mxGraph.prototype.isSwimlane = function(cell2, ignoreState) {
          if (cell2 != null && this.model.getParent(cell2) != this.model.getRoot() && !this.model.isEdge(cell2)) {
            return this.getCurrentCellStyle(cell2, ignoreState)[mxConstants.STYLE_SHAPE] == mxConstants.SHAPE_SWIMLANE;
          }
          return false;
        };
        mxGraph.prototype.isResizeContainer = function() {
          return this.resizeContainer;
        };
        mxGraph.prototype.setResizeContainer = function(value) {
          this.resizeContainer = value;
        };
        mxGraph.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxGraph.prototype.setEnabled = function(value) {
          this.enabled = value;
        };
        mxGraph.prototype.isEscapeEnabled = function() {
          return this.escapeEnabled;
        };
        mxGraph.prototype.setEscapeEnabled = function(value) {
          this.escapeEnabled = value;
        };
        mxGraph.prototype.isInvokesStopCellEditing = function() {
          return this.invokesStopCellEditing;
        };
        mxGraph.prototype.setInvokesStopCellEditing = function(value) {
          this.invokesStopCellEditing = value;
        };
        mxGraph.prototype.isEnterStopsCellEditing = function() {
          return this.enterStopsCellEditing;
        };
        mxGraph.prototype.setEnterStopsCellEditing = function(value) {
          this.enterStopsCellEditing = value;
        };
        mxGraph.prototype.isCellLocked = function(cell2) {
          var geometry = this.model.getGeometry(cell2);
          return this.isCellsLocked() || geometry != null && this.model.isVertex(cell2) && geometry.relative;
        };
        mxGraph.prototype.isCellsLocked = function() {
          return this.cellsLocked;
        };
        mxGraph.prototype.setCellsLocked = function(value) {
          this.cellsLocked = value;
        };
        mxGraph.prototype.getCloneableCells = function(cells) {
          return this.model.filterCells(cells, mxUtils.bind(this, function(cell2) {
            return this.isCellCloneable(cell2);
          }));
        };
        mxGraph.prototype.isCellCloneable = function(cell2) {
          var style = this.getCurrentCellStyle(cell2);
          return this.isCellsCloneable() && style[mxConstants.STYLE_CLONEABLE] != 0;
        };
        mxGraph.prototype.isCellsCloneable = function() {
          return this.cellsCloneable;
        };
        mxGraph.prototype.setCellsCloneable = function(value) {
          this.cellsCloneable = value;
        };
        mxGraph.prototype.getExportableCells = function(cells) {
          return this.model.filterCells(cells, mxUtils.bind(this, function(cell2) {
            return this.canExportCell(cell2);
          }));
        };
        mxGraph.prototype.canExportCell = function(cell2) {
          return this.exportEnabled;
        };
        mxGraph.prototype.getImportableCells = function(cells) {
          return this.model.filterCells(cells, mxUtils.bind(this, function(cell2) {
            return this.canImportCell(cell2);
          }));
        };
        mxGraph.prototype.canImportCell = function(cell2) {
          return this.importEnabled;
        };
        mxGraph.prototype.isCellSelectable = function(cell2) {
          return this.isCellsSelectable();
        };
        mxGraph.prototype.isCellsSelectable = function() {
          return this.cellsSelectable;
        };
        mxGraph.prototype.setCellsSelectable = function(value) {
          this.cellsSelectable = value;
        };
        mxGraph.prototype.getDeletableCells = function(cells) {
          return this.model.filterCells(cells, mxUtils.bind(this, function(cell2) {
            return this.isCellDeletable(cell2);
          }));
        };
        mxGraph.prototype.isCellDeletable = function(cell2) {
          var style = this.getCurrentCellStyle(cell2);
          return this.isCellsDeletable() && style[mxConstants.STYLE_DELETABLE] != 0;
        };
        mxGraph.prototype.isCellsDeletable = function() {
          return this.cellsDeletable;
        };
        mxGraph.prototype.setCellsDeletable = function(value) {
          this.cellsDeletable = value;
        };
        mxGraph.prototype.isLabelMovable = function(cell2) {
          return !this.isCellLocked(cell2) && (this.model.isEdge(cell2) && this.edgeLabelsMovable || this.model.isVertex(cell2) && this.vertexLabelsMovable);
        };
        mxGraph.prototype.isCellRotatable = function(cell2) {
          var style = this.getCurrentCellStyle(cell2);
          return style[mxConstants.STYLE_ROTATABLE] != 0;
        };
        mxGraph.prototype.getMovableCells = function(cells) {
          return this.model.filterCells(cells, mxUtils.bind(this, function(cell2) {
            return this.isCellMovable(cell2);
          }));
        };
        mxGraph.prototype.isCellMovable = function(cell2) {
          var style = this.getCurrentCellStyle(cell2);
          return this.isCellsMovable() && !this.isCellLocked(cell2) && style[mxConstants.STYLE_MOVABLE] != 0;
        };
        mxGraph.prototype.isCellsMovable = function() {
          return this.cellsMovable;
        };
        mxGraph.prototype.setCellsMovable = function(value) {
          this.cellsMovable = value;
        };
        mxGraph.prototype.isGridEnabled = function() {
          return this.gridEnabled;
        };
        mxGraph.prototype.setGridEnabled = function(value) {
          this.gridEnabled = value;
        };
        mxGraph.prototype.isPortsEnabled = function() {
          return this.portsEnabled;
        };
        mxGraph.prototype.setPortsEnabled = function(value) {
          this.portsEnabled = value;
        };
        mxGraph.prototype.getGridSize = function() {
          return this.gridSize;
        };
        mxGraph.prototype.setGridSize = function(value) {
          this.gridSize = value;
        };
        mxGraph.prototype.getTolerance = function() {
          return this.tolerance;
        };
        mxGraph.prototype.setTolerance = function(value) {
          this.tolerance = value;
        };
        mxGraph.prototype.isVertexLabelsMovable = function() {
          return this.vertexLabelsMovable;
        };
        mxGraph.prototype.setVertexLabelsMovable = function(value) {
          this.vertexLabelsMovable = value;
        };
        mxGraph.prototype.isEdgeLabelsMovable = function() {
          return this.edgeLabelsMovable;
        };
        mxGraph.prototype.setEdgeLabelsMovable = function(value) {
          this.edgeLabelsMovable = value;
        };
        mxGraph.prototype.isSwimlaneNesting = function() {
          return this.swimlaneNesting;
        };
        mxGraph.prototype.setSwimlaneNesting = function(value) {
          this.swimlaneNesting = value;
        };
        mxGraph.prototype.isSwimlaneSelectionEnabled = function() {
          return this.swimlaneSelectionEnabled;
        };
        mxGraph.prototype.setSwimlaneSelectionEnabled = function(value) {
          this.swimlaneSelectionEnabled = value;
        };
        mxGraph.prototype.isMultigraph = function() {
          return this.multigraph;
        };
        mxGraph.prototype.setMultigraph = function(value) {
          this.multigraph = value;
        };
        mxGraph.prototype.isAllowLoops = function() {
          return this.allowLoops;
        };
        mxGraph.prototype.setAllowDanglingEdges = function(value) {
          this.allowDanglingEdges = value;
        };
        mxGraph.prototype.isAllowDanglingEdges = function() {
          return this.allowDanglingEdges;
        };
        mxGraph.prototype.setConnectableEdges = function(value) {
          this.connectableEdges = value;
        };
        mxGraph.prototype.isConnectableEdges = function() {
          return this.connectableEdges;
        };
        mxGraph.prototype.setCloneInvalidEdges = function(value) {
          this.cloneInvalidEdges = value;
        };
        mxGraph.prototype.isCloneInvalidEdges = function() {
          return this.cloneInvalidEdges;
        };
        mxGraph.prototype.setAllowLoops = function(value) {
          this.allowLoops = value;
        };
        mxGraph.prototype.isDisconnectOnMove = function() {
          return this.disconnectOnMove;
        };
        mxGraph.prototype.setDisconnectOnMove = function(value) {
          this.disconnectOnMove = value;
        };
        mxGraph.prototype.isDropEnabled = function() {
          return this.dropEnabled;
        };
        mxGraph.prototype.setDropEnabled = function(value) {
          this.dropEnabled = value;
        };
        mxGraph.prototype.isSplitEnabled = function() {
          return this.splitEnabled;
        };
        mxGraph.prototype.setSplitEnabled = function(value) {
          this.splitEnabled = value;
        };
        mxGraph.prototype.isCellResizable = function(cell2) {
          var style = this.getCurrentCellStyle(cell2);
          return this.isCellsResizable() && !this.isCellLocked(cell2) && mxUtils.getValue(style, mxConstants.STYLE_RESIZABLE, "1") != "0";
        };
        mxGraph.prototype.isCellsResizable = function() {
          return this.cellsResizable;
        };
        mxGraph.prototype.setCellsResizable = function(value) {
          this.cellsResizable = value;
        };
        mxGraph.prototype.isTerminalPointMovable = function(cell2, source) {
          return true;
        };
        mxGraph.prototype.isCellBendable = function(cell2) {
          var style = this.getCurrentCellStyle(cell2);
          return this.isCellsBendable() && !this.isCellLocked(cell2) && style[mxConstants.STYLE_BENDABLE] != 0;
        };
        mxGraph.prototype.isCellsBendable = function() {
          return this.cellsBendable;
        };
        mxGraph.prototype.setCellsBendable = function(value) {
          this.cellsBendable = value;
        };
        mxGraph.prototype.isCellEditable = function(cell2) {
          var style = this.getCurrentCellStyle(cell2);
          return this.isCellsEditable() && !this.isCellLocked(cell2) && style[mxConstants.STYLE_EDITABLE] != 0;
        };
        mxGraph.prototype.isCellsEditable = function() {
          return this.cellsEditable;
        };
        mxGraph.prototype.setCellsEditable = function(value) {
          this.cellsEditable = value;
        };
        mxGraph.prototype.isCellDisconnectable = function(cell2, terminal, source) {
          return this.isCellsDisconnectable() && !this.isCellLocked(cell2);
        };
        mxGraph.prototype.isCellsDisconnectable = function() {
          return this.cellsDisconnectable;
        };
        mxGraph.prototype.setCellsDisconnectable = function(value) {
          this.cellsDisconnectable = value;
        };
        mxGraph.prototype.isValidSource = function(cell2) {
          return cell2 == null && this.allowDanglingEdges || cell2 != null && (!this.model.isEdge(cell2) || this.connectableEdges) && this.isCellConnectable(cell2);
        };
        mxGraph.prototype.isValidTarget = function(cell2) {
          return this.isValidSource(cell2);
        };
        mxGraph.prototype.isValidConnection = function(source, target) {
          return this.isValidSource(source) && this.isValidTarget(target);
        };
        mxGraph.prototype.setConnectable = function(connectable) {
          this.connectionHandler.setEnabled(connectable);
        };
        mxGraph.prototype.isConnectable = function() {
          return this.connectionHandler.isEnabled();
        };
        mxGraph.prototype.setTooltips = function(enabled) {
          this.tooltipHandler.setEnabled(enabled);
        };
        mxGraph.prototype.setPanning = function(enabled) {
          this.panningHandler.panningEnabled = enabled;
        };
        mxGraph.prototype.isEditing = function(cell2) {
          if (this.cellEditor != null) {
            var editingCell = this.cellEditor.getEditingCell();
            return cell2 == null ? editingCell != null : cell2 == editingCell;
          }
          return false;
        };
        mxGraph.prototype.isAutoSizeCell = function(cell2) {
          var style = this.getCurrentCellStyle(cell2);
          return this.isAutoSizeCells() || style[mxConstants.STYLE_AUTOSIZE] == 1;
        };
        mxGraph.prototype.isAutoSizeCells = function() {
          return this.autoSizeCells;
        };
        mxGraph.prototype.setAutoSizeCells = function(value) {
          this.autoSizeCells = value;
        };
        mxGraph.prototype.isExtendParent = function(cell2) {
          return !this.getModel().isEdge(cell2) && this.isExtendParents();
        };
        mxGraph.prototype.isExtendParents = function() {
          return this.extendParents;
        };
        mxGraph.prototype.setExtendParents = function(value) {
          this.extendParents = value;
        };
        mxGraph.prototype.isExtendParentsOnAdd = function(cell2) {
          return this.extendParentsOnAdd;
        };
        mxGraph.prototype.setExtendParentsOnAdd = function(value) {
          this.extendParentsOnAdd = value;
        };
        mxGraph.prototype.isExtendParentsOnMove = function() {
          return this.extendParentsOnMove;
        };
        mxGraph.prototype.setExtendParentsOnMove = function(value) {
          this.extendParentsOnMove = value;
        };
        mxGraph.prototype.isRecursiveResize = function(state) {
          return this.recursiveResize;
        };
        mxGraph.prototype.setRecursiveResize = function(value) {
          this.recursiveResize = value;
        };
        mxGraph.prototype.isConstrainChild = function(cell2) {
          return this.isConstrainChildren() && !this.getModel().isEdge(this.getModel().getParent(cell2));
        };
        mxGraph.prototype.isConstrainChildren = function() {
          return this.constrainChildren;
        };
        mxGraph.prototype.setConstrainChildren = function(value) {
          this.constrainChildren = value;
        };
        mxGraph.prototype.isConstrainRelativeChildren = function() {
          return this.constrainRelativeChildren;
        };
        mxGraph.prototype.setConstrainRelativeChildren = function(value) {
          this.constrainRelativeChildren = value;
        };
        mxGraph.prototype.isAllowNegativeCoordinates = function() {
          return this.allowNegativeCoordinates;
        };
        mxGraph.prototype.setAllowNegativeCoordinates = function(value) {
          this.allowNegativeCoordinates = value;
        };
        mxGraph.prototype.getOverlap = function(cell2) {
          return this.isAllowOverlapParent(cell2) ? this.defaultOverlap : 0;
        };
        mxGraph.prototype.isAllowOverlapParent = function(cell2) {
          return false;
        };
        mxGraph.prototype.getFoldableCells = function(cells, collapse) {
          return this.model.filterCells(cells, mxUtils.bind(this, function(cell2) {
            return this.isCellFoldable(cell2, collapse);
          }));
        };
        mxGraph.prototype.isCellFoldable = function(cell2, collapse) {
          var style = this.getCurrentCellStyle(cell2);
          return this.model.getChildCount(cell2) > 0 && style[mxConstants.STYLE_FOLDABLE] != 0;
        };
        mxGraph.prototype.isValidDropTarget = function(cell2, cells, evt) {
          return cell2 != null && (this.isSplitEnabled() && this.isSplitTarget(cell2, cells, evt) || !this.model.isEdge(cell2) && (this.isSwimlane(cell2) || this.model.getChildCount(cell2) > 0 && !this.isCellCollapsed(cell2)));
        };
        mxGraph.prototype.isSplitTarget = function(target, cells, evt) {
          if (this.model.isEdge(target) && cells != null && cells.length == 1 && this.isCellConnectable(cells[0]) && this.getEdgeValidationError(
            target,
            this.model.getTerminal(target, true),
            cells[0]
          ) == null) {
            var src = this.model.getTerminal(target, true);
            var trg = this.model.getTerminal(target, false);
            return !this.model.isAncestor(cells[0], src) && !this.model.isAncestor(cells[0], trg);
          }
          return false;
        };
        mxGraph.prototype.getDropTarget = function(cells, evt, cell2, clone) {
          if (!this.isSwimlaneNesting()) {
            for (var i = 0; i < cells.length; i++) {
              if (this.isSwimlane(cells[i])) {
                return null;
              }
            }
          }
          var pt = mxUtils.convertPoint(
            this.container,
            mxEvent.getClientX(evt),
            mxEvent.getClientY(evt)
          );
          pt.x -= this.panDx;
          pt.y -= this.panDy;
          var swimlane = this.getSwimlaneAt(pt.x, pt.y);
          if (cell2 == null) {
            cell2 = swimlane;
          } else if (swimlane != null) {
            var tmp = this.model.getParent(swimlane);
            while (tmp != null && this.isSwimlane(tmp) && tmp != cell2) {
              tmp = this.model.getParent(tmp);
            }
            if (tmp == cell2) {
              cell2 = swimlane;
            }
          }
          while (cell2 != null && !this.isValidDropTarget(cell2, cells, evt) && !this.model.isLayer(cell2)) {
            cell2 = this.model.getParent(cell2);
          }
          if (clone == null || !clone) {
            var parent = cell2;
            while (parent != null && mxUtils.indexOf(cells, parent) < 0) {
              parent = this.model.getParent(parent);
            }
          }
          return !this.model.isLayer(cell2) && parent == null ? cell2 : null;
        };
        mxGraph.prototype.getDefaultParent = function() {
          var parent = this.getCurrentRoot();
          if (parent == null) {
            parent = this.defaultParent;
            if (parent == null) {
              var root = this.model.getRoot();
              parent = this.model.getChildAt(root, 0);
            }
          }
          return parent;
        };
        mxGraph.prototype.setDefaultParent = function(cell2) {
          this.defaultParent = cell2;
        };
        mxGraph.prototype.getSwimlane = function(cell2) {
          while (cell2 != null && !this.isSwimlane(cell2)) {
            cell2 = this.model.getParent(cell2);
          }
          return cell2;
        };
        mxGraph.prototype.getSwimlaneAt = function(x, y, parent) {
          if (parent == null) {
            parent = this.getCurrentRoot();
            if (parent == null) {
              parent = this.model.getRoot();
            }
          }
          if (parent != null) {
            var childCount = this.model.getChildCount(parent);
            for (var i = 0; i < childCount; i++) {
              var child = this.model.getChildAt(parent, i);
              if (child != null) {
                var result2 = this.getSwimlaneAt(x, y, child);
                if (result2 != null) {
                  return result2;
                } else if (this.isCellVisible(child) && this.isSwimlane(child)) {
                  var state = this.view.getState(child);
                  if (this.intersects(state, x, y)) {
                    return child;
                  }
                }
              }
            }
          }
          return null;
        };
        mxGraph.prototype.getCellAt = function(x, y, parent, vertices, edges, ignoreFn) {
          vertices = vertices != null ? vertices : true;
          edges = edges != null ? edges : true;
          if (parent == null) {
            parent = this.getCurrentRoot();
            if (parent == null) {
              parent = this.getModel().getRoot();
            }
          }
          if (parent != null) {
            var childCount = this.model.getChildCount(parent);
            for (var i = childCount - 1; i >= 0; i--) {
              var cell2 = this.model.getChildAt(parent, i);
              var result2 = this.getCellAt(x, y, cell2, vertices, edges, ignoreFn);
              if (result2 != null) {
                return result2;
              } else if (this.isCellVisible(cell2) && (edges && this.model.isEdge(cell2) || vertices && this.model.isVertex(cell2))) {
                var state = this.view.getState(cell2);
                if (state != null && (ignoreFn == null || !ignoreFn(state, x, y)) && this.intersects(state, x, y)) {
                  return cell2;
                }
              }
            }
          }
          return null;
        };
        mxGraph.prototype.intersects = function(state, x, y) {
          if (state != null) {
            var pts = state.absolutePoints;
            if (pts != null) {
              var t2 = this.tolerance * this.tolerance;
              var pt = pts[0];
              for (var i = 1; i < pts.length; i++) {
                var next = pts[i];
                var dist = mxUtils.ptSegDistSq(pt.x, pt.y, next.x, next.y, x, y);
                if (dist <= t2) {
                  return true;
                }
                pt = next;
              }
            } else {
              var alpha = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0);
              if (alpha != 0) {
                var cos = Math.cos(-alpha);
                var sin = Math.sin(-alpha);
                var cx = new mxPoint(state.getCenterX(), state.getCenterY());
                var pt = mxUtils.getRotatedPoint(new mxPoint(x, y), cos, sin, cx);
                x = pt.x;
                y = pt.y;
              }
              if (mxUtils.contains(state, x, y)) {
                return true;
              }
            }
          }
          return false;
        };
        mxGraph.prototype.hitsSwimlaneContent = function(swimlane, x, y) {
          var state = this.getView().getState(swimlane);
          var size = this.getStartSize(swimlane);
          if (state != null) {
            var scale = this.getView().getScale();
            x -= state.x;
            y -= state.y;
            if (size.width > 0 && x > 0 && x > size.width * scale) {
              return true;
            } else if (size.height > 0 && y > 0 && y > size.height * scale) {
              return true;
            }
          }
          return false;
        };
        mxGraph.prototype.getChildVertices = function(parent) {
          return this.getChildCells(parent, true, false);
        };
        mxGraph.prototype.getChildEdges = function(parent) {
          return this.getChildCells(parent, false, true);
        };
        mxGraph.prototype.getChildCells = function(parent, vertices, edges) {
          parent = parent != null ? parent : this.getDefaultParent();
          vertices = vertices != null ? vertices : false;
          edges = edges != null ? edges : false;
          var cells = this.model.getChildCells(parent, vertices, edges);
          var result2 = [];
          for (var i = 0; i < cells.length; i++) {
            if (this.isCellVisible(cells[i])) {
              result2.push(cells[i]);
            }
          }
          return result2;
        };
        mxGraph.prototype.getConnections = function(cell2, parent) {
          return this.getEdges(cell2, parent, true, true, false);
        };
        mxGraph.prototype.getIncomingEdges = function(cell2, parent) {
          return this.getEdges(cell2, parent, true, false, false);
        };
        mxGraph.prototype.getOutgoingEdges = function(cell2, parent) {
          return this.getEdges(cell2, parent, false, true, false);
        };
        mxGraph.prototype.getEdges = function(cell2, parent, incoming, outgoing, includeLoops, recurse) {
          incoming = incoming != null ? incoming : true;
          outgoing = outgoing != null ? outgoing : true;
          includeLoops = includeLoops != null ? includeLoops : true;
          recurse = recurse != null ? recurse : false;
          var edges = [];
          var isCollapsed = this.isCellCollapsed(cell2);
          var childCount = this.model.getChildCount(cell2);
          for (var i = 0; i < childCount; i++) {
            var child = this.model.getChildAt(cell2, i);
            if (isCollapsed || !this.isCellVisible(child)) {
              edges = edges.concat(this.model.getEdges(child, incoming, outgoing));
            }
          }
          edges = edges.concat(this.model.getEdges(cell2, incoming, outgoing));
          var result2 = [];
          for (var i = 0; i < edges.length; i++) {
            var state = this.view.getState(edges[i]);
            var source = state != null ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);
            var target = state != null ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);
            if (includeLoops && source == target || source != target && (incoming && target == cell2 && (parent == null || this.isValidAncestor(source, parent, recurse)) || outgoing && source == cell2 && (parent == null || this.isValidAncestor(target, parent, recurse)))) {
              result2.push(edges[i]);
            }
          }
          return result2;
        };
        mxGraph.prototype.isValidAncestor = function(cell2, parent, recurse) {
          return recurse ? this.model.isAncestor(parent, cell2) : this.model.getParent(cell2) == parent;
        };
        mxGraph.prototype.getOpposites = function(edges, terminal, sources, targets) {
          sources = sources != null ? sources : true;
          targets = targets != null ? targets : true;
          var terminals = [];
          var dict = new mxDictionary();
          if (edges != null) {
            for (var i = 0; i < edges.length; i++) {
              var state = this.view.getState(edges[i]);
              var source = state != null ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);
              var target = state != null ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);
              if (source == terminal && target != null && target != terminal && targets) {
                if (!dict.get(target)) {
                  dict.put(target, true);
                  terminals.push(target);
                }
              } else if (target == terminal && source != null && source != terminal && sources) {
                if (!dict.get(source)) {
                  dict.put(source, true);
                  terminals.push(source);
                }
              }
            }
          }
          return terminals;
        };
        mxGraph.prototype.getEdgesBetween = function(source, target, directed) {
          directed = directed != null ? directed : false;
          var edges = this.getEdges(source);
          var result2 = [];
          for (var i = 0; i < edges.length; i++) {
            var state = this.view.getState(edges[i]);
            var src = state != null ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);
            var trg = state != null ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);
            if (src == source && trg == target || !directed && src == target && trg == source) {
              result2.push(edges[i]);
            }
          }
          return result2;
        };
        mxGraph.prototype.getPointForEvent = function(evt, addOffset) {
          var p = mxUtils.convertPoint(
            this.container,
            mxEvent.getClientX(evt),
            mxEvent.getClientY(evt)
          );
          var s = this.view.scale;
          var tr = this.view.translate;
          var off = addOffset != false ? this.gridSize / 2 : 0;
          p.x = this.snap(p.x / s - tr.x - off);
          p.y = this.snap(p.y / s - tr.y - off);
          return p;
        };
        mxGraph.prototype.getCells = function(x, y, width, height, parent, result2, intersection, ignoreFn, includeDescendants) {
          result2 = result2 != null ? result2 : [];
          if (width > 0 || height > 0 || intersection != null) {
            var model = this.getModel();
            var right = x + width;
            var bottom = y + height;
            if (parent == null) {
              parent = this.getCurrentRoot();
              if (parent == null) {
                parent = model.getRoot();
              }
            }
            if (parent != null) {
              var childCount = model.getChildCount(parent);
              for (var i = 0; i < childCount; i++) {
                var cell2 = model.getChildAt(parent, i);
                var state = this.view.getState(cell2);
                if (state != null && this.isCellVisible(cell2) && (ignoreFn == null || !ignoreFn(state))) {
                  var deg = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0;
                  var box = state;
                  if (deg != 0) {
                    box = mxUtils.getBoundingBox(box, deg);
                  }
                  var hit = intersection != null && model.isVertex(cell2) && mxUtils.intersects(intersection, box) || intersection == null && (model.isEdge(cell2) || model.isVertex(cell2)) && box.x >= x && box.y + box.height <= bottom && box.y >= y && box.x + box.width <= right;
                  if (hit) {
                    result2.push(cell2);
                  }
                  if (!hit || includeDescendants) {
                    this.getCells(x, y, width, height, cell2, result2, intersection, ignoreFn, includeDescendants);
                  }
                }
              }
            }
          }
          return result2;
        };
        mxGraph.prototype.getCellsBeyond = function(x0, y0, parent, rightHalfpane, bottomHalfpane) {
          var result2 = [];
          if (rightHalfpane || bottomHalfpane) {
            if (parent == null) {
              parent = this.getDefaultParent();
            }
            if (parent != null) {
              var childCount = this.model.getChildCount(parent);
              for (var i = 0; i < childCount; i++) {
                var child = this.model.getChildAt(parent, i);
                var state = this.view.getState(child);
                if (this.isCellVisible(child) && state != null) {
                  if ((!rightHalfpane || state.x >= x0) && (!bottomHalfpane || state.y >= y0)) {
                    result2.push(child);
                  }
                }
              }
            }
          }
          return result2;
        };
        mxGraph.prototype.findTreeRoots = function(parent, isolate, invert) {
          isolate = isolate != null ? isolate : false;
          invert = invert != null ? invert : false;
          var roots = [];
          if (parent != null) {
            var model = this.getModel();
            var childCount = model.getChildCount(parent);
            var best = null;
            var maxDiff = 0;
            for (var i = 0; i < childCount; i++) {
              var cell2 = model.getChildAt(parent, i);
              if (this.model.isVertex(cell2) && this.isCellVisible(cell2)) {
                var conns = this.getConnections(cell2, isolate ? parent : null);
                var fanOut = 0;
                var fanIn = 0;
                for (var j = 0; j < conns.length; j++) {
                  var src = this.view.getVisibleTerminal(conns[j], true);
                  if (src == cell2) {
                    fanOut++;
                  } else {
                    fanIn++;
                  }
                }
                if (invert && fanOut == 0 && fanIn > 0 || !invert && fanIn == 0 && fanOut > 0) {
                  roots.push(cell2);
                }
                var diff = invert ? fanIn - fanOut : fanOut - fanIn;
                if (diff > maxDiff) {
                  maxDiff = diff;
                  best = cell2;
                }
              }
            }
            if (roots.length == 0 && best != null) {
              roots.push(best);
            }
          }
          return roots;
        };
        mxGraph.prototype.traverse = function(vertex, directed, func, edge, visited, inverse) {
          if (func != null && vertex != null) {
            directed = directed != null ? directed : true;
            inverse = inverse != null ? inverse : false;
            visited = visited || new mxDictionary();
            if (!visited.get(vertex)) {
              visited.put(vertex, true);
              var result2 = func(vertex, edge);
              if (result2 == null || result2) {
                var edgeCount = this.model.getEdgeCount(vertex);
                if (edgeCount > 0) {
                  for (var i = 0; i < edgeCount; i++) {
                    var e = this.model.getEdgeAt(vertex, i);
                    var isSource = this.model.getTerminal(e, true) == vertex;
                    if (!directed || !inverse == isSource) {
                      var next = this.model.getTerminal(e, !isSource);
                      this.traverse(next, directed, func, e, visited, inverse);
                    }
                  }
                }
              }
            }
          }
        };
        mxGraph.prototype.isCellSelected = function(cell2) {
          return this.getSelectionModel().isSelected(cell2);
        };
        mxGraph.prototype.isSelectionEmpty = function() {
          return this.getSelectionModel().isEmpty();
        };
        mxGraph.prototype.clearSelection = function() {
          return this.getSelectionModel().clear();
        };
        mxGraph.prototype.getSelectionCount = function() {
          return this.getSelectionModel().cells.length;
        };
        mxGraph.prototype.getSelectionCell = function() {
          return this.getSelectionModel().cells[0];
        };
        mxGraph.prototype.getSelectionCells = function() {
          return this.getSelectionModel().cells.slice();
        };
        mxGraph.prototype.setSelectionCell = function(cell2) {
          this.getSelectionModel().setCell(cell2);
        };
        mxGraph.prototype.setSelectionCells = function(cells) {
          this.getSelectionModel().setCells(cells);
        };
        mxGraph.prototype.addSelectionCell = function(cell2) {
          this.getSelectionModel().addCell(cell2);
        };
        mxGraph.prototype.addSelectionCells = function(cells) {
          this.getSelectionModel().addCells(cells);
        };
        mxGraph.prototype.removeSelectionCell = function(cell2) {
          this.getSelectionModel().removeCell(cell2);
        };
        mxGraph.prototype.removeSelectionCells = function(cells) {
          this.getSelectionModel().removeCells(cells);
        };
        mxGraph.prototype.selectRegion = function(rect, evt) {
          var cells = this.getCells(rect.x, rect.y, rect.width, rect.height);
          this.selectCellsForEvent(cells, evt);
          return cells;
        };
        mxGraph.prototype.selectNextCell = function() {
          this.selectCell(true);
        };
        mxGraph.prototype.selectPreviousCell = function() {
          this.selectCell();
        };
        mxGraph.prototype.selectParentCell = function() {
          this.selectCell(false, true);
        };
        mxGraph.prototype.selectChildCell = function() {
          this.selectCell(false, false, true);
        };
        mxGraph.prototype.selectCell = function(isNext, isParent, isChild) {
          var sel = this.selectionModel;
          var cell2 = sel.cells.length > 0 ? sel.cells[0] : null;
          if (sel.cells.length > 1) {
            sel.clear();
          }
          var parent = cell2 != null ? this.model.getParent(cell2) : this.getDefaultParent();
          var childCount = this.model.getChildCount(parent);
          if (cell2 == null && childCount > 0) {
            var child = this.model.getChildAt(parent, 0);
            this.setSelectionCell(child);
          } else if ((cell2 == null || isParent) && this.view.getState(parent) != null && this.model.getGeometry(parent) != null) {
            if (this.getCurrentRoot() != parent) {
              this.setSelectionCell(parent);
            }
          } else if (cell2 != null && isChild) {
            var tmp = this.model.getChildCount(cell2);
            if (tmp > 0) {
              var child = this.model.getChildAt(cell2, 0);
              this.setSelectionCell(child);
            }
          } else if (childCount > 0) {
            var i = parent.getIndex(cell2);
            if (isNext) {
              i++;
              var child = this.model.getChildAt(parent, i % childCount);
              this.setSelectionCell(child);
            } else {
              i--;
              var index = i < 0 ? childCount - 1 : i;
              var child = this.model.getChildAt(parent, index);
              this.setSelectionCell(child);
            }
          }
        };
        mxGraph.prototype.selectAll = function(parent, descendants) {
          parent = parent || this.getDefaultParent();
          var cells = descendants ? this.model.filterDescendants(mxUtils.bind(this, function(cell2) {
            return cell2 != parent && this.view.getState(cell2) != null;
          }), parent) : this.model.getChildren(parent);
          if (cells != null) {
            this.setSelectionCells(cells);
          }
        };
        mxGraph.prototype.selectVertices = function(parent, selectGroups) {
          this.selectCells(true, false, parent, selectGroups);
        };
        mxGraph.prototype.selectEdges = function(parent) {
          this.selectCells(false, true, parent);
        };
        mxGraph.prototype.selectCells = function(vertices, edges, parent, selectGroups) {
          parent = parent || this.getDefaultParent();
          var filter = mxUtils.bind(this, function(cell2) {
            return this.view.getState(cell2) != null && ((selectGroups || this.model.getChildCount(cell2) == 0) && this.model.isVertex(cell2) && vertices && !this.model.isEdge(this.model.getParent(cell2)) || this.model.isEdge(cell2) && edges);
          });
          var cells = this.model.filterDescendants(filter, parent);
          if (cells != null) {
            this.setSelectionCells(cells);
          }
        };
        mxGraph.prototype.selectCellForEvent = function(cell2, evt) {
          var isSelected = this.isCellSelected(cell2);
          if (this.isToggleEvent(evt)) {
            if (isSelected) {
              this.removeSelectionCell(cell2);
            } else {
              this.addSelectionCell(cell2);
            }
          } else if (!isSelected || this.getSelectionCount() != 1) {
            this.setSelectionCell(cell2);
          }
        };
        mxGraph.prototype.selectCellsForEvent = function(cells, evt) {
          if (this.isToggleEvent(evt)) {
            this.addSelectionCells(cells);
          } else {
            this.setSelectionCells(cells);
          }
        };
        mxGraph.prototype.createHandler = function(state) {
          var result2 = null;
          if (state != null) {
            if (this.model.isEdge(state.cell)) {
              var source = state.getVisibleTerminalState(true);
              var target = state.getVisibleTerminalState(false);
              var geo = this.getCellGeometry(state.cell);
              var edgeStyle = this.view.getEdgeStyle(state, geo != null ? geo.points : null, source, target);
              result2 = this.createEdgeHandler(state, edgeStyle);
            } else {
              result2 = this.createVertexHandler(state);
            }
          }
          return result2;
        };
        mxGraph.prototype.createVertexHandler = function(state) {
          return new mxVertexHandler(state);
        };
        mxGraph.prototype.createEdgeHandler = function(state, edgeStyle) {
          var result2 = null;
          if (edgeStyle == mxEdgeStyle.Loop || edgeStyle == mxEdgeStyle.ElbowConnector || edgeStyle == mxEdgeStyle.SideToSide || edgeStyle == mxEdgeStyle.TopToBottom) {
            result2 = this.createElbowEdgeHandler(state);
          } else if (edgeStyle == mxEdgeStyle.SegmentConnector || edgeStyle == mxEdgeStyle.OrthConnector) {
            result2 = this.createEdgeSegmentHandler(state);
          } else {
            result2 = new mxEdgeHandler(state);
          }
          return result2;
        };
        mxGraph.prototype.createEdgeSegmentHandler = function(state) {
          return new mxEdgeSegmentHandler(state);
        };
        mxGraph.prototype.createElbowEdgeHandler = function(state) {
          return new mxElbowEdgeHandler(state);
        };
        mxGraph.prototype.addMouseListener = function(listener) {
          if (this.mouseListeners == null) {
            this.mouseListeners = [];
          }
          this.mouseListeners.push(listener);
        };
        mxGraph.prototype.removeMouseListener = function(listener) {
          if (this.mouseListeners != null) {
            for (var i = 0; i < this.mouseListeners.length; i++) {
              if (this.mouseListeners[i] == listener) {
                this.mouseListeners.splice(i, 1);
                break;
              }
            }
          }
        };
        mxGraph.prototype.updateMouseEvent = function(me, evtName) {
          if (me.graphX == null || me.graphY == null) {
            var pt = mxUtils.convertPoint(this.container, me.getX(), me.getY());
            me.graphX = pt.x - this.panDx;
            me.graphY = pt.y - this.panDy;
            if (me.getCell() == null && this.isMouseDown && evtName == mxEvent.MOUSE_MOVE) {
              me.state = this.view.getState(this.getCellAt(pt.x, pt.y, null, null, null, function(state) {
                return state.shape == null || state.shape.paintBackground != mxRectangleShape.prototype.paintBackground || mxUtils.getValue(state.style, mxConstants.STYLE_POINTER_EVENTS, "1") == "1" || state.shape.fill != null && state.shape.fill != mxConstants.NONE;
              }));
            }
          }
          return me;
        };
        mxGraph.prototype.getStateForTouchEvent = function(evt) {
          var x = mxEvent.getClientX(evt);
          var y = mxEvent.getClientY(evt);
          var pt = mxUtils.convertPoint(this.container, x, y);
          return this.view.getState(this.getCellAt(pt.x, pt.y));
        };
        mxGraph.prototype.isEventIgnored = function(evtName, me, sender) {
          var mouseEvent = mxEvent.isMouseEvent(me.getEvent());
          var result2 = false;
          if (me.getEvent() == this.lastEvent) {
            result2 = true;
          } else {
            this.lastEvent = me.getEvent();
          }
          if (this.eventSource != null && evtName != mxEvent.MOUSE_MOVE) {
            mxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
            this.mouseMoveRedirect = null;
            this.mouseUpRedirect = null;
            this.eventSource = null;
          } else if (!mxClient.IS_GC && this.eventSource != null && me.getSource() != this.eventSource) {
            result2 = true;
          } else if (mxClient.IS_TOUCH && evtName == mxEvent.MOUSE_DOWN && !mouseEvent && !mxEvent.isPenEvent(me.getEvent())) {
            this.eventSource = me.getSource();
            this.mouseMoveRedirect = mxUtils.bind(this, function(evt) {
              this.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, this.getStateForTouchEvent(evt)));
            });
            this.mouseUpRedirect = mxUtils.bind(this, function(evt) {
              this.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, this.getStateForTouchEvent(evt)));
            });
            mxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
          }
          if (this.isSyntheticEventIgnored(evtName, me, sender)) {
            result2 = true;
          }
          if (!mxEvent.isPopupTrigger(this.lastEvent) && evtName != mxEvent.MOUSE_MOVE && this.lastEvent.detail == 2) {
            return true;
          }
          if (evtName == mxEvent.MOUSE_UP && this.isMouseDown) {
            this.isMouseDown = false;
          } else if (evtName == mxEvent.MOUSE_DOWN && !this.isMouseDown) {
            this.isMouseDown = true;
            this.isMouseTrigger = mouseEvent;
          } else if (!result2 && ((!mxClient.IS_FF || evtName != mxEvent.MOUSE_MOVE) && this.isMouseDown && this.isMouseTrigger != mouseEvent || evtName == mxEvent.MOUSE_DOWN && this.isMouseDown || evtName == mxEvent.MOUSE_UP && !this.isMouseDown)) {
            result2 = true;
          }
          if (!result2 && evtName == mxEvent.MOUSE_DOWN) {
            this.lastMouseX = me.getX();
            this.lastMouseY = me.getY();
          }
          return result2;
        };
        mxGraph.prototype.isSyntheticEventIgnored = function(evtName, me, sender) {
          var result2 = false;
          var mouseEvent = mxEvent.isMouseEvent(me.getEvent());
          if (this.ignoreMouseEvents && mouseEvent && evtName != mxEvent.MOUSE_MOVE) {
            this.ignoreMouseEvents = evtName != mxEvent.MOUSE_UP;
            result2 = true;
          } else if (mxClient.IS_FF && !mouseEvent && evtName == mxEvent.MOUSE_UP) {
            this.ignoreMouseEvents = true;
          }
          return result2;
        };
        mxGraph.prototype.isEventSourceIgnored = function(evtName, me) {
          var source = me.getSource();
          var name2 = source.nodeName != null ? source.nodeName.toLowerCase() : "";
          var candidate = !mxEvent.isMouseEvent(me.getEvent()) || mxEvent.isLeftMouseButton(me.getEvent());
          return evtName == mxEvent.MOUSE_DOWN && candidate && (name2 == "select" || name2 == "option" || name2 == "input" && source.type != "checkbox" && source.type != "radio" && source.type != "button" && source.type != "submit" && source.type != "file");
        };
        mxGraph.prototype.getEventState = function(state) {
          return state;
        };
        mxGraph.prototype.fireMouseEvent = function(evtName, me, sender) {
          if (this.isEventSourceIgnored(evtName, me)) {
            if (this.tooltipHandler != null) {
              this.tooltipHandler.hide();
            }
            return;
          }
          if (sender == null) {
            sender = this;
          }
          me = this.updateMouseEvent(me, evtName);
          if (!this.nativeDblClickEnabled && !mxEvent.isPopupTrigger(me.getEvent()) || this.doubleTapEnabled && mxClient.IS_TOUCH && (mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent()))) {
            var currentTime = (/* @__PURE__ */ new Date()).getTime();
            if (!mxClient.IS_QUIRKS && evtName == mxEvent.MOUSE_DOWN || mxClient.IS_QUIRKS && evtName == mxEvent.MOUSE_UP && !this.fireDoubleClick) {
              if (this.lastTouchEvent != null && this.lastTouchEvent != me.getEvent() && currentTime - this.lastTouchTime < this.doubleTapTimeout && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance && this.doubleClickCounter < 2) {
                this.doubleClickCounter++;
                var doubleClickFired = false;
                if (evtName == mxEvent.MOUSE_UP) {
                  if (me.getCell() == this.lastTouchCell && this.lastTouchCell != null) {
                    this.lastTouchTime = 0;
                    var cell2 = this.lastTouchCell;
                    this.lastTouchCell = null;
                    if (mxClient.IS_QUIRKS) {
                      me.getSource().fireEvent("ondblclick");
                    }
                    this.dblClick(me.getEvent(), cell2);
                    doubleClickFired = true;
                  }
                } else {
                  this.fireDoubleClick = true;
                  this.lastTouchTime = 0;
                }
                if (!mxClient.IS_QUIRKS || doubleClickFired) {
                  mxEvent.consume(me.getEvent());
                  return;
                }
              } else if (this.lastTouchEvent == null || this.lastTouchEvent != me.getEvent()) {
                this.lastTouchCell = me.getCell();
                this.lastTouchX = me.getX();
                this.lastTouchY = me.getY();
                this.lastTouchTime = currentTime;
                this.lastTouchEvent = me.getEvent();
                this.doubleClickCounter = 0;
              }
            } else if ((this.isMouseDown || evtName == mxEvent.MOUSE_UP) && this.fireDoubleClick) {
              this.fireDoubleClick = false;
              var cell2 = this.lastTouchCell;
              this.lastTouchCell = null;
              this.isMouseDown = false;
              var valid = cell2 != null || (mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) && (mxClient.IS_GC || mxClient.IS_SF);
              if (valid && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance) {
                this.dblClick(me.getEvent(), cell2);
              } else {
                mxEvent.consume(me.getEvent());
              }
              return;
            }
          }
          if (!this.isEventIgnored(evtName, me, sender)) {
            me.state = this.getEventState(me.getState());
            this.fireEvent(new mxEventObject(mxEvent.FIRE_MOUSE_EVENT, "eventName", evtName, "event", me));
            if (mxClient.IS_OP || mxClient.IS_SF || mxClient.IS_GC || mxClient.IS_IE11 || mxClient.IS_IE && mxClient.IS_SVG || me.getEvent().target != this.container) {
              if (evtName == mxEvent.MOUSE_MOVE && this.isMouseDown && this.autoScroll && !mxEvent.isMultiTouchEvent(me.getEvent)) {
                this.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.autoExtend);
              } else if (evtName == mxEvent.MOUSE_UP && this.ignoreScrollbars && this.translateToScrollPosition && (this.container.scrollLeft != 0 || this.container.scrollTop != 0)) {
                var s = this.view.scale;
                var tr = this.view.translate;
                this.view.setTranslate(tr.x - this.container.scrollLeft / s, tr.y - this.container.scrollTop / s);
                this.container.scrollLeft = 0;
                this.container.scrollTop = 0;
              }
              if (this.mouseListeners != null) {
                var args = [sender, me];
                if (!me.getEvent().preventDefault) {
                  me.getEvent().returnValue = true;
                }
                for (var i = 0; i < this.mouseListeners.length; i++) {
                  var l = this.mouseListeners[i];
                  if (evtName == mxEvent.MOUSE_DOWN) {
                    l.mouseDown.apply(l, args);
                  } else if (evtName == mxEvent.MOUSE_MOVE) {
                    l.mouseMove.apply(l, args);
                  } else if (evtName == mxEvent.MOUSE_UP) {
                    l.mouseUp.apply(l, args);
                  }
                }
              }
              if (evtName == mxEvent.MOUSE_UP) {
                this.click(me);
              }
            }
            if ((mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) && evtName == mxEvent.MOUSE_DOWN && this.tapAndHoldEnabled && !this.tapAndHoldInProgress) {
              this.tapAndHoldInProgress = true;
              this.initialTouchX = me.getGraphX();
              this.initialTouchY = me.getGraphY();
              var handler = function() {
                if (this.tapAndHoldValid) {
                  this.tapAndHold(me);
                }
                this.tapAndHoldInProgress = false;
                this.tapAndHoldValid = false;
              };
              if (this.tapAndHoldThread) {
                window.clearTimeout(this.tapAndHoldThread);
              }
              this.tapAndHoldThread = window.setTimeout(mxUtils.bind(this, handler), this.tapAndHoldDelay);
              this.tapAndHoldValid = true;
            } else if (evtName == mxEvent.MOUSE_UP) {
              this.tapAndHoldInProgress = false;
              this.tapAndHoldValid = false;
            } else if (this.tapAndHoldValid) {
              this.tapAndHoldValid = Math.abs(this.initialTouchX - me.getGraphX()) < this.tolerance && Math.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;
            }
            if (evtName == mxEvent.MOUSE_DOWN && this.isEditing() && !this.cellEditor.isEventSource(me.getEvent())) {
              this.stopEditing(!this.isInvokesStopCellEditing());
            }
            this.consumeMouseEvent(evtName, me, sender);
          }
        };
        mxGraph.prototype.consumeMouseEvent = function(evtName, me, sender) {
          if (evtName == mxEvent.MOUSE_DOWN && mxEvent.isTouchEvent(me.getEvent())) {
            me.consume(false);
          }
        };
        mxGraph.prototype.fireGestureEvent = function(evt, cell2) {
          this.lastTouchTime = 0;
          this.fireEvent(new mxEventObject(mxEvent.GESTURE, "event", evt, "cell", cell2));
        };
        mxGraph.prototype.destroy = function() {
          if (!this.destroyed) {
            this.destroyed = true;
            if (this.tooltipHandler != null) {
              this.tooltipHandler.destroy();
            }
            if (this.selectionCellsHandler != null) {
              this.selectionCellsHandler.destroy();
            }
            if (this.panningHandler != null) {
              this.panningHandler.destroy();
            }
            if (this.popupMenuHandler != null) {
              this.popupMenuHandler.destroy();
            }
            if (this.connectionHandler != null) {
              this.connectionHandler.destroy();
            }
            if (this.graphHandler != null) {
              this.graphHandler.destroy();
            }
            if (this.cellEditor != null) {
              this.cellEditor.destroy();
            }
            if (this.view != null) {
              this.view.destroy();
            }
            if (this.model != null && this.graphModelChangeListener != null) {
              this.model.removeListener(this.graphModelChangeListener);
              this.graphModelChangeListener = null;
            }
            this.container = null;
          }
        };
        __mxOutput.mxGraph = typeof mxGraph !== "undefined" ? mxGraph : void 0;
        function azdataGraph(container, model, renderHint, styleSheet) {
          mxGraph.call(this, container, model, renderHint, styleSheet);
        }
        azdataGraph.prototype = Object.create(mxGraph.prototype);
        azdataGraph.prototype.constructor = azdataGraph;
        azdataGraph.prototype.insertInvertedEdge = function(parent, id, value, source, target, style) {
          var terminalStyle = "startArrow=classic;endArrow=none;";
          var edge = this.createEdge(parent, id, value, source, target, terminalStyle + style);
          return this.addEdge(edge, parent, source, target);
        };
        azdataGraph.prototype.insertWeightedInvertedEdge = function(parent, id, value, source, target, style) {
          return this.insertInvertedEdge(parent, id, value, source, target, `strokeWidth=${value.weight.toFixed(1)};` + style);
        };
        azdataGraph.prototype.getStyledTooltipForCell = function(cell2) {
          const tooltipWidth = "width: 45em;";
          const justifyContent = "display: flex; justify-content: space-between;";
          const boldText = "font-weight: bold;";
          const tooltipLineHeight = "padding-top: .13em; line-height: .5em;";
          const centerText = "text-align: center;";
          const headerBottomMargin = "margin-bottom: 1.5em;";
          const headerTopMargin = "margin-top: 1.5em;";
          const footerTopMargin = "margin-top: 1.5em;";
          const metricLabelMargin = "margin-right: 4em;";
          if (cell2?.value != null && cell2?.value?.metrics != null) {
            var tooltip = `<div style="${tooltipWidth}">`;
            if (!cell2.edge) {
              let tooltipTitle = this.truncateTooltipTitle(cell2.value.tooltipTitle);
              tooltip += `<div style="${centerText}"><span style="${boldText}">${tooltipTitle}</span></div>`;
              if (cell2.value.description) {
                tooltip += `<div style="${headerBottomMargin} ${headerTopMargin}"><span>${cell2.value.description}</span></div>`;
              }
            }
            let startIndex = cell2.edge ? 0 : 1;
            for (var i = startIndex; i < cell2.value.metrics.length; ++i) {
              if (cell2.value.metrics[i].isLongString) {
                continue;
              }
              tooltip += `<div style="${tooltipLineHeight}">`;
              tooltip += `<div style="${justifyContent}">`;
              tooltip += `<span style="${boldText} ${metricLabelMargin}">${cell2.value.metrics[i].name}</span>`;
              tooltip += `<span>${cell2.value.metrics[i].value}</span>`;
              tooltip += "</div>";
              if (i < cell2.value.metrics.length - 1) {
                tooltip += `<hr />`;
              }
              tooltip += `</div>`;
            }
            if (!cell2.edge) {
              cell2.value.metrics.filter((m) => m.isLongString).forEach((m) => {
                tooltip += "<hr />";
                tooltip += `<div style="${footerTopMargin}"><span style="${boldText}">${m.name}</span></div>`;
                let metricLabel = m.value.replace(/(\r\n|\n|\r)/gm, " ");
                if (metricLabel.length > 103) {
                  metricLabel = metricLabel.substring(0, 100) + "...";
                }
                tooltip += `<div><span>${metricLabel}</span></div>`;
              });
            }
            tooltip += "</div>";
            return tooltip;
          }
          return azdataGraph.prototype.getTooltipForCell.apply(this, arguments);
        };
        azdataGraph.prototype.truncateTooltipTitle = function(title) {
          let hasWindowsEOL = title.includes("\r\n");
          let titleSegments = hasWindowsEOL ? title.split("\r\n") : title.split("\n");
          let truncatedTitleSegments = titleSegments.map((segment) => {
            if (segment.length > 50) {
              return segment.substring(0, 50) + "...";
            } else {
              return segment;
            }
          });
          if (hasWindowsEOL) {
            title = truncatedTitleSegments.join("\r\n");
          } else {
            title = truncatedTitleSegments.join("\n");
          }
          return title;
        };
        azdataGraph.prototype.graphEventHandler = function(sender, event, eventCallback) {
          let selectedCell = event.getProperty("cell");
          if (eventCallback && selectedCell) {
            eventCallback(selectedCell);
          }
          event.consume();
        };
        azdataGraph.prototype.addDomEventListener = function(element, eventType, eventCallback) {
          mxEvent.addListener(element, eventType, (e) => {
            if (eventCallback) {
              eventCallback();
            }
            mxEvent.consume(e);
          });
        };
        __mxOutput.azDataGraph = typeof azDataGraph !== "undefined" ? azDataGraph : void 0;
        function mxCellOverlay(image, tooltip, align, verticalAlign, offset, cursor) {
          this.image = image;
          this.tooltip = tooltip;
          this.align = align != null ? align : this.align;
          this.verticalAlign = verticalAlign != null ? verticalAlign : this.verticalAlign;
          this.offset = offset != null ? offset : new mxPoint();
          this.cursor = cursor != null ? cursor : "help";
        }
        ;
        mxCellOverlay.prototype = new mxEventSource();
        mxCellOverlay.prototype.constructor = mxCellOverlay;
        mxCellOverlay.prototype.image = null;
        mxCellOverlay.prototype.tooltip = null;
        mxCellOverlay.prototype.align = mxConstants.ALIGN_RIGHT;
        mxCellOverlay.prototype.verticalAlign = mxConstants.ALIGN_BOTTOM;
        mxCellOverlay.prototype.offset = null;
        mxCellOverlay.prototype.cursor = null;
        mxCellOverlay.prototype.defaultOverlap = 0.5;
        mxCellOverlay.prototype.getBounds = function(state) {
          var isEdge = state.view.graph.getModel().isEdge(state.cell);
          var s = state.view.scale;
          var pt = null;
          var w2 = this.image.width;
          var h2 = this.image.height;
          if (isEdge) {
            var pts = state.absolutePoints;
            if (pts.length % 2 == 1) {
              pt = pts[Math.floor(pts.length / 2)];
            } else {
              var idx = pts.length / 2;
              var p0 = pts[idx - 1];
              var p1 = pts[idx];
              pt = new mxPoint(
                p0.x + (p1.x - p0.x) / 2,
                p0.y + (p1.y - p0.y) / 2
              );
            }
          } else {
            pt = new mxPoint();
            if (this.align == mxConstants.ALIGN_LEFT) {
              pt.x = state.x;
            } else if (this.align == mxConstants.ALIGN_CENTER) {
              pt.x = state.x + state.width / 2;
            } else {
              pt.x = state.x + state.width;
            }
            if (this.verticalAlign == mxConstants.ALIGN_TOP) {
              pt.y = state.y;
            } else if (this.verticalAlign == mxConstants.ALIGN_MIDDLE) {
              pt.y = state.y + state.height / 2;
            } else {
              pt.y = state.y + state.height;
            }
          }
          return new mxRectangle(
            Math.round(pt.x - (w2 * this.defaultOverlap - this.offset.x) * s),
            Math.round(pt.y - (h2 * this.defaultOverlap - this.offset.y) * s),
            w2 * s,
            h2 * s
          );
        };
        mxCellOverlay.prototype.toString = function() {
          return this.tooltip;
        };
        __mxOutput.mxCellOverlay = typeof mxCellOverlay !== "undefined" ? mxCellOverlay : void 0;
        function mxOutline(source, container) {
          this.source = source;
          if (container != null) {
            this.init(container);
          }
        }
        ;
        mxOutline.prototype.source = null;
        mxOutline.prototype.outline = null;
        mxOutline.prototype.graphRenderHint = mxConstants.RENDERING_HINT_FASTER;
        mxOutline.prototype.enabled = true;
        mxOutline.prototype.showViewport = true;
        mxOutline.prototype.border = 10;
        mxOutline.prototype.sizerSize = 8;
        mxOutline.prototype.labelsVisible = false;
        mxOutline.prototype.updateOnPan = false;
        mxOutline.prototype.sizerImage = null;
        mxOutline.prototype.minScale = 1e-4;
        mxOutline.prototype.suspended = false;
        mxOutline.prototype.forceVmlHandles = document.documentMode == 8;
        mxOutline.prototype.createGraph = function(container) {
          var graph = new mxGraph(container, this.source.getModel(), this.graphRenderHint, this.source.getStylesheet());
          graph.foldingEnabled = false;
          graph.autoScroll = false;
          return graph;
        };
        mxOutline.prototype.init = function(container) {
          this.outline = this.createGraph(container);
          var outlineGraphModelChanged = this.outline.graphModelChanged;
          this.outline.graphModelChanged = mxUtils.bind(this, function(changes) {
            if (!this.suspended && this.outline != null) {
              outlineGraphModelChanged.apply(this.outline, arguments);
            }
          });
          if (mxClient.IS_SVG) {
            var node = this.outline.getView().getCanvas().parentNode;
            node.setAttribute("shape-rendering", "optimizeSpeed");
            node.setAttribute("image-rendering", "optimizeSpeed");
          }
          this.outline.labelsVisible = this.labelsVisible;
          this.outline.setEnabled(false);
          this.updateHandler = mxUtils.bind(this, function(sender, evt) {
            if (!this.suspended && !this.active) {
              this.update();
            }
          });
          this.source.getModel().addListener(mxEvent.CHANGE, this.updateHandler);
          this.outline.addMouseListener(this);
          var view = this.source.getView();
          view.addListener(mxEvent.SCALE, this.updateHandler);
          view.addListener(mxEvent.TRANSLATE, this.updateHandler);
          view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.updateHandler);
          view.addListener(mxEvent.DOWN, this.updateHandler);
          view.addListener(mxEvent.UP, this.updateHandler);
          mxEvent.addListener(this.source.container, "scroll", this.updateHandler);
          this.panHandler = mxUtils.bind(this, function(sender) {
            if (this.updateOnPan) {
              this.updateHandler.apply(this, arguments);
            }
          });
          this.source.addListener(mxEvent.PAN, this.panHandler);
          this.refreshHandler = mxUtils.bind(this, function(sender) {
            this.outline.setStylesheet(this.source.getStylesheet());
            this.outline.refresh();
          });
          this.source.addListener(mxEvent.REFRESH, this.refreshHandler);
          this.bounds = new mxRectangle(0, 0, 0, 0);
          this.selectionBorder = new mxRectangleShape(
            this.bounds,
            null,
            mxConstants.OUTLINE_COLOR,
            mxConstants.OUTLINE_STROKEWIDTH
          );
          this.selectionBorder.dialect = this.outline.dialect;
          if (this.forceVmlHandles) {
            this.selectionBorder.isHtmlAllowed = function() {
              return false;
            };
          }
          this.selectionBorder.init(this.outline.getView().getOverlayPane());
          var handler = mxUtils.bind(this, function(evt) {
            var t = mxEvent.getSource(evt);
            var redirect = mxUtils.bind(this, function(evt2) {
              this.outline.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt2));
            });
            var redirect2 = mxUtils.bind(this, function(evt2) {
              mxEvent.removeGestureListeners(t, null, redirect, redirect2);
              this.outline.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt2));
            });
            mxEvent.addGestureListeners(t, null, redirect, redirect2);
            this.outline.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
          });
          mxEvent.addGestureListeners(this.selectionBorder.node, handler);
          this.sizer = this.createSizer();
          if (this.forceVmlHandles) {
            this.sizer.isHtmlAllowed = function() {
              return false;
            };
          }
          this.sizer.init(this.outline.getView().getOverlayPane());
          if (this.enabled) {
            this.sizer.node.style.cursor = "nwse-resize";
          }
          mxEvent.addGestureListeners(this.sizer.node, handler);
          this.selectionBorder.node.style.display = this.showViewport ? "" : "none";
          this.sizer.node.style.display = this.selectionBorder.node.style.display;
          this.selectionBorder.node.style.cursor = "move";
          this.update(false);
        };
        mxOutline.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxOutline.prototype.setEnabled = function(value) {
          this.enabled = value;
        };
        mxOutline.prototype.setZoomEnabled = function(value) {
          this.sizer.node.style.visibility = value ? "visible" : "hidden";
        };
        mxOutline.prototype.refresh = function() {
          this.update(true);
        };
        mxOutline.prototype.createSizer = function() {
          if (this.sizerImage != null) {
            var sizer = new mxImageShape(new mxRectangle(0, 0, this.sizerImage.width, this.sizerImage.height), this.sizerImage.src);
            sizer.dialect = this.outline.dialect;
            return sizer;
          } else {
            var sizer = new mxRectangleShape(
              new mxRectangle(0, 0, this.sizerSize, this.sizerSize),
              mxConstants.OUTLINE_HANDLE_FILLCOLOR,
              mxConstants.OUTLINE_HANDLE_STROKECOLOR
            );
            sizer.dialect = this.outline.dialect;
            return sizer;
          }
        };
        mxOutline.prototype.getSourceContainerSize = function() {
          return new mxRectangle(0, 0, this.source.container.scrollWidth, this.source.container.scrollHeight);
        };
        mxOutline.prototype.getOutlineOffset = function(scale) {
          return null;
        };
        mxOutline.prototype.getSourceGraphBounds = function() {
          return this.source.getGraphBounds();
        };
        mxOutline.prototype.update = function(revalidate) {
          if (this.source != null && this.source.container != null && this.outline != null && this.outline.container != null) {
            var sourceScale = this.source.view.scale;
            var scaledGraphBounds = this.getSourceGraphBounds();
            var unscaledGraphBounds = new mxRectangle(
              scaledGraphBounds.x / sourceScale + this.source.panDx,
              scaledGraphBounds.y / sourceScale + this.source.panDy,
              scaledGraphBounds.width / sourceScale,
              scaledGraphBounds.height / sourceScale
            );
            var unscaledFinderBounds = new mxRectangle(
              0,
              0,
              this.source.container.clientWidth / sourceScale,
              this.source.container.clientHeight / sourceScale
            );
            var union = unscaledGraphBounds.clone();
            union.add(unscaledFinderBounds);
            var size = this.getSourceContainerSize();
            var completeWidth = Math.max(size.width / sourceScale, union.width);
            var completeHeight = Math.max(size.height / sourceScale, union.height);
            var availableWidth = Math.max(0, this.outline.container.clientWidth - this.border);
            var availableHeight = Math.max(0, this.outline.container.clientHeight - this.border);
            var outlineScale = Math.min(availableWidth / completeWidth, availableHeight / completeHeight);
            var scale = isNaN(outlineScale) ? this.minScale : Math.max(this.minScale, outlineScale);
            if (scale > 0) {
              if (this.outline.getView().scale != scale) {
                this.outline.getView().scale = scale;
                revalidate = true;
              }
              var navView = this.outline.getView();
              if (navView.currentRoot != this.source.getView().currentRoot) {
                navView.setCurrentRoot(this.source.getView().currentRoot);
              }
              var t = this.source.view.translate;
              var tx = t.x + this.source.panDx;
              var ty = t.y + this.source.panDy;
              var off = this.getOutlineOffset(scale);
              if (off != null) {
                tx += off.x;
                ty += off.y;
              }
              if (unscaledGraphBounds.x < 0) {
                tx = tx - unscaledGraphBounds.x;
              }
              if (unscaledGraphBounds.y < 0) {
                ty = ty - unscaledGraphBounds.y;
              }
              if (navView.translate.x != tx || navView.translate.y != ty) {
                navView.translate.x = tx;
                navView.translate.y = ty;
                revalidate = true;
              }
              var t2 = navView.translate;
              scale = this.source.getView().scale;
              var scale2 = scale / navView.scale;
              var scale3 = 1 / navView.scale;
              var container = this.source.container;
              this.bounds = new mxRectangle(
                (t2.x - t.x - this.source.panDx) / scale3,
                (t2.y - t.y - this.source.panDy) / scale3,
                container.clientWidth / scale2,
                container.clientHeight / scale2
              );
              this.bounds.x += this.source.container.scrollLeft * navView.scale / scale;
              this.bounds.y += this.source.container.scrollTop * navView.scale / scale;
              var b = this.selectionBorder.bounds;
              if (b.x != this.bounds.x || b.y != this.bounds.y || b.width != this.bounds.width || b.height != this.bounds.height) {
                this.selectionBorder.bounds = this.bounds;
                this.selectionBorder.redraw();
              }
              var b = this.sizer.bounds;
              var b2 = new mxRectangle(
                this.bounds.x + this.bounds.width - b.width / 2,
                this.bounds.y + this.bounds.height - b.height / 2,
                b.width,
                b.height
              );
              if (b.x != b2.x || b.y != b2.y || b.width != b2.width || b.height != b2.height) {
                this.sizer.bounds = b2;
                if (this.sizer.node.style.visibility != "hidden") {
                  this.sizer.redraw();
                }
              }
              if (revalidate) {
                this.outline.view.revalidate();
              }
            }
          }
        };
        mxOutline.prototype.mouseDown = function(sender, me) {
          if (this.enabled && this.showViewport) {
            var tol = !mxEvent.isMouseEvent(me.getEvent()) ? this.source.tolerance : 0;
            var hit = this.source.allowHandleBoundsCheck && (mxClient.IS_IE || tol > 0) ? new mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
            this.zoom = me.isSource(this.sizer) || hit != null && mxUtils.intersects(shape.bounds, hit);
            this.startX = me.getX();
            this.startY = me.getY();
            this.active = true;
            if (this.source.useScrollbarsForPanning && mxUtils.hasScrollbars(this.source.container)) {
              this.dx0 = this.source.container.scrollLeft;
              this.dy0 = this.source.container.scrollTop;
            } else {
              this.dx0 = 0;
              this.dy0 = 0;
            }
          }
          me.consume();
        };
        mxOutline.prototype.mouseMove = function(sender, me) {
          if (this.active) {
            this.selectionBorder.node.style.display = this.showViewport ? "" : "none";
            this.sizer.node.style.display = this.selectionBorder.node.style.display;
            var delta = this.getTranslateForEvent(me);
            var dx = delta.x;
            var dy = delta.y;
            var bounds = null;
            if (!this.zoom) {
              var scale = this.outline.getView().scale;
              bounds = new mxRectangle(
                this.bounds.x + dx,
                this.bounds.y + dy,
                this.bounds.width,
                this.bounds.height
              );
              this.selectionBorder.bounds = bounds;
              this.selectionBorder.redraw();
              dx /= scale;
              dx *= this.source.getView().scale;
              dy /= scale;
              dy *= this.source.getView().scale;
              this.source.panGraph(-dx - this.dx0, -dy - this.dy0);
            } else {
              var container = this.source.container;
              var viewRatio = container.clientWidth / container.clientHeight;
              dy = dx / viewRatio;
              bounds = new mxRectangle(
                this.bounds.x,
                this.bounds.y,
                Math.max(1, this.bounds.width + dx),
                Math.max(1, this.bounds.height + dy)
              );
              this.selectionBorder.bounds = bounds;
              this.selectionBorder.redraw();
            }
            var b = this.sizer.bounds;
            this.sizer.bounds = new mxRectangle(
              bounds.x + bounds.width - b.width / 2,
              bounds.y + bounds.height - b.height / 2,
              b.width,
              b.height
            );
            if (this.sizer.node.style.visibility != "hidden") {
              this.sizer.redraw();
            }
            me.consume();
          }
        };
        mxOutline.prototype.getTranslateForEvent = function(me) {
          return new mxPoint(me.getX() - this.startX, me.getY() - this.startY);
        };
        mxOutline.prototype.mouseUp = function(sender, me) {
          if (this.active) {
            var delta = this.getTranslateForEvent(me);
            var dx = delta.x;
            var dy = delta.y;
            if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
              if (!this.zoom) {
                if (!this.source.useScrollbarsForPanning || !mxUtils.hasScrollbars(this.source.container)) {
                  this.source.panGraph(0, 0);
                  dx /= this.outline.getView().scale;
                  dy /= this.outline.getView().scale;
                  var t = this.source.getView().translate;
                  this.source.getView().setTranslate(t.x - dx, t.y - dy);
                }
              } else {
                var w2 = this.selectionBorder.bounds.width;
                var scale = this.source.getView().scale;
                this.source.zoomTo(Math.max(this.minScale, scale - dx * scale / w2), false);
              }
              this.update();
              me.consume();
            }
            this.index = null;
            this.active = false;
          }
        };
        mxOutline.prototype.destroy = function() {
          if (this.source != null) {
            this.source.removeListener(this.panHandler);
            this.source.removeListener(this.refreshHandler);
            this.source.getModel().removeListener(this.updateHandler);
            this.source.getView().removeListener(this.updateHandler);
            mxEvent.removeListener(this.source.container, "scroll", this.updateHandler);
            this.source = null;
          }
          if (this.outline != null) {
            this.outline.removeMouseListener(this);
            this.outline.destroy();
            this.outline = null;
          }
          if (this.selectionBorder != null) {
            this.selectionBorder.destroy();
            this.selectionBorder = null;
          }
          if (this.sizer != null) {
            this.sizer.destroy();
            this.sizer = null;
          }
        };
        __mxOutput.mxOutline = typeof mxOutline !== "undefined" ? mxOutline : void 0;
        function mxMultiplicity(source, type, attr, value, min, max, validNeighbors, countError, typeError, validNeighborsAllowed) {
          this.source = source;
          this.type = type;
          this.attr = attr;
          this.value = value;
          this.min = min != null ? min : 0;
          this.max = max != null ? max : "n";
          this.validNeighbors = validNeighbors;
          this.countError = mxResources.get(countError) || countError;
          this.typeError = mxResources.get(typeError) || typeError;
          this.validNeighborsAllowed = validNeighborsAllowed != null ? validNeighborsAllowed : true;
        }
        ;
        mxMultiplicity.prototype.type = null;
        mxMultiplicity.prototype.attr = null;
        mxMultiplicity.prototype.value = null;
        mxMultiplicity.prototype.source = null;
        mxMultiplicity.prototype.min = null;
        mxMultiplicity.prototype.max = null;
        mxMultiplicity.prototype.validNeighbors = null;
        mxMultiplicity.prototype.validNeighborsAllowed = true;
        mxMultiplicity.prototype.countError = null;
        mxMultiplicity.prototype.typeError = null;
        mxMultiplicity.prototype.check = function(graph, edge, source, target, sourceOut, targetIn) {
          var error = "";
          if (this.source && this.checkTerminal(graph, source, edge) || !this.source && this.checkTerminal(graph, target, edge)) {
            if (this.countError != null && (this.source && (this.max == 0 || sourceOut >= this.max) || !this.source && (this.max == 0 || targetIn >= this.max))) {
              error += this.countError + "\n";
            }
            if (this.validNeighbors != null && this.typeError != null && this.validNeighbors.length > 0) {
              var isValid = this.checkNeighbors(graph, edge, source, target);
              if (!isValid) {
                error += this.typeError + "\n";
              }
            }
          }
          return error.length > 0 ? error : null;
        };
        mxMultiplicity.prototype.checkNeighbors = function(graph, edge, source, target) {
          var sourceValue = graph.model.getValue(source);
          var targetValue = graph.model.getValue(target);
          var isValid = !this.validNeighborsAllowed;
          var valid = this.validNeighbors;
          for (var j = 0; j < valid.length; j++) {
            if (this.source && this.checkType(graph, targetValue, valid[j])) {
              isValid = this.validNeighborsAllowed;
              break;
            } else if (!this.source && this.checkType(graph, sourceValue, valid[j])) {
              isValid = this.validNeighborsAllowed;
              break;
            }
          }
          return isValid;
        };
        mxMultiplicity.prototype.checkTerminal = function(graph, terminal, edge) {
          var value = graph.model.getValue(terminal);
          return this.checkType(graph, value, this.type, this.attr, this.value);
        };
        mxMultiplicity.prototype.checkType = function(graph, value, type, attr, attrValue) {
          if (value != null) {
            if (!isNaN(value.nodeType)) {
              return mxUtils.isNode(value, type, attr, attrValue);
            } else {
              return value == type;
            }
          }
          return false;
        };
        __mxOutput.mxMultiplicity = typeof mxMultiplicity !== "undefined" ? mxMultiplicity : void 0;
        function mxLayoutManager(graph) {
          this.undoHandler = mxUtils.bind(this, function(sender, evt) {
            if (this.isEnabled()) {
              this.beforeUndo(evt.getProperty("edit"));
            }
          });
          this.moveHandler = mxUtils.bind(this, function(sender, evt) {
            if (this.isEnabled()) {
              this.cellsMoved(evt.getProperty("cells"), evt.getProperty("event"));
            }
          });
          this.resizeHandler = mxUtils.bind(this, function(sender, evt) {
            if (this.isEnabled()) {
              this.cellsResized(
                evt.getProperty("cells"),
                evt.getProperty("bounds"),
                evt.getProperty("previous")
              );
            }
          });
          this.setGraph(graph);
        }
        ;
        mxLayoutManager.prototype = new mxEventSource();
        mxLayoutManager.prototype.constructor = mxLayoutManager;
        mxLayoutManager.prototype.graph = null;
        mxLayoutManager.prototype.bubbling = true;
        mxLayoutManager.prototype.enabled = true;
        mxLayoutManager.prototype.undoHandler = null;
        mxLayoutManager.prototype.moveHandler = null;
        mxLayoutManager.prototype.resizeHandler = null;
        mxLayoutManager.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxLayoutManager.prototype.setEnabled = function(enabled) {
          this.enabled = enabled;
        };
        mxLayoutManager.prototype.isBubbling = function() {
          return this.bubbling;
        };
        mxLayoutManager.prototype.setBubbling = function(value) {
          this.bubbling = value;
        };
        mxLayoutManager.prototype.getGraph = function() {
          return this.graph;
        };
        mxLayoutManager.prototype.setGraph = function(graph) {
          if (this.graph != null) {
            var model = this.graph.getModel();
            model.removeListener(this.undoHandler);
            this.graph.removeListener(this.moveHandler);
            this.graph.removeListener(this.resizeHandler);
          }
          this.graph = graph;
          if (this.graph != null) {
            var model = this.graph.getModel();
            model.addListener(mxEvent.BEFORE_UNDO, this.undoHandler);
            this.graph.addListener(mxEvent.MOVE_CELLS, this.moveHandler);
            this.graph.addListener(mxEvent.RESIZE_CELLS, this.resizeHandler);
          }
        };
        mxLayoutManager.prototype.hasLayout = function(cell2) {
          return this.getLayout(cell2, mxEvent.LAYOUT_CELLS);
        };
        mxLayoutManager.prototype.getLayout = function(cell2, eventName) {
          return null;
        };
        mxLayoutManager.prototype.beforeUndo = function(undoableEdit) {
          this.executeLayoutForCells(this.getCellsForChanges(undoableEdit.changes));
        };
        mxLayoutManager.prototype.cellsMoved = function(cells, evt) {
          if (cells != null && evt != null) {
            var point = mxUtils.convertPoint(
              this.getGraph().container,
              mxEvent.getClientX(evt),
              mxEvent.getClientY(evt)
            );
            var model = this.getGraph().getModel();
            for (var i = 0; i < cells.length; i++) {
              var layout = this.getLayout(model.getParent(cells[i]), mxEvent.MOVE_CELLS);
              if (layout != null) {
                layout.moveCell(cells[i], point.x, point.y);
              }
            }
          }
        };
        mxLayoutManager.prototype.cellsResized = function(cells, bounds, prev) {
          if (cells != null && bounds != null) {
            var model = this.getGraph().getModel();
            for (var i = 0; i < cells.length; i++) {
              var layout = this.getLayout(model.getParent(cells[i]), mxEvent.RESIZE_CELLS);
              if (layout != null) {
                layout.resizeCell(cells[i], bounds[i], prev[i]);
              }
            }
          }
        };
        mxLayoutManager.prototype.getCellsForChanges = function(changes) {
          var result2 = [];
          for (var i = 0; i < changes.length; i++) {
            var change = changes[i];
            if (change instanceof mxRootChange) {
              return [];
            } else {
              result2 = result2.concat(this.getCellsForChange(change));
            }
          }
          return result2;
        };
        mxLayoutManager.prototype.getCellsForChange = function(change) {
          if (change instanceof mxChildChange) {
            return this.addCellsWithLayout(
              change.child,
              this.addCellsWithLayout(change.previous)
            );
          } else if (change instanceof mxTerminalChange || change instanceof mxGeometryChange) {
            return this.addCellsWithLayout(change.cell);
          } else if (change instanceof mxVisibleChange || change instanceof mxStyleChange) {
            return this.addCellsWithLayout(change.cell);
          }
          return [];
        };
        mxLayoutManager.prototype.addCellsWithLayout = function(cell2, result2) {
          return this.addDescendantsWithLayout(
            cell2,
            this.addAncestorsWithLayout(cell2, result2)
          );
        };
        mxLayoutManager.prototype.addAncestorsWithLayout = function(cell2, result2) {
          result2 = result2 != null ? result2 : [];
          if (cell2 != null) {
            var layout = this.hasLayout(cell2);
            if (layout != null) {
              result2.push(cell2);
            }
            if (this.isBubbling()) {
              var model = this.getGraph().getModel();
              this.addAncestorsWithLayout(
                model.getParent(cell2),
                result2
              );
            }
          }
          return result2;
        };
        mxLayoutManager.prototype.addDescendantsWithLayout = function(cell2, result2) {
          result2 = result2 != null ? result2 : [];
          if (cell2 != null && this.hasLayout(cell2)) {
            var model = this.getGraph().getModel();
            for (var i = 0; i < model.getChildCount(cell2); i++) {
              var child = model.getChildAt(cell2, i);
              if (this.hasLayout(child)) {
                result2.push(child);
                this.addDescendantsWithLayout(child, result2);
              }
            }
          }
          return result2;
        };
        mxLayoutManager.prototype.executeLayoutForCells = function(cells) {
          var sorted = mxUtils.sortCells(cells, false);
          this.layoutCells(sorted, true);
          this.layoutCells(sorted.reverse(), false);
        };
        mxLayoutManager.prototype.layoutCells = function(cells, bubble) {
          if (cells.length > 0) {
            var model = this.getGraph().getModel();
            model.beginUpdate();
            try {
              var last = null;
              for (var i = 0; i < cells.length; i++) {
                if (cells[i] != model.getRoot() && cells[i] != last) {
                  this.executeLayout(cells[i], bubble);
                  last = cells[i];
                }
              }
              this.fireEvent(new mxEventObject(mxEvent.LAYOUT_CELLS, "cells", cells));
            } finally {
              model.endUpdate();
            }
          }
        };
        mxLayoutManager.prototype.executeLayout = function(cell2, bubble) {
          var layout = this.getLayout(cell2, bubble ? mxEvent.BEGIN_UPDATE : mxEvent.END_UPDATE);
          if (layout != null) {
            layout.execute(cell2);
          }
        };
        mxLayoutManager.prototype.destroy = function() {
          this.setGraph(null);
        };
        __mxOutput.mxLayoutManager = typeof mxLayoutManager !== "undefined" ? mxLayoutManager : void 0;
        function mxSwimlaneManager(graph, horizontal, addEnabled, resizeEnabled) {
          this.horizontal = horizontal != null ? horizontal : true;
          this.addEnabled = addEnabled != null ? addEnabled : true;
          this.resizeEnabled = resizeEnabled != null ? resizeEnabled : true;
          this.addHandler = mxUtils.bind(this, function(sender, evt) {
            if (this.isEnabled() && this.isAddEnabled()) {
              this.cellsAdded(evt.getProperty("cells"));
            }
          });
          this.resizeHandler = mxUtils.bind(this, function(sender, evt) {
            if (this.isEnabled() && this.isResizeEnabled()) {
              this.cellsResized(evt.getProperty("cells"));
            }
          });
          this.setGraph(graph);
        }
        ;
        mxSwimlaneManager.prototype = new mxEventSource();
        mxSwimlaneManager.prototype.constructor = mxSwimlaneManager;
        mxSwimlaneManager.prototype.graph = null;
        mxSwimlaneManager.prototype.enabled = true;
        mxSwimlaneManager.prototype.horizontal = true;
        mxSwimlaneManager.prototype.addEnabled = true;
        mxSwimlaneManager.prototype.resizeEnabled = true;
        mxSwimlaneManager.prototype.addHandler = null;
        mxSwimlaneManager.prototype.resizeHandler = null;
        mxSwimlaneManager.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxSwimlaneManager.prototype.setEnabled = function(value) {
          this.enabled = value;
        };
        mxSwimlaneManager.prototype.isHorizontal = function() {
          return this.horizontal;
        };
        mxSwimlaneManager.prototype.setHorizontal = function(value) {
          this.horizontal = value;
        };
        mxSwimlaneManager.prototype.isAddEnabled = function() {
          return this.addEnabled;
        };
        mxSwimlaneManager.prototype.setAddEnabled = function(value) {
          this.addEnabled = value;
        };
        mxSwimlaneManager.prototype.isResizeEnabled = function() {
          return this.resizeEnabled;
        };
        mxSwimlaneManager.prototype.setResizeEnabled = function(value) {
          this.resizeEnabled = value;
        };
        mxSwimlaneManager.prototype.getGraph = function() {
          return this.graph;
        };
        mxSwimlaneManager.prototype.setGraph = function(graph) {
          if (this.graph != null) {
            this.graph.removeListener(this.addHandler);
            this.graph.removeListener(this.resizeHandler);
          }
          this.graph = graph;
          if (this.graph != null) {
            this.graph.addListener(mxEvent.ADD_CELLS, this.addHandler);
            this.graph.addListener(mxEvent.CELLS_RESIZED, this.resizeHandler);
          }
        };
        mxSwimlaneManager.prototype.isSwimlaneIgnored = function(swimlane) {
          return !this.getGraph().isSwimlane(swimlane);
        };
        mxSwimlaneManager.prototype.isCellHorizontal = function(cell2) {
          if (this.graph.isSwimlane(cell2)) {
            var style = this.graph.getCellStyle(cell2);
            return mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, 1) == 1;
          }
          return !this.isHorizontal();
        };
        mxSwimlaneManager.prototype.cellsAdded = function(cells) {
          if (cells != null) {
            var model = this.getGraph().getModel();
            model.beginUpdate();
            try {
              for (var i = 0; i < cells.length; i++) {
                if (!this.isSwimlaneIgnored(cells[i])) {
                  this.swimlaneAdded(cells[i]);
                }
              }
            } finally {
              model.endUpdate();
            }
          }
        };
        mxSwimlaneManager.prototype.swimlaneAdded = function(swimlane) {
          var model = this.getGraph().getModel();
          var parent = model.getParent(swimlane);
          var childCount = model.getChildCount(parent);
          var geo = null;
          for (var i = 0; i < childCount; i++) {
            var child = model.getChildAt(parent, i);
            if (child != swimlane && !this.isSwimlaneIgnored(child)) {
              geo = model.getGeometry(child);
              if (geo != null) {
                break;
              }
            }
          }
          if (geo != null) {
            var parentHorizontal = parent != null ? this.isCellHorizontal(parent) : this.horizontal;
            this.resizeSwimlane(swimlane, geo.width, geo.height, parentHorizontal);
          }
        };
        mxSwimlaneManager.prototype.cellsResized = function(cells) {
          if (cells != null) {
            var model = this.getGraph().getModel();
            model.beginUpdate();
            try {
              for (var i = 0; i < cells.length; i++) {
                if (!this.isSwimlaneIgnored(cells[i])) {
                  var geo = model.getGeometry(cells[i]);
                  if (geo != null) {
                    var size = new mxRectangle(0, 0, geo.width, geo.height);
                    var top = cells[i];
                    var current = top;
                    while (current != null) {
                      top = current;
                      current = model.getParent(current);
                      var tmp = this.graph.isSwimlane(current) ? this.graph.getStartSize(current) : new mxRectangle();
                      size.width += tmp.width;
                      size.height += tmp.height;
                    }
                    var parentHorizontal = current != null ? this.isCellHorizontal(current) : this.horizontal;
                    this.resizeSwimlane(top, size.width, size.height, parentHorizontal);
                  }
                }
              }
            } finally {
              model.endUpdate();
            }
          }
        };
        mxSwimlaneManager.prototype.resizeSwimlane = function(swimlane, w2, h2, parentHorizontal) {
          var model = this.getGraph().getModel();
          model.beginUpdate();
          try {
            var horizontal = this.isCellHorizontal(swimlane);
            if (!this.isSwimlaneIgnored(swimlane)) {
              var geo = model.getGeometry(swimlane);
              if (geo != null) {
                if (parentHorizontal && geo.height != h2 || !parentHorizontal && geo.width != w2) {
                  geo = geo.clone();
                  if (parentHorizontal) {
                    geo.height = h2;
                  } else {
                    geo.width = w2;
                  }
                  model.setGeometry(swimlane, geo);
                }
              }
            }
            var tmp = this.graph.isSwimlane(swimlane) ? this.graph.getStartSize(swimlane) : new mxRectangle();
            w2 -= tmp.width;
            h2 -= tmp.height;
            var childCount = model.getChildCount(swimlane);
            for (var i = 0; i < childCount; i++) {
              var child = model.getChildAt(swimlane, i);
              this.resizeSwimlane(child, w2, h2, horizontal);
            }
          } finally {
            model.endUpdate();
          }
        };
        mxSwimlaneManager.prototype.destroy = function() {
          this.setGraph(null);
        };
        __mxOutput.mxSwimlaneManager = typeof mxSwimlaneManager !== "undefined" ? mxSwimlaneManager : void 0;
        function mxTemporaryCellStates(view, scale, cells, isCellVisibleFn, getLinkForCellState) {
          scale = scale != null ? scale : 1;
          this.view = view;
          this.oldValidateCellState = view.validateCellState;
          this.oldBounds = view.getGraphBounds();
          this.oldStates = view.getStates();
          this.oldScale = view.getScale();
          this.oldDoRedrawShape = view.graph.cellRenderer.doRedrawShape;
          var self = this;
          if (getLinkForCellState != null) {
            view.graph.cellRenderer.doRedrawShape = function(state) {
              var oldPaint = state.shape.paint;
              state.shape.paint = function(c) {
                var link = getLinkForCellState(state);
                if (link != null) {
                  c.setLink(link);
                }
                oldPaint.apply(this, arguments);
                if (link != null) {
                  c.setLink(null);
                }
              };
              self.oldDoRedrawShape.apply(view.graph.cellRenderer, arguments);
              state.shape.paint = oldPaint;
            };
          }
          view.validateCellState = function(cell2, resurse) {
            if (cell2 == null || isCellVisibleFn == null || isCellVisibleFn(cell2)) {
              return self.oldValidateCellState.apply(view, arguments);
            }
            return null;
          };
          view.setStates(new mxDictionary());
          view.setScale(scale);
          if (cells != null) {
            view.resetValidationState();
            var bbox = null;
            for (var i = 0; i < cells.length; i++) {
              var bounds = view.getBoundingBox(view.validateCellState(view.validateCell(cells[i])));
              if (bbox == null) {
                bbox = bounds;
              } else {
                bbox.add(bounds);
              }
            }
            view.setGraphBounds(bbox || new mxRectangle());
          }
        }
        ;
        mxTemporaryCellStates.prototype.view = null;
        mxTemporaryCellStates.prototype.oldStates = null;
        mxTemporaryCellStates.prototype.oldBounds = null;
        mxTemporaryCellStates.prototype.oldScale = null;
        mxTemporaryCellStates.prototype.destroy = function() {
          this.view.setScale(this.oldScale);
          this.view.setStates(this.oldStates);
          this.view.setGraphBounds(this.oldBounds);
          this.view.validateCellState = this.oldValidateCellState;
          this.view.graph.cellRenderer.doRedrawShape = this.oldDoRedrawShape;
        };
        __mxOutput.mxTemporaryCellStates = typeof mxTemporaryCellStates !== "undefined" ? mxTemporaryCellStates : void 0;
        function mxCellStatePreview(graph) {
          this.deltas = new mxDictionary();
          this.graph = graph;
        }
        ;
        mxCellStatePreview.prototype.graph = null;
        mxCellStatePreview.prototype.deltas = null;
        mxCellStatePreview.prototype.count = 0;
        mxCellStatePreview.prototype.isEmpty = function() {
          return this.count == 0;
        };
        mxCellStatePreview.prototype.moveState = function(state, dx, dy, add, includeEdges) {
          add = add != null ? add : true;
          includeEdges = includeEdges != null ? includeEdges : true;
          var delta = this.deltas.get(state.cell);
          if (delta == null) {
            delta = { point: new mxPoint(dx, dy), state };
            this.deltas.put(state.cell, delta);
            this.count++;
          } else if (add) {
            delta.point.x += dx;
            delta.point.y += dy;
          } else {
            delta.point.x = dx;
            delta.point.y = dy;
          }
          if (includeEdges) {
            this.addEdges(state);
          }
          return delta.point;
        };
        mxCellStatePreview.prototype.show = function(visitor) {
          this.deltas.visit(mxUtils.bind(this, function(key, delta) {
            this.translateState(delta.state, delta.point.x, delta.point.y);
          }));
          this.deltas.visit(mxUtils.bind(this, function(key, delta) {
            this.revalidateState(delta.state, delta.point.x, delta.point.y, visitor);
          }));
        };
        mxCellStatePreview.prototype.translateState = function(state, dx, dy) {
          if (state != null) {
            var model = this.graph.getModel();
            if (model.isVertex(state.cell)) {
              state.view.updateCellState(state);
              var geo = model.getGeometry(state.cell);
              if ((dx != 0 || dy != 0) && geo != null && (!geo.relative || this.deltas.get(state.cell) != null)) {
                state.x += dx;
                state.y += dy;
              }
            }
            var childCount = model.getChildCount(state.cell);
            for (var i = 0; i < childCount; i++) {
              this.translateState(state.view.getState(model.getChildAt(state.cell, i)), dx, dy);
            }
          }
        };
        mxCellStatePreview.prototype.revalidateState = function(state, dx, dy, visitor) {
          if (state != null) {
            var model = this.graph.getModel();
            if (model.isEdge(state.cell)) {
              state.view.updateCellState(state);
            }
            var geo = this.graph.getCellGeometry(state.cell);
            var pState = state.view.getState(model.getParent(state.cell));
            if ((dx != 0 || dy != 0) && geo != null && geo.relative && model.isVertex(state.cell) && (pState == null || model.isVertex(pState.cell) || this.deltas.get(state.cell) != null)) {
              state.x += dx;
              state.y += dy;
            }
            this.graph.cellRenderer.redraw(state);
            if (visitor != null) {
              visitor(state);
            }
            var childCount = model.getChildCount(state.cell);
            for (var i = 0; i < childCount; i++) {
              this.revalidateState(this.graph.view.getState(model.getChildAt(state.cell, i)), dx, dy, visitor);
            }
          }
        };
        mxCellStatePreview.prototype.addEdges = function(state) {
          var model = this.graph.getModel();
          var edgeCount = model.getEdgeCount(state.cell);
          for (var i = 0; i < edgeCount; i++) {
            var s = state.view.getState(model.getEdgeAt(state.cell, i));
            if (s != null) {
              this.moveState(s, 0, 0);
            }
          }
        };
        __mxOutput.mxCellStatePreview = typeof mxCellStatePreview !== "undefined" ? mxCellStatePreview : void 0;
        function mxConnectionConstraint(point, perimeter, name2, dx, dy) {
          this.point = point;
          this.perimeter = perimeter != null ? perimeter : true;
          this.name = name2;
          this.dx = dx ? dx : 0;
          this.dy = dy ? dy : 0;
        }
        ;
        mxConnectionConstraint.prototype.point = null;
        mxConnectionConstraint.prototype.perimeter = null;
        mxConnectionConstraint.prototype.name = null;
        mxConnectionConstraint.prototype.dx = null;
        mxConnectionConstraint.prototype.dy = null;
        __mxOutput.mxConnectionConstraint = typeof mxConnectionConstraint !== "undefined" ? mxConnectionConstraint : void 0;
        function mxGraphHandler(graph) {
          this.graph = graph;
          this.graph.addMouseListener(this);
          this.panHandler = mxUtils.bind(this, function() {
            if (!this.suspended) {
              this.updatePreview();
              this.updateHint();
            }
          });
          this.graph.addListener(mxEvent.PAN, this.panHandler);
          this.escapeHandler = mxUtils.bind(this, function(sender, evt) {
            this.reset();
          });
          this.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
          this.refreshHandler = mxUtils.bind(this, function(sender, evt) {
            if (this.refreshThread) {
              window.clearTimeout(this.refreshThread);
            }
            this.refreshThread = window.setTimeout(mxUtils.bind(this, function() {
              this.refreshThread = null;
              if (this.first != null && !this.suspended) {
                var dx = this.currentDx;
                var dy = this.currentDy;
                this.currentDx = 0;
                this.currentDy = 0;
                this.updatePreview();
                this.bounds = this.graph.getView().getBounds(this.cells);
                this.pBounds = this.getPreviewBounds(this.cells);
                if (this.pBounds == null && !this.livePreviewUsed) {
                  this.reset();
                } else {
                  this.currentDx = dx;
                  this.currentDy = dy;
                  this.updatePreview();
                  this.updateHint();
                  if (this.livePreviewUsed) {
                    this.setHandlesVisibleForCells(
                      this.graph.selectionCellsHandler.getHandledSelectionCells(),
                      false,
                      true
                    );
                    this.updatePreview();
                  }
                }
              }
            }), 0);
          });
          this.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);
          this.graph.addListener(mxEvent.REFRESH, this.refreshHandler);
          this.keyHandler = mxUtils.bind(this, function(e) {
            if (this.graph.container != null && this.graph.container.style.visibility != "hidden" && this.first != null && !this.suspended) {
              var clone = this.graph.isCloneEvent(e) && this.graph.isCellsCloneable() && this.isCloneEnabled();
              if (clone != this.cloning) {
                this.cloning = clone;
                this.checkPreview();
                this.updatePreview();
              }
            }
          });
          mxEvent.addListener(document, "keydown", this.keyHandler);
          mxEvent.addListener(document, "keyup", this.keyHandler);
        }
        ;
        mxGraphHandler.prototype.graph = null;
        mxGraphHandler.prototype.maxCells = mxClient.IS_IE ? 20 : 50;
        mxGraphHandler.prototype.enabled = true;
        mxGraphHandler.prototype.highlightEnabled = true;
        mxGraphHandler.prototype.cloneEnabled = true;
        mxGraphHandler.prototype.moveEnabled = true;
        mxGraphHandler.prototype.guidesEnabled = false;
        mxGraphHandler.prototype.handlesVisible = true;
        mxGraphHandler.prototype.guide = null;
        mxGraphHandler.prototype.currentDx = null;
        mxGraphHandler.prototype.currentDy = null;
        mxGraphHandler.prototype.updateCursor = true;
        mxGraphHandler.prototype.selectEnabled = true;
        mxGraphHandler.prototype.removeCellsFromParent = true;
        mxGraphHandler.prototype.removeEmptyParents = false;
        mxGraphHandler.prototype.connectOnDrop = false;
        mxGraphHandler.prototype.scrollOnMove = true;
        mxGraphHandler.prototype.minimumSize = 6;
        mxGraphHandler.prototype.previewColor = "black";
        mxGraphHandler.prototype.htmlPreview = false;
        mxGraphHandler.prototype.shape = null;
        mxGraphHandler.prototype.scaleGrid = false;
        mxGraphHandler.prototype.rotationEnabled = true;
        mxGraphHandler.prototype.maxLivePreview = 0;
        mxGraphHandler.prototype.allowLivePreview = mxClient.IS_SVG;
        mxGraphHandler.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxGraphHandler.prototype.setEnabled = function(value) {
          this.enabled = value;
        };
        mxGraphHandler.prototype.isCloneEnabled = function() {
          return this.cloneEnabled;
        };
        mxGraphHandler.prototype.setCloneEnabled = function(value) {
          this.cloneEnabled = value;
        };
        mxGraphHandler.prototype.isMoveEnabled = function() {
          return this.moveEnabled;
        };
        mxGraphHandler.prototype.setMoveEnabled = function(value) {
          this.moveEnabled = value;
        };
        mxGraphHandler.prototype.isSelectEnabled = function() {
          return this.selectEnabled;
        };
        mxGraphHandler.prototype.setSelectEnabled = function(value) {
          this.selectEnabled = value;
        };
        mxGraphHandler.prototype.isRemoveCellsFromParent = function() {
          return this.removeCellsFromParent;
        };
        mxGraphHandler.prototype.setRemoveCellsFromParent = function(value) {
          this.removeCellsFromParent = value;
        };
        mxGraphHandler.prototype.isPropagateSelectionCell = function(cell2, immediate, me) {
          var parent = this.graph.model.getParent(cell2);
          if (immediate) {
            var geo = this.graph.model.isEdge(cell2) ? null : this.graph.getCellGeometry(cell2);
            return !this.graph.isSiblingSelected(cell2) && (geo != null && geo.relative || !this.graph.isSwimlane(parent));
          } else {
            return (!this.graph.isToggleEvent(me.getEvent()) || (!this.graph.isSiblingSelected(cell2) && !this.graph.isCellSelected(cell2) && !this.graph.isSwimlane(parent) || this.graph.isCellSelected(parent))) && (this.graph.isToggleEvent(me.getEvent()) || !this.graph.isCellSelected(parent));
          }
        };
        mxGraphHandler.prototype.getInitialCellForEvent = function(me) {
          var state = me.getState();
          if ((!this.graph.isToggleEvent(me.getEvent()) || !mxEvent.isAltDown(me.getEvent())) && state != null && !this.graph.isCellSelected(state.cell)) {
            var model = this.graph.model;
            var next = this.graph.view.getState(model.getParent(state.cell));
            while (next != null && !this.graph.isCellSelected(next.cell) && (model.isVertex(next.cell) || model.isEdge(next.cell)) && this.isPropagateSelectionCell(state.cell, true, me)) {
              state = next;
              next = this.graph.view.getState(this.graph.getModel().getParent(state.cell));
            }
          }
          return state != null ? state.cell : null;
        };
        mxGraphHandler.prototype.isDelayedSelection = function(cell2, me) {
          if (!this.graph.isToggleEvent(me.getEvent()) || !mxEvent.isAltDown(me.getEvent())) {
            while (cell2 != null) {
              if (this.graph.selectionCellsHandler.isHandled(cell2)) {
                return this.graph.cellEditor.getEditingCell() != cell2;
              }
              cell2 = this.graph.model.getParent(cell2);
            }
          }
          return this.graph.isToggleEvent(me.getEvent()) && !mxEvent.isAltDown(me.getEvent());
        };
        mxGraphHandler.prototype.selectDelayed = function(me) {
          if (!this.graph.popupMenuHandler.isPopupTrigger(me)) {
            var cell2 = me.getCell();
            if (cell2 == null) {
              cell2 = this.cell;
            }
            this.selectCellForEvent(cell2, me);
          }
        };
        mxGraphHandler.prototype.selectCellForEvent = function(cell2, me) {
          var state = this.graph.view.getState(cell2);
          if (state != null) {
            if (me.isSource(state.control)) {
              this.graph.selectCellForEvent(cell2, me.getEvent());
            } else {
              if (!this.graph.isToggleEvent(me.getEvent()) || !mxEvent.isAltDown(me.getEvent())) {
                var model = this.graph.getModel();
                var parent = model.getParent(cell2);
                while (this.graph.view.getState(parent) != null && (model.isVertex(parent) || model.isEdge(parent)) && this.isPropagateSelectionCell(cell2, false, me)) {
                  cell2 = parent;
                  parent = model.getParent(cell2);
                }
              }
              this.graph.selectCellForEvent(cell2, me.getEvent());
            }
          }
          return cell2;
        };
        mxGraphHandler.prototype.consumeMouseEvent = function(evtName, me) {
          me.consume();
        };
        mxGraphHandler.prototype.mouseDown = function(sender, me) {
          if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && me.getState() != null && !mxEvent.isMultiTouchEvent(me.getEvent())) {
            var cell2 = this.getInitialCellForEvent(me);
            this.delayedSelection = this.isDelayedSelection(cell2, me);
            this.cell = null;
            if (this.isSelectEnabled() && !this.delayedSelection) {
              this.graph.selectCellForEvent(cell2, me.getEvent());
            }
            if (this.isMoveEnabled()) {
              var model = this.graph.model;
              var geo = model.getGeometry(cell2);
              if (this.graph.isCellMovable(cell2) && (!model.isEdge(cell2) || this.graph.getSelectionCount() > 1 || geo.points != null && geo.points.length > 0 || model.getTerminal(cell2, true) == null || model.getTerminal(cell2, false) == null || this.graph.allowDanglingEdges || this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable())) {
                this.start(cell2, me.getX(), me.getY());
              } else if (this.delayedSelection) {
                this.cell = cell2;
              }
              this.cellWasClicked = true;
              this.consumeMouseEvent(mxEvent.MOUSE_DOWN, me);
            }
          }
        };
        mxGraphHandler.prototype.getGuideStates = function() {
          var parent = this.graph.getDefaultParent();
          var model = this.graph.getModel();
          var filter = mxUtils.bind(this, function(cell2) {
            return this.graph.view.getState(cell2) != null && model.isVertex(cell2) && model.getGeometry(cell2) != null && !model.getGeometry(cell2).relative;
          });
          return this.graph.view.getCellStates(model.filterDescendants(filter, parent));
        };
        mxGraphHandler.prototype.getCells = function(initialCell) {
          if (!this.delayedSelection && this.graph.isCellMovable(initialCell)) {
            return [initialCell];
          } else {
            return this.graph.getMovableCells(this.graph.getSelectionCells());
          }
        };
        mxGraphHandler.prototype.getPreviewBounds = function(cells) {
          var bounds = this.getBoundingBox(cells);
          if (bounds != null) {
            bounds.width = Math.max(0, bounds.width - 1);
            bounds.height = Math.max(0, bounds.height - 1);
            if (bounds.width < this.minimumSize) {
              var dx = this.minimumSize - bounds.width;
              bounds.x -= dx / 2;
              bounds.width = this.minimumSize;
            } else {
              bounds.x = Math.round(bounds.x);
              bounds.width = Math.ceil(bounds.width);
            }
            var tr = this.graph.view.translate;
            var s = this.graph.view.scale;
            if (bounds.height < this.minimumSize) {
              var dy = this.minimumSize - bounds.height;
              bounds.y -= dy / 2;
              bounds.height = this.minimumSize;
            } else {
              bounds.y = Math.round(bounds.y);
              bounds.height = Math.ceil(bounds.height);
            }
          }
          return bounds;
        };
        mxGraphHandler.prototype.getBoundingBox = function(cells) {
          var result2 = null;
          if (cells != null && cells.length > 0) {
            var model = this.graph.getModel();
            for (var i = 0; i < cells.length; i++) {
              if (model.isVertex(cells[i]) || model.isEdge(cells[i])) {
                var state = this.graph.view.getState(cells[i]);
                if (state != null) {
                  var bbox = state;
                  if (model.isVertex(cells[i]) && state.shape != null && state.shape.boundingBox != null) {
                    bbox = state.shape.boundingBox;
                  }
                  if (result2 == null) {
                    result2 = mxRectangle.fromRectangle(bbox);
                  } else {
                    result2.add(bbox);
                  }
                }
              }
            }
          }
          return result2;
        };
        mxGraphHandler.prototype.createPreviewShape = function(bounds) {
          var shape2 = new mxRectangleShape(bounds, null, this.previewColor);
          shape2.isDashed = true;
          if (this.htmlPreview) {
            shape2.dialect = mxConstants.DIALECT_STRICTHTML;
            shape2.init(this.graph.container);
          } else {
            shape2.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
            shape2.init(this.graph.getView().getOverlayPane());
            shape2.pointerEvents = false;
            if (mxClient.IS_IOS) {
              shape2.getSvgScreenOffset = function() {
                return 0;
              };
            }
          }
          return shape2;
        };
        mxGraphHandler.prototype.start = function(cell2, x, y, cells) {
          this.cell = cell2;
          this.first = mxUtils.convertPoint(this.graph.container, x, y);
          this.cells = cells != null ? cells : this.getCells(this.cell);
          this.bounds = this.graph.getView().getBounds(this.cells);
          this.pBounds = this.getPreviewBounds(this.cells);
          this.allCells = new mxDictionary();
          this.cloning = false;
          this.cellCount = 0;
          for (var i = 0; i < this.cells.length; i++) {
            this.cellCount += this.addStates(this.cells[i], this.allCells);
          }
          if (this.guidesEnabled) {
            this.guide = new mxGuide(this.graph, this.getGuideStates());
            var parent = this.graph.model.getParent(cell2);
            var ignore = this.graph.model.getChildCount(parent) < 2;
            var connected = new mxDictionary();
            var opps = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);
            for (var i = 0; i < opps.length; i++) {
              var state = this.graph.view.getState(opps[i]);
              if (state != null && !connected.get(state)) {
                connected.put(state, true);
              }
            }
            this.guide.isStateIgnored = mxUtils.bind(this, function(state2) {
              var p = this.graph.model.getParent(state2.cell);
              return state2.cell != null && (!this.cloning && this.isCellMoving(state2.cell) || state2.cell != (this.target || parent) && !ignore && !connected.get(state2) && (this.target == null || this.graph.model.getChildCount(
                this.target
              ) >= 2) && p != (this.target || parent));
            });
          }
        };
        mxGraphHandler.prototype.addStates = function(cell2, dict) {
          var state = this.graph.view.getState(cell2);
          var count = 0;
          if (state != null && dict.get(cell2) == null) {
            dict.put(cell2, state);
            count++;
            var childCount = this.graph.model.getChildCount(cell2);
            for (var i = 0; i < childCount; i++) {
              count += this.addStates(this.graph.model.getChildAt(cell2, i), dict);
            }
          }
          return count;
        };
        mxGraphHandler.prototype.isCellMoving = function(cell2) {
          return this.allCells.get(cell2) != null;
        };
        mxGraphHandler.prototype.useGuidesForEvent = function(me) {
          return this.guide != null ? this.guide.isEnabledForEvent(me.getEvent()) && !this.graph.isConstrainedEvent(me.getEvent()) : true;
        };
        mxGraphHandler.prototype.snap = function(vector) {
          var scale = this.scaleGrid ? this.graph.view.scale : 1;
          vector.x = this.graph.snap(vector.x / scale) * scale;
          vector.y = this.graph.snap(vector.y / scale) * scale;
          return vector;
        };
        mxGraphHandler.prototype.getDelta = function(me) {
          var point = mxUtils.convertPoint(this.graph.container, me.getX(), me.getY());
          return new mxPoint(
            point.x - this.first.x - this.graph.panDx,
            point.y - this.first.y - this.graph.panDy
          );
        };
        mxGraphHandler.prototype.updateHint = function(me) {
        };
        mxGraphHandler.prototype.removeHint = function() {
        };
        mxGraphHandler.prototype.roundLength = function(length) {
          return Math.round(length * 100) / 100;
        };
        mxGraphHandler.prototype.isValidDropTarget = function(target, me) {
          return this.graph.model.getParent(this.cell) != target;
        };
        mxGraphHandler.prototype.checkPreview = function() {
          if (this.livePreviewActive && this.cloning) {
            this.resetLivePreview();
            this.livePreviewActive = false;
          } else if (this.maxLivePreview >= this.cellCount && !this.livePreviewActive && this.allowLivePreview) {
            if (!this.cloning || !this.livePreviewActive) {
              this.livePreviewActive = true;
              this.livePreviewUsed = true;
            }
          } else if (!this.livePreviewUsed && this.shape == null) {
            this.shape = this.createPreviewShape(this.bounds);
          }
        };
        mxGraphHandler.prototype.mouseMove = function(sender, me) {
          var graph = this.graph;
          if (!me.isConsumed() && graph.isMouseDown && this.cell != null && this.first != null && this.bounds != null && !this.suspended) {
            if (mxEvent.isMultiTouchEvent(me.getEvent())) {
              this.reset();
              return;
            }
            var delta = this.getDelta(me);
            var tol = graph.tolerance;
            if (this.shape != null || this.livePreviewActive || Math.abs(delta.x) > tol || Math.abs(delta.y) > tol) {
              if (this.highlight == null) {
                this.highlight = new mxCellHighlight(
                  this.graph,
                  mxConstants.DROP_TARGET_COLOR,
                  3
                );
              }
              var clone = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();
              var gridEnabled = graph.isGridEnabledEvent(me.getEvent());
              var cell2 = me.getCell();
              var hideGuide = true;
              var target = null;
              this.cloning = clone;
              if (graph.isDropEnabled() && this.highlightEnabled) {
                target = graph.getDropTarget(this.cells, me.getEvent(), cell2, clone);
              }
              var state = graph.getView().getState(target);
              var highlight = false;
              if (state != null && (clone || this.isValidDropTarget(target, me))) {
                if (this.target != target) {
                  this.target = target;
                  this.setHighlightColor(mxConstants.DROP_TARGET_COLOR);
                }
                highlight = true;
              } else {
                this.target = null;
                if (this.connectOnDrop && cell2 != null && this.cells.length == 1 && graph.getModel().isVertex(cell2) && graph.isCellConnectable(cell2)) {
                  state = graph.getView().getState(cell2);
                  if (state != null) {
                    var error = graph.getEdgeValidationError(null, this.cell, cell2);
                    var color = error == null ? mxConstants.VALID_COLOR : mxConstants.INVALID_CONNECT_TARGET_COLOR;
                    this.setHighlightColor(color);
                    highlight = true;
                  }
                }
              }
              if (state != null && highlight) {
                this.highlight.highlight(state);
              } else {
                this.highlight.hide();
              }
              if (this.guide != null && this.useGuidesForEvent(me)) {
                delta = this.guide.move(this.bounds, delta, gridEnabled, clone);
                hideGuide = false;
              } else {
                delta = this.graph.snapDelta(delta, this.bounds, !gridEnabled, false, false);
              }
              if (this.guide != null && hideGuide) {
                this.guide.hide();
              }
              if (graph.isConstrainedEvent(me.getEvent())) {
                if (Math.abs(delta.x) > Math.abs(delta.y)) {
                  delta.y = 0;
                } else {
                  delta.x = 0;
                }
              }
              this.checkPreview();
              if (this.currentDx != delta.x || this.currentDy != delta.y) {
                this.currentDx = delta.x;
                this.currentDy = delta.y;
                this.updatePreview();
              }
            }
            this.updateHint(me);
            this.consumeMouseEvent(mxEvent.MOUSE_MOVE, me);
            mxEvent.consume(me.getEvent());
          } else if ((this.isMoveEnabled() || this.isCloneEnabled()) && this.updateCursor && !me.isConsumed() && (me.getState() != null || me.sourceState != null) && !graph.isMouseDown) {
            var cursor = graph.getCursorForMouseEvent(me);
            if (cursor == null && graph.isEnabled() && graph.isCellMovable(me.getCell())) {
              if (graph.getModel().isEdge(me.getCell())) {
                cursor = mxConstants.CURSOR_MOVABLE_EDGE;
              } else {
                cursor = mxConstants.CURSOR_MOVABLE_VERTEX;
              }
            }
            if (cursor != null && me.sourceState != null) {
              me.sourceState.setCursor(cursor);
            }
          }
        };
        mxGraphHandler.prototype.updatePreview = function(remote) {
          if (this.livePreviewUsed && !remote) {
            if (this.cells != null) {
              this.setHandlesVisibleForCells(
                this.graph.selectionCellsHandler.getHandledSelectionCells(),
                false
              );
              this.updateLivePreview(this.currentDx, this.currentDy);
            }
          } else {
            this.updatePreviewShape();
          }
        };
        mxGraphHandler.prototype.updatePreviewShape = function() {
          if (this.shape != null && this.pBounds != null) {
            this.shape.bounds = new mxRectangle(
              Math.round(this.pBounds.x + this.currentDx),
              Math.round(this.pBounds.y + this.currentDy),
              this.pBounds.width,
              this.pBounds.height
            );
            this.shape.redraw();
          }
        };
        mxGraphHandler.prototype.updateLivePreview = function(dx, dy) {
          if (!this.suspended) {
            var states = [];
            if (this.allCells != null) {
              this.allCells.visit(mxUtils.bind(this, function(key, state2) {
                var realState = this.graph.view.getState(state2.cell);
                if (realState != state2) {
                  state2.destroy();
                  if (realState != null) {
                    this.allCells.put(state2.cell, realState);
                  } else {
                    this.allCells.remove(state2.cell);
                  }
                  state2 = realState;
                }
                if (state2 != null) {
                  var tempState = state2.clone();
                  states.push([state2, tempState]);
                  if (state2.shape != null) {
                    if (state2.shape.originalPointerEvents == null) {
                      state2.shape.originalPointerEvents = state2.shape.pointerEvents;
                    }
                    state2.shape.pointerEvents = false;
                    if (state2.text != null) {
                      if (state2.text.originalPointerEvents == null) {
                        state2.text.originalPointerEvents = state2.text.pointerEvents;
                      }
                      state2.text.pointerEvents = false;
                    }
                  }
                  if (this.graph.model.isVertex(state2.cell)) {
                    state2.x += dx;
                    state2.y += dy;
                    if (!this.cloning) {
                      state2.view.graph.cellRenderer.redraw(state2, true);
                      state2.view.invalidate(state2.cell);
                      state2.invalid = false;
                      if (state2.control != null && state2.control.node != null) {
                        state2.control.node.style.visibility = "hidden";
                      }
                    } else if (state2.text != null) {
                      state2.text.updateBoundingBox();
                      if (state2.text.boundingBox != null) {
                        state2.text.boundingBox.x += dx;
                        state2.text.boundingBox.y += dy;
                      }
                      if (state2.text.unrotatedBoundingBox != null) {
                        state2.text.unrotatedBoundingBox.x += dx;
                        state2.text.unrotatedBoundingBox.y += dy;
                      }
                    }
                  }
                }
              }));
            }
            if (states.length == 0) {
              this.reset();
            } else {
              var s = this.graph.view.scale;
              for (var i = 0; i < states.length; i++) {
                var state = states[i][0];
                if (this.graph.model.isEdge(state.cell)) {
                  var geometry = this.graph.getCellGeometry(state.cell);
                  var points = [];
                  if (geometry != null && geometry.points != null) {
                    for (var j = 0; j < geometry.points.length; j++) {
                      if (geometry.points[j] != null) {
                        points.push(new mxPoint(
                          geometry.points[j].x + dx / s,
                          geometry.points[j].y + dy / s
                        ));
                      }
                    }
                  }
                  var source = state.visibleSourceState;
                  var target = state.visibleTargetState;
                  var pts = states[i][1].absolutePoints;
                  if (source == null || !this.isCellMoving(source.cell)) {
                    var pt0 = pts[0];
                    state.setAbsoluteTerminalPoint(new mxPoint(pt0.x + dx, pt0.y + dy), true);
                    source = null;
                  } else {
                    state.view.updateFixedTerminalPoint(
                      state,
                      source,
                      true,
                      this.graph.getConnectionConstraint(state, source, true)
                    );
                  }
                  if (target == null || !this.isCellMoving(target.cell)) {
                    var ptn = pts[pts.length - 1];
                    state.setAbsoluteTerminalPoint(new mxPoint(ptn.x + dx, ptn.y + dy), false);
                    target = null;
                  } else {
                    state.view.updateFixedTerminalPoint(
                      state,
                      target,
                      false,
                      this.graph.getConnectionConstraint(state, target, false)
                    );
                  }
                  state.view.updatePoints(state, points, source, target);
                  state.view.updateFloatingTerminalPoints(state, source, target);
                  state.view.updateEdgeLabelOffset(state);
                  state.invalid = false;
                  if (!this.cloning) {
                    state.view.graph.cellRenderer.redraw(state, true);
                  }
                }
              }
              this.graph.view.validate();
              this.redrawHandles(states);
              this.resetPreviewStates(states);
            }
          }
        };
        mxGraphHandler.prototype.redrawHandles = function(states) {
          for (var i = 0; i < states.length; i++) {
            var handler = this.graph.selectionCellsHandler.getHandler(states[i][0].cell);
            if (handler != null) {
              handler.redraw(true);
            }
          }
        };
        mxGraphHandler.prototype.resetPreviewStates = function(states) {
          for (var i = 0; i < states.length; i++) {
            states[i][0].setState(states[i][1]);
          }
        };
        mxGraphHandler.prototype.suspend = function() {
          if (!this.suspended) {
            if (this.livePreviewUsed) {
              this.updateLivePreview(0, 0);
            }
            if (this.shape != null) {
              this.shape.node.style.visibility = "hidden";
            }
            if (this.guide != null) {
              this.guide.setVisible(false);
            }
            this.suspended = true;
          }
        };
        mxGraphHandler.prototype.resume = function() {
          if (this.suspended) {
            this.suspended = null;
            if (this.livePreviewUsed) {
              this.livePreviewActive = true;
            }
            if (this.shape != null) {
              this.shape.node.style.visibility = "visible";
            }
            if (this.guide != null) {
              this.guide.setVisible(true);
            }
          }
        };
        mxGraphHandler.prototype.resetLivePreview = function() {
          if (this.allCells != null) {
            this.allCells.visit(mxUtils.bind(this, function(key, state) {
              if (state.shape != null && state.shape.originalPointerEvents != null) {
                state.shape.pointerEvents = state.shape.originalPointerEvents;
                state.shape.originalPointerEvents = null;
                state.shape.bounds = null;
                if (state.text != null) {
                  state.text.pointerEvents = state.text.originalPointerEvents;
                  state.text.originalPointerEvents = null;
                }
              }
              if (state.control != null && state.control.node != null && state.control.node.style.visibility == "hidden") {
                state.control.node.style.visibility = "";
              }
              if (!this.cloning) {
                if (state.text != null) {
                  state.text.updateBoundingBox();
                }
              }
              state.view.invalidate(state.cell);
            }));
            this.graph.view.validate();
          }
        };
        mxGraphHandler.prototype.setHandlesVisibleForCells = function(cells, visible, force) {
          if (force || this.handlesVisible != visible) {
            this.handlesVisible = visible;
            for (var i = 0; i < cells.length; i++) {
              var handler = this.graph.selectionCellsHandler.getHandler(cells[i]);
              if (handler != null) {
                handler.setHandlesVisible(visible);
                if (visible) {
                  handler.redraw();
                }
              }
            }
          }
        };
        mxGraphHandler.prototype.setHighlightColor = function(color) {
          if (this.highlight != null) {
            this.highlight.setHighlightColor(color);
          }
        };
        mxGraphHandler.prototype.mouseUp = function(sender, me) {
          if (!me.isConsumed()) {
            if (this.livePreviewUsed) {
              this.resetLivePreview();
            }
            if (this.cell != null && this.first != null && (this.shape != null || this.livePreviewUsed) && this.currentDx != null && this.currentDy != null) {
              var graph = this.graph;
              var cell2 = me.getCell();
              if (this.connectOnDrop && this.target == null && cell2 != null && graph.getModel().isVertex(cell2) && graph.isCellConnectable(cell2) && graph.isEdgeValid(null, this.cell, cell2)) {
                graph.connectionHandler.connect(this.cell, cell2, me.getEvent());
              } else {
                var clone = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();
                var scale = graph.getView().scale;
                var dx = this.roundLength(this.currentDx / scale);
                var dy = this.roundLength(this.currentDy / scale);
                var target = this.target;
                if (graph.isSplitEnabled() && graph.isSplitTarget(target, this.cells, me.getEvent())) {
                  graph.splitEdge(
                    target,
                    this.cells,
                    null,
                    dx,
                    dy,
                    me.getGraphX(),
                    me.getGraphY()
                  );
                } else {
                  this.moveCells(this.cells, dx, dy, clone, this.target, me.getEvent());
                }
              }
            } else if (this.isSelectEnabled() && this.delayedSelection && this.cell != null) {
              this.selectDelayed(me);
            }
          }
          if (this.cellWasClicked) {
            this.consumeMouseEvent(mxEvent.MOUSE_UP, me);
          }
          this.reset();
        };
        mxGraphHandler.prototype.reset = function() {
          if (this.livePreviewUsed) {
            this.resetLivePreview();
            this.setHandlesVisibleForCells(
              this.graph.selectionCellsHandler.getHandledSelectionCells(),
              true
            );
          }
          this.destroyShapes();
          this.removeHint();
          this.delayedSelection = false;
          this.livePreviewActive = null;
          this.livePreviewUsed = null;
          this.cellWasClicked = false;
          this.suspended = null;
          this.currentDx = null;
          this.currentDy = null;
          this.cellCount = null;
          this.cloning = false;
          this.allCells = null;
          this.pBounds = null;
          this.guides = null;
          this.target = null;
          this.first = null;
          this.cells = null;
          this.cell = null;
        };
        mxGraphHandler.prototype.shouldRemoveCellsFromParent = function(parent, cells, evt) {
          if (this.graph.getModel().isVertex(parent)) {
            var pState = this.graph.getView().getState(parent);
            if (pState != null) {
              var pt = mxUtils.convertPoint(
                this.graph.container,
                mxEvent.getClientX(evt),
                mxEvent.getClientY(evt)
              );
              var alpha = mxUtils.toRadians(mxUtils.getValue(pState.style, mxConstants.STYLE_ROTATION) || 0);
              if (alpha != 0) {
                var cos = Math.cos(-alpha);
                var sin = Math.sin(-alpha);
                var cx = new mxPoint(pState.getCenterX(), pState.getCenterY());
                pt = mxUtils.getRotatedPoint(pt, cos, sin, cx);
              }
              return !mxUtils.contains(pState, pt.x, pt.y);
            }
          }
          return false;
        };
        mxGraphHandler.prototype.moveCells = function(cells, dx, dy, clone, target, evt) {
          if (clone) {
            cells = this.graph.getCloneableCells(cells);
          }
          var parent = this.graph.getModel().getParent(this.cell);
          if (target == null && this.isRemoveCellsFromParent() && this.shouldRemoveCellsFromParent(parent, cells, evt)) {
            target = this.graph.getDefaultParent();
          }
          clone = clone && !this.graph.isCellLocked(target || this.graph.getDefaultParent());
          this.graph.getModel().beginUpdate();
          try {
            var parents = [];
            if (!clone && target != null && this.removeEmptyParents) {
              var dict = new mxDictionary();
              for (var i = 0; i < cells.length; i++) {
                dict.put(cells[i], true);
              }
              for (var i = 0; i < cells.length; i++) {
                var par = this.graph.model.getParent(cells[i]);
                if (par != null && !dict.get(par)) {
                  dict.put(par, true);
                  parents.push(par);
                }
              }
            }
            cells = this.graph.moveCells(cells, dx, dy, clone, target, evt);
            var temp = [];
            for (var i = 0; i < parents.length; i++) {
              if (this.shouldRemoveParent(parents[i])) {
                temp.push(parents[i]);
              }
            }
            this.graph.removeCells(temp, false);
          } finally {
            this.graph.getModel().endUpdate();
          }
          if (clone) {
            this.graph.setSelectionCells(cells);
          }
          if (this.isSelectEnabled() && this.scrollOnMove) {
            this.graph.scrollCellToVisible(cells[0]);
          }
        };
        mxGraphHandler.prototype.shouldRemoveParent = function(parent) {
          var state = this.graph.view.getState(parent);
          return state != null && (this.graph.model.isEdge(state.cell) || this.graph.model.isVertex(state.cell)) && this.graph.isCellDeletable(state.cell) && this.graph.model.getChildCount(state.cell) == 0 && this.graph.isTransparentState(state);
        };
        mxGraphHandler.prototype.destroyShapes = function() {
          if (this.shape != null) {
            this.shape.destroy();
            this.shape = null;
          }
          if (this.guide != null) {
            this.guide.destroy();
            this.guide = null;
          }
          if (this.highlight != null) {
            this.highlight.destroy();
            this.highlight = null;
          }
        };
        mxGraphHandler.prototype.destroy = function() {
          this.graph.removeMouseListener(this);
          this.graph.removeListener(this.panHandler);
          if (this.escapeHandler != null) {
            this.graph.removeListener(this.escapeHandler);
            this.escapeHandler = null;
          }
          if (this.refreshHandler != null) {
            this.graph.getModel().removeListener(this.refreshHandler);
            this.graph.removeListener(this.refreshHandler);
            this.refreshHandler = null;
          }
          mxEvent.removeListener(document, "keydown", this.keyHandler);
          mxEvent.removeListener(document, "keyup", this.keyHandler);
          this.destroyShapes();
          this.removeHint();
        };
        __mxOutput.mxGraphHandler = typeof mxGraphHandler !== "undefined" ? mxGraphHandler : void 0;
        function mxPanningHandler(graph) {
          if (graph != null) {
            this.graph = graph;
            this.graph.addMouseListener(this);
            this.forcePanningHandler = mxUtils.bind(this, function(sender, evt) {
              var evtName = evt.getProperty("eventName");
              var me = evt.getProperty("event");
              if (evtName == mxEvent.MOUSE_DOWN && this.isForcePanningEvent(me)) {
                this.start(me);
                this.active = true;
                this.fireEvent(new mxEventObject(mxEvent.PAN_START, "event", me));
                me.consume();
              }
            });
            this.graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.forcePanningHandler);
            this.gestureHandler = mxUtils.bind(this, function(sender, eo) {
              if (this.isPinchEnabled()) {
                var evt = eo.getProperty("event");
                if (!mxEvent.isConsumed(evt) && evt.type == "gesturestart") {
                  this.initialScale = this.graph.view.scale;
                  if (!this.active && this.mouseDownEvent != null) {
                    this.start(this.mouseDownEvent);
                    this.mouseDownEvent = null;
                  }
                } else if (evt.type == "gestureend" && this.initialScale != null) {
                  this.initialScale = null;
                }
                if (this.initialScale != null) {
                  this.zoomGraph(evt);
                }
              }
            });
            this.graph.addListener(mxEvent.GESTURE, this.gestureHandler);
            this.mouseUpListener = mxUtils.bind(this, function() {
              if (this.active) {
                this.reset();
              }
            });
            mxEvent.addListener(document, "mouseup", this.mouseUpListener);
          }
        }
        ;
        mxPanningHandler.prototype = new mxEventSource();
        mxPanningHandler.prototype.constructor = mxPanningHandler;
        mxPanningHandler.prototype.graph = null;
        mxPanningHandler.prototype.useLeftButtonForPanning = false;
        mxPanningHandler.prototype.usePopupTrigger = true;
        mxPanningHandler.prototype.ignoreCell = false;
        mxPanningHandler.prototype.previewEnabled = true;
        mxPanningHandler.prototype.useGrid = false;
        mxPanningHandler.prototype.panningEnabled = true;
        mxPanningHandler.prototype.pinchEnabled = true;
        mxPanningHandler.prototype.maxScale = 8;
        mxPanningHandler.prototype.minScale = 0.01;
        mxPanningHandler.prototype.dx = null;
        mxPanningHandler.prototype.dy = null;
        mxPanningHandler.prototype.startX = 0;
        mxPanningHandler.prototype.startY = 0;
        mxPanningHandler.prototype.isActive = function() {
          return this.active || this.initialScale != null;
        };
        mxPanningHandler.prototype.isPanningEnabled = function() {
          return this.panningEnabled;
        };
        mxPanningHandler.prototype.setPanningEnabled = function(value) {
          this.panningEnabled = value;
        };
        mxPanningHandler.prototype.isPinchEnabled = function() {
          return this.pinchEnabled;
        };
        mxPanningHandler.prototype.setPinchEnabled = function(value) {
          this.pinchEnabled = value;
        };
        mxPanningHandler.prototype.isPanningTrigger = function(me) {
          var evt = me.getEvent();
          return this.useLeftButtonForPanning && me.getState() == null && mxEvent.isLeftMouseButton(evt) || mxEvent.isControlDown(evt) && mxEvent.isShiftDown(evt) || this.usePopupTrigger && mxEvent.isPopupTrigger(evt);
        };
        mxPanningHandler.prototype.isForcePanningEvent = function(me) {
          return this.ignoreCell || mxEvent.isMultiTouchEvent(me.getEvent());
        };
        mxPanningHandler.prototype.mouseDown = function(sender, me) {
          this.mouseDownEvent = me;
          if (!me.isConsumed() && this.isPanningEnabled() && !this.active && this.isPanningTrigger(me)) {
            this.start(me);
            this.consumePanningTrigger(me);
          }
        };
        mxPanningHandler.prototype.start = function(me) {
          this.dx0 = -this.graph.container.scrollLeft;
          this.dy0 = -this.graph.container.scrollTop;
          this.startX = me.getX();
          this.startY = me.getY();
          this.dx = null;
          this.dy = null;
          this.panningTrigger = true;
        };
        mxPanningHandler.prototype.consumePanningTrigger = function(me) {
          me.consume();
        };
        mxPanningHandler.prototype.mouseMove = function(sender, me) {
          this.dx = me.getX() - this.startX;
          this.dy = me.getY() - this.startY;
          if (this.active) {
            if (this.previewEnabled) {
              if (this.useGrid) {
                this.dx = this.graph.snap(this.dx);
                this.dy = this.graph.snap(this.dy);
              }
              this.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0);
            }
            this.fireEvent(new mxEventObject(mxEvent.PAN, "event", me));
          } else if (this.panningTrigger) {
            var tmp = this.active;
            this.active = Math.abs(this.dx) > this.graph.tolerance || Math.abs(this.dy) > this.graph.tolerance;
            if (!tmp && this.active) {
              this.fireEvent(new mxEventObject(mxEvent.PAN_START, "event", me));
            }
          }
          if (this.active || this.panningTrigger) {
            me.consume();
          }
        };
        mxPanningHandler.prototype.mouseUp = function(sender, me) {
          if (this.active) {
            if (this.dx != null && this.dy != null) {
              if (!this.graph.useScrollbarsForPanning || !mxUtils.hasScrollbars(this.graph.container)) {
                var scale = this.graph.getView().scale;
                var t = this.graph.getView().translate;
                this.graph.panGraph(0, 0);
                this.panGraph(t.x + this.dx / scale, t.y + this.dy / scale);
              }
              me.consume();
            }
            this.fireEvent(new mxEventObject(mxEvent.PAN_END, "event", me));
          }
          this.reset();
        };
        mxPanningHandler.prototype.zoomGraph = function(evt) {
          var value = Math.round(this.initialScale * evt.scale * 100) / 100;
          if (this.minScale != null) {
            value = Math.max(this.minScale, value);
          }
          if (this.maxScale != null) {
            value = Math.min(this.maxScale, value);
          }
          if (this.graph.view.scale != value) {
            this.graph.zoomTo(value);
            mxEvent.consume(evt);
          }
        };
        mxPanningHandler.prototype.reset = function() {
          this.panningTrigger = false;
          this.mouseDownEvent = null;
          this.active = false;
          this.dx = null;
          this.dy = null;
        };
        mxPanningHandler.prototype.panGraph = function(dx, dy) {
          this.graph.getView().setTranslate(dx, dy);
        };
        mxPanningHandler.prototype.destroy = function() {
          this.graph.removeMouseListener(this);
          this.graph.removeListener(this.forcePanningHandler);
          this.graph.removeListener(this.gestureHandler);
          mxEvent.removeListener(document, "mouseup", this.mouseUpListener);
        };
        __mxOutput.mxPanningHandler = typeof mxPanningHandler !== "undefined" ? mxPanningHandler : void 0;
        function mxPopupMenuHandler(graph, factoryMethod) {
          if (graph != null) {
            this.graph = graph;
            this.factoryMethod = factoryMethod;
            this.graph.addMouseListener(this);
            this.gestureHandler = mxUtils.bind(this, function(sender, eo) {
              this.inTolerance = false;
            });
            this.graph.addListener(mxEvent.GESTURE, this.gestureHandler);
            this.init();
          }
        }
        ;
        mxPopupMenuHandler.prototype = new mxPopupMenu();
        mxPopupMenuHandler.prototype.constructor = mxPopupMenuHandler;
        mxPopupMenuHandler.prototype.graph = null;
        mxPopupMenuHandler.prototype.selectOnPopup = true;
        mxPopupMenuHandler.prototype.clearSelectionOnBackground = true;
        mxPopupMenuHandler.prototype.triggerX = null;
        mxPopupMenuHandler.prototype.triggerY = null;
        mxPopupMenuHandler.prototype.screenX = null;
        mxPopupMenuHandler.prototype.screenY = null;
        mxPopupMenuHandler.prototype.init = function() {
          mxPopupMenu.prototype.init.apply(this);
          mxEvent.addGestureListeners(this.div, mxUtils.bind(this, function(evt) {
            this.graph.tooltipHandler.hide();
          }));
        };
        mxPopupMenuHandler.prototype.isSelectOnPopup = function(me) {
          return this.selectOnPopup;
        };
        mxPopupMenuHandler.prototype.mouseDown = function(sender, me) {
          if (this.isEnabled() && !mxEvent.isMultiTouchEvent(me.getEvent())) {
            this.hideMenu();
            this.triggerX = me.getGraphX();
            this.triggerY = me.getGraphY();
            this.screenX = mxEvent.getMainEvent(me.getEvent()).screenX;
            this.screenY = mxEvent.getMainEvent(me.getEvent()).screenY;
            this.popupTrigger = this.isPopupTrigger(me);
            this.inTolerance = true;
          }
        };
        mxPopupMenuHandler.prototype.mouseMove = function(sender, me) {
          if (this.inTolerance && this.screenX != null && this.screenY != null) {
            if (Math.abs(mxEvent.getMainEvent(me.getEvent()).screenX - this.screenX) > this.graph.tolerance || Math.abs(mxEvent.getMainEvent(me.getEvent()).screenY - this.screenY) > this.graph.tolerance) {
              this.inTolerance = false;
            }
          }
        };
        mxPopupMenuHandler.prototype.mouseUp = function(sender, me) {
          if (this.popupTrigger && this.inTolerance && this.triggerX != null && this.triggerY != null) {
            var cell2 = this.getCellForPopupEvent(me);
            if (this.graph.isEnabled() && this.isSelectOnPopup(me) && cell2 != null && !this.graph.isCellSelected(cell2)) {
              this.graph.setSelectionCell(cell2);
            } else if (this.clearSelectionOnBackground && cell2 == null) {
              this.graph.clearSelection();
            }
            this.graph.tooltipHandler.hide();
            var origin = mxUtils.getScrollOrigin();
            this.popup(me.getX() + origin.x + 1, me.getY() + origin.y + 1, cell2, me.getEvent());
            me.consume();
          }
          this.popupTrigger = false;
          this.inTolerance = false;
        };
        mxPopupMenuHandler.prototype.getCellForPopupEvent = function(me) {
          return me.getCell();
        };
        mxPopupMenuHandler.prototype.destroy = function() {
          this.graph.removeMouseListener(this);
          this.graph.removeListener(this.gestureHandler);
          mxPopupMenu.prototype.destroy.apply(this);
        };
        __mxOutput.mxPopupMenuHandler = typeof mxPopupMenuHandler !== "undefined" ? mxPopupMenuHandler : void 0;
        function mxCellMarker(graph, validColor, invalidColor, hotspot) {
          mxEventSource.call(this);
          if (graph != null) {
            this.graph = graph;
            this.validColor = validColor != null ? validColor : mxConstants.DEFAULT_VALID_COLOR;
            this.invalidColor = invalidColor != null ? invalidColor : mxConstants.DEFAULT_INVALID_COLOR;
            this.hotspot = hotspot != null ? hotspot : mxConstants.DEFAULT_HOTSPOT;
            this.highlight = new mxCellHighlight(graph);
          }
        }
        ;
        mxUtils.extend(mxCellMarker, mxEventSource);
        mxCellMarker.prototype.graph = null;
        mxCellMarker.prototype.enabled = true;
        mxCellMarker.prototype.hotspot = mxConstants.DEFAULT_HOTSPOT;
        mxCellMarker.prototype.hotspotEnabled = false;
        mxCellMarker.prototype.validColor = null;
        mxCellMarker.prototype.invalidColor = null;
        mxCellMarker.prototype.currentColor = null;
        mxCellMarker.prototype.validState = null;
        mxCellMarker.prototype.markedState = null;
        mxCellMarker.prototype.setEnabled = function(enabled) {
          this.enabled = enabled;
        };
        mxCellMarker.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxCellMarker.prototype.setHotspot = function(hotspot) {
          this.hotspot = hotspot;
        };
        mxCellMarker.prototype.getHotspot = function() {
          return this.hotspot;
        };
        mxCellMarker.prototype.setHotspotEnabled = function(enabled) {
          this.hotspotEnabled = enabled;
        };
        mxCellMarker.prototype.isHotspotEnabled = function() {
          return this.hotspotEnabled;
        };
        mxCellMarker.prototype.hasValidState = function() {
          return this.validState != null;
        };
        mxCellMarker.prototype.getValidState = function() {
          return this.validState;
        };
        mxCellMarker.prototype.getMarkedState = function() {
          return this.markedState;
        };
        mxCellMarker.prototype.reset = function() {
          this.validState = null;
          if (this.markedState != null) {
            this.markedState = null;
            this.unmark();
          }
        };
        mxCellMarker.prototype.process = function(me) {
          var state = null;
          if (this.isEnabled()) {
            state = this.getState(me);
            this.setCurrentState(state, me);
          }
          return state;
        };
        mxCellMarker.prototype.setCurrentState = function(state, me, color) {
          var isValid = state != null ? this.isValidState(state) : false;
          color = color != null ? color : this.getMarkerColor(me.getEvent(), state, isValid);
          if (isValid) {
            this.validState = state;
          } else {
            this.validState = null;
          }
          if (state != this.markedState || color != this.currentColor) {
            this.currentColor = color;
            if (state != null && this.currentColor != null) {
              this.markedState = state;
              this.mark();
            } else if (this.markedState != null) {
              this.markedState = null;
              this.unmark();
            }
          }
        };
        mxCellMarker.prototype.markCell = function(cell2, color) {
          var state = this.graph.getView().getState(cell2);
          if (state != null) {
            this.currentColor = color != null ? color : this.validColor;
            this.markedState = state;
            this.mark();
          }
        };
        mxCellMarker.prototype.mark = function() {
          this.highlight.setHighlightColor(this.currentColor);
          this.highlight.highlight(this.markedState);
          this.fireEvent(new mxEventObject(mxEvent.MARK, "state", this.markedState));
        };
        mxCellMarker.prototype.unmark = function() {
          this.mark();
        };
        mxCellMarker.prototype.isValidState = function(state) {
          return true;
        };
        mxCellMarker.prototype.getMarkerColor = function(evt, state, isValid) {
          return isValid ? this.validColor : this.invalidColor;
        };
        mxCellMarker.prototype.getState = function(me) {
          var view = this.graph.getView();
          var cell2 = this.getCell(me);
          var state = this.getStateToMark(view.getState(cell2));
          return state != null && this.intersects(state, me) ? state : null;
        };
        mxCellMarker.prototype.getCell = function(me) {
          return me.getCell();
        };
        mxCellMarker.prototype.getStateToMark = function(state) {
          return state;
        };
        mxCellMarker.prototype.intersects = function(state, me) {
          if (this.hotspotEnabled) {
            return mxUtils.intersectsHotspot(
              state,
              me.getGraphX(),
              me.getGraphY(),
              this.hotspot,
              mxConstants.MIN_HOTSPOT_SIZE,
              mxConstants.MAX_HOTSPOT_SIZE
            );
          }
          return true;
        };
        mxCellMarker.prototype.destroy = function() {
          this.graph.getView().removeListener(this.resetHandler);
          this.graph.getModel().removeListener(this.resetHandler);
          this.highlight.destroy();
        };
        __mxOutput.mxCellMarker = typeof mxCellMarker !== "undefined" ? mxCellMarker : void 0;
        function mxSelectionCellsHandler(graph) {
          mxEventSource.call(this);
          this.graph = graph;
          this.handlers = new mxDictionary();
          this.graph.addMouseListener(this);
          this.refreshHandler = mxUtils.bind(this, function(sender, evt) {
            if (this.isEnabled()) {
              this.refresh();
            }
          });
          this.graph.getSelectionModel().addListener(mxEvent.CHANGE, this.refreshHandler);
          this.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);
          this.graph.getView().addListener(mxEvent.SCALE, this.refreshHandler);
          this.graph.getView().addListener(mxEvent.TRANSLATE, this.refreshHandler);
          this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.refreshHandler);
          this.graph.getView().addListener(mxEvent.DOWN, this.refreshHandler);
          this.graph.getView().addListener(mxEvent.UP, this.refreshHandler);
        }
        ;
        mxUtils.extend(mxSelectionCellsHandler, mxEventSource);
        mxSelectionCellsHandler.prototype.graph = null;
        mxSelectionCellsHandler.prototype.enabled = true;
        mxSelectionCellsHandler.prototype.refreshHandler = null;
        mxSelectionCellsHandler.prototype.maxHandlers = 100;
        mxSelectionCellsHandler.prototype.handlers = null;
        mxSelectionCellsHandler.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxSelectionCellsHandler.prototype.setEnabled = function(value) {
          this.enabled = value;
        };
        mxSelectionCellsHandler.prototype.getHandler = function(cell2) {
          return this.handlers.get(cell2);
        };
        mxSelectionCellsHandler.prototype.isHandled = function(cell2) {
          return this.getHandler(cell2) != null;
        };
        mxSelectionCellsHandler.prototype.reset = function() {
          this.handlers.visit(function(key, handler) {
            handler.reset.apply(handler);
          });
        };
        mxSelectionCellsHandler.prototype.getHandledSelectionCells = function() {
          return this.graph.getSelectionCells();
        };
        mxSelectionCellsHandler.prototype.refresh = function() {
          var oldHandlers = this.handlers;
          this.handlers = new mxDictionary();
          var tmp = mxUtils.sortCells(this.getHandledSelectionCells(), false);
          for (var i = 0; i < tmp.length; i++) {
            var state = this.graph.view.getState(tmp[i]);
            if (state != null) {
              var handler = oldHandlers.remove(tmp[i]);
              if (handler != null) {
                if (handler.state != state) {
                  handler.destroy();
                  handler = null;
                } else if (!this.isHandlerActive(handler)) {
                  if (handler.refresh != null) {
                    handler.refresh();
                  }
                  handler.redraw();
                }
              }
              if (handler != null) {
                this.handlers.put(tmp[i], handler);
              }
            }
          }
          oldHandlers.visit(mxUtils.bind(this, function(key, handler2) {
            this.fireEvent(new mxEventObject(mxEvent.REMOVE, "state", handler2.state));
            handler2.destroy();
          }));
          for (var i = 0; i < tmp.length; i++) {
            var state = this.graph.view.getState(tmp[i]);
            if (state != null) {
              var handler = this.handlers.get(tmp[i]);
              if (handler == null) {
                handler = this.graph.createHandler(state);
                this.fireEvent(new mxEventObject(mxEvent.ADD, "state", state));
                this.handlers.put(tmp[i], handler);
              } else {
                handler.updateParentHighlight();
              }
            }
          }
        };
        mxSelectionCellsHandler.prototype.isHandlerActive = function(handler) {
          return handler.index != null;
        };
        mxSelectionCellsHandler.prototype.updateHandler = function(state) {
          var handler = this.handlers.remove(state.cell);
          if (handler != null) {
            var index = handler.index;
            var x = handler.startX;
            var y = handler.startY;
            handler.destroy();
            handler = this.graph.createHandler(state);
            if (handler != null) {
              this.handlers.put(state.cell, handler);
              if (index != null && x != null && y != null) {
                handler.start(x, y, index);
              }
            }
          }
        };
        mxSelectionCellsHandler.prototype.mouseDown = function(sender, me) {
          if (this.graph.isEnabled() && this.isEnabled()) {
            var args = [sender, me];
            this.handlers.visit(function(key, handler) {
              handler.mouseDown.apply(handler, args);
            });
          }
        };
        mxSelectionCellsHandler.prototype.mouseMove = function(sender, me) {
          if (this.graph.isEnabled() && this.isEnabled()) {
            var args = [sender, me];
            this.handlers.visit(function(key, handler) {
              handler.mouseMove.apply(handler, args);
            });
          }
        };
        mxSelectionCellsHandler.prototype.mouseUp = function(sender, me) {
          if (this.graph.isEnabled() && this.isEnabled()) {
            var args = [sender, me];
            this.handlers.visit(function(key, handler) {
              handler.mouseUp.apply(handler, args);
            });
          }
        };
        mxSelectionCellsHandler.prototype.destroy = function() {
          this.graph.removeMouseListener(this);
          if (this.refreshHandler != null) {
            this.graph.getSelectionModel().removeListener(this.refreshHandler);
            this.graph.getModel().removeListener(this.refreshHandler);
            this.graph.getView().removeListener(this.refreshHandler);
            this.refreshHandler = null;
          }
        };
        __mxOutput.mxSelectionCellsHandler = typeof mxSelectionCellsHandler !== "undefined" ? mxSelectionCellsHandler : void 0;
        function mxConnectionHandler(graph, factoryMethod) {
          mxEventSource.call(this);
          if (graph != null) {
            this.graph = graph;
            this.factoryMethod = factoryMethod;
            this.init();
            this.escapeHandler = mxUtils.bind(this, function(sender, evt) {
              this.reset();
            });
            this.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
          }
        }
        ;
        mxUtils.extend(mxConnectionHandler, mxEventSource);
        mxConnectionHandler.prototype.graph = null;
        mxConnectionHandler.prototype.factoryMethod = true;
        mxConnectionHandler.prototype.moveIconFront = false;
        mxConnectionHandler.prototype.moveIconBack = false;
        mxConnectionHandler.prototype.connectImage = null;
        mxConnectionHandler.prototype.targetConnectImage = false;
        mxConnectionHandler.prototype.enabled = true;
        mxConnectionHandler.prototype.select = true;
        mxConnectionHandler.prototype.createTarget = false;
        mxConnectionHandler.prototype.marker = null;
        mxConnectionHandler.prototype.constraintHandler = null;
        mxConnectionHandler.prototype.error = null;
        mxConnectionHandler.prototype.waypointsEnabled = false;
        mxConnectionHandler.prototype.ignoreMouseDown = false;
        mxConnectionHandler.prototype.first = null;
        mxConnectionHandler.prototype.connectIconOffset = new mxPoint(0, mxConstants.TOOLTIP_VERTICAL_OFFSET);
        mxConnectionHandler.prototype.edgeState = null;
        mxConnectionHandler.prototype.changeHandler = null;
        mxConnectionHandler.prototype.drillHandler = null;
        mxConnectionHandler.prototype.mouseDownCounter = 0;
        mxConnectionHandler.prototype.movePreviewAway = mxClient.IS_VML;
        mxConnectionHandler.prototype.outlineConnect = false;
        mxConnectionHandler.prototype.livePreview = false;
        mxConnectionHandler.prototype.cursor = null;
        mxConnectionHandler.prototype.insertBeforeSource = false;
        mxConnectionHandler.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxConnectionHandler.prototype.setEnabled = function(enabled) {
          this.enabled = enabled;
        };
        mxConnectionHandler.prototype.isInsertBefore = function(edge, source, target, evt, dropTarget) {
          return this.insertBeforeSource && source != target;
        };
        mxConnectionHandler.prototype.isCreateTarget = function(evt) {
          return this.createTarget;
        };
        mxConnectionHandler.prototype.setCreateTarget = function(value) {
          this.createTarget = value;
        };
        mxConnectionHandler.prototype.createShape = function() {
          var shape2 = this.livePreview && this.edgeState != null ? this.graph.cellRenderer.createShape(this.edgeState) : new mxPolyline([], mxConstants.INVALID_COLOR);
          shape2.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
          shape2.scale = this.graph.view.scale;
          shape2.pointerEvents = false;
          shape2.isDashed = true;
          shape2.init(this.graph.getView().getOverlayPane());
          mxEvent.redirectMouseEvents(shape2.node, this.graph, null);
          return shape2;
        };
        mxConnectionHandler.prototype.init = function() {
          this.graph.addMouseListener(this);
          this.marker = this.createMarker();
          this.constraintHandler = new mxConstraintHandler(this.graph);
          this.changeHandler = mxUtils.bind(this, function(sender) {
            if (this.iconState != null) {
              this.iconState = this.graph.getView().getState(this.iconState.cell);
            }
            if (this.iconState != null) {
              this.redrawIcons(this.icons, this.iconState);
              this.constraintHandler.reset();
            } else if (this.previous != null && this.graph.view.getState(this.previous.cell) == null) {
              this.reset();
            }
          });
          this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
          this.graph.getView().addListener(mxEvent.SCALE, this.changeHandler);
          this.graph.getView().addListener(mxEvent.TRANSLATE, this.changeHandler);
          this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.changeHandler);
          this.drillHandler = mxUtils.bind(this, function(sender) {
            this.reset();
          });
          this.graph.addListener(mxEvent.START_EDITING, this.drillHandler);
          this.graph.getView().addListener(mxEvent.DOWN, this.drillHandler);
          this.graph.getView().addListener(mxEvent.UP, this.drillHandler);
        };
        mxConnectionHandler.prototype.isConnectableCell = function(cell2) {
          return true;
        };
        mxConnectionHandler.prototype.createMarker = function() {
          var marker = new mxCellMarker(this.graph);
          marker.hotspotEnabled = true;
          marker.getCell = mxUtils.bind(this, function(me) {
            var cell2 = mxCellMarker.prototype.getCell.apply(marker, arguments);
            this.error = null;
            if (cell2 == null && this.currentPoint != null) {
              cell2 = this.graph.getCellAt(this.currentPoint.x, this.currentPoint.y);
            }
            if (cell2 != null && !this.graph.isCellConnectable(cell2)) {
              var parent = this.graph.getModel().getParent(cell2);
              if (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent)) {
                cell2 = parent;
              }
            }
            if (this.graph.isSwimlane(cell2) && this.currentPoint != null && this.graph.hitsSwimlaneContent(cell2, this.currentPoint.x, this.currentPoint.y) || !this.isConnectableCell(cell2)) {
              cell2 = null;
            }
            if (cell2 != null) {
              if (this.isConnecting()) {
                if (this.previous != null) {
                  this.error = this.validateConnection(this.previous.cell, cell2);
                  if (this.error != null && this.error.length == 0) {
                    cell2 = null;
                    if (this.isCreateTarget(me.getEvent())) {
                      this.error = null;
                    }
                  }
                }
              } else if (!this.isValidSource(cell2, me)) {
                cell2 = null;
              }
            } else if (this.isConnecting() && !this.isCreateTarget(me.getEvent()) && !this.graph.allowDanglingEdges) {
              this.error = "";
            }
            return cell2;
          });
          marker.isValidState = mxUtils.bind(this, function(state) {
            if (this.isConnecting()) {
              return this.error == null;
            } else {
              return mxCellMarker.prototype.isValidState.apply(marker, arguments);
            }
          });
          marker.getMarkerColor = mxUtils.bind(this, function(evt, state, isValid) {
            return this.connectImage == null || this.isConnecting() ? mxCellMarker.prototype.getMarkerColor.apply(marker, arguments) : null;
          });
          marker.intersects = mxUtils.bind(this, function(state, evt) {
            if (this.connectImage != null || this.isConnecting()) {
              return true;
            }
            return mxCellMarker.prototype.intersects.apply(marker, arguments);
          });
          return marker;
        };
        mxConnectionHandler.prototype.start = function(state, x, y, edgeState) {
          this.previous = state;
          this.first = new mxPoint(x, y);
          this.edgeState = edgeState != null ? edgeState : this.createEdgeState(null);
          this.marker.currentColor = this.marker.validColor;
          this.marker.markedState = state;
          this.marker.mark();
          this.fireEvent(new mxEventObject(mxEvent.START, "state", this.previous));
        };
        mxConnectionHandler.prototype.isConnecting = function() {
          return this.first != null && this.shape != null;
        };
        mxConnectionHandler.prototype.isValidSource = function(cell2, me) {
          return this.graph.isValidSource(cell2);
        };
        mxConnectionHandler.prototype.isValidTarget = function(cell2) {
          return true;
        };
        mxConnectionHandler.prototype.validateConnection = function(source, target) {
          if (!this.isValidTarget(target)) {
            return "";
          }
          return this.graph.getEdgeValidationError(null, source, target);
        };
        mxConnectionHandler.prototype.getConnectImage = function(state) {
          return this.connectImage;
        };
        mxConnectionHandler.prototype.isMoveIconToFrontForState = function(state) {
          if (state.text != null && state.text.node.parentNode == this.graph.container) {
            return true;
          }
          return this.moveIconFront;
        };
        mxConnectionHandler.prototype.createIcons = function(state) {
          var image = this.getConnectImage(state);
          if (image != null && state != null) {
            this.iconState = state;
            var icons = [];
            var bounds = new mxRectangle(0, 0, image.width, image.height);
            var icon = new mxImageShape(bounds, image.src, null, null, 0);
            icon.preserveImageAspect = false;
            if (this.isMoveIconToFrontForState(state)) {
              icon.dialect = mxConstants.DIALECT_STRICTHTML;
              icon.init(this.graph.container);
            } else {
              icon.dialect = this.graph.dialect == mxConstants.DIALECT_SVG ? mxConstants.DIALECT_SVG : mxConstants.DIALECT_VML;
              icon.init(this.graph.getView().getOverlayPane());
              if (this.moveIconBack && icon.node.previousSibling != null) {
                icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);
              }
            }
            icon.node.style.cursor = mxConstants.CURSOR_CONNECT;
            var getState = mxUtils.bind(this, function() {
              return this.currentState != null ? this.currentState : state;
            });
            var mouseDown = mxUtils.bind(this, function(evt) {
              if (!mxEvent.isConsumed(evt)) {
                this.icon = icon;
                this.graph.fireMouseEvent(
                  mxEvent.MOUSE_DOWN,
                  new mxMouseEvent(evt, getState())
                );
              }
            });
            mxEvent.redirectMouseEvents(icon.node, this.graph, getState, mouseDown);
            icons.push(icon);
            this.redrawIcons(icons, this.iconState);
            return icons;
          }
          return null;
        };
        mxConnectionHandler.prototype.redrawIcons = function(icons, state) {
          if (icons != null && icons[0] != null && state != null) {
            var pos = this.getIconPosition(icons[0], state);
            icons[0].bounds.x = pos.x;
            icons[0].bounds.y = pos.y;
            icons[0].redraw();
          }
        };
        mxConnectionHandler.prototype.getIconPosition = function(icon, state) {
          var scale = this.graph.getView().scale;
          var cx = state.getCenterX();
          var cy = state.getCenterY();
          if (this.graph.isSwimlane(state.cell)) {
            var size = this.graph.getStartSize(state.cell);
            cx = size.width != 0 ? state.x + size.width * scale / 2 : cx;
            cy = size.height != 0 ? state.y + size.height * scale / 2 : cy;
            var alpha = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0);
            if (alpha != 0) {
              var cos = Math.cos(alpha);
              var sin = Math.sin(alpha);
              var ct = new mxPoint(state.getCenterX(), state.getCenterY());
              var pt = mxUtils.getRotatedPoint(new mxPoint(cx, cy), cos, sin, ct);
              cx = pt.x;
              cy = pt.y;
            }
          }
          return new mxPoint(
            cx - icon.bounds.width / 2,
            cy - icon.bounds.height / 2
          );
        };
        mxConnectionHandler.prototype.destroyIcons = function() {
          if (this.icons != null) {
            for (var i = 0; i < this.icons.length; i++) {
              this.icons[i].destroy();
            }
            this.icons = null;
            this.icon = null;
            this.selectedIcon = null;
            this.iconState = null;
          }
        };
        mxConnectionHandler.prototype.isStartEvent = function(me) {
          return this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null || this.previous != null && this.error == null && (this.icons == null || this.icons != null && this.icon != null);
        };
        mxConnectionHandler.prototype.mouseDown = function(sender, me) {
          this.mouseDownCounter++;
          if (this.isEnabled() && this.graph.isEnabled() && !me.isConsumed() && !this.isConnecting() && this.isStartEvent(me)) {
            if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null && this.constraintHandler.currentPoint != null) {
              this.sourceConstraint = this.constraintHandler.currentConstraint;
              this.previous = this.constraintHandler.currentFocus;
              this.first = this.constraintHandler.currentPoint.clone();
            } else {
              this.first = new mxPoint(me.getGraphX(), me.getGraphY());
            }
            this.edgeState = this.createEdgeState(me);
            this.mouseDownCounter = 1;
            if (this.waypointsEnabled && this.shape == null) {
              this.waypoints = null;
              this.shape = this.createShape();
              if (this.edgeState != null) {
                this.shape.apply(this.edgeState);
              }
            }
            if (this.previous == null && this.edgeState != null) {
              var pt = this.graph.getPointForEvent(me.getEvent());
              this.edgeState.cell.geometry.setTerminalPoint(pt, true);
            }
            this.fireEvent(new mxEventObject(mxEvent.START, "state", this.previous));
            me.consume();
          }
          this.selectedIcon = this.icon;
          this.icon = null;
        };
        mxConnectionHandler.prototype.isImmediateConnectSource = function(state) {
          return !this.graph.isCellMovable(state.cell);
        };
        mxConnectionHandler.prototype.createEdgeState = function(me) {
          return null;
        };
        mxConnectionHandler.prototype.isOutlineConnectEvent = function(me) {
          var offset = mxUtils.getOffset(this.graph.container);
          var evt = me.getEvent();
          var clientX = mxEvent.getClientX(evt);
          var clientY = mxEvent.getClientY(evt);
          var doc = document.documentElement;
          var left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
          var top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
          var gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;
          var gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;
          return this.outlineConnect && !mxEvent.isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || mxEvent.isAltDown(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX != clientX || gridY != clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));
        };
        mxConnectionHandler.prototype.updateCurrentState = function(me, point) {
          this.constraintHandler.update(me, this.first == null, false, this.first == null || me.isSource(this.marker.highlight.shape) ? null : point);
          if (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null) {
            if (this.marker.highlight != null && this.marker.highlight.state != null && this.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell) {
              if (this.marker.highlight.shape.stroke != "transparent") {
                this.marker.highlight.shape.stroke = "transparent";
                this.marker.highlight.repaint();
              }
            } else {
              this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent");
            }
            if (this.previous != null) {
              this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);
              if (this.error == null) {
                this.currentState = this.constraintHandler.currentFocus;
              }
              if (this.error != null || this.currentState != null && !this.isCellEnabled(this.currentState.cell)) {
                this.constraintHandler.reset();
              }
            }
          } else {
            if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {
              this.marker.reset();
              this.currentState = null;
            } else {
              this.marker.process(me);
              this.currentState = this.marker.getValidState();
            }
            if (this.currentState != null && !this.isCellEnabled(this.currentState.cell)) {
              this.constraintHandler.reset();
              this.marker.reset();
              this.currentState = null;
            }
            var outline = this.isOutlineConnectEvent(me);
            if (this.currentState != null && outline) {
              if (me.isSource(this.marker.highlight.shape)) {
                point = new mxPoint(me.getGraphX(), me.getGraphY());
              }
              var constraint = this.graph.getOutlineConstraint(point, this.currentState, me);
              this.constraintHandler.setFocus(me, this.currentState, false);
              this.constraintHandler.currentConstraint = constraint;
              this.constraintHandler.currentPoint = point;
            }
            if (this.outlineConnect) {
              if (this.marker.highlight != null && this.marker.highlight.shape != null) {
                var s = this.graph.view.scale;
                if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
                  this.marker.highlight.shape.stroke = mxConstants.OUTLINE_HIGHLIGHT_COLOR;
                  this.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;
                  this.marker.highlight.repaint();
                } else if (this.marker.hasValidState()) {
                  if (this.graph.isCellConnectable(me.getCell()) && this.marker.getValidState() != me.getState()) {
                    this.marker.highlight.shape.stroke = "transparent";
                    this.currentState = null;
                  } else {
                    this.marker.highlight.shape.stroke = mxConstants.DEFAULT_VALID_COLOR;
                  }
                  this.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / s / s;
                  this.marker.highlight.repaint();
                }
              }
            }
          }
        };
        mxConnectionHandler.prototype.isCellEnabled = function(cell2) {
          return true;
        };
        mxConnectionHandler.prototype.convertWaypoint = function(point) {
          var scale = this.graph.getView().getScale();
          var tr = this.graph.getView().getTranslate();
          point.x = point.x / scale - tr.x;
          point.y = point.y / scale - tr.y;
        };
        mxConnectionHandler.prototype.snapToPreview = function(me, point) {
          if (!mxEvent.isAltDown(me.getEvent()) && this.previous != null) {
            var tol = this.graph.gridSize * this.graph.view.scale / 2;
            var tmp = this.sourceConstraint != null ? this.first : new mxPoint(this.previous.getCenterX(), this.previous.getCenterY());
            if (Math.abs(tmp.x - me.getGraphX()) < tol) {
              point.x = tmp.x;
            }
            if (Math.abs(tmp.y - me.getGraphY()) < tol) {
              point.y = tmp.y;
            }
          }
        };
        mxConnectionHandler.prototype.mouseMove = function(sender, me) {
          if (!me.isConsumed() && (this.ignoreMouseDown || this.first != null || !this.graph.isMouseDown)) {
            if (!this.isEnabled() && this.currentState != null) {
              this.destroyIcons();
              this.currentState = null;
            }
            var view = this.graph.getView();
            var scale = view.scale;
            var tr = view.translate;
            var point = new mxPoint(me.getGraphX(), me.getGraphY());
            this.error = null;
            if (this.graph.isGridEnabledEvent(me.getEvent())) {
              point = new mxPoint(
                (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale,
                (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale
              );
            }
            this.snapToPreview(me, point);
            this.currentPoint = point;
            if ((this.first != null || this.isEnabled() && this.graph.isEnabled()) && (this.shape != null || this.first == null || Math.abs(me.getGraphX() - this.first.x) > this.graph.tolerance || Math.abs(me.getGraphY() - this.first.y) > this.graph.tolerance)) {
              this.updateCurrentState(me, point);
            }
            if (this.first != null) {
              var constraint = null;
              var current = point;
              if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null && this.constraintHandler.currentPoint != null) {
                constraint = this.constraintHandler.currentConstraint;
                current = this.constraintHandler.currentPoint.clone();
              } else if (this.previous != null && !this.graph.isIgnoreTerminalEvent(me.getEvent()) && mxEvent.isShiftDown(me.getEvent())) {
                if (Math.abs(this.previous.getCenterX() - point.x) < Math.abs(this.previous.getCenterY() - point.y)) {
                  point.x = this.previous.getCenterX();
                } else {
                  point.y = this.previous.getCenterY();
                }
              }
              var pt2 = this.first;
              if (this.selectedIcon != null) {
                var w2 = this.selectedIcon.bounds.width;
                var h2 = this.selectedIcon.bounds.height;
                if (this.currentState != null && this.targetConnectImage) {
                  var pos = this.getIconPosition(this.selectedIcon, this.currentState);
                  this.selectedIcon.bounds.x = pos.x;
                  this.selectedIcon.bounds.y = pos.y;
                } else {
                  var bounds = new mxRectangle(
                    me.getGraphX() + this.connectIconOffset.x,
                    me.getGraphY() + this.connectIconOffset.y,
                    w2,
                    h2
                  );
                  this.selectedIcon.bounds = bounds;
                }
                this.selectedIcon.redraw();
              }
              if (this.edgeState != null) {
                this.updateEdgeState(current, constraint);
                current = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];
                pt2 = this.edgeState.absolutePoints[0];
              } else {
                if (this.currentState != null) {
                  if (this.constraintHandler.currentConstraint == null) {
                    var tmp = this.getTargetPerimeterPoint(this.currentState, me);
                    if (tmp != null) {
                      current = tmp;
                    }
                  }
                }
                if (this.sourceConstraint == null && this.previous != null) {
                  var next = this.waypoints != null && this.waypoints.length > 0 ? this.waypoints[0] : current;
                  var tmp = this.getSourcePerimeterPoint(this.previous, next, me);
                  if (tmp != null) {
                    pt2 = tmp;
                  }
                }
              }
              if (this.currentState == null && this.movePreviewAway) {
                var tmp = pt2;
                if (this.edgeState != null && this.edgeState.absolutePoints.length >= 2) {
                  var tmp2 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];
                  if (tmp2 != null) {
                    tmp = tmp2;
                  }
                }
                var dx = current.x - tmp.x;
                var dy = current.y - tmp.y;
                var len = Math.sqrt(dx * dx + dy * dy);
                if (len == 0) {
                  return;
                }
                this.originalPoint = current.clone();
                current.x -= dx * 4 / len;
                current.y -= dy * 4 / len;
              } else {
                this.originalPoint = null;
              }
              if (this.shape == null) {
                var dx = Math.abs(me.getGraphX() - this.first.x);
                var dy = Math.abs(me.getGraphY() - this.first.y);
                if (dx > this.graph.tolerance || dy > this.graph.tolerance) {
                  this.shape = this.createShape();
                  if (this.edgeState != null) {
                    this.shape.apply(this.edgeState);
                  }
                  this.updateCurrentState(me, point);
                }
              }
              if (this.shape != null) {
                if (this.edgeState != null) {
                  this.shape.points = this.edgeState.absolutePoints;
                } else {
                  var pts = [pt2];
                  if (this.waypoints != null) {
                    pts = pts.concat(this.waypoints);
                  }
                  pts.push(current);
                  this.shape.points = pts;
                }
                this.drawPreview();
              }
              if (this.cursor != null) {
                this.graph.container.style.cursor = this.cursor;
              }
              mxEvent.consume(me.getEvent());
              me.consume();
            } else if (!this.isEnabled() || !this.graph.isEnabled()) {
              this.constraintHandler.reset();
            } else if (this.previous != this.currentState && this.edgeState == null) {
              this.destroyIcons();
              if (this.currentState != null && this.error == null && this.constraintHandler.currentConstraint == null) {
                this.icons = this.createIcons(this.currentState);
                if (this.icons == null) {
                  this.currentState.setCursor(mxConstants.CURSOR_CONNECT);
                  me.consume();
                }
              }
              this.previous = this.currentState;
            } else if (this.previous == this.currentState && this.currentState != null && this.icons == null && !this.graph.isMouseDown) {
              me.consume();
            }
            if (!this.graph.isMouseDown && this.currentState != null && this.icons != null) {
              var hitsIcon = false;
              var target = me.getSource();
              for (var i = 0; i < this.icons.length && !hitsIcon; i++) {
                hitsIcon = target == this.icons[i].node || target.parentNode == this.icons[i].node;
              }
              if (!hitsIcon) {
                this.updateIcons(this.currentState, this.icons, me);
              }
            }
          } else {
            this.constraintHandler.reset();
          }
        };
        mxConnectionHandler.prototype.updateEdgeState = function(current, constraint) {
          if (this.sourceConstraint != null && this.sourceConstraint.point != null) {
            this.edgeState.style[mxConstants.STYLE_EXIT_X] = this.sourceConstraint.point.x;
            this.edgeState.style[mxConstants.STYLE_EXIT_Y] = this.sourceConstraint.point.y;
          }
          if (constraint != null && constraint.point != null) {
            this.edgeState.style[mxConstants.STYLE_ENTRY_X] = constraint.point.x;
            this.edgeState.style[mxConstants.STYLE_ENTRY_Y] = constraint.point.y;
          } else {
            delete this.edgeState.style[mxConstants.STYLE_ENTRY_X];
            delete this.edgeState.style[mxConstants.STYLE_ENTRY_Y];
          }
          this.edgeState.absolutePoints = [null, this.currentState != null ? null : current];
          this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);
          if (this.currentState != null) {
            if (constraint == null) {
              constraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);
            }
            this.edgeState.setAbsoluteTerminalPoint(null, false);
            this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);
          }
          var realPoints = null;
          if (this.waypoints != null) {
            realPoints = [];
            for (var i = 0; i < this.waypoints.length; i++) {
              var pt = this.waypoints[i].clone();
              this.convertWaypoint(pt);
              realPoints[i] = pt;
            }
          }
          this.graph.view.updatePoints(this.edgeState, realPoints, this.previous, this.currentState);
          this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);
        };
        mxConnectionHandler.prototype.getTargetPerimeterPoint = function(state, me) {
          var result2 = null;
          var view = state.view;
          var targetPerimeter = view.getPerimeterFunction(state);
          if (targetPerimeter != null) {
            var next = this.waypoints != null && this.waypoints.length > 0 ? this.waypoints[this.waypoints.length - 1] : new mxPoint(this.previous.getCenterX(), this.previous.getCenterY());
            var tmp = targetPerimeter(
              view.getPerimeterBounds(state),
              this.edgeState,
              next,
              false
            );
            if (tmp != null) {
              result2 = tmp;
            }
          } else {
            result2 = new mxPoint(state.getCenterX(), state.getCenterY());
          }
          return result2;
        };
        mxConnectionHandler.prototype.getSourcePerimeterPoint = function(state, next, me) {
          var result2 = null;
          var view = state.view;
          var sourcePerimeter = view.getPerimeterFunction(state);
          var c = new mxPoint(state.getCenterX(), state.getCenterY());
          if (sourcePerimeter != null) {
            var theta = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0);
            var rad = -theta * (Math.PI / 180);
            if (theta != 0) {
              next = mxUtils.getRotatedPoint(new mxPoint(next.x, next.y), Math.cos(rad), Math.sin(rad), c);
            }
            var tmp = sourcePerimeter(view.getPerimeterBounds(state), state, next, false);
            if (tmp != null) {
              if (theta != 0) {
                tmp = mxUtils.getRotatedPoint(new mxPoint(tmp.x, tmp.y), Math.cos(-rad), Math.sin(-rad), c);
              }
              result2 = tmp;
            }
          } else {
            result2 = c;
          }
          return result2;
        };
        mxConnectionHandler.prototype.updateIcons = function(state, icons, me) {
        };
        mxConnectionHandler.prototype.isStopEvent = function(me) {
          return me.getState() != null;
        };
        mxConnectionHandler.prototype.addWaypointForEvent = function(me) {
          var point = mxUtils.convertPoint(this.graph.container, me.getX(), me.getY());
          var dx = Math.abs(point.x - this.first.x);
          var dy = Math.abs(point.y - this.first.y);
          var addPoint = this.waypoints != null || this.mouseDownCounter > 1 && (dx > this.graph.tolerance || dy > this.graph.tolerance);
          if (addPoint) {
            if (this.waypoints == null) {
              this.waypoints = [];
            }
            var scale = this.graph.view.scale;
            var point = new mxPoint(
              this.graph.snap(me.getGraphX() / scale) * scale,
              this.graph.snap(me.getGraphY() / scale) * scale
            );
            this.waypoints.push(point);
          }
        };
        mxConnectionHandler.prototype.checkConstraints = function(c1, c2) {
          return c1 == null || c2 == null || c1.point == null || c2.point == null || !c1.point.equals(c2.point) || c1.dx != c2.dx || c1.dy != c2.dy || c1.perimeter != c2.perimeter;
        };
        mxConnectionHandler.prototype.mouseUp = function(sender, me) {
          if (!me.isConsumed() && this.isConnecting()) {
            if (this.waypointsEnabled && !this.isStopEvent(me)) {
              this.addWaypointForEvent(me);
              me.consume();
              return;
            }
            var c1 = this.sourceConstraint;
            var c2 = this.constraintHandler.currentConstraint;
            var source = this.previous != null ? this.previous.cell : null;
            var target = null;
            if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
              target = this.constraintHandler.currentFocus.cell;
            }
            if (target == null && this.currentState != null) {
              target = this.currentState.cell;
            }
            if (this.error == null && (source == null || target == null || source != target || this.checkConstraints(c1, c2))) {
              this.connect(source, target, me.getEvent(), me.getCell());
            } else {
              if (this.previous != null && this.marker.validState != null && this.previous.cell == this.marker.validState.cell) {
                this.graph.selectCellForEvent(this.marker.source, me.getEvent());
              }
              if (this.error != null && this.error.length > 0) {
                this.graph.validationAlert(this.error);
              }
            }
            this.destroyIcons();
            me.consume();
          }
          if (this.first != null) {
            this.reset();
          }
        };
        mxConnectionHandler.prototype.reset = function() {
          if (this.shape != null) {
            this.shape.destroy();
            this.shape = null;
          }
          if (this.cursor != null && this.graph.container != null) {
            this.graph.container.style.cursor = "";
          }
          this.destroyIcons();
          this.marker.reset();
          this.constraintHandler.reset();
          this.originalPoint = null;
          this.currentPoint = null;
          this.edgeState = null;
          this.previous = null;
          this.error = null;
          this.sourceConstraint = null;
          this.mouseDownCounter = 0;
          this.first = null;
          this.fireEvent(new mxEventObject(mxEvent.RESET));
        };
        mxConnectionHandler.prototype.drawPreview = function() {
          this.updatePreview(this.error == null);
          this.shape.redraw();
        };
        mxConnectionHandler.prototype.updatePreview = function(valid) {
          this.shape.strokewidth = this.getEdgeWidth(valid);
          this.shape.stroke = this.getEdgeColor(valid);
        };
        mxConnectionHandler.prototype.getEdgeColor = function(valid) {
          return valid ? mxConstants.VALID_COLOR : mxConstants.INVALID_COLOR;
        };
        mxConnectionHandler.prototype.getEdgeWidth = function(valid) {
          return valid ? 3 : 1;
        };
        mxConnectionHandler.prototype.connect = function(source, target, evt, dropTarget) {
          if (target != null || this.isCreateTarget(evt) || this.graph.allowDanglingEdges) {
            var model = this.graph.getModel();
            var terminalInserted = false;
            var edge = null;
            model.beginUpdate();
            try {
              if (source != null && target == null && !this.graph.isIgnoreTerminalEvent(evt) && this.isCreateTarget(evt)) {
                target = this.createTargetVertex(evt, source);
                if (target != null) {
                  dropTarget = this.graph.getDropTarget([target], evt, dropTarget);
                  terminalInserted = true;
                  if (dropTarget == null || !this.graph.getModel().isEdge(dropTarget)) {
                    var pstate = this.graph.getView().getState(dropTarget);
                    if (pstate != null) {
                      var tmp = model.getGeometry(target);
                      tmp.x -= pstate.origin.x;
                      tmp.y -= pstate.origin.y;
                    }
                  } else {
                    dropTarget = this.graph.getDefaultParent();
                  }
                  this.graph.addCell(target, dropTarget);
                }
              }
              var parent = this.graph.getDefaultParent();
              if (source != null && target != null && model.getParent(source) == model.getParent(target) && model.getParent(model.getParent(source)) != model.getRoot()) {
                parent = model.getParent(source);
                if (source.geometry != null && source.geometry.relative && (target.geometry != null && target.geometry.relative)) {
                  parent = model.getParent(parent);
                }
              }
              var value = null;
              var style = null;
              if (this.edgeState != null) {
                value = this.edgeState.cell.value;
                style = this.edgeState.cell.style;
              }
              edge = this.insertEdge(parent, null, value, source, target, style);
              if (edge != null) {
                this.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);
                this.graph.setConnectionConstraint(edge, target, false, this.constraintHandler.currentConstraint);
                if (this.edgeState != null) {
                  model.setGeometry(edge, this.edgeState.cell.geometry);
                }
                var parent = model.getParent(source);
                if (this.isInsertBefore(edge, source, target, evt, dropTarget)) {
                  var index = null;
                  var tmp = source;
                  while (tmp.parent != null && tmp.geometry != null && tmp.geometry.relative && tmp.parent != edge.parent) {
                    tmp = this.graph.model.getParent(tmp);
                  }
                  if (tmp != null && tmp.parent != null && tmp.parent == edge.parent) {
                    model.add(parent, edge, tmp.parent.getIndex(tmp));
                  }
                }
                var geo = model.getGeometry(edge);
                if (geo == null) {
                  geo = new mxGeometry();
                  geo.relative = true;
                  model.setGeometry(edge, geo);
                }
                if (this.waypoints != null && this.waypoints.length > 0) {
                  var s = this.graph.view.scale;
                  var tr = this.graph.view.translate;
                  geo.points = [];
                  for (var i = 0; i < this.waypoints.length; i++) {
                    var pt = this.waypoints[i];
                    geo.points.push(new mxPoint(pt.x / s - tr.x, pt.y / s - tr.y));
                  }
                }
                if (target == null) {
                  var t = this.graph.view.translate;
                  var s = this.graph.view.scale;
                  var pt = this.originalPoint != null ? new mxPoint(this.originalPoint.x / s - t.x, this.originalPoint.y / s - t.y) : new mxPoint(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);
                  pt.x -= this.graph.panDx / this.graph.view.scale;
                  pt.y -= this.graph.panDy / this.graph.view.scale;
                  geo.setTerminalPoint(pt, false);
                }
                this.fireEvent(new mxEventObject(
                  mxEvent.CONNECT,
                  "cell",
                  edge,
                  "terminal",
                  target,
                  "event",
                  evt,
                  "target",
                  dropTarget,
                  "terminalInserted",
                  terminalInserted
                ));
              }
            } catch (e) {
              mxLog.show();
              mxLog.debug(e.message);
            } finally {
              model.endUpdate();
            }
            if (this.select) {
              this.selectCells(edge, terminalInserted ? target : null);
            }
          }
        };
        mxConnectionHandler.prototype.selectCells = function(edge, target) {
          this.graph.setSelectionCell(edge);
        };
        mxConnectionHandler.prototype.insertEdge = function(parent, id, value, source, target, style) {
          if (this.factoryMethod == null) {
            return this.graph.insertEdge(parent, id, value, source, target, style);
          } else {
            var edge = this.createEdge(value, source, target, style);
            edge = this.graph.addEdge(edge, parent, source, target);
            return edge;
          }
        };
        mxConnectionHandler.prototype.createTargetVertex = function(evt, source) {
          var geo = this.graph.getCellGeometry(source);
          while (geo != null && geo.relative) {
            source = this.graph.getModel().getParent(source);
            geo = this.graph.getCellGeometry(source);
          }
          var clone = this.graph.cloneCell(source);
          var geo = this.graph.getModel().getGeometry(clone);
          if (geo != null) {
            var t = this.graph.view.translate;
            var s = this.graph.view.scale;
            var point = new mxPoint(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);
            geo.x = Math.round(point.x - geo.width / 2 - this.graph.panDx / s);
            geo.y = Math.round(point.y - geo.height / 2 - this.graph.panDy / s);
            var tol = this.getAlignmentTolerance();
            if (tol > 0) {
              var sourceState = this.graph.view.getState(source);
              if (sourceState != null) {
                var x = sourceState.x / s - t.x;
                var y = sourceState.y / s - t.y;
                if (Math.abs(x - geo.x) <= tol) {
                  geo.x = Math.round(x);
                }
                if (Math.abs(y - geo.y) <= tol) {
                  geo.y = Math.round(y);
                }
              }
            }
          }
          return clone;
        };
        mxConnectionHandler.prototype.getAlignmentTolerance = function(evt) {
          return this.graph.isGridEnabled() ? this.graph.gridSize / 2 : this.graph.tolerance;
        };
        mxConnectionHandler.prototype.createEdge = function(value, source, target, style) {
          var edge = null;
          if (this.factoryMethod != null) {
            edge = this.factoryMethod(source, target, style);
          }
          if (edge == null) {
            edge = new mxCell(value || "");
            edge.setEdge(true);
            edge.setStyle(style);
            var geo = new mxGeometry();
            geo.relative = true;
            edge.setGeometry(geo);
          }
          return edge;
        };
        mxConnectionHandler.prototype.destroy = function() {
          this.graph.removeMouseListener(this);
          if (this.shape != null) {
            this.shape.destroy();
            this.shape = null;
          }
          if (this.marker != null) {
            this.marker.destroy();
            this.marker = null;
          }
          if (this.constraintHandler != null) {
            this.constraintHandler.destroy();
            this.constraintHandler = null;
          }
          if (this.changeHandler != null) {
            this.graph.getModel().removeListener(this.changeHandler);
            this.graph.getView().removeListener(this.changeHandler);
            this.changeHandler = null;
          }
          if (this.drillHandler != null) {
            this.graph.removeListener(this.drillHandler);
            this.graph.getView().removeListener(this.drillHandler);
            this.drillHandler = null;
          }
          if (this.escapeHandler != null) {
            this.graph.removeListener(this.escapeHandler);
            this.escapeHandler = null;
          }
        };
        __mxOutput.mxConnectionHandler = typeof mxConnectionHandler !== "undefined" ? mxConnectionHandler : void 0;
        function mxConstraintHandler(graph) {
          this.graph = graph;
          this.resetHandler = mxUtils.bind(this, function(sender, evt) {
            if (this.currentFocus != null && this.graph.view.getState(this.currentFocus.cell) == null) {
              this.reset();
            } else {
              this.redraw();
            }
          });
          this.graph.model.addListener(mxEvent.CHANGE, this.resetHandler);
          this.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.resetHandler);
          this.graph.view.addListener(mxEvent.TRANSLATE, this.resetHandler);
          this.graph.view.addListener(mxEvent.SCALE, this.resetHandler);
          this.graph.addListener(mxEvent.ROOT, this.resetHandler);
        }
        ;
        mxConstraintHandler.prototype.pointImage = new mxImage(mxClient.imageBasePath + "/point.gif", 5, 5);
        mxConstraintHandler.prototype.graph = null;
        mxConstraintHandler.prototype.enabled = true;
        mxConstraintHandler.prototype.highlightColor = mxConstants.DEFAULT_VALID_COLOR;
        mxConstraintHandler.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxConstraintHandler.prototype.setEnabled = function(enabled) {
          this.enabled = enabled;
        };
        mxConstraintHandler.prototype.reset = function() {
          if (this.focusIcons != null) {
            for (var i = 0; i < this.focusIcons.length; i++) {
              this.focusIcons[i].destroy();
            }
            this.focusIcons = null;
          }
          if (this.focusHighlight != null) {
            this.focusHighlight.destroy();
            this.focusHighlight = null;
          }
          this.currentConstraint = null;
          this.currentFocusArea = null;
          this.currentPoint = null;
          this.currentFocus = null;
          this.focusPoints = null;
        };
        mxConstraintHandler.prototype.getTolerance = function(me) {
          return this.graph.getTolerance();
        };
        mxConstraintHandler.prototype.getImageForConstraint = function(state, constraint, point) {
          return this.pointImage;
        };
        mxConstraintHandler.prototype.isEventIgnored = function(me, source) {
          return false;
        };
        mxConstraintHandler.prototype.isStateIgnored = function(state, source) {
          return false;
        };
        mxConstraintHandler.prototype.destroyIcons = function() {
          if (this.focusIcons != null) {
            for (var i = 0; i < this.focusIcons.length; i++) {
              this.focusIcons[i].destroy();
            }
            this.focusIcons = null;
            this.focusPoints = null;
          }
        };
        mxConstraintHandler.prototype.destroyFocusHighlight = function() {
          if (this.focusHighlight != null) {
            this.focusHighlight.destroy();
            this.focusHighlight = null;
          }
        };
        mxConstraintHandler.prototype.isKeepFocusEvent = function(me) {
          return mxEvent.isShiftDown(me.getEvent());
        };
        mxConstraintHandler.prototype.getCellForEvent = function(me, point) {
          var cell2 = me.getCell();
          if (cell2 == null && point != null && (me.getGraphX() != point.x || me.getGraphY() != point.y)) {
            cell2 = this.graph.getCellAt(point.x, point.y);
          }
          if (cell2 != null && !this.graph.isCellConnectable(cell2)) {
            var parent = this.graph.getModel().getParent(cell2);
            if (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent)) {
              cell2 = parent;
            }
          }
          return this.graph.isCellLocked(cell2) ? null : cell2;
        };
        mxConstraintHandler.prototype.update = function(me, source, existingEdge, point) {
          if (this.isEnabled() && !this.isEventIgnored(me)) {
            if (this.mouseleaveHandler == null && this.graph.container != null) {
              this.mouseleaveHandler = mxUtils.bind(this, function() {
                this.reset();
              });
              mxEvent.addListener(this.graph.container, "mouseleave", this.resetHandler);
            }
            var tol = this.getTolerance(me);
            var x = point != null ? point.x : me.getGraphX();
            var y = point != null ? point.y : me.getGraphY();
            var grid = new mxRectangle(x - tol, y - tol, 2 * tol, 2 * tol);
            var mouse = new mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol);
            var state = this.graph.view.getState(this.getCellForEvent(me, point));
            if (!this.isKeepFocusEvent(me) && (this.currentFocusArea == null || this.currentFocus == null || state != null || !this.graph.getModel().isVertex(this.currentFocus.cell) || !mxUtils.intersects(this.currentFocusArea, mouse)) && state != this.currentFocus) {
              this.currentFocusArea = null;
              this.currentFocus = null;
              this.setFocus(me, state, source);
            }
            this.currentConstraint = null;
            this.currentPoint = null;
            var minDistSq = null;
            if (this.focusIcons != null && this.constraints != null && (state == null || this.currentFocus == state)) {
              var cx = mouse.getCenterX();
              var cy = mouse.getCenterY();
              for (var i = 0; i < this.focusIcons.length; i++) {
                var dx = cx - this.focusIcons[i].bounds.getCenterX();
                var dy = cy - this.focusIcons[i].bounds.getCenterY();
                var tmp = dx * dx + dy * dy;
                if ((this.intersects(this.focusIcons[i], mouse, source, existingEdge) || point != null && this.intersects(this.focusIcons[i], grid, source, existingEdge)) && (minDistSq == null || tmp < minDistSq)) {
                  this.currentConstraint = this.constraints[i];
                  this.currentPoint = this.focusPoints[i];
                  minDistSq = tmp;
                  var tmp = this.focusIcons[i].bounds.clone();
                  tmp.grow(mxConstants.HIGHLIGHT_SIZE + 1);
                  tmp.width -= 1;
                  tmp.height -= 1;
                  if (this.focusHighlight == null) {
                    var hl = this.createHighlightShape();
                    hl.dialect = this.graph.dialect == mxConstants.DIALECT_SVG ? mxConstants.DIALECT_SVG : mxConstants.DIALECT_VML;
                    hl.pointerEvents = false;
                    hl.init(this.graph.getView().getOverlayPane());
                    this.focusHighlight = hl;
                    var getState = mxUtils.bind(this, function() {
                      return this.currentFocus != null ? this.currentFocus : state;
                    });
                    mxEvent.redirectMouseEvents(hl.node, this.graph, getState);
                  }
                  this.focusHighlight.bounds = tmp;
                  this.focusHighlight.redraw();
                }
              }
            }
            if (this.currentConstraint == null) {
              this.destroyFocusHighlight();
            }
          } else {
            this.currentConstraint = null;
            this.currentFocus = null;
            this.currentPoint = null;
          }
        };
        mxConstraintHandler.prototype.redraw = function() {
          if (this.currentFocus != null && this.constraints != null && this.focusIcons != null) {
            var state = this.graph.view.getState(this.currentFocus.cell);
            this.currentFocus = state;
            this.currentFocusArea = new mxRectangle(state.x, state.y, state.width, state.height);
            for (var i = 0; i < this.constraints.length; i++) {
              var cp = this.graph.getConnectionPoint(state, this.constraints[i]);
              var img = this.getImageForConstraint(state, this.constraints[i], cp);
              var bounds = new mxRectangle(
                Math.round(cp.x - img.width / 2),
                Math.round(cp.y - img.height / 2),
                img.width,
                img.height
              );
              this.focusIcons[i].bounds = bounds;
              this.focusIcons[i].redraw();
              this.currentFocusArea.add(this.focusIcons[i].bounds);
              this.focusPoints[i] = cp;
            }
          }
        };
        mxConstraintHandler.prototype.setFocus = function(me, state, source) {
          this.constraints = state != null && !this.isStateIgnored(state, source) && this.graph.isCellConnectable(state.cell) ? this.isEnabled() ? this.graph.getAllConnectionConstraints(state, source) || [] : [] : null;
          if (this.constraints != null) {
            this.currentFocus = state;
            this.currentFocusArea = new mxRectangle(state.x, state.y, state.width, state.height);
            if (this.focusIcons != null) {
              for (var i = 0; i < this.focusIcons.length; i++) {
                this.focusIcons[i].destroy();
              }
              this.focusIcons = null;
              this.focusPoints = null;
            }
            this.focusPoints = [];
            this.focusIcons = [];
            for (var i = 0; i < this.constraints.length; i++) {
              var cp = this.graph.getConnectionPoint(state, this.constraints[i]);
              var img = this.getImageForConstraint(state, this.constraints[i], cp);
              var src = img.src;
              var bounds = new mxRectangle(
                Math.round(cp.x - img.width / 2),
                Math.round(cp.y - img.height / 2),
                img.width,
                img.height
              );
              var icon = new mxImageShape(bounds, src);
              icon.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
              icon.preserveImageAspect = false;
              icon.init(this.graph.getView().getDecoratorPane());
              if (mxClient.IS_QUIRKS || document.documentMode == 8) {
                mxEvent.addListener(icon.node, "dragstart", function(evt) {
                  mxEvent.consume(evt);
                  return false;
                });
              }
              if (icon.node.previousSibling != null) {
                icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);
              }
              var getState = mxUtils.bind(this, function() {
                return this.currentFocus != null ? this.currentFocus : state;
              });
              icon.redraw();
              mxEvent.redirectMouseEvents(icon.node, this.graph, getState);
              this.currentFocusArea.add(icon.bounds);
              this.focusIcons.push(icon);
              this.focusPoints.push(cp);
            }
            this.currentFocusArea.grow(this.getTolerance(me));
          } else {
            this.destroyIcons();
            this.destroyFocusHighlight();
          }
        };
        mxConstraintHandler.prototype.createHighlightShape = function() {
          var hl = new mxRectangleShape(null, this.highlightColor, this.highlightColor, mxConstants.HIGHLIGHT_STROKEWIDTH);
          hl.opacity = mxConstants.HIGHLIGHT_OPACITY;
          return hl;
        };
        mxConstraintHandler.prototype.intersects = function(icon, mouse, source, existingEdge) {
          return mxUtils.intersects(icon.bounds, mouse);
        };
        mxConstraintHandler.prototype.destroy = function() {
          this.reset();
          if (this.resetHandler != null) {
            this.graph.model.removeListener(this.resetHandler);
            this.graph.view.removeListener(this.resetHandler);
            this.graph.removeListener(this.resetHandler);
            this.resetHandler = null;
          }
          if (this.mouseleaveHandler != null && this.graph.container != null) {
            mxEvent.removeListener(this.graph.container, "mouseleave", this.mouseleaveHandler);
            this.mouseleaveHandler = null;
          }
        };
        __mxOutput.mxConstraintHandler = typeof mxConstraintHandler !== "undefined" ? mxConstraintHandler : void 0;
        function mxRubberband(graph) {
          if (graph != null) {
            this.graph = graph;
            this.graph.addMouseListener(this);
            this.forceRubberbandHandler = mxUtils.bind(this, function(sender, evt) {
              var evtName = evt.getProperty("eventName");
              var me = evt.getProperty("event");
              if (evtName == mxEvent.MOUSE_DOWN && this.isForceRubberbandEvent(me)) {
                var offset = mxUtils.getOffset(this.graph.container);
                var origin = mxUtils.getScrollOrigin(this.graph.container);
                origin.x -= offset.x;
                origin.y -= offset.y;
                this.start(me.getX() + origin.x, me.getY() + origin.y);
                me.consume(false);
              }
            });
            this.graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.forceRubberbandHandler);
            this.panHandler = mxUtils.bind(this, function() {
              this.repaint();
            });
            this.graph.addListener(mxEvent.PAN, this.panHandler);
            this.gestureHandler = mxUtils.bind(this, function(sender, eo) {
              if (this.first != null) {
                this.reset();
              }
            });
            this.graph.addListener(mxEvent.GESTURE, this.gestureHandler);
            if (mxClient.IS_IE) {
              mxEvent.addListener(
                window,
                "unload",
                mxUtils.bind(this, function() {
                  this.destroy();
                })
              );
            }
          }
        }
        ;
        mxRubberband.prototype.defaultOpacity = 20;
        mxRubberband.prototype.enabled = true;
        mxRubberband.prototype.div = null;
        mxRubberband.prototype.sharedDiv = null;
        mxRubberband.prototype.currentX = 0;
        mxRubberband.prototype.currentY = 0;
        mxRubberband.prototype.fadeOut = false;
        mxRubberband.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxRubberband.prototype.setEnabled = function(enabled) {
          this.enabled = enabled;
        };
        mxRubberband.prototype.isForceRubberbandEvent = function(me) {
          return mxEvent.isAltDown(me.getEvent());
        };
        mxRubberband.prototype.mouseDown = function(sender, me) {
          if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && me.getState() == null && !mxEvent.isMultiTouchEvent(me.getEvent())) {
            var offset = mxUtils.getOffset(this.graph.container);
            var origin = mxUtils.getScrollOrigin(this.graph.container);
            origin.x -= offset.x;
            origin.y -= offset.y;
            this.start(me.getX() + origin.x, me.getY() + origin.y);
            me.consume(false);
          }
        };
        mxRubberband.prototype.start = function(x, y) {
          this.first = new mxPoint(x, y);
          var container = this.graph.container;
          function createMouseEvent(evt) {
            var me = new mxMouseEvent(evt);
            var pt = mxUtils.convertPoint(container, me.getX(), me.getY());
            me.graphX = pt.x;
            me.graphY = pt.y;
            return me;
          }
          ;
          this.dragHandler = mxUtils.bind(this, function(evt) {
            this.mouseMove(this.graph, createMouseEvent(evt));
          });
          this.dropHandler = mxUtils.bind(this, function(evt) {
            this.mouseUp(this.graph, createMouseEvent(evt));
          });
          if (mxClient.IS_FF) {
            mxEvent.addGestureListeners(document, null, this.dragHandler, this.dropHandler);
          }
        };
        mxRubberband.prototype.mouseMove = function(sender, me) {
          if (!me.isConsumed() && this.first != null) {
            var origin = mxUtils.getScrollOrigin(this.graph.container);
            var offset = mxUtils.getOffset(this.graph.container);
            origin.x -= offset.x;
            origin.y -= offset.y;
            var x = me.getX() + origin.x;
            var y = me.getY() + origin.y;
            var dx = this.first.x - x;
            var dy = this.first.y - y;
            var tol = this.graph.tolerance;
            if (this.div != null || Math.abs(dx) > tol || Math.abs(dy) > tol) {
              if (this.div == null) {
                this.div = this.createShape();
              }
              mxUtils.clearSelection();
              this.update(x, y);
              me.consume();
            }
          }
        };
        mxRubberband.prototype.createShape = function() {
          if (this.sharedDiv == null) {
            this.sharedDiv = document.createElement("div");
            this.sharedDiv.className = "mxRubberband";
            mxUtils.setOpacity(this.sharedDiv, this.defaultOpacity);
          }
          this.graph.container.appendChild(this.sharedDiv);
          var result2 = this.sharedDiv;
          if (mxClient.IS_SVG && (!mxClient.IS_IE || document.documentMode >= 10) && this.fadeOut) {
            this.sharedDiv = null;
          }
          return result2;
        };
        mxRubberband.prototype.isActive = function(sender, me) {
          return this.div != null && this.div.style.display != "none";
        };
        mxRubberband.prototype.mouseUp = function(sender, me) {
          var active2 = this.isActive();
          this.reset();
          if (active2) {
            this.execute(me.getEvent());
            me.consume();
          }
        };
        mxRubberband.prototype.execute = function(evt) {
          var rect = new mxRectangle(this.x, this.y, this.width, this.height);
          this.graph.selectRegion(rect, evt);
        };
        mxRubberband.prototype.reset = function() {
          if (this.div != null) {
            if (mxClient.IS_SVG && (!mxClient.IS_IE || document.documentMode >= 10) && this.fadeOut) {
              var temp = this.div;
              mxUtils.setPrefixedStyle(temp.style, "transition", "all 0.2s linear");
              temp.style.pointerEvents = "none";
              temp.style.opacity = 0;
              window.setTimeout(function() {
                temp.parentNode.removeChild(temp);
              }, 200);
            } else {
              this.div.parentNode.removeChild(this.div);
            }
          }
          mxEvent.removeGestureListeners(document, null, this.dragHandler, this.dropHandler);
          this.dragHandler = null;
          this.dropHandler = null;
          this.currentX = 0;
          this.currentY = 0;
          this.first = null;
          this.div = null;
        };
        mxRubberband.prototype.update = function(x, y) {
          this.currentX = x;
          this.currentY = y;
          this.repaint();
        };
        mxRubberband.prototype.repaint = function() {
          if (this.div != null) {
            var x = this.currentX - this.graph.panDx;
            var y = this.currentY - this.graph.panDy;
            this.x = Math.min(this.first.x, x);
            this.y = Math.min(this.first.y, y);
            this.width = Math.max(this.first.x, x) - this.x;
            this.height = Math.max(this.first.y, y) - this.y;
            var dx = mxClient.IS_VML ? this.graph.panDx : 0;
            var dy = mxClient.IS_VML ? this.graph.panDy : 0;
            this.div.style.left = this.x + dx + "px";
            this.div.style.top = this.y + dy + "px";
            this.div.style.width = Math.max(1, this.width) + "px";
            this.div.style.height = Math.max(1, this.height) + "px";
          }
        };
        mxRubberband.prototype.destroy = function() {
          if (!this.destroyed) {
            this.destroyed = true;
            this.graph.removeMouseListener(this);
            this.graph.removeListener(this.forceRubberbandHandler);
            this.graph.removeListener(this.panHandler);
            this.reset();
            if (this.sharedDiv != null) {
              this.sharedDiv = null;
            }
          }
        };
        __mxOutput.mxRubberband = typeof mxRubberband !== "undefined" ? mxRubberband : void 0;
        function mxHandle(state, cursor, image, shape2) {
          this.graph = state.view.graph;
          this.state = state;
          this.cursor = cursor != null ? cursor : this.cursor;
          this.image = image != null ? image : this.image;
          this.shape = shape2 != null ? shape2 : null;
          this.init();
        }
        ;
        mxHandle.prototype.cursor = "default";
        mxHandle.prototype.image = null;
        mxHandle.prototype.ignoreGrid = false;
        mxHandle.prototype.getPosition = function(bounds) {
        };
        mxHandle.prototype.setPosition = function(bounds, pt, me) {
        };
        mxHandle.prototype.execute = function(me) {
        };
        mxHandle.prototype.copyStyle = function(key) {
          this.graph.setCellStyles(key, this.state.style[key], [this.state.cell]);
        };
        mxHandle.prototype.processEvent = function(me) {
          var scale = this.graph.view.scale;
          var tr = this.graph.view.translate;
          var pt = new mxPoint(me.getGraphX() / scale - tr.x, me.getGraphY() / scale - tr.y);
          if (this.shape != null && this.shape.bounds != null) {
            pt.x -= this.shape.bounds.width / scale / 4;
            pt.y -= this.shape.bounds.height / scale / 4;
          }
          var alpha1 = -mxUtils.toRadians(this.getRotation());
          var alpha2 = -mxUtils.toRadians(this.getTotalRotation()) - alpha1;
          pt = this.flipPoint(this.rotatePoint(this.snapPoint(
            this.rotatePoint(pt, alpha1),
            this.ignoreGrid || !this.graph.isGridEnabledEvent(me.getEvent())
          ), alpha2));
          this.setPosition(this.state.getPaintBounds(), pt, me);
          this.redraw();
        };
        mxHandle.prototype.positionChanged = function() {
          if (this.state.text != null) {
            this.state.text.apply(this.state);
          }
          if (this.state.shape != null) {
            this.state.shape.apply(this.state);
          }
          this.graph.cellRenderer.redraw(this.state, true);
        };
        mxHandle.prototype.getRotation = function() {
          if (this.state.shape != null) {
            return this.state.shape.getRotation();
          }
          return 0;
        };
        mxHandle.prototype.getTotalRotation = function() {
          if (this.state.shape != null) {
            return this.state.shape.getShapeRotation();
          }
          return 0;
        };
        mxHandle.prototype.init = function() {
          var html = this.isHtmlRequired();
          if (this.image != null) {
            this.shape = new mxImageShape(new mxRectangle(0, 0, this.image.width, this.image.height), this.image.src);
            this.shape.preserveImageAspect = false;
          } else if (this.shape == null) {
            this.shape = this.createShape(html);
          }
          this.initShape(html);
        };
        mxHandle.prototype.createShape = function(html) {
          var bounds = new mxRectangle(0, 0, mxConstants.HANDLE_SIZE, mxConstants.HANDLE_SIZE);
          return new mxRectangleShape(bounds, mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
        };
        mxHandle.prototype.initShape = function(html) {
          if (html && this.shape.isHtmlAllowed()) {
            this.shape.dialect = mxConstants.DIALECT_STRICTHTML;
            this.shape.init(this.graph.container);
          } else {
            this.shape.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
            if (this.cursor != null) {
              this.shape.init(this.graph.getView().getOverlayPane());
            }
          }
          mxEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);
          this.shape.node.style.cursor = this.cursor;
        };
        mxHandle.prototype.redraw = function() {
          if (this.shape != null && this.state.shape != null) {
            var pt = this.getPosition(this.state.getPaintBounds());
            if (pt != null) {
              var alpha = mxUtils.toRadians(this.getTotalRotation());
              pt = this.rotatePoint(this.flipPoint(pt), alpha);
              var scale = this.graph.view.scale;
              var tr = this.graph.view.translate;
              this.shape.bounds.x = Math.floor((pt.x + tr.x) * scale - this.shape.bounds.width / 2);
              this.shape.bounds.y = Math.floor((pt.y + tr.y) * scale - this.shape.bounds.height / 2);
              this.shape.redraw();
            }
          }
        };
        mxHandle.prototype.isHtmlRequired = function() {
          return this.state.text != null && this.state.text.node.parentNode == this.graph.container;
        };
        mxHandle.prototype.rotatePoint = function(pt, alpha) {
          var bounds = this.state.getCellBounds();
          var cx = new mxPoint(bounds.getCenterX(), bounds.getCenterY());
          var cos = Math.cos(alpha);
          var sin = Math.sin(alpha);
          return mxUtils.getRotatedPoint(pt, cos, sin, cx);
        };
        mxHandle.prototype.flipPoint = function(pt) {
          if (this.state.shape != null) {
            var bounds = this.state.getCellBounds();
            if (this.state.shape.flipH) {
              pt.x = 2 * bounds.x + bounds.width - pt.x;
            }
            if (this.state.shape.flipV) {
              pt.y = 2 * bounds.y + bounds.height - pt.y;
            }
          }
          return pt;
        };
        mxHandle.prototype.snapPoint = function(pt, ignore) {
          if (!ignore) {
            pt.x = this.graph.snap(pt.x);
            pt.y = this.graph.snap(pt.y);
          }
          return pt;
        };
        mxHandle.prototype.setVisible = function(visible) {
          if (this.shape != null && this.shape.node != null) {
            this.shape.node.style.display = visible ? "" : "none";
          }
        };
        mxHandle.prototype.reset = function() {
          this.setVisible(true);
          this.state.style = this.graph.getCellStyle(this.state.cell);
          this.positionChanged();
        };
        mxHandle.prototype.destroy = function() {
          if (this.shape != null) {
            this.shape.destroy();
            this.shape = null;
          }
        };
        __mxOutput.mxHandle = typeof mxHandle !== "undefined" ? mxHandle : void 0;
        function mxVertexHandler(state) {
          if (state != null) {
            this.state = state;
            this.init();
            this.escapeHandler = mxUtils.bind(this, function(sender, evt) {
              if (this.livePreview && this.index != null) {
                this.state.view.graph.cellRenderer.redraw(this.state, true);
                this.state.view.invalidate(this.state.cell);
                this.state.invalid = false;
                this.state.view.validate();
              }
              this.reset();
            });
            this.state.view.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
          }
        }
        ;
        mxVertexHandler.prototype.graph = null;
        mxVertexHandler.prototype.state = null;
        mxVertexHandler.prototype.singleSizer = false;
        mxVertexHandler.prototype.index = null;
        mxVertexHandler.prototype.allowHandleBoundsCheck = true;
        mxVertexHandler.prototype.handleImage = null;
        mxVertexHandler.prototype.handlesVisible = true;
        mxVertexHandler.prototype.tolerance = 0;
        mxVertexHandler.prototype.rotationEnabled = false;
        mxVertexHandler.prototype.parentHighlightEnabled = false;
        mxVertexHandler.prototype.rotationRaster = true;
        mxVertexHandler.prototype.rotationCursor = "crosshair";
        mxVertexHandler.prototype.livePreview = false;
        mxVertexHandler.prototype.movePreviewToFront = false;
        mxVertexHandler.prototype.manageSizers = false;
        mxVertexHandler.prototype.constrainGroupByChildren = false;
        mxVertexHandler.prototype.rotationHandleVSpacing = -16;
        mxVertexHandler.prototype.horizontalOffset = 0;
        mxVertexHandler.prototype.verticalOffset = 0;
        mxVertexHandler.prototype.init = function() {
          this.graph = this.state.view.graph;
          this.selectionBounds = this.getSelectionBounds(this.state);
          this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
          this.selectionBorder = this.createSelectionShape(this.bounds);
          this.state.cell.highlightShape = this.selectionBorder;
          this.selectionBorder.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
          this.selectionBorder.pointerEvents = false;
          this.selectionBorder.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
          this.selectionBorder.init(this.graph.getView().getOverlayPane());
          mxEvent.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);
          if (this.graph.isCellMovable(this.state.cell)) {
            this.selectionBorder.setCursor(mxConstants.CURSOR_MOVABLE_VERTEX);
          }
          if (mxGraphHandler.prototype.maxCells <= 0 || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells) {
            var resizable = this.graph.isCellResizable(this.state.cell);
            this.sizers = [];
            if (resizable || this.graph.isLabelMovable(this.state.cell) && this.state.width >= 2 && this.state.height >= 2) {
              var i = 0;
              if (resizable) {
                if (!this.singleSizer) {
                  this.sizers.push(this.createSizer("nw-resize", i++));
                  this.sizers.push(this.createSizer("n-resize", i++));
                  this.sizers.push(this.createSizer("ne-resize", i++));
                  this.sizers.push(this.createSizer("w-resize", i++));
                  this.sizers.push(this.createSizer("e-resize", i++));
                  this.sizers.push(this.createSizer("sw-resize", i++));
                  this.sizers.push(this.createSizer("s-resize", i++));
                }
                this.sizers.push(this.createSizer("se-resize", i++));
              }
              var geo = this.graph.model.getGeometry(this.state.cell);
              if (geo != null && !geo.relative && !this.graph.isSwimlane(this.state.cell) && this.graph.isLabelMovable(this.state.cell)) {
                this.labelShape = this.createSizer(
                  mxConstants.CURSOR_LABEL_HANDLE,
                  mxEvent.LABEL_HANDLE,
                  mxConstants.LABEL_HANDLE_SIZE,
                  mxConstants.LABEL_HANDLE_FILLCOLOR
                );
                this.sizers.push(this.labelShape);
              }
            } else if (this.graph.isCellMovable(this.state.cell) && !this.graph.isCellResizable(this.state.cell) && this.state.width < 2 && this.state.height < 2) {
              this.labelShape = this.createSizer(
                mxConstants.CURSOR_MOVABLE_VERTEX,
                mxEvent.LABEL_HANDLE,
                null,
                mxConstants.LABEL_HANDLE_FILLCOLOR
              );
              this.sizers.push(this.labelShape);
            }
          }
          if (this.isRotationHandleVisible()) {
            this.rotationShape = this.createSizer(
              this.rotationCursor,
              mxEvent.ROTATION_HANDLE,
              mxConstants.HANDLE_SIZE + 3,
              mxConstants.HANDLE_FILLCOLOR
            );
            this.sizers.push(this.rotationShape);
          }
          this.customHandles = this.createCustomHandles();
          this.redraw();
          if (this.constrainGroupByChildren) {
            this.updateMinBounds();
          }
        };
        mxVertexHandler.prototype.isRotationHandleVisible = function() {
          return this.graph.isEnabled() && this.rotationEnabled && this.graph.isCellRotatable(this.state.cell) && (mxGraphHandler.prototype.maxCells <= 0 || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells);
        };
        mxVertexHandler.prototype.isConstrainedEvent = function(me) {
          return mxEvent.isShiftDown(me.getEvent()) || this.state.style[mxConstants.STYLE_ASPECT] == "fixed";
        };
        mxVertexHandler.prototype.isCenteredEvent = function(state, me) {
          return false;
        };
        mxVertexHandler.prototype.createCustomHandles = function() {
          return null;
        };
        mxVertexHandler.prototype.updateMinBounds = function() {
          var children = this.graph.getChildCells(this.state.cell);
          if (children.length > 0) {
            this.minBounds = this.graph.view.getBounds(children);
            if (this.minBounds != null) {
              var s = this.state.view.scale;
              var t = this.state.view.translate;
              this.minBounds.x -= this.state.x;
              this.minBounds.y -= this.state.y;
              this.minBounds.x /= s;
              this.minBounds.y /= s;
              this.minBounds.width /= s;
              this.minBounds.height /= s;
              this.x0 = this.state.x / s - t.x;
              this.y0 = this.state.y / s - t.y;
            }
          }
        };
        mxVertexHandler.prototype.getSelectionBounds = function(state) {
          return new mxRectangle(Math.round(state.x), Math.round(state.y), Math.round(state.width), Math.round(state.height));
        };
        mxVertexHandler.prototype.createParentHighlightShape = function(bounds) {
          return this.createSelectionShape(bounds);
        };
        mxVertexHandler.prototype.createSelectionShape = function(bounds) {
          var shape2 = new mxRectangleShape(
            mxRectangle.fromRectangle(bounds),
            null,
            this.getSelectionColor()
          );
          shape2.strokewidth = this.getSelectionStrokeWidth();
          shape2.isDashed = this.graph.container.contains(document.activeElement) ? this.isSelectionDashed() : false;
          return shape2;
        };
        mxVertexHandler.prototype.getSelectionColor = function() {
          return this.state.style[mxConstants.STYLE_CELL_HIGHLIGHT_COLOR] ?? mxConstants.VERTEX_SELECTION_COLOR;
        };
        mxVertexHandler.prototype.getSelectionStrokeWidth = function() {
          return this.state.style[mxConstants.STYLE_CELL_HIGHLIGHT_STROKE_WIDTH] ?? mxConstants.VERTEX_SELECTION_STROKEWIDTH;
        };
        mxVertexHandler.prototype.isSelectionDashed = function() {
          return this.state.style[mxConstants.STYLE_CELL_HIGHLIGHT_DASHED] ?? mxConstants.VERTEX_SELECTION_DASHED;
        };
        mxVertexHandler.prototype.createSizer = function(cursor, index, size, fillColor) {
          size = size || mxConstants.HANDLE_SIZE;
          var bounds = new mxRectangle(0, 0, size, size);
          var sizer = this.createSizerShape(bounds, index, fillColor);
          if (sizer.isHtmlAllowed() && this.state.text != null && this.state.text.node.parentNode == this.graph.container) {
            sizer.bounds.height -= 1;
            sizer.bounds.width -= 1;
            sizer.dialect = mxConstants.DIALECT_STRICTHTML;
            sizer.init(this.graph.container);
          } else {
            sizer.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
            sizer.init(this.graph.getView().getOverlayPane());
          }
          mxEvent.redirectMouseEvents(sizer.node, this.graph, this.state);
          if (this.graph.isEnabled()) {
            sizer.setCursor(cursor);
          }
          if (!this.isSizerVisible(index)) {
            sizer.visible = false;
          }
          return sizer;
        };
        mxVertexHandler.prototype.isSizerVisible = function(index) {
          return true;
        };
        mxVertexHandler.prototype.createSizerShape = function(bounds, index, fillColor) {
          if (this.handleImage != null) {
            bounds = new mxRectangle(bounds.x, bounds.y, this.handleImage.width, this.handleImage.height);
            var shape2 = new mxImageShape(bounds, this.handleImage.src);
            shape2.preserveImageAspect = false;
            return shape2;
          } else if (index == mxEvent.ROTATION_HANDLE) {
            return new mxEllipse(bounds, fillColor || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
          } else {
            return new mxRectangleShape(bounds, fillColor || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
          }
        };
        mxVertexHandler.prototype.moveSizerTo = function(shape2, x, y) {
          if (shape2 != null) {
            shape2.bounds.x = Math.floor(x - shape2.bounds.width / 2);
            shape2.bounds.y = Math.floor(y - shape2.bounds.height / 2);
            if (shape2.node != null && shape2.node.style.display != "none") {
              shape2.redraw();
            }
          }
        };
        mxVertexHandler.prototype.getHandleForEvent = function(me) {
          var tol = !mxEvent.isMouseEvent(me.getEvent()) ? this.tolerance : 1;
          var hit = this.allowHandleBoundsCheck && (mxClient.IS_IE || tol > 0) ? new mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
          var checkShape = mxUtils.bind(this, function(shape2) {
            var st = shape2 != null && shape2.constructor != mxImageShape && this.allowHandleBoundsCheck ? shape2.strokewidth + shape2.svgStrokeTolerance : null;
            var real = st != null ? new mxRectangle(
              me.getGraphX() - Math.floor(st / 2),
              me.getGraphY() - Math.floor(st / 2),
              st,
              st
            ) : hit;
            return shape2 != null && (me.isSource(shape2) || real != null && mxUtils.intersects(shape2.bounds, real) && shape2.node.style.display != "none" && shape2.node.style.visibility != "hidden");
          });
          if (checkShape(this.rotationShape)) {
            return mxEvent.ROTATION_HANDLE;
          } else if (checkShape(this.labelShape)) {
            return mxEvent.LABEL_HANDLE;
          }
          if (this.sizers != null) {
            for (var i = 0; i < this.sizers.length; i++) {
              if (checkShape(this.sizers[i])) {
                return i;
              }
            }
          }
          if (this.customHandles != null && this.isCustomHandleEvent(me)) {
            for (var i = this.customHandles.length - 1; i >= 0; i--) {
              if (checkShape(this.customHandles[i].shape)) {
                return mxEvent.CUSTOM_HANDLE - i;
              }
            }
          }
          return null;
        };
        mxVertexHandler.prototype.isCustomHandleEvent = function(me) {
          return true;
        };
        mxVertexHandler.prototype.mouseDown = function(sender, me) {
          if (!me.isConsumed() && this.graph.isEnabled()) {
            var handle = this.getHandleForEvent(me);
            if (handle != null) {
              this.start(me.getGraphX(), me.getGraphY(), handle);
              me.consume();
            }
          }
        };
        mxVertexHandler.prototype.isLivePreviewBorder = function() {
          return this.state.shape != null && this.state.shape.fill == null && this.state.shape.stroke == null;
        };
        mxVertexHandler.prototype.start = function(x, y, index) {
          if (this.selectionBorder != null) {
            this.livePreviewActive = this.livePreview && this.graph.model.getChildCount(this.state.cell) == 0;
            this.inTolerance = true;
            this.childOffsetX = 0;
            this.childOffsetY = 0;
            this.index = index;
            this.startX = x;
            this.startY = y;
            if (this.index <= mxEvent.CUSTOM_HANDLE && this.isGhostPreview()) {
              this.ghostPreview = this.createGhostPreview();
            } else {
              var model = this.state.view.graph.model;
              var parent = model.getParent(this.state.cell);
              if (this.state.view.currentRoot != parent && (model.isVertex(parent) || model.isEdge(parent))) {
                this.parentState = this.state.view.graph.view.getState(parent);
              }
              this.selectionBorder.node.style.display = index == mxEvent.ROTATION_HANDLE ? "inline" : "none";
              if (!this.livePreviewActive || this.isLivePreviewBorder()) {
                this.preview = this.createSelectionShape(this.bounds);
                if (!(mxClient.IS_SVG && Number(this.state.style[mxConstants.STYLE_ROTATION] || "0") != 0) && this.state.text != null && this.state.text.node.parentNode == this.graph.container) {
                  this.preview.dialect = mxConstants.DIALECT_STRICTHTML;
                  this.preview.init(this.graph.container);
                } else {
                  this.preview.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
                  this.preview.init(this.graph.view.getOverlayPane());
                }
              }
              if (index == mxEvent.ROTATION_HANDLE) {
                var pos = this.getRotationHandlePosition();
                var dx = pos.x - this.state.getCenterX();
                var dy = pos.y - this.state.getCenterY();
                this.startAngle = dx != 0 ? Math.atan(dy / dx) * 180 / Math.PI + 90 : 0;
                this.startDist = Math.sqrt(dx * dx + dy * dy);
              }
              if (this.livePreviewActive) {
                this.hideSizers();
                if (index == mxEvent.ROTATION_HANDLE) {
                  this.rotationShape.node.style.display = "";
                } else if (index == mxEvent.LABEL_HANDLE) {
                  this.labelShape.node.style.display = "";
                } else if (this.sizers != null && this.sizers[index] != null) {
                  this.sizers[index].node.style.display = "";
                } else if (index <= mxEvent.CUSTOM_HANDLE && this.customHandles != null) {
                  this.customHandles[mxEvent.CUSTOM_HANDLE - index].setVisible(true);
                }
                var edges = this.graph.getEdges(this.state.cell);
                this.edgeHandlers = [];
                for (var i = 0; i < edges.length; i++) {
                  var handler = this.graph.selectionCellsHandler.getHandler(edges[i]);
                  if (handler != null) {
                    this.edgeHandlers.push(handler);
                  }
                }
              }
            }
          }
        };
        mxVertexHandler.prototype.createGhostPreview = function() {
          var shape2 = this.graph.cellRenderer.createShape(this.state);
          shape2.init(this.graph.view.getOverlayPane());
          shape2.scale = this.state.view.scale;
          shape2.bounds = this.bounds;
          shape2.outline = true;
          return shape2;
        };
        mxVertexHandler.prototype.setHandlesVisible = function(visible) {
          this.handlesVisible = visible;
          if (this.sizers != null) {
            for (var i = 0; i < this.sizers.length; i++) {
              this.sizers[i].node.style.display = visible ? "" : "none";
            }
          }
          if (this.customHandles != null) {
            for (var i = 0; i < this.customHandles.length; i++) {
              this.customHandles[i].setVisible(visible);
            }
          }
        };
        mxVertexHandler.prototype.hideSizers = function() {
          this.setHandlesVisible(false);
        };
        mxVertexHandler.prototype.checkTolerance = function(me) {
          if (this.inTolerance && this.startX != null && this.startY != null) {
            if (mxEvent.isMouseEvent(me.getEvent()) || Math.abs(me.getGraphX() - this.startX) > this.graph.tolerance || Math.abs(me.getGraphY() - this.startY) > this.graph.tolerance) {
              this.inTolerance = false;
            }
          }
        };
        mxVertexHandler.prototype.updateHint = function(me) {
        };
        mxVertexHandler.prototype.removeHint = function() {
        };
        mxVertexHandler.prototype.roundAngle = function(angle) {
          return Math.round(angle * 10) / 10;
        };
        mxVertexHandler.prototype.roundLength = function(length) {
          return Math.round(length * 100) / 100;
        };
        mxVertexHandler.prototype.mouseMove = function(sender, me) {
          if (!me.isConsumed() && this.index != null) {
            this.checkTolerance(me);
            if (!this.inTolerance) {
              if (this.index <= mxEvent.CUSTOM_HANDLE) {
                if (this.customHandles != null) {
                  this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].processEvent(me);
                  this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].active = true;
                  if (this.ghostPreview != null) {
                    this.ghostPreview.apply(this.state);
                    this.ghostPreview.strokewidth = this.getSelectionStrokeWidth() / this.ghostPreview.scale / this.ghostPreview.scale;
                    this.ghostPreview.isDashed = this.isSelectionDashed();
                    this.ghostPreview.stroke = this.getSelectionColor();
                    this.ghostPreview.redraw();
                    if (this.selectionBounds != null) {
                      this.selectionBorder.node.style.display = "none";
                    }
                  } else {
                    if (this.movePreviewToFront) {
                      this.moveToFront();
                    }
                    this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].positionChanged();
                  }
                }
              } else if (this.index == mxEvent.LABEL_HANDLE) {
                this.moveLabel(me);
              } else {
                if (this.index == mxEvent.ROTATION_HANDLE) {
                  this.rotateVertex(me);
                } else {
                  this.resizeVertex(me);
                }
                this.updateHint(me);
              }
            }
            me.consume();
          } else if (!this.graph.isMouseDown && this.getHandleForEvent(me) != null) {
            me.consume(false);
          }
        };
        mxVertexHandler.prototype.isGhostPreview = function() {
          return this.state.view.graph.model.getChildCount(this.state.cell) > 0;
        };
        mxVertexHandler.prototype.moveLabel = function(me) {
          var point = new mxPoint(me.getGraphX(), me.getGraphY());
          var tr = this.graph.view.translate;
          var scale = this.graph.view.scale;
          if (this.graph.isGridEnabledEvent(me.getEvent())) {
            point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;
            point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;
          }
          var index = this.rotationShape != null ? this.sizers.length - 2 : this.sizers.length - 1;
          this.moveSizerTo(this.sizers[index], point.x, point.y);
        };
        mxVertexHandler.prototype.rotateVertex = function(me) {
          var point = new mxPoint(me.getGraphX(), me.getGraphY());
          var dx = this.state.x + this.state.width / 2 - point.x;
          var dy = this.state.y + this.state.height / 2 - point.y;
          this.currentAlpha = dx != 0 ? Math.atan(dy / dx) * 180 / Math.PI + 90 : dy < 0 ? 180 : 0;
          if (dx > 0) {
            this.currentAlpha -= 180;
          }
          this.currentAlpha -= this.startAngle;
          if (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent())) {
            var dx = point.x - this.state.getCenterX();
            var dy = point.y - this.state.getCenterY();
            var dist = Math.sqrt(dx * dx + dy * dy);
            if (dist - this.startDist < 2) {
              raster = 15;
            } else if (dist - this.startDist < 25) {
              raster = 5;
            } else {
              raster = 1;
            }
            this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;
          } else {
            this.currentAlpha = this.roundAngle(this.currentAlpha);
          }
          this.selectionBorder.rotation = this.currentAlpha;
          this.selectionBorder.redraw();
          if (this.livePreviewActive) {
            this.redrawHandles();
          }
        };
        mxVertexHandler.prototype.resizeVertex = function(me) {
          var ct = new mxPoint(this.state.getCenterX(), this.state.getCenterY());
          var alpha = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
          var point = new mxPoint(me.getGraphX(), me.getGraphY());
          var tr = this.graph.view.translate;
          var scale = this.graph.view.scale;
          var cos = Math.cos(-alpha);
          var sin = Math.sin(-alpha);
          var dx = point.x - this.startX;
          var dy = point.y - this.startY;
          var tx = cos * dx - sin * dy;
          var ty = sin * dx + cos * dy;
          dx = tx;
          dy = ty;
          var geo = this.graph.getCellGeometry(this.state.cell);
          this.unscaledBounds = this.union(
            geo,
            dx / scale,
            dy / scale,
            this.index,
            this.graph.isGridEnabledEvent(me.getEvent()),
            1,
            new mxPoint(0, 0),
            this.isConstrainedEvent(me),
            this.isCenteredEvent(this.state, me)
          );
          if (!geo.relative) {
            var max = this.graph.getMaximumGraphBounds();
            if (max != null && this.parentState != null) {
              max = mxRectangle.fromRectangle(max);
              max.x -= (this.parentState.x - tr.x * scale) / scale;
              max.y -= (this.parentState.y - tr.y * scale) / scale;
            }
            if (this.graph.isConstrainChild(this.state.cell)) {
              var tmp = this.graph.getCellContainmentArea(this.state.cell);
              if (tmp != null) {
                var overlap = this.graph.getOverlap(this.state.cell);
                if (overlap > 0) {
                  tmp = mxRectangle.fromRectangle(tmp);
                  tmp.x -= tmp.width * overlap;
                  tmp.y -= tmp.height * overlap;
                  tmp.width += 2 * tmp.width * overlap;
                  tmp.height += 2 * tmp.height * overlap;
                }
                if (max == null) {
                  max = tmp;
                } else {
                  max = mxRectangle.fromRectangle(max);
                  max.intersect(tmp);
                }
              }
            }
            if (max != null) {
              if (this.unscaledBounds.x < max.x) {
                this.unscaledBounds.width -= max.x - this.unscaledBounds.x;
                this.unscaledBounds.x = max.x;
              }
              if (this.unscaledBounds.y < max.y) {
                this.unscaledBounds.height -= max.y - this.unscaledBounds.y;
                this.unscaledBounds.y = max.y;
              }
              if (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width) {
                this.unscaledBounds.width -= this.unscaledBounds.x + this.unscaledBounds.width - max.x - max.width;
              }
              if (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height) {
                this.unscaledBounds.height -= this.unscaledBounds.y + this.unscaledBounds.height - max.y - max.height;
              }
            }
          }
          var old = this.bounds;
          this.bounds = new mxRectangle((this.parentState != null ? this.parentState.x : tr.x * scale) + this.unscaledBounds.x * scale, (this.parentState != null ? this.parentState.y : tr.y * scale) + this.unscaledBounds.y * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);
          if (geo.relative && this.parentState != null) {
            this.bounds.x += this.state.x - this.parentState.x;
            this.bounds.y += this.state.y - this.parentState.y;
          }
          cos = Math.cos(alpha);
          sin = Math.sin(alpha);
          var c2 = new mxPoint(this.bounds.getCenterX(), this.bounds.getCenterY());
          var dx = c2.x - ct.x;
          var dy = c2.y - ct.y;
          var dx2 = cos * dx - sin * dy;
          var dy2 = sin * dx + cos * dy;
          var dx3 = dx2 - dx;
          var dy3 = dy2 - dy;
          var dx4 = this.bounds.x - this.state.x;
          var dy4 = this.bounds.y - this.state.y;
          var dx5 = cos * dx4 - sin * dy4;
          var dy5 = sin * dx4 + cos * dy4;
          this.bounds.x += dx3;
          this.bounds.y += dy3;
          this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + dx3 / scale);
          this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + dy3 / scale);
          this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);
          this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);
          if (!this.graph.isCellCollapsed(this.state.cell) && (dx3 != 0 || dy3 != 0)) {
            this.childOffsetX = this.state.x - this.bounds.x + dx5;
            this.childOffsetY = this.state.y - this.bounds.y + dy5;
          } else {
            this.childOffsetX = 0;
            this.childOffsetY = 0;
          }
          if (!old.equals(this.bounds)) {
            if (this.livePreviewActive) {
              this.updateLivePreview(me);
            }
            if (this.preview != null) {
              this.drawPreview();
            } else {
              this.updateParentHighlight();
            }
          }
        };
        mxVertexHandler.prototype.updateLivePreview = function(me) {
          var scale = this.graph.view.scale;
          var tr = this.graph.view.translate;
          var tempState = this.state.clone();
          this.state.x = this.bounds.x;
          this.state.y = this.bounds.y;
          this.state.origin = new mxPoint(this.state.x / scale - tr.x, this.state.y / scale - tr.y);
          this.state.width = this.bounds.width;
          this.state.height = this.bounds.height;
          var off = this.state.absoluteOffset;
          off = new mxPoint(off.x, off.y);
          this.state.absoluteOffset.x = 0;
          this.state.absoluteOffset.y = 0;
          var geo = this.graph.getCellGeometry(this.state.cell);
          if (geo != null) {
            var offset = geo.offset || this.EMPTY_POINT;
            if (offset != null && !geo.relative) {
              this.state.absoluteOffset.x = this.state.view.scale * offset.x;
              this.state.absoluteOffset.y = this.state.view.scale * offset.y;
            }
            this.state.view.updateVertexLabelOffset(this.state);
          }
          this.state.view.graph.cellRenderer.redraw(this.state, true);
          this.state.view.invalidate(this.state.cell);
          this.state.invalid = false;
          this.state.view.validate();
          this.redrawHandles();
          if (this.movePreviewToFront) {
            this.moveToFront();
          }
          if (this.state.control != null && this.state.control.node != null) {
            this.state.control.node.style.visibility = "hidden";
          }
          this.state.setState(tempState);
        };
        mxVertexHandler.prototype.moveToFront = function() {
          if (this.state.text != null && this.state.text.node != null && this.state.text.node.nextSibling != null || this.state.shape != null && this.state.shape.node != null && this.state.shape.node.nextSibling != null && (this.state.text == null || this.state.shape.node.nextSibling != this.state.text.node)) {
            if (this.state.shape != null && this.state.shape.node != null) {
              this.state.shape.node.parentNode.appendChild(this.state.shape.node);
            }
            if (this.state.text != null && this.state.text.node != null) {
              this.state.text.node.parentNode.appendChild(this.state.text.node);
            }
          }
        };
        mxVertexHandler.prototype.mouseUp = function(sender, me) {
          if (this.index != null && this.state != null) {
            var point = new mxPoint(me.getGraphX(), me.getGraphY());
            var index = this.index;
            this.index = null;
            if (this.ghostPreview == null) {
              this.state.view.invalidate(this.state.cell, false, false);
              this.state.view.validate();
            }
            this.graph.getModel().beginUpdate();
            try {
              if (index <= mxEvent.CUSTOM_HANDLE) {
                if (this.customHandles != null) {
                  var style = this.state.view.graph.getCellStyle(this.state.cell);
                  this.customHandles[mxEvent.CUSTOM_HANDLE - index].active = false;
                  this.customHandles[mxEvent.CUSTOM_HANDLE - index].execute(me);
                  if (this.customHandles != null && this.customHandles[mxEvent.CUSTOM_HANDLE - index] != null) {
                    this.state.style = style;
                    this.customHandles[mxEvent.CUSTOM_HANDLE - index].positionChanged();
                  }
                }
              } else if (index == mxEvent.ROTATION_HANDLE) {
                if (this.currentAlpha != null) {
                  var delta = this.currentAlpha - (this.state.style[mxConstants.STYLE_ROTATION] || 0);
                  if (delta != 0) {
                    this.rotateCell(this.state.cell, delta);
                  }
                } else {
                  this.rotateClick();
                }
              } else {
                var gridEnabled = this.graph.isGridEnabledEvent(me.getEvent());
                var alpha = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
                var cos = Math.cos(-alpha);
                var sin = Math.sin(-alpha);
                var dx = point.x - this.startX;
                var dy = point.y - this.startY;
                var tx = cos * dx - sin * dy;
                var ty = sin * dx + cos * dy;
                dx = tx;
                dy = ty;
                var s = this.graph.view.scale;
                var recurse = this.isRecursiveResize(this.state, me);
                this.resizeCell(
                  this.state.cell,
                  this.roundLength(dx / s),
                  this.roundLength(dy / s),
                  index,
                  gridEnabled,
                  this.isConstrainedEvent(me),
                  recurse
                );
              }
            } finally {
              this.graph.getModel().endUpdate();
            }
            me.consume();
            this.reset();
            this.redrawHandles();
          }
        };
        mxVertexHandler.prototype.isRecursiveResize = function(state, me) {
          return this.graph.isRecursiveResize(this.state);
        };
        mxVertexHandler.prototype.rotateClick = function() {
        };
        mxVertexHandler.prototype.rotateCell = function(cell2, angle, parent) {
          if (angle != 0) {
            var model = this.graph.getModel();
            if (model.isVertex(cell2) || model.isEdge(cell2)) {
              if (!model.isEdge(cell2)) {
                var style = this.graph.getCurrentCellStyle(cell2);
                var total = (style[mxConstants.STYLE_ROTATION] || 0) + angle;
                this.graph.setCellStyles(mxConstants.STYLE_ROTATION, total, [cell2]);
              }
              var geo = this.graph.getCellGeometry(cell2);
              if (geo != null) {
                var pgeo = this.graph.getCellGeometry(parent);
                if (pgeo != null && !model.isEdge(parent)) {
                  geo = geo.clone();
                  geo.rotate(angle, new mxPoint(pgeo.width / 2, pgeo.height / 2));
                  model.setGeometry(cell2, geo);
                }
                if (model.isVertex(cell2) && !geo.relative || model.isEdge(cell2)) {
                  var childCount = model.getChildCount(cell2);
                  for (var i = 0; i < childCount; i++) {
                    this.rotateCell(model.getChildAt(cell2, i), angle, cell2);
                  }
                }
              }
            }
          }
        };
        mxVertexHandler.prototype.reset = function() {
          if (this.sizers != null && this.index != null && this.sizers[this.index] != null && this.sizers[this.index].node.style.display == "none") {
            this.sizers[this.index].node.style.display = "";
          }
          this.currentAlpha = null;
          this.inTolerance = null;
          this.index = null;
          if (this.preview != null) {
            this.preview.destroy();
            this.preview = null;
          }
          if (this.ghostPreview != null) {
            this.ghostPreview.destroy();
            this.ghostPreview = null;
          }
          if (this.livePreviewActive && this.sizers != null) {
            for (var i = 0; i < this.sizers.length; i++) {
              if (this.sizers[i] != null) {
                this.sizers[i].node.style.display = "";
              }
            }
            if (this.state.control != null && this.state.control.node != null) {
              this.state.control.node.style.visibility = "";
            }
          }
          if (this.customHandles != null) {
            for (var i = 0; i < this.customHandles.length; i++) {
              if (this.customHandles[i].active) {
                this.customHandles[i].active = false;
                this.customHandles[i].reset();
              } else {
                this.customHandles[i].setVisible(true);
              }
            }
          }
          if (this.selectionBorder != null) {
            this.selectionBorder.node.style.display = "inline";
            this.selectionBounds = this.getSelectionBounds(this.state);
            this.bounds = new mxRectangle(
              this.selectionBounds.x,
              this.selectionBounds.y,
              this.selectionBounds.width,
              this.selectionBounds.height
            );
            this.drawPreview();
          }
          this.removeHint();
          this.redrawHandles();
          this.edgeHandlers = null;
          this.handlesVisible = true;
          this.unscaledBounds = null;
          this.livePreviewActive = null;
        };
        mxVertexHandler.prototype.resizeCell = function(cell2, dx, dy, index, gridEnabled, constrained, recurse) {
          var geo = this.graph.model.getGeometry(cell2);
          if (geo != null) {
            if (index == mxEvent.LABEL_HANDLE) {
              var alpha = -mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
              var cos = Math.cos(alpha);
              var sin = Math.sin(alpha);
              var scale = this.graph.view.scale;
              var pt = mxUtils.getRotatedPoint(
                new mxPoint(
                  Math.round((this.labelShape.bounds.getCenterX() - this.startX) / scale),
                  Math.round((this.labelShape.bounds.getCenterY() - this.startY) / scale)
                ),
                cos,
                sin
              );
              geo = geo.clone();
              if (geo.offset == null) {
                geo.offset = pt;
              } else {
                geo.offset.x += pt.x;
                geo.offset.y += pt.y;
              }
              this.graph.model.setGeometry(cell2, geo);
            } else if (this.unscaledBounds != null) {
              var scale = this.graph.view.scale;
              if (this.childOffsetX != 0 || this.childOffsetY != 0) {
                this.moveChildren(cell2, Math.round(this.childOffsetX / scale), Math.round(this.childOffsetY / scale));
              }
              this.graph.resizeCell(cell2, this.unscaledBounds, recurse);
            }
          }
        };
        mxVertexHandler.prototype.moveChildren = function(cell2, dx, dy) {
          var model = this.graph.getModel();
          var childCount = model.getChildCount(cell2);
          for (var i = 0; i < childCount; i++) {
            var child = model.getChildAt(cell2, i);
            var geo = this.graph.getCellGeometry(child);
            if (geo != null) {
              geo = geo.clone();
              geo.translate(dx, dy);
              model.setGeometry(child, geo);
            }
          }
        };
        mxVertexHandler.prototype.union = function(bounds, dx, dy, index, gridEnabled, scale, tr, constrained, centered) {
          gridEnabled = gridEnabled != null ? gridEnabled && this.graph.gridEnabled : this.graph.gridEnabled;
          if (this.singleSizer) {
            var x = bounds.x + bounds.width + dx;
            var y = bounds.y + bounds.height + dy;
            if (gridEnabled) {
              x = this.graph.snap(x / scale) * scale;
              y = this.graph.snap(y / scale) * scale;
            }
            var rect = new mxRectangle(bounds.x, bounds.y, 0, 0);
            rect.add(new mxRectangle(x, y, 0, 0));
            return rect;
          } else {
            var w0 = bounds.width;
            var h0 = bounds.height;
            var left = bounds.x - tr.x * scale;
            var right = left + w0;
            var top = bounds.y - tr.y * scale;
            var bottom = top + h0;
            var cx = left + w0 / 2;
            var cy = top + h0 / 2;
            if (index > 4) {
              bottom = bottom + dy;
              if (gridEnabled) {
                bottom = this.graph.snap(bottom / scale) * scale;
              } else {
                bottom = Math.round(bottom / scale) * scale;
              }
            } else if (index < 3) {
              top = top + dy;
              if (gridEnabled) {
                top = this.graph.snap(top / scale) * scale;
              } else {
                top = Math.round(top / scale) * scale;
              }
            }
            if (index == 0 || index == 3 || index == 5) {
              left += dx;
              if (gridEnabled) {
                left = this.graph.snap(left / scale) * scale;
              } else {
                left = Math.round(left / scale) * scale;
              }
            } else if (index == 2 || index == 4 || index == 7) {
              right += dx;
              if (gridEnabled) {
                right = this.graph.snap(right / scale) * scale;
              } else {
                right = Math.round(right / scale) * scale;
              }
            }
            var width = right - left;
            var height = bottom - top;
            if (constrained) {
              var geo = this.graph.getCellGeometry(this.state.cell);
              if (geo != null) {
                var aspect = geo.width / geo.height;
                if (index == 1 || index == 2 || index == 7 || index == 6) {
                  width = height * aspect;
                } else {
                  height = width / aspect;
                }
                if (index == 0) {
                  left = right - width;
                  top = bottom - height;
                }
              }
            }
            if (centered) {
              width += width - w0;
              height += height - h0;
              var cdx = cx - (left + width / 2);
              var cdy = cy - (top + height / 2);
              left += cdx;
              top += cdy;
              right += cdx;
              bottom += cdy;
            }
            if (width < 0) {
              left += width;
              width = Math.abs(width);
            }
            if (height < 0) {
              top += height;
              height = Math.abs(height);
            }
            var result2 = new mxRectangle(left + tr.x * scale, top + tr.y * scale, width, height);
            if (this.minBounds != null) {
              result2.width = Math.max(result2.width, this.minBounds.x * scale + this.minBounds.width * scale + Math.max(0, this.x0 * scale - result2.x));
              result2.height = Math.max(result2.height, this.minBounds.y * scale + this.minBounds.height * scale + Math.max(0, this.y0 * scale - result2.y));
            }
            return result2;
          }
        };
        mxVertexHandler.prototype.redraw = function(ignoreHandles) {
          this.selectionBounds = this.getSelectionBounds(this.state);
          this.bounds = this.selectionBounds;
          if (this.state.text) {
            this.state.text.updateBoundingBox();
          }
          if (this.state && this.state?.text?.boundingBox && this.selectionBounds) {
            const x = this.state.text ? Math.min(this.selectionBounds.x, this.state.text.boundingBox.x) : this.selectionBounds.x;
            const y = this.state.text ? Math.min(this.selectionBounds.y, this.state.text.boundingBox.y) : this.selectionBounds.y;
            const w2 = this.state.text ? Math.max(this.selectionBounds.x + this.selectionBounds.width, this.state.text.boundingBox.x + this.state.text.boundingBox.width) - x : this.selectionBounds.width;
            const h2 = this.state.text ? Math.max(this.selectionBounds.y + this.selectionBounds.height, this.state.text.boundingBox.y + this.state.text.boundingBox.height) - y : this.selectionBounds.height;
            this.bounds = new mxRectangle(x - 2, y - 2, w2 + 5, h2 + 3);
          }
          this.drawPreview();
          if (!ignoreHandles) {
            this.redrawHandles();
          }
        };
        mxVertexHandler.prototype.getHandlePadding = function() {
          var result2 = new mxPoint(0, 0);
          var tol = this.tolerance;
          if (this.sizers != null && this.sizers.length > 0 && this.sizers[0] != null && (this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * tol || this.bounds.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {
            tol /= 2;
            result2.x = this.sizers[0].bounds.width + tol;
            result2.y = this.sizers[0].bounds.height + tol;
          }
          return result2;
        };
        mxVertexHandler.prototype.getSizerBounds = function() {
          return this.bounds;
        };
        mxVertexHandler.prototype.redrawHandles = function() {
          var s = this.getSizerBounds();
          var tol = this.tolerance;
          this.horizontalOffset = 0;
          this.verticalOffset = 0;
          if (this.customHandles != null) {
            for (var i = 0; i < this.customHandles.length; i++) {
              var temp = this.customHandles[i].shape.node.style.display;
              this.customHandles[i].redraw();
              this.customHandles[i].shape.node.style.display = temp;
              this.customHandles[i].shape.node.style.visibility = this.handlesVisible && this.isCustomHandleVisible(
                this.customHandles[i]
              ) ? "" : "hidden";
            }
          }
          if (this.sizers != null && this.sizers.length > 0 && this.sizers[0] != null) {
            if (this.index == null && this.manageSizers && this.sizers.length >= 8) {
              var padding = this.getHandlePadding();
              this.horizontalOffset = padding.x;
              this.verticalOffset = padding.y;
              if (this.horizontalOffset != 0 || this.verticalOffset != 0) {
                s = new mxRectangle(s.x, s.y, s.width, s.height);
                s.x -= this.horizontalOffset / 2;
                s.width += this.horizontalOffset;
                s.y -= this.verticalOffset / 2;
                s.height += this.verticalOffset;
              }
              if (this.sizers.length >= 8) {
                if (s.width < 2 * this.sizers[0].bounds.width + 2 * tol || s.height < 2 * this.sizers[0].bounds.height + 2 * tol) {
                  this.sizers[0].node.style.display = "none";
                  this.sizers[2].node.style.display = "none";
                  this.sizers[5].node.style.display = "none";
                  this.sizers[7].node.style.display = "none";
                } else if (this.handlesVisible) {
                  this.sizers[0].node.style.display = "";
                  this.sizers[2].node.style.display = "";
                  this.sizers[5].node.style.display = "";
                  this.sizers[7].node.style.display = "";
                }
              }
            }
            var r = s.x + s.width;
            var b = s.y + s.height;
            if (this.singleSizer) {
              this.moveSizerTo(this.sizers[0], r, b);
            } else {
              var cx = s.x + s.width / 2;
              var cy = s.y + s.height / 2;
              if (this.sizers.length >= 8) {
                var crs = ["nw-resize", "n-resize", "ne-resize", "e-resize", "se-resize", "s-resize", "sw-resize", "w-resize"];
                var alpha = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
                var cos = Math.cos(alpha);
                var sin = Math.sin(alpha);
                var da = Math.round(alpha * 4 / Math.PI);
                var ct = new mxPoint(s.getCenterX(), s.getCenterY());
                var pt = mxUtils.getRotatedPoint(new mxPoint(s.x, s.y), cos, sin, ct);
                this.moveSizerTo(this.sizers[0], pt.x, pt.y);
                this.sizers[0].setCursor(crs[mxUtils.mod(0 + da, crs.length)]);
                pt.x = cx;
                pt.y = s.y;
                pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
                this.moveSizerTo(this.sizers[1], pt.x, pt.y);
                this.sizers[1].setCursor(crs[mxUtils.mod(1 + da, crs.length)]);
                pt.x = r;
                pt.y = s.y;
                pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
                this.moveSizerTo(this.sizers[2], pt.x, pt.y);
                this.sizers[2].setCursor(crs[mxUtils.mod(2 + da, crs.length)]);
                pt.x = s.x;
                pt.y = cy;
                pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
                this.moveSizerTo(this.sizers[3], pt.x, pt.y);
                this.sizers[3].setCursor(crs[mxUtils.mod(7 + da, crs.length)]);
                pt.x = r;
                pt.y = cy;
                pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
                this.moveSizerTo(this.sizers[4], pt.x, pt.y);
                this.sizers[4].setCursor(crs[mxUtils.mod(3 + da, crs.length)]);
                pt.x = s.x;
                pt.y = b;
                pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
                this.moveSizerTo(this.sizers[5], pt.x, pt.y);
                this.sizers[5].setCursor(crs[mxUtils.mod(6 + da, crs.length)]);
                pt.x = cx;
                pt.y = b;
                pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
                this.moveSizerTo(this.sizers[6], pt.x, pt.y);
                this.sizers[6].setCursor(crs[mxUtils.mod(5 + da, crs.length)]);
                pt.x = r;
                pt.y = b;
                pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
                this.moveSizerTo(this.sizers[7], pt.x, pt.y);
                this.sizers[7].setCursor(crs[mxUtils.mod(4 + da, crs.length)]);
                pt.x = cx + this.state.absoluteOffset.x;
                pt.y = cy + this.state.absoluteOffset.y;
                pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
                this.moveSizerTo(this.sizers[8], pt.x, pt.y);
              } else if (this.state.width >= 2 && this.state.height >= 2) {
                this.moveSizerTo(this.sizers[0], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);
              } else {
                this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);
              }
            }
          }
          if (this.rotationShape != null) {
            var alpha = mxUtils.toRadians(this.currentAlpha != null ? this.currentAlpha : this.state.style[mxConstants.STYLE_ROTATION] || "0");
            var cos = Math.cos(alpha);
            var sin = Math.sin(alpha);
            var ct = new mxPoint(this.state.getCenterX(), this.state.getCenterY());
            var pt = mxUtils.getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);
            if (this.rotationShape.node != null) {
              this.moveSizerTo(this.rotationShape, pt.x, pt.y);
              this.rotationShape.node.style.visibility = this.state.view.graph.isEditing() || !this.handlesVisible ? "hidden" : "";
            }
          }
          if (this.selectionBorder != null) {
            this.selectionBorder.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
          }
          if (this.edgeHandlers != null) {
            for (var i = 0; i < this.edgeHandlers.length; i++) {
              this.edgeHandlers[i].redraw();
            }
          }
        };
        mxVertexHandler.prototype.isCustomHandleVisible = function(handle) {
          return !this.graph.isEditing() && this.state.view.graph.getSelectionCount() == 1;
        };
        mxVertexHandler.prototype.getRotationHandlePosition = function() {
          return new mxPoint(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing);
        };
        mxVertexHandler.prototype.isParentHighlightVisible = function() {
          return !this.graph.isCellSelected(this.graph.model.getParent(this.state.cell));
        };
        mxVertexHandler.prototype.updateParentHighlight = function() {
          if (!this.isDestroyed()) {
            var visible = this.isParentHighlightVisible();
            var parent = this.graph.model.getParent(this.state.cell);
            var pstate = this.graph.view.getState(parent);
            if (this.parentHighlight != null) {
              if (this.graph.model.isVertex(parent) && visible) {
                var b = this.parentHighlight.bounds;
                if (pstate != null && (b.x != pstate.x || b.y != pstate.y || b.width != pstate.width || b.height != pstate.height)) {
                  this.parentHighlight.bounds = mxRectangle.fromRectangle(pstate);
                  this.parentHighlight.redraw();
                }
              } else {
                if (pstate != null && pstate.parentHighlight == this.parentHighlight) {
                  pstate.parentHighlight = null;
                }
                this.parentHighlight.destroy();
                this.parentHighlight = null;
              }
            } else if (this.parentHighlightEnabled && visible) {
              if (this.graph.model.isVertex(parent) && pstate != null && pstate.parentHighlight == null) {
                this.parentHighlight = this.createParentHighlightShape(pstate);
                this.parentHighlight.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
                this.parentHighlight.pointerEvents = false;
                this.parentHighlight.rotation = Number(pstate.style[mxConstants.STYLE_ROTATION] || "0");
                this.parentHighlight.init(this.graph.getView().getOverlayPane());
                this.parentHighlight.redraw();
                pstate.parentHighlight = this.parentHighlight;
              }
            }
          }
        };
        mxVertexHandler.prototype.drawPreview = function() {
          if (this.preview != null) {
            this.preview.bounds = this.bounds;
            if (this.preview.node.parentNode == this.graph.container) {
              this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);
              this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);
            }
            this.preview.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
            this.preview.redraw();
          }
          this.selectionBorder.bounds = this.getSelectionBorderBounds();
          this.selectionBorder.redraw();
          this.updateParentHighlight();
        };
        mxVertexHandler.prototype.getSelectionBorderBounds = function() {
          return this.bounds;
        };
        mxVertexHandler.prototype.isDestroyed = function() {
          return this.selectionBorder == null;
        };
        mxVertexHandler.prototype.destroy = function() {
          if (this.escapeHandler != null) {
            this.state.view.graph.removeListener(this.escapeHandler);
            this.escapeHandler = null;
          }
          if (this.preview != null) {
            this.preview.destroy();
            this.preview = null;
          }
          if (this.parentHighlight != null) {
            var parent = this.graph.model.getParent(this.state.cell);
            var pstate = this.graph.view.getState(parent);
            if (pstate != null && pstate.parentHighlight == this.parentHighlight) {
              pstate.parentHighlight = null;
            }
            this.parentHighlight.destroy();
            this.parentHighlight = null;
          }
          if (this.ghostPreview != null) {
            this.ghostPreview.destroy();
            this.ghostPreview = null;
          }
          if (this.selectionBorder != null) {
            this.selectionBorder.destroy();
            this.selectionBorder = null;
          }
          this.labelShape = null;
          this.removeHint();
          if (this.sizers != null) {
            for (var i = 0; i < this.sizers.length; i++) {
              this.sizers[i].destroy();
            }
            this.sizers = null;
          }
          if (this.customHandles != null) {
            for (var i = 0; i < this.customHandles.length; i++) {
              this.customHandles[i].destroy();
            }
            this.customHandles = null;
          }
        };
        __mxOutput.mxVertexHandler = typeof mxVertexHandler !== "undefined" ? mxVertexHandler : void 0;
        function mxEdgeHandler(state) {
          if (state != null && state.shape != null) {
            this.state = state;
            this.init();
            this.escapeHandler = mxUtils.bind(this, function(sender, evt) {
              var dirty = this.index != null;
              this.reset();
              if (dirty) {
                this.graph.cellRenderer.redraw(this.state, false, state.view.isRendering());
              }
            });
            this.state.view.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
          }
        }
        ;
        mxEdgeHandler.prototype.graph = null;
        mxEdgeHandler.prototype.state = null;
        mxEdgeHandler.prototype.marker = null;
        mxEdgeHandler.prototype.constraintHandler = null;
        mxEdgeHandler.prototype.error = null;
        mxEdgeHandler.prototype.shape = null;
        mxEdgeHandler.prototype.bends = null;
        mxEdgeHandler.prototype.labelShape = null;
        mxEdgeHandler.prototype.cloneEnabled = true;
        mxEdgeHandler.prototype.addEnabled = false;
        mxEdgeHandler.prototype.removeEnabled = false;
        mxEdgeHandler.prototype.dblClickRemoveEnabled = false;
        mxEdgeHandler.prototype.mergeRemoveEnabled = false;
        mxEdgeHandler.prototype.straightRemoveEnabled = false;
        mxEdgeHandler.prototype.virtualBendsEnabled = false;
        mxEdgeHandler.prototype.virtualBendOpacity = 20;
        mxEdgeHandler.prototype.parentHighlightEnabled = false;
        mxEdgeHandler.prototype.preferHtml = false;
        mxEdgeHandler.prototype.allowHandleBoundsCheck = true;
        mxEdgeHandler.prototype.snapToTerminals = false;
        mxEdgeHandler.prototype.handleImage = null;
        mxEdgeHandler.prototype.tolerance = 0;
        mxEdgeHandler.prototype.outlineConnect = false;
        mxEdgeHandler.prototype.manageLabelHandle = false;
        mxEdgeHandler.prototype.init = function() {
          this.graph = this.state.view.graph;
          this.marker = this.createMarker();
          this.constraintHandler = new mxConstraintHandler(this.graph);
          this.points = [];
          this.abspoints = this.getSelectionPoints(this.state);
          this.shape = this.createSelectionShape(this.abspoints);
          this.shape.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
          this.shape.init(this.graph.getView().getOverlayPane());
          this.shape.pointerEvents = false;
          this.shape.setCursor(mxConstants.CURSOR_MOVABLE_EDGE);
          mxEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);
          this.preferHtml = this.state.text != null && this.state.text.node.parentNode == this.graph.container;
          if (!this.preferHtml) {
            var sourceState = this.state.getVisibleTerminalState(true);
            if (sourceState != null) {
              this.preferHtml = sourceState.text != null && sourceState.text.node.parentNode == this.graph.container;
            }
            if (!this.preferHtml) {
              var targetState = this.state.getVisibleTerminalState(false);
              if (targetState != null) {
                this.preferHtml = targetState.text != null && targetState.text.node.parentNode == this.graph.container;
              }
            }
          }
          if (this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells || mxGraphHandler.prototype.maxCells <= 0) {
            this.bends = this.createBends();
            if (this.isVirtualBendsEnabled()) {
              this.virtualBends = this.createVirtualBends();
            }
          }
          this.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
          this.labelShape = this.createLabelHandleShape();
          this.initBend(this.labelShape);
          this.labelShape.setCursor(mxConstants.CURSOR_LABEL_HANDLE);
          this.customHandles = this.createCustomHandles();
          this.updateParentHighlight();
          this.redraw();
        };
        mxEdgeHandler.prototype.isParentHighlightVisible = mxVertexHandler.prototype.isParentHighlightVisible;
        mxEdgeHandler.prototype.updateParentHighlight = mxVertexHandler.prototype.updateParentHighlight;
        mxEdgeHandler.prototype.createCustomHandles = function() {
          return null;
        };
        mxEdgeHandler.prototype.isVirtualBendsEnabled = function(evt) {
          return this.virtualBendsEnabled && (this.state.style[mxConstants.STYLE_EDGE] == null || this.state.style[mxConstants.STYLE_EDGE] == mxConstants.NONE || this.state.style[mxConstants.STYLE_NOEDGESTYLE] == 1) && mxUtils.getValue(this.state.style, mxConstants.STYLE_SHAPE, null) != "arrow";
        };
        mxEdgeHandler.prototype.isCellEnabled = function(cell2) {
          return true;
        };
        mxEdgeHandler.prototype.isAddPointEvent = function(evt) {
          return mxEvent.isShiftDown(evt);
        };
        mxEdgeHandler.prototype.isRemovePointEvent = function(evt) {
          return mxEvent.isShiftDown(evt);
        };
        mxEdgeHandler.prototype.getSelectionPoints = function(state) {
          return state.absolutePoints;
        };
        mxEdgeHandler.prototype.createParentHighlightShape = function(bounds) {
          var shape2 = new mxRectangleShape(
            mxRectangle.fromRectangle(bounds),
            null,
            this.getSelectionColor()
          );
          shape2.strokewidth = this.getSelectionStrokeWidth();
          shape2.isDashed = this.isSelectionDashed();
          return shape2;
        };
        mxEdgeHandler.prototype.createSelectionShape = function(points) {
          var shape2 = new this.state.shape.constructor();
          shape2.outline = true;
          shape2.apply(this.state);
          shape2.isDashed = this.isSelectionDashed();
          shape2.stroke = this.getSelectionColor();
          shape2.isShadow = false;
          return shape2;
        };
        mxEdgeHandler.prototype.getSelectionColor = function() {
          return mxConstants.EDGE_SELECTION_COLOR;
        };
        mxEdgeHandler.prototype.getSelectionStrokeWidth = function() {
          return mxConstants.EDGE_SELECTION_STROKEWIDTH;
        };
        mxEdgeHandler.prototype.isSelectionDashed = function() {
          return false;
        };
        mxEdgeHandler.prototype.isConnectableCell = function(cell2) {
          return true;
        };
        mxEdgeHandler.prototype.getCellAt = function(x, y) {
          return !this.outlineConnect ? this.graph.getCellAt(x, y) : null;
        };
        mxEdgeHandler.prototype.createMarker = function() {
          var marker = new mxCellMarker(this.graph);
          var self = this;
          marker.getCell = function(me) {
            var cell2 = mxCellMarker.prototype.getCell.apply(this, arguments);
            if ((cell2 == self.state.cell || cell2 == null) && self.currentPoint != null) {
              cell2 = self.graph.getCellAt(self.currentPoint.x, self.currentPoint.y);
            }
            if (cell2 != null && !this.graph.isCellConnectable(cell2)) {
              var parent = this.graph.getModel().getParent(cell2);
              if (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent)) {
                cell2 = parent;
              }
            }
            var model = self.graph.getModel();
            if (this.graph.isSwimlane(cell2) && self.currentPoint != null && this.graph.hitsSwimlaneContent(cell2, self.currentPoint.x, self.currentPoint.y) || !self.isConnectableCell(cell2) || (cell2 == self.state.cell || cell2 != null && !self.graph.connectableEdges && model.isEdge(cell2)) || model.isAncestor(self.state.cell, cell2)) {
              cell2 = null;
            }
            if (!this.graph.isCellConnectable(cell2)) {
              cell2 = null;
            }
            return cell2;
          };
          marker.isValidState = function(state) {
            var model = self.graph.getModel();
            var other = self.graph.view.getTerminalPort(
              state,
              self.graph.view.getState(model.getTerminal(
                self.state.cell,
                !self.isSource
              )),
              !self.isSource
            );
            var otherCell = other != null ? other.cell : null;
            var source = self.isSource ? state.cell : otherCell;
            var target = self.isSource ? otherCell : state.cell;
            self.error = self.validateConnection(source, target);
            return self.error == null;
          };
          return marker;
        };
        mxEdgeHandler.prototype.validateConnection = function(source, target) {
          return this.graph.getEdgeValidationError(this.state.cell, source, target);
        };
        mxEdgeHandler.prototype.createBends = function() {
          var cell2 = this.state.cell;
          var bends = [];
          for (var i = 0; i < this.abspoints.length; i++) {
            if (this.isHandleVisible(i)) {
              var source = i == 0;
              var target = i == this.abspoints.length - 1;
              var terminal = source || target;
              if (terminal || this.graph.isCellBendable(cell2)) {
                mxUtils.bind(this, function(index) {
                  var bend = this.createHandleShape(index);
                  this.initBend(bend, mxUtils.bind(this, mxUtils.bind(this, function() {
                    if (this.dblClickRemoveEnabled) {
                      this.removePoint(this.state, index);
                    }
                  })));
                  if (this.isHandleEnabled(i)) {
                    bend.setCursor(terminal ? mxConstants.CURSOR_TERMINAL_HANDLE : mxConstants.CURSOR_BEND_HANDLE);
                  }
                  bends.push(bend);
                  if (!terminal) {
                    this.points.push(new mxPoint(0, 0));
                    bend.node.style.visibility = "hidden";
                  }
                })(i);
              }
            }
          }
          return bends;
        };
        mxEdgeHandler.prototype.createVirtualBends = function() {
          var cell2 = this.state.cell;
          var last = this.abspoints[0];
          var bends = [];
          if (this.graph.isCellBendable(cell2)) {
            for (var i = 1; i < this.abspoints.length; i++) {
              mxUtils.bind(this, function(bend) {
                this.initBend(bend);
                bend.setCursor(mxConstants.CURSOR_VIRTUAL_BEND_HANDLE);
                bends.push(bend);
              })(this.createHandleShape());
            }
          }
          return bends;
        };
        mxEdgeHandler.prototype.isHandleEnabled = function(index) {
          return true;
        };
        mxEdgeHandler.prototype.isHandleVisible = function(index) {
          var source = this.state.getVisibleTerminalState(true);
          var target = this.state.getVisibleTerminalState(false);
          var geo = this.graph.getCellGeometry(this.state.cell);
          var edgeStyle = geo != null ? this.graph.view.getEdgeStyle(this.state, geo.points, source, target) : null;
          return edgeStyle != mxEdgeStyle.EntityRelation || index == 0 || index == this.abspoints.length - 1;
        };
        mxEdgeHandler.prototype.createHandleShape = function(index) {
          if (this.handleImage != null) {
            var shape2 = new mxImageShape(new mxRectangle(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src);
            shape2.preserveImageAspect = false;
            return shape2;
          } else {
            var s = mxConstants.HANDLE_SIZE;
            if (this.preferHtml) {
              s -= 1;
            }
            return new mxRectangleShape(new mxRectangle(0, 0, s, s), mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
          }
        };
        mxEdgeHandler.prototype.createLabelHandleShape = function() {
          if (this.labelHandleImage != null) {
            var shape2 = new mxImageShape(new mxRectangle(0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);
            shape2.preserveImageAspect = false;
            return shape2;
          } else {
            var s = mxConstants.LABEL_HANDLE_SIZE;
            return new mxRectangleShape(new mxRectangle(0, 0, s, s), mxConstants.LABEL_HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
          }
        };
        mxEdgeHandler.prototype.initBend = function(bend, dblClick) {
          if (this.preferHtml) {
            bend.dialect = mxConstants.DIALECT_STRICTHTML;
            bend.init(this.graph.container);
          } else {
            bend.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
            bend.init(this.graph.getView().getOverlayPane());
          }
          mxEvent.redirectMouseEvents(
            bend.node,
            this.graph,
            this.state,
            null,
            null,
            null,
            dblClick
          );
          if (mxClient.IS_QUIRKS || document.documentMode == 8) {
            mxEvent.addListener(bend.node, "dragstart", function(evt) {
              mxEvent.consume(evt);
              return false;
            });
          }
          if (mxClient.IS_TOUCH) {
            bend.node.setAttribute("pointer-events", "none");
          }
        };
        mxEdgeHandler.prototype.getHandleForEvent = function(me) {
          var result2 = null;
          if (this.state != null) {
            let checkShape2 = function(shape2) {
              if (shape2 != null && shape2.node != null && shape2.node.style.display != "none" && shape2.node.style.visibility != "hidden" && (me.isSource(shape2) || hit != null && mxUtils.intersects(shape2.bounds, hit))) {
                var dx = me.getGraphX() - shape2.bounds.getCenterX();
                var dy = me.getGraphY() - shape2.bounds.getCenterY();
                var tmp = dx * dx + dy * dy;
                if (minDistSq == null || tmp <= minDistSq) {
                  minDistSq = tmp;
                  return true;
                }
              }
              return false;
            };
            var checkShape = checkShape2;
            var tol = !mxEvent.isMouseEvent(me.getEvent()) ? this.tolerance : 1;
            var hit = this.allowHandleBoundsCheck && (mxClient.IS_IE || tol > 0) ? new mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
            var minDistSq = null;
            if (this.customHandles != null && this.isCustomHandleEvent(me)) {
              for (var i = this.customHandles.length - 1; i >= 0; i--) {
                if (checkShape2(this.customHandles[i].shape)) {
                  return mxEvent.CUSTOM_HANDLE - i;
                }
              }
            }
            if (me.isSource(this.state.text) || checkShape2(this.labelShape)) {
              result2 = mxEvent.LABEL_HANDLE;
            }
            if (this.bends != null) {
              for (var i = 0; i < this.bends.length; i++) {
                if (checkShape2(this.bends[i])) {
                  result2 = i;
                }
              }
            }
            if (this.virtualBends != null && this.isAddVirtualBendEvent(me)) {
              for (var i = 0; i < this.virtualBends.length; i++) {
                if (checkShape2(this.virtualBends[i])) {
                  result2 = mxEvent.VIRTUAL_HANDLE - i;
                }
              }
            }
          }
          return result2;
        };
        mxEdgeHandler.prototype.isAddVirtualBendEvent = function(me) {
          return true;
        };
        mxEdgeHandler.prototype.isCustomHandleEvent = function(me) {
          return true;
        };
        mxEdgeHandler.prototype.mouseDown = function(sender, me) {
          var handle = this.getHandleForEvent(me);
          if (this.bends != null && this.bends[handle] != null) {
            var b = this.bends[handle].bounds;
            this.snapPoint = new mxPoint(b.getCenterX(), b.getCenterY());
          }
          if (this.addEnabled && handle == null && this.isAddPointEvent(me.getEvent())) {
            this.addPoint(this.state, me.getEvent());
            me.consume();
          } else if (handle != null && !me.isConsumed() && this.graph.isEnabled()) {
            if (this.removeEnabled && this.isRemovePointEvent(me.getEvent())) {
              this.removePoint(this.state, handle);
            } else if (handle != mxEvent.LABEL_HANDLE || this.graph.isLabelMovable(me.getCell())) {
              if (handle <= mxEvent.VIRTUAL_HANDLE) {
                mxUtils.setOpacity(this.virtualBends[mxEvent.VIRTUAL_HANDLE - handle].node, 100);
              }
              this.start(me.getX(), me.getY(), handle);
            }
            me.consume();
          }
        };
        mxEdgeHandler.prototype.start = function(x, y, index) {
          this.startX = x;
          this.startY = y;
          this.isSource = this.bends == null ? false : index == 0;
          this.isTarget = this.bends == null ? false : index == this.bends.length - 1;
          this.isLabel = index == mxEvent.LABEL_HANDLE;
          if (this.isSource || this.isTarget) {
            var cell2 = this.state.cell;
            var terminal = this.graph.model.getTerminal(cell2, this.isSource);
            if (terminal == null && this.graph.isTerminalPointMovable(cell2, this.isSource) || terminal != null && this.graph.isCellDisconnectable(cell2, terminal, this.isSource)) {
              this.index = index;
            }
          } else {
            this.index = index;
          }
          if (this.index <= mxEvent.CUSTOM_HANDLE && this.index > mxEvent.VIRTUAL_HANDLE) {
            if (this.customHandles != null) {
              for (var i = 0; i < this.customHandles.length; i++) {
                if (i != mxEvent.CUSTOM_HANDLE - this.index) {
                  this.customHandles[i].setVisible(false);
                }
              }
            }
          }
        };
        mxEdgeHandler.prototype.clonePreviewState = function(point, terminal) {
          return this.state.clone();
        };
        mxEdgeHandler.prototype.getSnapToTerminalTolerance = function() {
          return this.graph.gridSize * this.graph.view.scale / 2;
        };
        mxEdgeHandler.prototype.updateHint = function(me, point) {
        };
        mxEdgeHandler.prototype.removeHint = function() {
        };
        mxEdgeHandler.prototype.roundLength = function(length) {
          return Math.round(length);
        };
        mxEdgeHandler.prototype.isSnapToTerminalsEvent = function(me) {
          return this.snapToTerminals && !mxEvent.isAltDown(me.getEvent());
        };
        mxEdgeHandler.prototype.getPointForEvent = function(me) {
          var view = this.graph.getView();
          var scale = view.scale;
          var point = new mxPoint(
            this.roundLength(me.getGraphX() / scale) * scale,
            this.roundLength(me.getGraphY() / scale) * scale
          );
          var tt = this.getSnapToTerminalTolerance();
          var overrideX = false;
          var overrideY = false;
          if (tt > 0 && this.isSnapToTerminalsEvent(me)) {
            let snapToPoint2 = function(pt) {
              if (pt != null) {
                var x = pt.x;
                if (Math.abs(point.x - x) < tt) {
                  point.x = x;
                  overrideX = true;
                }
                var y = pt.y;
                if (Math.abs(point.y - y) < tt) {
                  point.y = y;
                  overrideY = true;
                }
              }
            }, snapToTerminal2 = function(terminal) {
              if (terminal != null) {
                snapToPoint2.call(this, new mxPoint(
                  view.getRoutingCenterX(terminal),
                  view.getRoutingCenterY(terminal)
                ));
              }
            };
            var snapToPoint = snapToPoint2, snapToTerminal = snapToTerminal2;
            ;
            snapToTerminal2.call(this, this.state.getVisibleTerminalState(true));
            snapToTerminal2.call(this, this.state.getVisibleTerminalState(false));
            if (this.state.absolutePoints != null) {
              for (var i = 0; i < this.state.absolutePoints.length; i++) {
                snapToPoint2.call(this, this.state.absolutePoints[i]);
              }
            }
          }
          if (this.graph.isGridEnabledEvent(me.getEvent())) {
            var tr = view.translate;
            if (!overrideX) {
              point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;
            }
            if (!overrideY) {
              point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;
            }
          }
          return point;
        };
        mxEdgeHandler.prototype.getPreviewTerminalState = function(me) {
          this.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);
          if (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null) {
            if (this.marker.highlight != null && this.marker.highlight.state != null && this.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell) {
              if (this.marker.highlight.shape.stroke != "transparent") {
                this.marker.highlight.shape.stroke = "transparent";
                this.marker.highlight.repaint();
              }
            } else {
              this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent");
            }
            var model = this.graph.getModel();
            var other = this.graph.view.getTerminalPort(
              this.state,
              this.graph.view.getState(model.getTerminal(
                this.state.cell,
                !this.isSource
              )),
              !this.isSource
            );
            var otherCell = other != null ? other.cell : null;
            var source = this.isSource ? this.constraintHandler.currentFocus.cell : otherCell;
            var target = this.isSource ? otherCell : this.constraintHandler.currentFocus.cell;
            this.error = this.validateConnection(source, target);
            var result2 = null;
            if (this.error == null) {
              result2 = this.constraintHandler.currentFocus;
            }
            if (this.error != null || result2 != null && !this.isCellEnabled(result2.cell)) {
              this.constraintHandler.reset();
            }
            return result2;
          } else if (!this.graph.isIgnoreTerminalEvent(me.getEvent())) {
            this.marker.process(me);
            var state = this.marker.getValidState();
            if (state != null && !this.isCellEnabled(state.cell)) {
              this.constraintHandler.reset();
              this.marker.reset();
            }
            return this.marker.getValidState();
          } else {
            this.marker.reset();
            return null;
          }
        };
        mxEdgeHandler.prototype.getPreviewPoints = function(pt, me) {
          var geometry = this.graph.getCellGeometry(this.state.cell);
          var points = geometry.points != null ? geometry.points.slice() : null;
          var point = new mxPoint(pt.x, pt.y);
          var result2 = null;
          if (!this.isSource && !this.isTarget) {
            this.convertPoint(point, false);
            if (points == null) {
              points = [point];
            } else {
              if (this.index <= mxEvent.VIRTUAL_HANDLE) {
                points.splice(mxEvent.VIRTUAL_HANDLE - this.index, 0, point);
              }
              if (!this.isSource && !this.isTarget) {
                for (var i = 0; i < this.bends.length; i++) {
                  if (i != this.index) {
                    var bend = this.bends[i];
                    if (bend != null && mxUtils.contains(bend.bounds, pt.x, pt.y)) {
                      if (this.index <= mxEvent.VIRTUAL_HANDLE) {
                        points.splice(mxEvent.VIRTUAL_HANDLE - this.index, 1);
                      } else {
                        points.splice(this.index - 1, 1);
                      }
                      result2 = points;
                    }
                  }
                }
                if (result2 == null && this.straightRemoveEnabled && (me == null || !mxEvent.isAltDown(me.getEvent()))) {
                  let checkRemove2 = function(idx, tmp) {
                    if (idx > 0 && idx < abs.length - 1 && mxUtils.ptSegDistSq(
                      abs[idx - 1].x,
                      abs[idx - 1].y,
                      abs[idx + 1].x,
                      abs[idx + 1].y,
                      tmp.x,
                      tmp.y
                    ) < tol) {
                      points.splice(idx - 1, 1);
                      result2 = points;
                    }
                  };
                  var checkRemove = checkRemove2;
                  var tol = this.graph.tolerance * this.graph.tolerance;
                  var abs = this.state.absolutePoints.slice();
                  abs[this.index] = pt;
                  var src = this.state.getVisibleTerminalState(true);
                  if (src != null) {
                    var c = this.graph.getConnectionConstraint(this.state, src, true);
                    if (c == null || this.graph.getConnectionPoint(src, c) == null) {
                      abs[0] = new mxPoint(src.view.getRoutingCenterX(src), src.view.getRoutingCenterY(src));
                    }
                  }
                  var trg = this.state.getVisibleTerminalState(false);
                  if (trg != null) {
                    var c = this.graph.getConnectionConstraint(this.state, trg, false);
                    if (c == null || this.graph.getConnectionPoint(trg, c) == null) {
                      abs[abs.length - 1] = new mxPoint(trg.view.getRoutingCenterX(trg), trg.view.getRoutingCenterY(trg));
                    }
                  }
                  ;
                  checkRemove2(this.index, pt);
                }
              }
              if (result2 == null && this.index > mxEvent.VIRTUAL_HANDLE) {
                points[this.index - 1] = point;
              }
            }
          } else if (this.graph.resetEdgesOnConnect) {
            points = null;
          }
          return result2 != null ? result2 : points;
        };
        mxEdgeHandler.prototype.isOutlineConnectEvent = function(me) {
          var offset = mxUtils.getOffset(this.graph.container);
          var evt = me.getEvent();
          var clientX = mxEvent.getClientX(evt);
          var clientY = mxEvent.getClientY(evt);
          var doc = document.documentElement;
          var left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
          var top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
          var gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;
          var gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;
          return this.outlineConnect && !mxEvent.isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || mxEvent.isAltDown(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX != clientX || gridY != clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));
        };
        mxEdgeHandler.prototype.updatePreviewState = function(edge, point, terminalState, me, outline) {
          var sourceState = this.isSource ? terminalState : this.state.getVisibleTerminalState(true);
          var targetState = this.isTarget ? terminalState : this.state.getVisibleTerminalState(false);
          var sourceConstraint = this.graph.getConnectionConstraint(edge, sourceState, true);
          var targetConstraint = this.graph.getConnectionConstraint(edge, targetState, false);
          var constraint = this.constraintHandler.currentConstraint;
          if (constraint == null && outline) {
            if (terminalState != null) {
              if (me.isSource(this.marker.highlight.shape)) {
                point = new mxPoint(me.getGraphX(), me.getGraphY());
              }
              constraint = this.graph.getOutlineConstraint(point, terminalState, me);
              this.constraintHandler.setFocus(me, terminalState, this.isSource);
              this.constraintHandler.currentConstraint = constraint;
              this.constraintHandler.currentPoint = point;
            } else {
              constraint = new mxConnectionConstraint();
            }
          }
          if (this.outlineConnect && this.marker.highlight != null && this.marker.highlight.shape != null) {
            var s = this.graph.view.scale;
            if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
              this.marker.highlight.shape.stroke = outline ? mxConstants.OUTLINE_HIGHLIGHT_COLOR : "transparent";
              this.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;
              this.marker.highlight.repaint();
            } else if (this.marker.hasValidState()) {
              this.marker.highlight.shape.stroke = this.graph.isCellConnectable(me.getCell()) && this.marker.getValidState() != me.getState() ? "transparent" : mxConstants.DEFAULT_VALID_COLOR;
              this.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / s / s;
              this.marker.highlight.repaint();
            }
          }
          if (this.isSource) {
            sourceConstraint = constraint;
          } else if (this.isTarget) {
            targetConstraint = constraint;
          }
          if (this.isSource || this.isTarget) {
            if (constraint != null && constraint.point != null) {
              edge.style[this.isSource ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X] = constraint.point.x;
              edge.style[this.isSource ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y] = constraint.point.y;
            } else {
              delete edge.style[this.isSource ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];
              delete edge.style[this.isSource ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];
            }
          }
          edge.setVisibleTerminalState(sourceState, true);
          edge.setVisibleTerminalState(targetState, false);
          if (!this.isSource || sourceState != null) {
            edge.view.updateFixedTerminalPoint(edge, sourceState, true, sourceConstraint);
          }
          if (!this.isTarget || targetState != null) {
            edge.view.updateFixedTerminalPoint(edge, targetState, false, targetConstraint);
          }
          if ((this.isSource || this.isTarget) && terminalState == null) {
            edge.setAbsoluteTerminalPoint(point, this.isSource);
            if (this.marker.getMarkedState() == null) {
              this.error = this.graph.allowDanglingEdges ? null : "";
            }
          }
          edge.view.updatePoints(edge, this.points, sourceState, targetState);
          edge.view.updateFloatingTerminalPoints(edge, sourceState, targetState);
        };
        mxEdgeHandler.prototype.mouseMove = function(sender, me) {
          if (this.index != null && this.marker != null) {
            this.currentPoint = this.getPointForEvent(me);
            this.error = null;
            if (!this.graph.isIgnoreTerminalEvent(me.getEvent()) && mxEvent.isShiftDown(me.getEvent()) && this.snapPoint != null) {
              if (Math.abs(this.snapPoint.x - this.currentPoint.x) < Math.abs(this.snapPoint.y - this.currentPoint.y)) {
                this.currentPoint.x = this.snapPoint.x;
              } else {
                this.currentPoint.y = this.snapPoint.y;
              }
            }
            if (this.index <= mxEvent.CUSTOM_HANDLE && this.index > mxEvent.VIRTUAL_HANDLE) {
              if (this.customHandles != null) {
                this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].processEvent(me);
                this.customHandles[mxEvent.CUSTOM_HANDLE - this.index].positionChanged();
                if (this.shape != null && this.shape.node != null) {
                  this.shape.node.style.display = "none";
                }
              }
            } else if (this.isLabel) {
              this.label.x = this.currentPoint.x;
              this.label.y = this.currentPoint.y;
            } else {
              this.points = this.getPreviewPoints(this.currentPoint, me);
              var terminalState = this.isSource || this.isTarget ? this.getPreviewTerminalState(me) : null;
              if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null && this.constraintHandler.currentPoint != null) {
                this.currentPoint = this.constraintHandler.currentPoint.clone();
              } else if (this.outlineConnect) {
                var outline = this.isSource || this.isTarget ? this.isOutlineConnectEvent(me) : false;
                if (outline) {
                  terminalState = this.marker.highlight.state;
                } else if (terminalState != null && terminalState != me.getState() && this.graph.isCellConnectable(me.getCell()) && this.marker.highlight.shape != null) {
                  this.marker.highlight.shape.stroke = "transparent";
                  this.marker.highlight.repaint();
                  terminalState = null;
                }
              }
              if (terminalState != null && !this.isCellEnabled(terminalState.cell)) {
                terminalState = null;
                this.marker.reset();
              }
              var clone = this.clonePreviewState(this.currentPoint, terminalState != null ? terminalState.cell : null);
              this.updatePreviewState(clone, this.currentPoint, terminalState, me, outline);
              var color = this.error == null ? this.marker.validColor : this.marker.invalidColor;
              this.setPreviewColor(color);
              this.abspoints = clone.absolutePoints;
              this.active = true;
              this.updateHint(me, this.currentPoint);
            }
            this.drawPreview();
            mxEvent.consume(me.getEvent());
            me.consume();
          } else if (mxClient.IS_IE && this.getHandleForEvent(me) != null) {
            me.consume(false);
          }
        };
        mxEdgeHandler.prototype.mouseUp = function(sender, me) {
          if (this.index != null && this.marker != null) {
            if (this.shape != null && this.shape.node != null) {
              this.shape.node.style.display = "";
            }
            var edge = this.state.cell;
            var index = this.index;
            this.index = null;
            if (me.getX() != this.startX || me.getY() != this.startY) {
              var clone = !this.graph.isIgnoreTerminalEvent(me.getEvent()) && this.graph.isCloneEvent(me.getEvent()) && this.cloneEnabled && this.graph.isCellsCloneable();
              if (this.error != null) {
                if (this.error.length > 0) {
                  this.graph.validationAlert(this.error);
                }
              } else if (index <= mxEvent.CUSTOM_HANDLE && index > mxEvent.VIRTUAL_HANDLE) {
                if (this.customHandles != null) {
                  var model = this.graph.getModel();
                  model.beginUpdate();
                  try {
                    this.customHandles[mxEvent.CUSTOM_HANDLE - index].execute(me);
                    if (this.shape != null && this.shape.node != null) {
                      this.shape.apply(this.state);
                      this.shape.redraw();
                    }
                  } finally {
                    model.endUpdate();
                  }
                }
              } else if (this.isLabel) {
                this.moveLabel(this.state, this.label.x, this.label.y);
              } else if (this.isSource || this.isTarget) {
                var terminal = null;
                if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
                  terminal = this.constraintHandler.currentFocus.cell;
                }
                if (terminal == null && this.marker.hasValidState() && this.marker.highlight != null && this.marker.highlight.shape != null && this.marker.highlight.shape.stroke != "transparent" && this.marker.highlight.shape.stroke != "white") {
                  terminal = this.marker.validState.cell;
                }
                if (terminal != null) {
                  var model = this.graph.getModel();
                  var parent = model.getParent(edge);
                  model.beginUpdate();
                  try {
                    if (clone) {
                      var geo = model.getGeometry(edge);
                      var clone = this.graph.cloneCell(edge);
                      model.add(parent, clone, model.getChildCount(parent));
                      if (geo != null) {
                        geo = geo.clone();
                        model.setGeometry(clone, geo);
                      }
                      var other = model.getTerminal(edge, !this.isSource);
                      this.graph.connectCell(clone, other, !this.isSource);
                      edge = clone;
                    }
                    edge = this.connect(edge, terminal, this.isSource, clone, me);
                  } finally {
                    model.endUpdate();
                  }
                } else if (this.graph.isAllowDanglingEdges()) {
                  var pt = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];
                  pt.x = this.roundLength(pt.x / this.graph.view.scale - this.graph.view.translate.x);
                  pt.y = this.roundLength(pt.y / this.graph.view.scale - this.graph.view.translate.y);
                  var pstate = this.graph.getView().getState(
                    this.graph.getModel().getParent(edge)
                  );
                  if (pstate != null) {
                    pt.x -= pstate.origin.x;
                    pt.y -= pstate.origin.y;
                  }
                  pt.x -= this.graph.panDx / this.graph.view.scale;
                  pt.y -= this.graph.panDy / this.graph.view.scale;
                  edge = this.changeTerminalPoint(edge, pt, this.isSource, clone);
                }
              } else if (this.active) {
                edge = this.changePoints(edge, this.points, clone);
              } else {
                this.graph.getView().invalidate(this.state.cell);
                this.graph.getView().validate(this.state.cell);
              }
            } else if (this.graph.isToggleEvent(me.getEvent())) {
              this.graph.selectCellForEvent(this.state.cell, me.getEvent());
            }
            if (this.marker != null) {
              this.reset();
              if (edge != this.state.cell) {
                this.graph.setSelectionCell(edge);
              }
            }
            me.consume();
          }
        };
        mxEdgeHandler.prototype.reset = function() {
          if (this.active) {
            this.refresh();
          }
          this.error = null;
          this.index = null;
          this.label = null;
          this.points = null;
          this.snapPoint = null;
          this.isLabel = false;
          this.isSource = false;
          this.isTarget = false;
          this.active = false;
          if (this.livePreview && this.sizers != null) {
            for (var i = 0; i < this.sizers.length; i++) {
              if (this.sizers[i] != null) {
                this.sizers[i].node.style.display = "";
              }
            }
          }
          if (this.marker != null) {
            this.marker.reset();
          }
          if (this.constraintHandler != null) {
            this.constraintHandler.reset();
          }
          if (this.customHandles != null) {
            for (var i = 0; i < this.customHandles.length; i++) {
              this.customHandles[i].reset();
            }
          }
          this.setPreviewColor(mxConstants.EDGE_SELECTION_COLOR);
          this.removeHint();
          this.redraw();
        };
        mxEdgeHandler.prototype.setPreviewColor = function(color) {
          if (this.shape != null) {
            this.shape.stroke = color;
          }
        };
        mxEdgeHandler.prototype.convertPoint = function(point, gridEnabled) {
          var scale = this.graph.getView().getScale();
          var tr = this.graph.getView().getTranslate();
          if (gridEnabled) {
            point.x = this.graph.snap(point.x);
            point.y = this.graph.snap(point.y);
          }
          point.x = Math.round(point.x / scale - tr.x);
          point.y = Math.round(point.y / scale - tr.y);
          var pstate = this.graph.getView().getState(
            this.graph.getModel().getParent(this.state.cell)
          );
          if (pstate != null) {
            point.x -= pstate.origin.x;
            point.y -= pstate.origin.y;
          }
          return point;
        };
        mxEdgeHandler.prototype.moveLabel = function(edgeState, x, y) {
          var model = this.graph.getModel();
          var geometry = model.getGeometry(edgeState.cell);
          if (geometry != null) {
            var scale = this.graph.getView().scale;
            geometry = geometry.clone();
            if (geometry.relative) {
              var pt = this.graph.getView().getRelativePoint(edgeState, x, y);
              geometry.x = Math.round(pt.x * 1e4) / 1e4;
              geometry.y = Math.round(pt.y);
              geometry.offset = new mxPoint(0, 0);
              var pt = this.graph.view.getPoint(edgeState, geometry);
              geometry.offset = new mxPoint(Math.round((x - pt.x) / scale), Math.round((y - pt.y) / scale));
            } else {
              var points = edgeState.absolutePoints;
              var p0 = points[0];
              var pe = points[points.length - 1];
              if (p0 != null && pe != null) {
                var cx = p0.x + (pe.x - p0.x) / 2;
                var cy = p0.y + (pe.y - p0.y) / 2;
                geometry.offset = new mxPoint(Math.round((x - cx) / scale), Math.round((y - cy) / scale));
                geometry.x = 0;
                geometry.y = 0;
              }
            }
            model.setGeometry(edgeState.cell, geometry);
          }
        };
        mxEdgeHandler.prototype.connect = function(edge, terminal, isSource, isClone, me) {
          var model = this.graph.getModel();
          var parent = model.getParent(edge);
          model.beginUpdate();
          try {
            var constraint = this.constraintHandler.currentConstraint;
            if (constraint == null) {
              constraint = new mxConnectionConstraint();
            }
            this.graph.connectCell(edge, terminal, isSource, constraint);
          } finally {
            model.endUpdate();
          }
          return edge;
        };
        mxEdgeHandler.prototype.changeTerminalPoint = function(edge, point, isSource, clone) {
          var model = this.graph.getModel();
          model.beginUpdate();
          try {
            if (clone) {
              var parent = model.getParent(edge);
              var terminal = model.getTerminal(edge, !isSource);
              edge = this.graph.cloneCell(edge);
              model.add(parent, edge, model.getChildCount(parent));
              model.setTerminal(edge, terminal, !isSource);
            }
            var geo = model.getGeometry(edge);
            if (geo != null) {
              geo = geo.clone();
              geo.setTerminalPoint(point, isSource);
              model.setGeometry(edge, geo);
              this.graph.connectCell(edge, null, isSource, new mxConnectionConstraint());
            }
          } finally {
            model.endUpdate();
          }
          return edge;
        };
        mxEdgeHandler.prototype.changePoints = function(edge, points, clone) {
          var model = this.graph.getModel();
          model.beginUpdate();
          try {
            if (clone) {
              var parent = model.getParent(edge);
              var source = model.getTerminal(edge, true);
              var target = model.getTerminal(edge, false);
              edge = this.graph.cloneCell(edge);
              model.add(parent, edge, model.getChildCount(parent));
              model.setTerminal(edge, source, true);
              model.setTerminal(edge, target, false);
            }
            var geo = model.getGeometry(edge);
            if (geo != null) {
              geo = geo.clone();
              geo.points = points;
              model.setGeometry(edge, geo);
            }
          } finally {
            model.endUpdate();
          }
          return edge;
        };
        mxEdgeHandler.prototype.addPoint = function(state, evt) {
          var pt = mxUtils.convertPoint(
            this.graph.container,
            mxEvent.getClientX(evt),
            mxEvent.getClientY(evt)
          );
          var gridEnabled = this.graph.isGridEnabledEvent(evt);
          this.convertPoint(pt, gridEnabled);
          this.addPointAt(state, pt.x, pt.y);
          mxEvent.consume(evt);
        };
        mxEdgeHandler.prototype.addPointAt = function(state, x, y) {
          var geo = this.graph.getCellGeometry(state.cell);
          var pt = new mxPoint(x, y);
          if (geo != null) {
            geo = geo.clone();
            var t = this.graph.view.translate;
            var s = this.graph.view.scale;
            var offset = new mxPoint(t.x * s, t.y * s);
            var parent = this.graph.model.getParent(this.state.cell);
            if (this.graph.model.isVertex(parent)) {
              var pState = this.graph.view.getState(parent);
              offset = new mxPoint(pState.x, pState.y);
            }
            var index = mxUtils.findNearestSegment(state, pt.x * s + offset.x, pt.y * s + offset.y);
            if (geo.points == null) {
              geo.points = [pt];
            } else {
              geo.points.splice(index, 0, pt);
            }
            this.graph.getModel().setGeometry(state.cell, geo);
            this.refresh();
            this.redraw();
          }
        };
        mxEdgeHandler.prototype.removePoint = function(state, index) {
          if (index > 0 && index < this.abspoints.length - 1) {
            var geo = this.graph.getCellGeometry(this.state.cell);
            if (geo != null && geo.points != null) {
              geo = geo.clone();
              geo.points.splice(index - 1, 1);
              this.graph.getModel().setGeometry(state.cell, geo);
              this.refresh();
              this.redraw();
            }
          }
        };
        mxEdgeHandler.prototype.getHandleFillColor = function(index) {
          var isSource = index == 0;
          var cell2 = this.state.cell;
          var terminal = this.graph.getModel().getTerminal(cell2, isSource);
          var color = mxConstants.HANDLE_FILLCOLOR;
          if (terminal != null && !this.graph.isCellDisconnectable(cell2, terminal, isSource) || terminal == null && !this.graph.isTerminalPointMovable(cell2, isSource)) {
            color = mxConstants.LOCKED_HANDLE_FILLCOLOR;
          } else if (terminal != null && this.graph.isCellDisconnectable(cell2, terminal, isSource)) {
            color = mxConstants.CONNECT_HANDLE_FILLCOLOR;
          }
          return color;
        };
        mxEdgeHandler.prototype.redraw = function(ignoreHandles) {
          if (this.state != null) {
            this.abspoints = this.state.absolutePoints.slice();
            var g = this.graph.getModel().getGeometry(this.state.cell);
            if (g != null) {
              var pts = g.points;
              if (this.bends != null && this.bends.length > 0) {
                if (pts != null) {
                  if (this.points == null) {
                    this.points = [];
                  }
                  for (var i = 1; i < this.bends.length - 1; i++) {
                    if (this.bends[i] != null && this.abspoints[i] != null) {
                      this.points[i - 1] = pts[i - 1];
                    }
                  }
                }
              }
            }
            this.drawPreview();
            if (!ignoreHandles) {
              this.redrawHandles();
            }
          }
        };
        mxEdgeHandler.prototype.redrawHandles = function() {
          var cell2 = this.state.cell;
          var b = this.labelShape.bounds;
          this.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
          this.labelShape.bounds = new mxRectangle(
            Math.round(this.label.x - b.width / 2),
            Math.round(this.label.y - b.height / 2),
            b.width,
            b.height
          );
          var lab = this.graph.getLabel(cell2);
          this.labelShape.visible = lab != null && lab.length > 0 && this.graph.isLabelMovable(cell2);
          if (this.bends != null && this.bends.length > 0) {
            var n = this.abspoints.length - 1;
            var p0 = this.abspoints[0];
            var x0 = p0.x;
            var y0 = p0.y;
            b = this.bends[0].bounds;
            this.bends[0].bounds = new mxRectangle(
              Math.floor(x0 - b.width / 2),
              Math.floor(y0 - b.height / 2),
              b.width,
              b.height
            );
            this.bends[0].fill = this.getHandleFillColor(0);
            this.bends[0].redraw();
            if (this.manageLabelHandle) {
              this.checkLabelHandle(this.bends[0].bounds);
            }
            var pe = this.abspoints[n];
            var xn = pe.x;
            var yn = pe.y;
            var bn = this.bends.length - 1;
            b = this.bends[bn].bounds;
            this.bends[bn].bounds = new mxRectangle(
              Math.floor(xn - b.width / 2),
              Math.floor(yn - b.height / 2),
              b.width,
              b.height
            );
            this.bends[bn].fill = this.getHandleFillColor(bn);
            this.bends[bn].redraw();
            if (this.manageLabelHandle) {
              this.checkLabelHandle(this.bends[bn].bounds);
            }
            this.redrawInnerBends(p0, pe);
          }
          if (this.abspoints != null && this.virtualBends != null && this.virtualBends.length > 0) {
            var last = this.abspoints[0];
            for (var i = 0; i < this.virtualBends.length; i++) {
              if (this.virtualBends[i] != null && this.abspoints[i + 1] != null) {
                var pt = this.abspoints[i + 1];
                var b = this.virtualBends[i];
                var x = last.x + (pt.x - last.x) / 2;
                var y = last.y + (pt.y - last.y) / 2;
                b.bounds = new mxRectangle(
                  Math.floor(x - b.bounds.width / 2),
                  Math.floor(y - b.bounds.height / 2),
                  b.bounds.width,
                  b.bounds.height
                );
                b.redraw();
                mxUtils.setOpacity(b.node, this.virtualBendOpacity);
                last = pt;
                if (this.manageLabelHandle) {
                  this.checkLabelHandle(b.bounds);
                }
              }
            }
          }
          if (this.labelShape != null) {
            this.labelShape.redraw();
          }
          if (this.customHandles != null) {
            for (var i = 0; i < this.customHandles.length; i++) {
              var temp = this.customHandles[i].shape.node.style.display;
              this.customHandles[i].redraw();
              this.customHandles[i].shape.node.style.display = temp;
              this.customHandles[i].shape.node.style.visibility = this.isCustomHandleVisible(this.customHandles[i]) ? "" : "hidden";
            }
          }
        };
        mxEdgeHandler.prototype.isCustomHandleVisible = function(handle) {
          return !this.graph.isEditing() && this.state.view.graph.getSelectionCount() == 1;
        };
        mxEdgeHandler.prototype.setHandlesVisible = function(visible) {
          if (this.bends != null) {
            for (var i = 0; i < this.bends.length; i++) {
              this.bends[i].node.style.display = visible ? "" : "none";
            }
          }
          if (this.virtualBends != null) {
            for (var i = 0; i < this.virtualBends.length; i++) {
              this.virtualBends[i].node.style.display = visible ? "" : "none";
            }
          }
          if (this.labelShape != null) {
            this.labelShape.node.style.display = visible ? "" : "none";
          }
          if (this.customHandles != null) {
            for (var i = 0; i < this.customHandles.length; i++) {
              this.customHandles[i].setVisible(visible);
            }
          }
        };
        mxEdgeHandler.prototype.redrawInnerBends = function(p0, pe) {
          for (var i = 1; i < this.bends.length - 1; i++) {
            if (this.bends[i] != null) {
              if (this.abspoints[i] != null) {
                var x = this.abspoints[i].x;
                var y = this.abspoints[i].y;
                var b = this.bends[i].bounds;
                this.bends[i].node.style.visibility = "visible";
                this.bends[i].bounds = new mxRectangle(
                  Math.round(x - b.width / 2),
                  Math.round(y - b.height / 2),
                  b.width,
                  b.height
                );
                if (this.manageLabelHandle) {
                  this.checkLabelHandle(this.bends[i].bounds);
                } else if (this.handleImage == null && this.labelShape.visible && mxUtils.intersects(this.bends[i].bounds, this.labelShape.bounds)) {
                  w = mxConstants.HANDLE_SIZE + 3;
                  h = mxConstants.HANDLE_SIZE + 3;
                  this.bends[i].bounds = new mxRectangle(Math.round(x - w / 2), Math.round(y - h / 2), w, h);
                }
                this.bends[i].redraw();
              } else {
                this.bends[i].destroy();
                this.bends[i] = null;
              }
            }
          }
        };
        mxEdgeHandler.prototype.checkLabelHandle = function(b) {
          if (this.labelShape != null) {
            var b2 = this.labelShape.bounds;
            if (mxUtils.intersects(b, b2)) {
              if (b.getCenterY() < b2.getCenterY()) {
                b2.y = b.y + b.height;
              } else {
                b2.y = b.y - b2.height;
              }
            }
          }
        };
        mxEdgeHandler.prototype.drawPreview = function() {
          try {
            if (this.isLabel) {
              var b = this.labelShape.bounds;
              var bounds = new mxRectangle(
                Math.round(this.label.x - b.width / 2),
                Math.round(this.label.y - b.height / 2),
                b.width,
                b.height
              );
              if (!this.labelShape.bounds.equals(bounds)) {
                this.labelShape.bounds = bounds;
                this.labelShape.redraw();
              }
            }
            if (this.shape != null && !mxUtils.equalPoints(this.shape.points, this.abspoints)) {
              this.shape.apply(this.state);
              this.shape.points = this.abspoints.slice();
              this.shape.scale = this.state.view.scale;
              this.shape.isDashed = this.isSelectionDashed();
              this.shape.stroke = this.getSelectionColor();
              this.shape.strokewidth = this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;
              this.shape.isShadow = false;
              this.shape.redraw();
            }
            this.updateParentHighlight();
          } catch (e) {
          }
        };
        mxEdgeHandler.prototype.refresh = function() {
          if (this.state != null) {
            this.abspoints = this.getSelectionPoints(this.state);
            this.points = [];
            if (this.bends != null) {
              this.destroyBends(this.bends);
              this.bends = this.createBends();
            }
            if (this.virtualBends != null) {
              this.destroyBends(this.virtualBends);
              this.virtualBends = this.createVirtualBends();
            }
            if (this.customHandles != null) {
              this.destroyBends(this.customHandles);
              this.customHandles = this.createCustomHandles();
            }
            if (this.labelShape != null && this.labelShape.node != null && this.labelShape.node.parentNode != null) {
              this.labelShape.node.parentNode.appendChild(this.labelShape.node);
            }
          }
        };
        mxEdgeHandler.prototype.isDestroyed = function() {
          return this.shape == null;
        };
        mxEdgeHandler.prototype.destroyBends = function(bends) {
          if (bends != null) {
            for (var i = 0; i < bends.length; i++) {
              if (bends[i] != null) {
                bends[i].destroy();
              }
            }
          }
        };
        mxEdgeHandler.prototype.destroy = function() {
          if (this.escapeHandler != null) {
            this.state.view.graph.removeListener(this.escapeHandler);
            this.escapeHandler = null;
          }
          if (this.marker != null) {
            this.marker.destroy();
            this.marker = null;
          }
          if (this.shape != null) {
            this.shape.destroy();
            this.shape = null;
          }
          if (this.parentHighlight != null) {
            var parent = this.graph.model.getParent(this.state.cell);
            var pstate = this.graph.view.getState(parent);
            if (pstate != null && pstate.parentHighlight == this.parentHighlight) {
              pstate.parentHighlight = null;
            }
            this.parentHighlight.destroy();
            this.parentHighlight = null;
          }
          if (this.labelShape != null) {
            this.labelShape.destroy();
            this.labelShape = null;
          }
          if (this.constraintHandler != null) {
            this.constraintHandler.destroy();
            this.constraintHandler = null;
          }
          this.destroyBends(this.virtualBends);
          this.virtualBends = null;
          this.destroyBends(this.customHandles);
          this.customHandles = null;
          this.destroyBends(this.bends);
          this.bends = null;
          this.removeHint();
        };
        __mxOutput.mxEdgeHandler = typeof mxEdgeHandler !== "undefined" ? mxEdgeHandler : void 0;
        function mxElbowEdgeHandler(state) {
          mxEdgeHandler.call(this, state);
        }
        ;
        mxUtils.extend(mxElbowEdgeHandler, mxEdgeHandler);
        mxElbowEdgeHandler.prototype.flipEnabled = true;
        mxElbowEdgeHandler.prototype.doubleClickOrientationResource = mxClient.language != "none" ? "doubleClickOrientation" : "";
        mxElbowEdgeHandler.prototype.createBends = function() {
          var bends = [];
          var bend = this.createHandleShape(0);
          this.initBend(bend);
          bend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
          bends.push(bend);
          bends.push(this.createVirtualBend(mxUtils.bind(this, function(evt) {
            if (!mxEvent.isConsumed(evt) && this.flipEnabled) {
              this.graph.flipEdge(this.state.cell, evt);
              mxEvent.consume(evt);
            }
          })));
          this.points.push(new mxPoint(0, 0));
          bend = this.createHandleShape(2);
          this.initBend(bend);
          bend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
          bends.push(bend);
          return bends;
        };
        mxElbowEdgeHandler.prototype.createVirtualBend = function(dblClickHandler) {
          var bend = this.createHandleShape();
          this.initBend(bend, dblClickHandler);
          bend.setCursor(this.getCursorForBend());
          if (!this.graph.isCellBendable(this.state.cell)) {
            bend.node.style.display = "none";
          }
          return bend;
        };
        mxElbowEdgeHandler.prototype.getCursorForBend = function() {
          return this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.TopToBottom || this.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_TOPTOBOTTOM || (this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.ElbowConnector || this.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_ELBOW) && this.state.style[mxConstants.STYLE_ELBOW] == mxConstants.ELBOW_VERTICAL ? "row-resize" : "col-resize";
        };
        mxElbowEdgeHandler.prototype.getTooltipForNode = function(node) {
          var tip = null;
          if (this.bends != null && this.bends[1] != null && (node == this.bends[1].node || node.parentNode == this.bends[1].node)) {
            tip = this.doubleClickOrientationResource;
            tip = mxResources.get(tip) || tip;
          }
          return tip;
        };
        mxElbowEdgeHandler.prototype.convertPoint = function(point, gridEnabled) {
          var scale = this.graph.getView().getScale();
          var tr = this.graph.getView().getTranslate();
          var origin = this.state.origin;
          if (gridEnabled) {
            point.x = this.graph.snap(point.x);
            point.y = this.graph.snap(point.y);
          }
          point.x = Math.round(point.x / scale - tr.x - origin.x);
          point.y = Math.round(point.y / scale - tr.y - origin.y);
          return point;
        };
        mxElbowEdgeHandler.prototype.redrawInnerBends = function(p0, pe) {
          var g = this.graph.getModel().getGeometry(this.state.cell);
          var pts = this.state.absolutePoints;
          var pt = null;
          if (pts.length > 1) {
            p0 = pts[1];
            pe = pts[pts.length - 2];
          } else if (g.points != null && g.points.length > 0) {
            pt = pts[0];
          }
          if (pt == null) {
            pt = new mxPoint(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);
          } else {
            pt = new mxPoint(
              this.graph.getView().scale * (pt.x + this.graph.getView().translate.x + this.state.origin.x),
              this.graph.getView().scale * (pt.y + this.graph.getView().translate.y + this.state.origin.y)
            );
          }
          var b = this.bends[1].bounds;
          var w2 = b.width;
          var h2 = b.height;
          var bounds = new mxRectangle(Math.round(pt.x - w2 / 2), Math.round(pt.y - h2 / 2), w2, h2);
          if (this.manageLabelHandle) {
            this.checkLabelHandle(bounds);
          } else if (this.handleImage == null && this.labelShape.visible && mxUtils.intersects(bounds, this.labelShape.bounds)) {
            w2 = mxConstants.HANDLE_SIZE + 3;
            h2 = mxConstants.HANDLE_SIZE + 3;
            bounds = new mxRectangle(Math.floor(pt.x - w2 / 2), Math.floor(pt.y - h2 / 2), w2, h2);
          }
          this.bends[1].bounds = bounds;
          this.bends[1].redraw();
          if (this.manageLabelHandle) {
            this.checkLabelHandle(this.bends[1].bounds);
          }
        };
        __mxOutput.mxElbowEdgeHandler = typeof mxElbowEdgeHandler !== "undefined" ? mxElbowEdgeHandler : void 0;
        function mxEdgeSegmentHandler(state) {
          mxEdgeHandler.call(this, state);
        }
        ;
        mxUtils.extend(mxEdgeSegmentHandler, mxElbowEdgeHandler);
        mxEdgeSegmentHandler.prototype.getCurrentPoints = function() {
          var pts = this.state.absolutePoints;
          if (pts != null) {
            var tol = Math.max(1, this.graph.view.scale);
            if (pts.length == 2 || pts.length == 3 && (Math.abs(pts[0].x - pts[1].x) < tol && Math.abs(pts[1].x - pts[2].x) < tol || Math.abs(pts[0].y - pts[1].y) < tol && Math.abs(pts[1].y - pts[2].y) < tol)) {
              var cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;
              var cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;
              pts = [pts[0], new mxPoint(cx, cy), new mxPoint(cx, cy), pts[pts.length - 1]];
            }
          }
          return pts;
        };
        mxEdgeSegmentHandler.prototype.getPreviewPoints = function(point) {
          if (this.isSource || this.isTarget) {
            return mxElbowEdgeHandler.prototype.getPreviewPoints.apply(this, arguments);
          } else {
            var pts = this.getCurrentPoints();
            var last = this.convertPoint(pts[0].clone(), false);
            point = this.convertPoint(point.clone(), false);
            var result2 = [];
            for (var i = 1; i < pts.length; i++) {
              var pt = this.convertPoint(pts[i].clone(), false);
              if (i == this.index) {
                if (Math.round(last.x - pt.x) == 0) {
                  last.x = point.x;
                  pt.x = point.x;
                }
                if (Math.round(last.y - pt.y) == 0) {
                  last.y = point.y;
                  pt.y = point.y;
                }
              }
              if (i < pts.length - 1) {
                result2.push(pt);
              }
              last = pt;
            }
            if (result2.length == 1) {
              var source = this.state.getVisibleTerminalState(true);
              var target = this.state.getVisibleTerminalState(false);
              var scale = this.state.view.getScale();
              var tr = this.state.view.getTranslate();
              var x = result2[0].x * scale + tr.x;
              var y = result2[0].y * scale + tr.y;
              if (source != null && mxUtils.contains(source, x, y) || target != null && mxUtils.contains(target, x, y)) {
                result2 = [point, point];
              }
            }
            return result2;
          }
        };
        mxEdgeSegmentHandler.prototype.updatePreviewState = function(edge, point, terminalState, me) {
          mxEdgeHandler.prototype.updatePreviewState.apply(this, arguments);
          if (!this.isSource && !this.isTarget) {
            point = this.convertPoint(point.clone(), false);
            var pts = edge.absolutePoints;
            var pt0 = pts[0];
            var pt1 = pts[1];
            var result2 = [];
            for (var i = 2; i < pts.length; i++) {
              var pt2 = pts[i];
              if ((Math.round(pt0.x - pt1.x) != 0 || Math.round(pt1.x - pt2.x) != 0) && (Math.round(pt0.y - pt1.y) != 0 || Math.round(pt1.y - pt2.y) != 0)) {
                result2.push(this.convertPoint(pt1.clone(), false));
              }
              pt0 = pt1;
              pt1 = pt2;
            }
            var source = this.state.getVisibleTerminalState(true);
            var target = this.state.getVisibleTerminalState(false);
            var rpts = this.state.absolutePoints;
            if (result2.length == 0 && (Math.round(pts[0].x - pts[pts.length - 1].x) == 0 || Math.round(pts[0].y - pts[pts.length - 1].y) == 0)) {
              result2 = [point, point];
            } else if (pts.length == 5 && result2.length == 2 && source != null && target != null && rpts != null && Math.round(rpts[0].x - rpts[rpts.length - 1].x) == 0) {
              var view = this.graph.getView();
              var scale = view.getScale();
              var tr = view.getTranslate();
              var y0 = view.getRoutingCenterY(source) / scale - tr.y;
              var sc = this.graph.getConnectionConstraint(edge, source, true);
              if (sc != null) {
                var pt = this.graph.getConnectionPoint(source, sc);
                if (pt != null) {
                  this.convertPoint(pt, false);
                  y0 = pt.y;
                }
              }
              var ye = view.getRoutingCenterY(target) / scale - tr.y;
              var tc = this.graph.getConnectionConstraint(edge, target, false);
              if (tc) {
                var pt = this.graph.getConnectionPoint(target, tc);
                if (pt != null) {
                  this.convertPoint(pt, false);
                  ye = pt.y;
                }
              }
              result2 = [new mxPoint(point.x, y0), new mxPoint(point.x, ye)];
            }
            this.points = result2;
            edge.view.updateFixedTerminalPoints(edge, source, target);
            edge.view.updatePoints(edge, this.points, source, target);
            edge.view.updateFloatingTerminalPoints(edge, source, target);
          }
        };
        mxEdgeSegmentHandler.prototype.connect = function(edge, terminal, isSource, isClone, me) {
          var model = this.graph.getModel();
          var geo = model.getGeometry(edge);
          var result2 = null;
          if (geo != null && geo.points != null && geo.points.length > 0) {
            var pts = this.abspoints;
            var pt0 = pts[0];
            var pt1 = pts[1];
            result2 = [];
            for (var i = 2; i < pts.length; i++) {
              var pt2 = pts[i];
              if ((Math.round(pt0.x - pt1.x) != 0 || Math.round(pt1.x - pt2.x) != 0) && (Math.round(pt0.y - pt1.y) != 0 || Math.round(pt1.y - pt2.y) != 0)) {
                result2.push(this.convertPoint(pt1.clone(), false));
              }
              pt0 = pt1;
              pt1 = pt2;
            }
          }
          model.beginUpdate();
          try {
            if (result2 != null) {
              var geo = model.getGeometry(edge);
              if (geo != null) {
                geo = geo.clone();
                geo.points = result2;
                model.setGeometry(edge, geo);
              }
            }
            edge = mxEdgeHandler.prototype.connect.apply(this, arguments);
          } finally {
            model.endUpdate();
          }
          return edge;
        };
        mxEdgeSegmentHandler.prototype.getTooltipForNode = function(node) {
          return null;
        };
        mxEdgeSegmentHandler.prototype.start = function(x, y, index) {
          mxEdgeHandler.prototype.start.apply(this, arguments);
          if (this.bends != null && this.bends[index] != null && !this.isSource && !this.isTarget) {
            mxUtils.setOpacity(this.bends[index].node, 100);
          }
        };
        mxEdgeSegmentHandler.prototype.createBends = function() {
          var bends = [];
          var bend = this.createHandleShape(0);
          this.initBend(bend);
          bend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
          bends.push(bend);
          var pts = this.getCurrentPoints();
          if (this.graph.isCellBendable(this.state.cell)) {
            if (this.points == null) {
              this.points = [];
            }
            for (var i = 0; i < pts.length - 1; i++) {
              bend = this.createVirtualBend();
              bends.push(bend);
              var horizontal = Math.round(pts[i].x - pts[i + 1].x) == 0;
              if (Math.round(pts[i].y - pts[i + 1].y) == 0 && i < pts.length - 2) {
                horizontal = Math.round(pts[i].x - pts[i + 2].x) == 0;
              }
              bend.setCursor(horizontal ? "col-resize" : "row-resize");
              this.points.push(new mxPoint(0, 0));
            }
          }
          var bend = this.createHandleShape(pts.length);
          this.initBend(bend);
          bend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);
          bends.push(bend);
          return bends;
        };
        mxEdgeSegmentHandler.prototype.redraw = function() {
          this.refresh();
          mxEdgeHandler.prototype.redraw.apply(this, arguments);
        };
        mxEdgeSegmentHandler.prototype.redrawInnerBends = function(p0, pe) {
          if (this.graph.isCellBendable(this.state.cell)) {
            var pts = this.getCurrentPoints();
            if (pts != null && pts.length > 1) {
              var straight = false;
              if (pts.length == 4 && Math.round(pts[1].x - pts[2].x) == 0 && Math.round(pts[1].y - pts[2].y) == 0) {
                straight = true;
                if (Math.round(pts[0].y - pts[pts.length - 1].y) == 0) {
                  var cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;
                  pts[1] = new mxPoint(cx, pts[1].y);
                  pts[2] = new mxPoint(cx, pts[2].y);
                } else {
                  var cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;
                  pts[1] = new mxPoint(pts[1].x, cy);
                  pts[2] = new mxPoint(pts[2].x, cy);
                }
              }
              for (var i = 0; i < pts.length - 1; i++) {
                if (this.bends[i + 1] != null) {
                  var p0 = pts[i];
                  var pe = pts[i + 1];
                  var pt = new mxPoint(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);
                  var b = this.bends[i + 1].bounds;
                  this.bends[i + 1].bounds = new mxRectangle(
                    Math.floor(pt.x - b.width / 2),
                    Math.floor(pt.y - b.height / 2),
                    b.width,
                    b.height
                  );
                  this.bends[i + 1].redraw();
                  if (this.manageLabelHandle) {
                    this.checkLabelHandle(this.bends[i + 1].bounds);
                  }
                }
              }
              if (straight) {
                mxUtils.setOpacity(this.bends[1].node, this.virtualBendOpacity);
                mxUtils.setOpacity(this.bends[3].node, this.virtualBendOpacity);
              }
            }
          }
        };
        __mxOutput.mxEdgeSegmentHandler = typeof mxEdgeSegmentHandler !== "undefined" ? mxEdgeSegmentHandler : void 0;
        function mxKeyHandler(graph, target) {
          if (graph != null) {
            this.graph = graph;
            this.target = target || document.documentElement;
            this.normalKeys = [];
            this.shiftKeys = [];
            this.controlKeys = [];
            this.controlShiftKeys = [];
            this.keydownHandler = mxUtils.bind(this, function(evt) {
              this.keyDown(evt);
            });
            mxEvent.addListener(this.target, "keydown", this.keydownHandler);
            if (mxClient.IS_IE) {
              mxEvent.addListener(
                window,
                "unload",
                mxUtils.bind(this, function() {
                  this.destroy();
                })
              );
            }
          }
        }
        ;
        mxKeyHandler.prototype.graph = null;
        mxKeyHandler.prototype.target = null;
        mxKeyHandler.prototype.normalKeys = null;
        mxKeyHandler.prototype.shiftKeys = null;
        mxKeyHandler.prototype.controlKeys = null;
        mxKeyHandler.prototype.controlShiftKeys = null;
        mxKeyHandler.prototype.enabled = true;
        mxKeyHandler.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxKeyHandler.prototype.setEnabled = function(enabled) {
          this.enabled = enabled;
        };
        mxKeyHandler.prototype.bindKey = function(code, funct) {
          this.normalKeys[code] = funct;
        };
        mxKeyHandler.prototype.bindShiftKey = function(code, funct) {
          this.shiftKeys[code] = funct;
        };
        mxKeyHandler.prototype.bindControlKey = function(code, funct) {
          this.controlKeys[code] = funct;
        };
        mxKeyHandler.prototype.bindControlShiftKey = function(code, funct) {
          this.controlShiftKeys[code] = funct;
        };
        mxKeyHandler.prototype.isControlDown = function(evt) {
          return mxEvent.isControlDown(evt);
        };
        mxKeyHandler.prototype.getFunction = function(evt) {
          if (evt != null && !mxEvent.isAltDown(evt)) {
            if (this.isControlDown(evt)) {
              if (mxEvent.isShiftDown(evt)) {
                return this.controlShiftKeys[evt.keyCode];
              } else {
                return this.controlKeys[evt.keyCode];
              }
            } else {
              if (mxEvent.isShiftDown(evt)) {
                return this.shiftKeys[evt.keyCode];
              } else {
                return this.normalKeys[evt.keyCode];
              }
            }
          }
          return null;
        };
        mxKeyHandler.prototype.isGraphEvent = function(evt) {
          var source = mxEvent.getSource(evt);
          if (source == this.target || source.parentNode == this.target || this.graph.cellEditor != null && this.graph.cellEditor.isEventSource(evt)) {
            return true;
          }
          return mxUtils.isAncestorNode(this.graph.container, source);
        };
        mxKeyHandler.prototype.keyDown = function(evt) {
          if (this.isEnabledForEvent(evt)) {
            if (evt.keyCode == 27) {
              this.escape(evt);
            } else if (!this.isEventIgnored(evt)) {
              var boundFunction = this.getFunction(evt);
              if (boundFunction != null) {
                boundFunction(evt);
                mxEvent.consume(evt);
              }
            }
          }
        };
        mxKeyHandler.prototype.isEnabledForEvent = function(evt) {
          return this.graph.isEnabled() && !mxEvent.isConsumed(evt) && this.isGraphEvent(evt) && this.isEnabled();
        };
        mxKeyHandler.prototype.isEventIgnored = function(evt) {
          return this.graph.isEditing();
        };
        mxKeyHandler.prototype.escape = function(evt) {
          if (this.graph.isEscapeEnabled()) {
            this.graph.escape(evt);
          }
        };
        mxKeyHandler.prototype.destroy = function() {
          if (this.target != null && this.keydownHandler != null) {
            mxEvent.removeListener(this.target, "keydown", this.keydownHandler);
            this.keydownHandler = null;
          }
          this.target = null;
        };
        __mxOutput.mxKeyHandler = typeof mxKeyHandler !== "undefined" ? mxKeyHandler : void 0;
        function mxTooltipHandler(graph, delay) {
          if (graph != null) {
            this.graph = graph;
            this.delay = delay || 500;
            this.graph.addMouseListener(this);
          }
        }
        ;
        mxTooltipHandler.prototype.isVisible = false;
        mxTooltipHandler.prototype.zIndex = 10005;
        mxTooltipHandler.prototype.graph = null;
        mxTooltipHandler.prototype.delay = null;
        mxTooltipHandler.prototype.ignoreTouchEvents = true;
        mxTooltipHandler.prototype.hideOnHover = false;
        mxTooltipHandler.prototype.destroyed = false;
        mxTooltipHandler.prototype.enabled = true;
        mxTooltipHandler.prototype.isEnabled = function() {
          return this.enabled;
        };
        mxTooltipHandler.prototype.setEnabled = function(enabled) {
          this.enabled = enabled;
        };
        mxTooltipHandler.prototype.isHideOnHover = function() {
          return this.hideOnHover;
        };
        mxTooltipHandler.prototype.setHideOnHover = function(value) {
          this.hideOnHover = value;
        };
        mxTooltipHandler.prototype.init = function() {
          if (document.body != null) {
            this.div = document.createElement("div");
            this.div.className = "mxTooltip";
            this.div.style.visibility = "hidden";
            this.div.setAttribute("role", "tooltip");
            this.div.setAttribute("aria-live", "polite");
            document.body.appendChild(this.div);
            mxEvent.addGestureListeners(this.div, mxUtils.bind(this, function(evt) {
              var source = mxEvent.getSource(evt);
              if (source.nodeName != "A") {
                this.hideTooltip();
              }
            }));
            mxEvent.addListener(this.div, "mousemove", mxUtils.bind(this, function(evt) {
              var pt = mxUtils.convertPoint(this.graph.container, evt.clientX, evt.clientY);
              if (this.sourceCell !== void 0 && pt.x < this.sourceCell?.geometry?.x || pt.x > this.sourceCell?.geometry?.x + this.sourceCell?.geometry?.width || pt.y < this.sourceCell?.geometry?.y || pt.y > this.sourceCell?.geometry?.y + this.sourceCell?.geometry?.height) {
                this.hideTooltip();
              }
            }));
            mxEvent.addListener(this.div, "mouseleave", mxUtils.bind(this, function(evt) {
              this.hideTooltip();
            }));
          }
        };
        mxTooltipHandler.prototype.getStateForEvent = function(me) {
          return me.getState();
        };
        mxTooltipHandler.prototype.mouseDown = function(sender, me) {
          this.reset(me, false);
          this.hideTooltip();
        };
        mxTooltipHandler.prototype.mouseMove = function(sender, me) {
          if (me.getX() != this.lastX || me.getY() != this.lastY) {
            this.reset(me, true);
            var state = this.getStateForEvent(me);
            if (this.isHideOnHover() || state != this.state || me.getSource() != this.node && (!this.stateSource || state != null && this.stateSource == (me.isSource(state.shape) || !me.isSource(state.text)))) {
              if (this.sourceCell?.cellDivs?.container) {
                const container = this.sourceCell.cellDivs.container;
                const containerRect = container.getBoundingClientRect();
                if (me.evt.x < containerRect.x || me.evt.x > containerRect.x + containerRect.width || me.evt.y < containerRect.y || me.evt.y > containerRect.y + containerRect.height) {
                  this.hideTooltip();
                }
              } else {
                this.hideTooltip();
              }
            }
          }
          this.lastX = me.getX();
          this.lastY = me.getY();
        };
        mxTooltipHandler.prototype.mouseUp = function(sender, me) {
          this.reset(me, true);
          this.hideTooltip();
        };
        mxTooltipHandler.prototype.resetTimer = function() {
          if (this.thread != null) {
            window.clearTimeout(this.thread);
            this.thread = null;
          }
        };
        mxTooltipHandler.prototype.reset = function(me, restart, state) {
          if (!this.ignoreTouchEvents || mxEvent.isMouseEvent(me.getEvent())) {
            this.resetTimer();
            state = state != null ? state : this.getStateForEvent(me);
            if (restart && this.isEnabled() && state != null && (this.div == null || this.div.style.visibility == "hidden")) {
              var node = me.getSource();
              var x = me.getX();
              var y = me.getY();
              var stateSource = me.isSource(state.shape) || me.isSource(state.text);
              this.thread = window.setTimeout(mxUtils.bind(this, function() {
                this.sourceCell = me.sourceState.cell;
                if (!this.graph.isEditing() && !this.graph.popupMenuHandler.isMenuShowing() && !this.graph.isMouseDown) {
                  var tip = this.graph.getTooltip(state, node, x, y);
                  this.show(tip, x, y);
                  this.state = state;
                  this.node = node;
                  this.stateSource = stateSource;
                }
              }), this.delay);
            }
          }
        };
        mxTooltipHandler.prototype.hide = function() {
          this.resetTimer();
          this.hideTooltip();
        };
        mxTooltipHandler.prototype.hideTooltip = function() {
          if (this.div != null) {
            this.div.style.visibility = "hidden";
            this.div.innerHTML = "";
            this.isVisible = false;
          }
          this.sourceCell = void 0;
        };
        mxTooltipHandler.prototype.show = function(tip, x, y, cell2) {
          if (cell2) {
            this.sourceCell = cell2;
          }
          if (!this.destroyed && tip != null && tip.length > 0) {
            if (this.div == null) {
              this.init();
            }
            var origin = mxUtils.getScrollOrigin();
            this.div.style.zIndex = this.zIndex;
            this.div.style.left = x + origin.x + "px";
            this.div.style.top = y + mxConstants.TOOLTIP_VERTICAL_OFFSET + origin.y + "px";
            if (!mxUtils.isNode(tip)) {
              this.div.innerHTML = tip.replace(/\n/g, "<br>");
            } else {
              this.div.innerHTML = "";
              this.div.appendChild(tip);
            }
            const tooltipPadding = 4;
            const tooltipWidth = this.div.offsetWidth + tooltipPadding;
            const tooltipHeight = this.div.offsetHeight + tooltipPadding;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            if (windowWidth - x < tooltipWidth) {
              this.div.style.left = Math.max(window.scrollX, windowWidth - tooltipWidth) + "px";
            }
            if (windowHeight - y < tooltipHeight) {
              this.div.style.top = Math.max(window.scrollY, windowHeight - tooltipHeight) + "px";
            }
            this.div.style.visibility = "";
            this.isVisible = true;
            this.graph.fireEvent(new mxEventObject(mxEvent.TOOLTIP_SHOWN, "tooltip", this.div, "x", x, "y", y));
          }
        };
        mxTooltipHandler.prototype.destroy = function() {
          if (!this.destroyed) {
            this.graph.removeMouseListener(this);
            mxEvent.release(this.div);
            if (this.div != null && this.div.parentNode != null) {
              this.div.parentNode.removeChild(this.div);
            }
            this.destroyed = true;
            this.div = null;
            this.isVisible = false;
          }
        };
        __mxOutput.mxTooltipHandler = typeof mxTooltipHandler !== "undefined" ? mxTooltipHandler : void 0;
        function mxCellTracker(graph, color, funct) {
          mxCellMarker.call(this, graph, color);
          this.graph.addMouseListener(this);
          if (funct != null) {
            this.getCell = funct;
          }
          if (mxClient.IS_IE) {
            mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
              this.destroy();
            }));
          }
        }
        ;
        mxUtils.extend(mxCellTracker, mxCellMarker);
        mxCellTracker.prototype.mouseDown = function(sender, me) {
        };
        mxCellTracker.prototype.mouseMove = function(sender, me) {
          if (this.isEnabled()) {
            this.process(me);
          }
        };
        mxCellTracker.prototype.mouseUp = function(sender, me) {
        };
        mxCellTracker.prototype.destroy = function() {
          if (!this.destroyed) {
            this.destroyed = true;
            this.graph.removeMouseListener(this);
            mxCellMarker.prototype.destroy.apply(this);
          }
        };
        __mxOutput.mxCellTracker = typeof mxCellTracker !== "undefined" ? mxCellTracker : void 0;
        function mxCellHighlight(graph, highlightColor, strokeWidth, dashed) {
          if (graph != null) {
            this.graph = graph;
            this.highlightColor = highlightColor != null ? highlightColor : mxConstants.DEFAULT_VALID_COLOR;
            this.strokeWidth = strokeWidth != null ? strokeWidth : mxConstants.HIGHLIGHT_STROKEWIDTH;
            this.dashed = dashed != null ? dashed : false;
            this.opacity = mxConstants.HIGHLIGHT_OPACITY;
            this.repaintHandler = mxUtils.bind(this, function() {
              if (this.state != null) {
                var tmp = this.graph.view.getState(this.state.cell);
                if (tmp == null) {
                  this.hide();
                } else {
                  this.state = tmp;
                  this.repaint();
                }
              }
            });
            this.graph.getView().addListener(mxEvent.SCALE, this.repaintHandler);
            this.graph.getView().addListener(mxEvent.TRANSLATE, this.repaintHandler);
            this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.repaintHandler);
            this.graph.getModel().addListener(mxEvent.CHANGE, this.repaintHandler);
            this.resetHandler = mxUtils.bind(this, function() {
              this.hide();
            });
            this.graph.getView().addListener(mxEvent.DOWN, this.resetHandler);
            this.graph.getView().addListener(mxEvent.UP, this.resetHandler);
          }
        }
        ;
        mxCellHighlight.prototype.keepOnTop = false;
        mxCellHighlight.prototype.graph = null;
        mxCellHighlight.prototype.state = null;
        mxCellHighlight.prototype.spacing = 2;
        mxCellHighlight.prototype.resetHandler = null;
        mxCellHighlight.prototype.setHighlightColor = function(color) {
          this.highlightColor = color;
          if (this.shape != null) {
            this.shape.stroke = color;
          }
        };
        mxCellHighlight.prototype.drawHighlight = function() {
          this.shape = this.createShape();
          this.repaint();
          if (!this.keepOnTop && this.shape.node.parentNode.firstChild != this.shape.node) {
            this.shape.node.parentNode.insertBefore(this.shape.node, this.shape.node.parentNode.firstChild);
          }
        };
        mxCellHighlight.prototype.createShape = function() {
          var shape2 = this.graph.cellRenderer.createShape(this.state);
          shape2.svgStrokeTolerance = this.graph.tolerance;
          shape2.points = this.state.absolutePoints;
          shape2.apply(this.state);
          shape2.stroke = this.highlightColor;
          shape2.opacity = this.opacity;
          shape2.isDashed = this.dashed;
          shape2.isShadow = false;
          shape2.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;
          shape2.init(this.graph.getView().getOverlayPane());
          mxEvent.redirectMouseEvents(shape2.node, this.graph, this.state);
          if (this.graph.dialect != mxConstants.DIALECT_SVG) {
            shape2.pointerEvents = false;
          } else {
            shape2.svgPointerEvents = "stroke";
          }
          return shape2;
        };
        mxCellHighlight.prototype.getStrokeWidth = function(state) {
          return this.strokeWidth;
        };
        mxCellHighlight.prototype.repaint = function() {
          if (this.state != null && this.shape != null) {
            this.shape.scale = this.state.view.scale;
            if (this.graph.model.isEdge(this.state.cell)) {
              this.shape.strokewidth = this.getStrokeWidth();
              this.shape.points = this.state.absolutePoints;
              this.shape.outline = false;
            } else {
              const x = this.state.text ? Math.min(this.state.x, this.state.text.boundingBox.x) : this.state.x;
              const y = this.state.text ? Math.min(this.state.y, this.state.text.boundingBox.y) : this.state.y;
              const w2 = this.state.text ? Math.max(this.state.x + this.state.width, this.state.text.boundingBox.x + this.state.text.boundingBox.width) - x : this.state.width;
              const h2 = this.state.text ? Math.max(this.state.y + this.state.height, this.state.text.boundingBox.y + this.state.text.boundingBox.height) - y : this.state.height;
              this.shape.bounds = new mxRectangle(x - 2, y - 2, w2 + 5, h2 + 3);
              this.shape.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
              this.shape.strokewidth = this.getStrokeWidth() / this.state.view.scale;
              this.shape.outline = true;
            }
            if (this.state.shape != null) {
              this.shape.setCursor(this.state.shape.getCursor());
            }
            if (mxClient.IS_QUIRKS || document.documentMode == 8) {
              if (this.shape.stroke == "transparent") {
                this.shape.stroke = "white";
                this.shape.opacity = 1;
              } else {
                this.shape.opacity = this.opacity;
              }
            }
            this.shape.redraw();
          }
        };
        mxCellHighlight.prototype.hide = function() {
          this.highlight(null);
        };
        mxCellHighlight.prototype.highlight = function(state) {
          if (this.state != state) {
            if (this.shape != null) {
              this.shape.destroy();
              this.shape = null;
            }
            this.state = state;
            if (this.state != null) {
              this.drawHighlight();
            }
          }
        };
        mxCellHighlight.prototype.isHighlightAt = function(x, y) {
          var hit = false;
          if (this.shape != null && document.elementFromPoint != null && !mxClient.IS_QUIRKS) {
            var elt = document.elementFromPoint(x, y);
            while (elt != null) {
              if (elt == this.shape.node) {
                hit = true;
                break;
              }
              elt = elt.parentNode;
            }
          }
          return hit;
        };
        mxCellHighlight.prototype.destroy = function() {
          this.graph.getView().removeListener(this.resetHandler);
          this.graph.getView().removeListener(this.repaintHandler);
          this.graph.getModel().removeListener(this.repaintHandler);
          if (this.shape != null) {
            this.shape.destroy();
            this.shape = null;
          }
        };
        __mxOutput.mxCellHighlight = typeof mxCellHighlight !== "undefined" ? mxCellHighlight : void 0;
        function mxDefaultKeyHandler(editor) {
          if (editor != null) {
            this.editor = editor;
            this.handler = new mxKeyHandler(editor.graph);
            var old = this.handler.escape;
            this.handler.escape = function(evt) {
              old.apply(this, arguments);
              editor.hideProperties();
              editor.fireEvent(new mxEventObject(mxEvent.ESCAPE, "event", evt));
            };
          }
        }
        ;
        mxDefaultKeyHandler.prototype.editor = null;
        mxDefaultKeyHandler.prototype.handler = null;
        mxDefaultKeyHandler.prototype.bindAction = function(code, action, control) {
          var keyHandler = mxUtils.bind(this, function() {
            this.editor.execute(action);
          });
          if (control) {
            this.handler.bindControlKey(code, keyHandler);
          } else {
            this.handler.bindKey(code, keyHandler);
          }
        };
        mxDefaultKeyHandler.prototype.destroy = function() {
          this.handler.destroy();
          this.handler = null;
        };
        __mxOutput.mxDefaultKeyHandler = typeof mxDefaultKeyHandler !== "undefined" ? mxDefaultKeyHandler : void 0;
        function mxDefaultPopupMenu(config) {
          this.config = config;
        }
        ;
        mxDefaultPopupMenu.prototype.imageBasePath = null;
        mxDefaultPopupMenu.prototype.config = null;
        mxDefaultPopupMenu.prototype.createMenu = function(editor, menu, cell2, evt) {
          if (this.config != null) {
            var conditions = this.createConditions(editor, cell2, evt);
            var item = this.config.firstChild;
            this.addItems(editor, menu, cell2, evt, conditions, item, null);
          }
        };
        mxDefaultPopupMenu.prototype.addItems = function(editor, menu, cell2, evt, conditions, item, parent) {
          var addSeparator = false;
          while (item != null) {
            if (item.nodeName == "add") {
              var condition = item.getAttribute("if");
              if (condition == null || conditions[condition]) {
                var as = item.getAttribute("as");
                as = mxResources.get(as) || as;
                var funct = mxUtils.eval(mxUtils.getTextContent(item));
                var action = item.getAttribute("action");
                var icon = item.getAttribute("icon");
                var iconCls = item.getAttribute("iconCls");
                var enabledCond = item.getAttribute("enabled-if");
                var enabled = enabledCond == null || conditions[enabledCond];
                if (addSeparator) {
                  menu.addSeparator(parent);
                  addSeparator = false;
                }
                if (icon != null && this.imageBasePath) {
                  icon = this.imageBasePath + icon;
                }
                var row = this.addAction(menu, editor, as, icon, funct, action, cell2, parent, iconCls, enabled);
                this.addItems(editor, menu, cell2, evt, conditions, item.firstChild, row);
              }
            } else if (item.nodeName == "separator") {
              addSeparator = true;
            }
            item = item.nextSibling;
          }
        };
        mxDefaultPopupMenu.prototype.addAction = function(menu, editor, lab, icon, funct, action, cell2, parent, iconCls, enabled) {
          var clickHandler = function(evt) {
            if (typeof funct == "function") {
              funct.call(editor, editor, cell2, evt);
            }
            if (action != null) {
              editor.execute(action, cell2, evt);
            }
          };
          return menu.addItem(lab, icon, clickHandler, parent, iconCls, enabled);
        };
        mxDefaultPopupMenu.prototype.createConditions = function(editor, cell2, evt) {
          var model = editor.graph.getModel();
          var childCount = model.getChildCount(cell2);
          var conditions = [];
          conditions["nocell"] = cell2 == null;
          conditions["ncells"] = editor.graph.getSelectionCount() > 1;
          conditions["notRoot"] = model.getRoot() != model.getParent(editor.graph.getDefaultParent());
          conditions["cell"] = cell2 != null;
          var isCell = cell2 != null && editor.graph.getSelectionCount() == 1;
          conditions["nonEmpty"] = isCell && childCount > 0;
          conditions["expandable"] = isCell && editor.graph.isCellFoldable(cell2, false);
          conditions["collapsable"] = isCell && editor.graph.isCellFoldable(cell2, true);
          conditions["validRoot"] = isCell && editor.graph.isValidRoot(cell2);
          conditions["emptyValidRoot"] = conditions["validRoot"] && childCount == 0;
          conditions["swimlane"] = isCell && editor.graph.isSwimlane(cell2);
          var condNodes = this.config.getElementsByTagName("condition");
          for (var i = 0; i < condNodes.length; i++) {
            var funct = mxUtils.eval(mxUtils.getTextContent(condNodes[i]));
            var name2 = condNodes[i].getAttribute("name");
            if (name2 != null && typeof funct == "function") {
              conditions[name2] = funct(editor, cell2, evt);
            }
          }
          return conditions;
        };
        __mxOutput.mxDefaultPopupMenu = typeof mxDefaultPopupMenu !== "undefined" ? mxDefaultPopupMenu : void 0;
        function mxDefaultToolbar(container, editor) {
          this.editor = editor;
          if (container != null && editor != null) {
            this.init(container);
          }
        }
        ;
        mxDefaultToolbar.prototype.editor = null;
        mxDefaultToolbar.prototype.toolbar = null;
        mxDefaultToolbar.prototype.resetHandler = null;
        mxDefaultToolbar.prototype.spacing = 4;
        mxDefaultToolbar.prototype.connectOnDrop = false;
        mxDefaultToolbar.prototype.init = function(container) {
          if (container != null) {
            this.toolbar = new mxToolbar(container);
            this.toolbar.addListener(mxEvent.SELECT, mxUtils.bind(this, function(sender, evt) {
              var funct = evt.getProperty("function");
              if (funct != null) {
                this.editor.insertFunction = mxUtils.bind(this, function() {
                  funct.apply(this, arguments);
                  this.toolbar.resetMode();
                });
              } else {
                this.editor.insertFunction = null;
              }
            }));
            this.resetHandler = mxUtils.bind(this, function() {
              if (this.toolbar != null) {
                this.toolbar.resetMode(true);
              }
            });
            this.editor.graph.addListener(mxEvent.DOUBLE_CLICK, this.resetHandler);
            this.editor.addListener(mxEvent.ESCAPE, this.resetHandler);
          }
        };
        mxDefaultToolbar.prototype.addItem = function(title, icon, action, pressed) {
          var clickHandler = mxUtils.bind(this, function() {
            if (action != null && action.length > 0) {
              this.editor.execute(action);
            }
          });
          return this.toolbar.addItem(title, icon, clickHandler, pressed);
        };
        mxDefaultToolbar.prototype.addSeparator = function(icon) {
          icon = icon || mxClient.imageBasePath + "/separator.gif";
          this.toolbar.addSeparator(icon);
        };
        mxDefaultToolbar.prototype.addCombo = function() {
          return this.toolbar.addCombo();
        };
        mxDefaultToolbar.prototype.addActionCombo = function(title) {
          return this.toolbar.addActionCombo(title);
        };
        mxDefaultToolbar.prototype.addActionOption = function(combo, title, action) {
          var clickHandler = mxUtils.bind(this, function() {
            this.editor.execute(action);
          });
          this.addOption(combo, title, clickHandler);
        };
        mxDefaultToolbar.prototype.addOption = function(combo, title, value) {
          return this.toolbar.addOption(combo, title, value);
        };
        mxDefaultToolbar.prototype.addMode = function(title, icon, mode, pressed, funct) {
          var clickHandler = mxUtils.bind(this, function() {
            this.editor.setMode(mode);
            if (funct != null) {
              funct(this.editor);
            }
          });
          return this.toolbar.addSwitchMode(title, icon, clickHandler, pressed);
        };
        mxDefaultToolbar.prototype.addPrototype = function(title, icon, ptype, pressed, insert, toggle) {
          var factory2 = mxUtils.bind(this, function() {
            if (typeof ptype == "function") {
              return ptype();
            } else if (ptype != null) {
              return this.editor.graph.cloneCell(ptype);
            }
            return null;
          });
          var clickHandler = mxUtils.bind(this, function(evt, cell2) {
            if (typeof insert == "function") {
              insert(this.editor, factory2(), evt, cell2);
            } else {
              this.drop(factory2(), evt, cell2);
            }
            this.toolbar.resetMode();
            mxEvent.consume(evt);
          });
          var img = this.toolbar.addMode(title, icon, clickHandler, pressed, null, toggle);
          var dropHandler = function(graph, evt, cell2) {
            clickHandler(evt, cell2);
          };
          this.installDropHandler(img, dropHandler);
          return img;
        };
        mxDefaultToolbar.prototype.drop = function(vertex, evt, target) {
          var graph = this.editor.graph;
          var model = graph.getModel();
          if (target == null || model.isEdge(target) || !this.connectOnDrop || !graph.isCellConnectable(target)) {
            while (target != null && !graph.isValidDropTarget(target, [vertex], evt)) {
              target = model.getParent(target);
            }
            this.insert(vertex, evt, target);
          } else {
            this.connect(vertex, evt, target);
          }
        };
        mxDefaultToolbar.prototype.insert = function(vertex, evt, target) {
          var graph = this.editor.graph;
          if (graph.canImportCell(vertex)) {
            var x = mxEvent.getClientX(evt);
            var y = mxEvent.getClientY(evt);
            var pt = mxUtils.convertPoint(graph.container, x, y);
            if (graph.isSplitEnabled() && graph.isSplitTarget(target, [vertex], evt)) {
              return graph.splitEdge(target, [vertex], null, pt.x, pt.y);
            } else {
              return this.editor.addVertex(target, vertex, pt.x, pt.y);
            }
          }
          return null;
        };
        mxDefaultToolbar.prototype.connect = function(vertex, evt, source) {
          var graph = this.editor.graph;
          var model = graph.getModel();
          if (source != null && graph.isCellConnectable(vertex) && graph.isEdgeValid(null, source, vertex)) {
            var edge = null;
            model.beginUpdate();
            try {
              var geo = model.getGeometry(source);
              var g = model.getGeometry(vertex).clone();
              g.x = geo.x + (geo.width - g.width) / 2;
              g.y = geo.y + (geo.height - g.height) / 2;
              var step = this.spacing * graph.gridSize;
              var dist = model.getDirectedEdgeCount(source, true) * 20;
              if (this.editor.horizontalFlow) {
                g.x += (g.width + geo.width) / 2 + step + dist;
              } else {
                g.y += (g.height + geo.height) / 2 + step + dist;
              }
              vertex.setGeometry(g);
              var parent = model.getParent(source);
              graph.addCell(vertex, parent);
              graph.constrainChild(vertex);
              edge = this.editor.createEdge(source, vertex);
              if (model.getGeometry(edge) == null) {
                var edgeGeometry = new mxGeometry();
                edgeGeometry.relative = true;
                model.setGeometry(edge, edgeGeometry);
              }
              graph.addEdge(edge, parent, source, vertex);
            } finally {
              model.endUpdate();
            }
            graph.setSelectionCells([vertex, edge]);
            graph.scrollCellToVisible(vertex);
          }
        };
        mxDefaultToolbar.prototype.installDropHandler = function(img, dropHandler) {
          var sprite = document.createElement("img");
          sprite.setAttribute("src", img.getAttribute("src"));
          var loader = mxUtils.bind(this, function(evt) {
            sprite.style.width = 2 * img.offsetWidth + "px";
            sprite.style.height = 2 * img.offsetHeight + "px";
            mxUtils.makeDraggable(
              img,
              this.editor.graph,
              dropHandler,
              sprite
            );
            mxEvent.removeListener(sprite, "load", loader);
          });
          if (mxClient.IS_IE) {
            loader();
          } else {
            mxEvent.addListener(sprite, "load", loader);
          }
        };
        mxDefaultToolbar.prototype.destroy = function() {
          if (this.resetHandler != null) {
            this.editor.graph.removeListener("dblclick", this.resetHandler);
            this.editor.removeListener("escape", this.resetHandler);
            this.resetHandler = null;
          }
          if (this.toolbar != null) {
            this.toolbar.destroy();
            this.toolbar = null;
          }
        };
        __mxOutput.mxDefaultToolbar = typeof mxDefaultToolbar !== "undefined" ? mxDefaultToolbar : void 0;
        function mxEditor(config) {
          this.actions = [];
          this.addActions();
          if (document.body != null) {
            this.cycleAttributeValues = [];
            this.popupHandler = new mxDefaultPopupMenu();
            this.undoManager = new mxUndoManager();
            this.graph = this.createGraph();
            this.toolbar = this.createToolbar();
            this.keyHandler = new mxDefaultKeyHandler(this);
            this.configure(config);
            this.graph.swimlaneIndicatorColorAttribute = this.cycleAttributeName;
            if (this.onInit != null) {
              this.onInit();
            }
            if (mxClient.IS_IE) {
              mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
                this.destroy();
              }));
            }
          }
        }
        ;
        mxEditor.prototype = new mxEventSource();
        mxEditor.prototype.constructor = mxEditor;
        mxEditor.prototype.askZoomResource = mxClient.language != "none" ? "askZoom" : "";
        mxEditor.prototype.lastSavedResource = mxClient.language != "none" ? "lastSaved" : "";
        mxEditor.prototype.currentFileResource = mxClient.language != "none" ? "currentFile" : "";
        mxEditor.prototype.propertiesResource = mxClient.language != "none" ? "properties" : "";
        mxEditor.prototype.tasksResource = mxClient.language != "none" ? "tasks" : "";
        mxEditor.prototype.helpResource = mxClient.language != "none" ? "help" : "";
        mxEditor.prototype.outlineResource = mxClient.language != "none" ? "outline" : "";
        mxEditor.prototype.outline = null;
        mxEditor.prototype.graph = null;
        mxEditor.prototype.graphRenderHint = null;
        mxEditor.prototype.toolbar = null;
        mxEditor.prototype.status = null;
        mxEditor.prototype.popupHandler = null;
        mxEditor.prototype.undoManager = null;
        mxEditor.prototype.keyHandler = null;
        mxEditor.prototype.actions = null;
        mxEditor.prototype.dblClickAction = "edit";
        mxEditor.prototype.swimlaneRequired = false;
        mxEditor.prototype.disableContextMenu = true;
        mxEditor.prototype.insertFunction = null;
        mxEditor.prototype.forcedInserting = false;
        mxEditor.prototype.templates = null;
        mxEditor.prototype.defaultEdge = null;
        mxEditor.prototype.defaultEdgeStyle = null;
        mxEditor.prototype.defaultGroup = null;
        mxEditor.prototype.groupBorderSize = null;
        mxEditor.prototype.filename = null;
        mxEditor.prototype.linefeed = "&#xa;";
        mxEditor.prototype.postParameterName = "xml";
        mxEditor.prototype.escapePostData = true;
        mxEditor.prototype.urlPost = null;
        mxEditor.prototype.urlImage = null;
        mxEditor.prototype.horizontalFlow = false;
        mxEditor.prototype.layoutDiagram = false;
        mxEditor.prototype.swimlaneSpacing = 0;
        mxEditor.prototype.maintainSwimlanes = false;
        mxEditor.prototype.layoutSwimlanes = false;
        mxEditor.prototype.cycleAttributeValues = null;
        mxEditor.prototype.cycleAttributeIndex = 0;
        mxEditor.prototype.cycleAttributeName = "fillColor";
        mxEditor.prototype.tasks = null;
        mxEditor.prototype.tasksWindowImage = null;
        mxEditor.prototype.tasksTop = 20;
        mxEditor.prototype.help = null;
        mxEditor.prototype.helpWindowImage = null;
        mxEditor.prototype.urlHelp = null;
        mxEditor.prototype.helpWidth = 300;
        mxEditor.prototype.helpHeight = 260;
        mxEditor.prototype.propertiesWidth = 240;
        mxEditor.prototype.propertiesHeight = null;
        mxEditor.prototype.movePropertiesDialog = false;
        mxEditor.prototype.validating = false;
        mxEditor.prototype.modified = false;
        mxEditor.prototype.isModified = function() {
          return this.modified;
        };
        mxEditor.prototype.setModified = function(value) {
          this.modified = value;
        };
        mxEditor.prototype.addActions = function() {
          this.addAction("save", function(editor) {
            editor.save();
          });
          this.addAction("print", function(editor) {
            var preview = new mxPrintPreview(editor.graph, 1);
            preview.open();
          });
          this.addAction("show", function(editor) {
            mxUtils.show(editor.graph, null, 10, 10);
          });
          this.addAction("exportImage", function(editor) {
            var url = editor.getUrlImage();
            if (url == null || mxClient.IS_LOCAL) {
              editor.execute("show");
            } else {
              var node = mxUtils.getViewXml(editor.graph, 1);
              var xml = mxUtils.getXml(node, "\n");
              mxUtils.submit(url, editor.postParameterName + "=" + encodeURIComponent(xml), document, "_blank");
            }
          });
          this.addAction("refresh", function(editor) {
            editor.graph.refresh();
          });
          this.addAction("cut", function(editor) {
            if (editor.graph.isEnabled()) {
              mxClipboard.cut(editor.graph);
            }
          });
          this.addAction("copy", function(editor) {
            if (editor.graph.isEnabled()) {
              mxClipboard.copy(editor.graph);
            }
          });
          this.addAction("paste", function(editor) {
            if (editor.graph.isEnabled()) {
              mxClipboard.paste(editor.graph);
            }
          });
          this.addAction("delete", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.removeCells();
            }
          });
          this.addAction("group", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.setSelectionCell(editor.groupCells());
            }
          });
          this.addAction("ungroup", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.setSelectionCells(editor.graph.ungroupCells());
            }
          });
          this.addAction("removeFromParent", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.removeCellsFromParent();
            }
          });
          this.addAction("undo", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.undo();
            }
          });
          this.addAction("redo", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.redo();
            }
          });
          this.addAction("zoomIn", function(editor) {
            editor.graph.zoomIn();
          });
          this.addAction("zoomOut", function(editor) {
            editor.graph.zoomOut();
          });
          this.addAction("actualSize", function(editor) {
            editor.graph.zoomActual();
          });
          this.addAction("fit", function(editor) {
            editor.graph.fit();
          });
          this.addAction("showProperties", function(editor, cell2) {
            editor.showProperties(cell2);
          });
          this.addAction("selectAll", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.selectAll();
            }
          });
          this.addAction("selectNone", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.clearSelection();
            }
          });
          this.addAction("selectVertices", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.selectVertices();
            }
          });
          this.addAction("selectEdges", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.selectEdges();
            }
          });
          this.addAction("edit", function(editor, cell2) {
            if (editor.graph.isEnabled() && editor.graph.isCellEditable(cell2)) {
              editor.graph.startEditingAtCell(cell2);
            }
          });
          this.addAction("toBack", function(editor, cell2) {
            if (editor.graph.isEnabled()) {
              editor.graph.orderCells(true);
            }
          });
          this.addAction("toFront", function(editor, cell2) {
            if (editor.graph.isEnabled()) {
              editor.graph.orderCells(false);
            }
          });
          this.addAction("enterGroup", function(editor, cell2) {
            editor.graph.enterGroup(cell2);
          });
          this.addAction("exitGroup", function(editor) {
            editor.graph.exitGroup();
          });
          this.addAction("home", function(editor) {
            editor.graph.home();
          });
          this.addAction("selectPrevious", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.selectPreviousCell();
            }
          });
          this.addAction("selectNext", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.selectNextCell();
            }
          });
          this.addAction("selectParent", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.selectParentCell();
            }
          });
          this.addAction("selectChild", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.selectChildCell();
            }
          });
          this.addAction("collapse", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.foldCells(true);
            }
          });
          this.addAction("collapseAll", function(editor) {
            if (editor.graph.isEnabled()) {
              var cells = editor.graph.getChildVertices();
              editor.graph.foldCells(true, false, cells);
            }
          });
          this.addAction("expand", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.foldCells(false);
            }
          });
          this.addAction("expandAll", function(editor) {
            if (editor.graph.isEnabled()) {
              var cells = editor.graph.getChildVertices();
              editor.graph.foldCells(false, false, cells);
            }
          });
          this.addAction("bold", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.toggleCellStyleFlags(
                mxConstants.STYLE_FONTSTYLE,
                mxConstants.FONT_BOLD
              );
            }
          });
          this.addAction("italic", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.toggleCellStyleFlags(
                mxConstants.STYLE_FONTSTYLE,
                mxConstants.FONT_ITALIC
              );
            }
          });
          this.addAction("underline", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.toggleCellStyleFlags(
                mxConstants.STYLE_FONTSTYLE,
                mxConstants.FONT_UNDERLINE
              );
            }
          });
          this.addAction("alignCellsLeft", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.alignCells(mxConstants.ALIGN_LEFT);
            }
          });
          this.addAction("alignCellsCenter", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.alignCells(mxConstants.ALIGN_CENTER);
            }
          });
          this.addAction("alignCellsRight", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.alignCells(mxConstants.ALIGN_RIGHT);
            }
          });
          this.addAction("alignCellsTop", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.alignCells(mxConstants.ALIGN_TOP);
            }
          });
          this.addAction("alignCellsMiddle", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.alignCells(mxConstants.ALIGN_MIDDLE);
            }
          });
          this.addAction("alignCellsBottom", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.alignCells(mxConstants.ALIGN_BOTTOM);
            }
          });
          this.addAction("alignFontLeft", function(editor) {
            editor.graph.setCellStyles(
              mxConstants.STYLE_ALIGN,
              mxConstants.ALIGN_LEFT
            );
          });
          this.addAction("alignFontCenter", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.setCellStyles(
                mxConstants.STYLE_ALIGN,
                mxConstants.ALIGN_CENTER
              );
            }
          });
          this.addAction("alignFontRight", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.setCellStyles(
                mxConstants.STYLE_ALIGN,
                mxConstants.ALIGN_RIGHT
              );
            }
          });
          this.addAction("alignFontTop", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.setCellStyles(
                mxConstants.STYLE_VERTICAL_ALIGN,
                mxConstants.ALIGN_TOP
              );
            }
          });
          this.addAction("alignFontMiddle", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.setCellStyles(
                mxConstants.STYLE_VERTICAL_ALIGN,
                mxConstants.ALIGN_MIDDLE
              );
            }
          });
          this.addAction("alignFontBottom", function(editor) {
            if (editor.graph.isEnabled()) {
              editor.graph.setCellStyles(
                mxConstants.STYLE_VERTICAL_ALIGN,
                mxConstants.ALIGN_BOTTOM
              );
            }
          });
          this.addAction("zoom", function(editor) {
            var current = editor.graph.getView().scale * 100;
            var scale = parseFloat(mxUtils.prompt(
              mxResources.get(editor.askZoomResource) || editor.askZoomResource,
              current
            )) / 100;
            if (!isNaN(scale)) {
              editor.graph.getView().setScale(scale);
            }
          });
          this.addAction("toggleTasks", function(editor) {
            if (editor.tasks != null) {
              editor.tasks.setVisible(!editor.tasks.isVisible());
            } else {
              editor.showTasks();
            }
          });
          this.addAction("toggleHelp", function(editor) {
            if (editor.help != null) {
              editor.help.setVisible(!editor.help.isVisible());
            } else {
              editor.showHelp();
            }
          });
          this.addAction("toggleOutline", function(editor) {
            if (editor.outline == null) {
              editor.showOutline();
            } else {
              editor.outline.setVisible(!editor.outline.isVisible());
            }
          });
          this.addAction("toggleConsole", function(editor) {
            mxLog.setVisible(!mxLog.isVisible());
          });
        };
        mxEditor.prototype.configure = function(node) {
          if (node != null) {
            var dec = new mxCodec(node.ownerDocument);
            dec.decode(node, this);
            this.resetHistory();
          }
        };
        mxEditor.prototype.resetFirstTime = function() {
          document.cookie = "mxgraph=seen; expires=Fri, 27 Jul 2001 02:47:11 UTC; path=/";
        };
        mxEditor.prototype.resetHistory = function() {
          this.lastSnapshot = (/* @__PURE__ */ new Date()).getTime();
          this.undoManager.clear();
          this.ignoredChanges = 0;
          this.setModified(false);
        };
        mxEditor.prototype.addAction = function(actionname, funct) {
          this.actions[actionname] = funct;
        };
        mxEditor.prototype.execute = function(actionname, cell2, evt) {
          var action = this.actions[actionname];
          if (action != null) {
            try {
              var args = arguments;
              args[0] = this;
              action.apply(this, args);
            } catch (e) {
              mxUtils.error("Cannot execute " + actionname + ": " + e.message, 280, true);
              throw e;
            }
          } else {
            mxUtils.error("Cannot find action " + actionname, 280, true);
          }
        };
        mxEditor.prototype.addTemplate = function(name2, template) {
          this.templates[name2] = template;
        };
        mxEditor.prototype.getTemplate = function(name2) {
          return this.templates[name2];
        };
        mxEditor.prototype.createGraph = function() {
          var graph = new mxGraph(null, null, this.graphRenderHint);
          graph.setTooltips(true);
          graph.setPanning(true);
          this.installDblClickHandler(graph);
          this.installUndoHandler(graph);
          this.installDrillHandler(graph);
          this.installChangeHandler(graph);
          this.installInsertHandler(graph);
          graph.popupMenuHandler.factoryMethod = mxUtils.bind(this, function(menu, cell2, evt) {
            return this.createPopupMenu(menu, cell2, evt);
          });
          graph.connectionHandler.factoryMethod = mxUtils.bind(this, function(source, target) {
            return this.createEdge(source, target);
          });
          this.createSwimlaneManager(graph);
          this.createLayoutManager(graph);
          return graph;
        };
        mxEditor.prototype.createSwimlaneManager = function(graph) {
          var swimlaneMgr = new mxSwimlaneManager(graph, false);
          swimlaneMgr.isHorizontal = mxUtils.bind(this, function() {
            return this.horizontalFlow;
          });
          swimlaneMgr.isEnabled = mxUtils.bind(this, function() {
            return this.maintainSwimlanes;
          });
          return swimlaneMgr;
        };
        mxEditor.prototype.createLayoutManager = function(graph) {
          var layoutMgr = new mxLayoutManager(graph);
          var self = this;
          layoutMgr.getLayout = function(cell2) {
            var layout = null;
            var model = self.graph.getModel();
            if (model.getParent(cell2) != null) {
              if (self.layoutSwimlanes && graph.isSwimlane(cell2)) {
                if (self.swimlaneLayout == null) {
                  self.swimlaneLayout = self.createSwimlaneLayout();
                }
                layout = self.swimlaneLayout;
              } else if (self.layoutDiagram && (graph.isValidRoot(cell2) || model.getParent(model.getParent(cell2)) == null)) {
                if (self.diagramLayout == null) {
                  self.diagramLayout = self.createDiagramLayout();
                }
                layout = self.diagramLayout;
              }
            }
            return layout;
          };
          return layoutMgr;
        };
        mxEditor.prototype.setGraphContainer = function(container) {
          if (this.graph.container == null) {
            this.graph.init(container);
            this.rubberband = new mxRubberband(this.graph);
            if (this.disableContextMenu) {
              mxEvent.disableContextMenu(container);
            }
            if (mxClient.IS_QUIRKS) {
              new mxDivResizer(container);
            }
          }
        };
        mxEditor.prototype.installDblClickHandler = function(graph) {
          graph.addListener(
            mxEvent.DOUBLE_CLICK,
            mxUtils.bind(this, function(sender, evt) {
              var cell2 = evt.getProperty("cell");
              if (cell2 != null && graph.isEnabled() && this.dblClickAction != null) {
                this.execute(this.dblClickAction, cell2);
                evt.consume();
              }
            })
          );
        };
        mxEditor.prototype.installUndoHandler = function(graph) {
          var listener = mxUtils.bind(this, function(sender, evt) {
            var edit = evt.getProperty("edit");
            this.undoManager.undoableEditHappened(edit);
          });
          graph.getModel().addListener(mxEvent.UNDO, listener);
          graph.getView().addListener(mxEvent.UNDO, listener);
          var undoHandler = function(sender, evt) {
            var changes = evt.getProperty("edit").changes;
            graph.setSelectionCells(graph.getSelectionCellsForChanges(changes));
          };
          this.undoManager.addListener(mxEvent.UNDO, undoHandler);
          this.undoManager.addListener(mxEvent.REDO, undoHandler);
        };
        mxEditor.prototype.installDrillHandler = function(graph) {
          var listener = mxUtils.bind(this, function(sender) {
            this.fireEvent(new mxEventObject(mxEvent.ROOT));
          });
          graph.getView().addListener(mxEvent.DOWN, listener);
          graph.getView().addListener(mxEvent.UP, listener);
        };
        mxEditor.prototype.installChangeHandler = function(graph) {
          var listener = mxUtils.bind(this, function(sender, evt) {
            this.setModified(true);
            if (this.validating == true) {
              graph.validateGraph();
            }
            var changes = evt.getProperty("edit").changes;
            for (var i = 0; i < changes.length; i++) {
              var change = changes[i];
              if (change instanceof mxRootChange || change instanceof mxValueChange && change.cell == this.graph.model.root || change instanceof mxCellAttributeChange && change.cell == this.graph.model.root) {
                this.fireEvent(new mxEventObject(mxEvent.ROOT));
                break;
              }
            }
          });
          graph.getModel().addListener(mxEvent.CHANGE, listener);
        };
        mxEditor.prototype.installInsertHandler = function(graph) {
          var self = this;
          var insertHandler = {
            mouseDown: function(sender, me) {
              if (self.insertFunction != null && !me.isPopupTrigger() && (self.forcedInserting || me.getState() == null)) {
                self.graph.clearSelection();
                self.insertFunction(me.getEvent(), me.getCell());
                this.isActive = true;
                me.consume();
              }
            },
            mouseMove: function(sender, me) {
              if (this.isActive) {
                me.consume();
              }
            },
            mouseUp: function(sender, me) {
              if (this.isActive) {
                this.isActive = false;
                me.consume();
              }
            }
          };
          graph.addMouseListener(insertHandler);
        };
        mxEditor.prototype.createDiagramLayout = function() {
          var gs = this.graph.gridSize;
          var layout = new mxStackLayout(
            this.graph,
            !this.horizontalFlow,
            this.swimlaneSpacing,
            2 * gs,
            2 * gs
          );
          layout.isVertexIgnored = function(cell2) {
            return !layout.graph.isSwimlane(cell2);
          };
          return layout;
        };
        mxEditor.prototype.createSwimlaneLayout = function() {
          return new mxCompactTreeLayout(this.graph, this.horizontalFlow);
        };
        mxEditor.prototype.createToolbar = function() {
          return new mxDefaultToolbar(null, this);
        };
        mxEditor.prototype.setToolbarContainer = function(container) {
          this.toolbar.init(container);
          if (mxClient.IS_QUIRKS) {
            new mxDivResizer(container);
          }
        };
        mxEditor.prototype.setStatusContainer = function(container) {
          if (this.status == null) {
            this.status = container;
            this.addListener(mxEvent.SAVE, mxUtils.bind(this, function() {
              var tstamp = (/* @__PURE__ */ new Date()).toLocaleString();
              this.setStatus((mxResources.get(this.lastSavedResource) || this.lastSavedResource) + ": " + tstamp);
            }));
            this.addListener(mxEvent.OPEN, mxUtils.bind(this, function() {
              this.setStatus((mxResources.get(this.currentFileResource) || this.currentFileResource) + ": " + this.filename);
            }));
            if (mxClient.IS_QUIRKS) {
              new mxDivResizer(container);
            }
          }
        };
        mxEditor.prototype.setStatus = function(message) {
          if (this.status != null && message != null) {
            this.status.innerHTML = message;
          }
        };
        mxEditor.prototype.setTitleContainer = function(container) {
          this.addListener(mxEvent.ROOT, mxUtils.bind(this, function(sender) {
            container.innerHTML = this.getTitle();
          }));
          if (mxClient.IS_QUIRKS) {
            new mxDivResizer(container);
          }
        };
        mxEditor.prototype.treeLayout = function(cell2, horizontal) {
          if (cell2 != null) {
            var layout = new mxCompactTreeLayout(this.graph, horizontal);
            layout.execute(cell2);
          }
        };
        mxEditor.prototype.getTitle = function() {
          var title = "";
          var graph = this.graph;
          var cell2 = graph.getCurrentRoot();
          while (cell2 != null && graph.getModel().getParent(
            graph.getModel().getParent(cell2)
          ) != null) {
            if (graph.isValidRoot(cell2)) {
              title = " > " + graph.convertValueToString(cell2) + title;
            }
            cell2 = graph.getModel().getParent(cell2);
          }
          var prefix = this.getRootTitle();
          return prefix + title;
        };
        mxEditor.prototype.getRootTitle = function() {
          var root = this.graph.getModel().getRoot();
          return this.graph.convertValueToString(root);
        };
        mxEditor.prototype.undo = function() {
          this.undoManager.undo();
        };
        mxEditor.prototype.redo = function() {
          this.undoManager.redo();
        };
        mxEditor.prototype.groupCells = function() {
          var border = this.groupBorderSize != null ? this.groupBorderSize : this.graph.gridSize;
          return this.graph.groupCells(this.createGroup(), border);
        };
        mxEditor.prototype.createGroup = function() {
          var model = this.graph.getModel();
          return model.cloneCell(this.defaultGroup);
        };
        mxEditor.prototype.open = function(filename) {
          if (filename != null) {
            var xml = mxUtils.load(filename).getXml();
            this.readGraphModel(xml.documentElement);
            this.filename = filename;
            this.fireEvent(new mxEventObject(mxEvent.OPEN, "filename", filename));
          }
        };
        mxEditor.prototype.readGraphModel = function(node) {
          var dec = new mxCodec(node.ownerDocument);
          dec.decode(node, this.graph.getModel());
          this.resetHistory();
        };
        mxEditor.prototype.save = function(url, linefeed) {
          url = url || this.getUrlPost();
          if (url != null && url.length > 0) {
            var data = this.writeGraphModel(linefeed);
            this.postDiagram(url, data);
            this.setModified(false);
          }
          this.fireEvent(new mxEventObject(mxEvent.SAVE, "url", url));
        };
        mxEditor.prototype.postDiagram = function(url, data) {
          if (this.escapePostData) {
            data = encodeURIComponent(data);
          }
          mxUtils.post(
            url,
            this.postParameterName + "=" + data,
            mxUtils.bind(this, function(req) {
              this.fireEvent(new mxEventObject(
                mxEvent.POST,
                "request",
                req,
                "url",
                url,
                "data",
                data
              ));
            })
          );
        };
        mxEditor.prototype.writeGraphModel = function(linefeed) {
          linefeed = linefeed != null ? linefeed : this.linefeed;
          var enc = new mxCodec();
          var node = enc.encode(this.graph.getModel());
          return mxUtils.getXml(node, linefeed);
        };
        mxEditor.prototype.getUrlPost = function() {
          return this.urlPost;
        };
        mxEditor.prototype.getUrlImage = function() {
          return this.urlImage;
        };
        mxEditor.prototype.swapStyles = function(first, second) {
          var style = this.graph.getStylesheet().styles[second];
          this.graph.getView().getStylesheet().putCellStyle(
            second,
            this.graph.getStylesheet().styles[first]
          );
          this.graph.getStylesheet().putCellStyle(first, style);
          this.graph.refresh();
        };
        mxEditor.prototype.showProperties = function(cell2) {
          cell2 = cell2 || this.graph.getSelectionCell();
          if (cell2 == null) {
            cell2 = this.graph.getCurrentRoot();
            if (cell2 == null) {
              cell2 = this.graph.getModel().getRoot();
            }
          }
          if (cell2 != null) {
            this.graph.stopEditing(true);
            var offset = mxUtils.getOffset(this.graph.container);
            var x = offset.x + 10;
            var y = offset.y;
            if (this.properties != null && !this.movePropertiesDialog) {
              x = this.properties.getX();
              y = this.properties.getY();
            } else {
              var bounds = this.graph.getCellBounds(cell2);
              if (bounds != null) {
                x += bounds.x + Math.min(200, bounds.width);
                y += bounds.y;
              }
            }
            this.hideProperties();
            var node = this.createProperties(cell2);
            if (node != null) {
              this.properties = new mxWindow(mxResources.get(this.propertiesResource) || this.propertiesResource, node, x, y, this.propertiesWidth, this.propertiesHeight, false);
              this.properties.setVisible(true);
            }
          }
        };
        mxEditor.prototype.isPropertiesVisible = function() {
          return this.properties != null;
        };
        mxEditor.prototype.createProperties = function(cell2) {
          var model = this.graph.getModel();
          var value = model.getValue(cell2);
          if (mxUtils.isNode(value)) {
            var form = new mxForm("properties");
            var id = form.addText("ID", cell2.getId());
            id.setAttribute("readonly", "true");
            var geo = null;
            var yField = null;
            var xField = null;
            var widthField = null;
            var heightField = null;
            if (model.isVertex(cell2)) {
              geo = model.getGeometry(cell2);
              if (geo != null) {
                yField = form.addText("top", geo.y);
                xField = form.addText("left", geo.x);
                widthField = form.addText("width", geo.width);
                heightField = form.addText("height", geo.height);
              }
            }
            var tmp = model.getStyle(cell2);
            var style = form.addText("Style", tmp || "");
            var attrs = value.attributes;
            var texts = [];
            for (var i = 0; i < attrs.length; i++) {
              var val = attrs[i].value;
              texts[i] = form.addTextarea(
                attrs[i].nodeName,
                val,
                attrs[i].nodeName == "label" ? 4 : 2
              );
            }
            var okFunction = mxUtils.bind(this, function() {
              this.hideProperties();
              model.beginUpdate();
              try {
                if (geo != null) {
                  geo = geo.clone();
                  geo.x = parseFloat(xField.value);
                  geo.y = parseFloat(yField.value);
                  geo.width = parseFloat(widthField.value);
                  geo.height = parseFloat(heightField.value);
                  model.setGeometry(cell2, geo);
                }
                if (style.value.length > 0) {
                  model.setStyle(cell2, style.value);
                } else {
                  model.setStyle(cell2, null);
                }
                for (var i2 = 0; i2 < attrs.length; i2++) {
                  var edit = new mxCellAttributeChange(
                    cell2,
                    attrs[i2].nodeName,
                    texts[i2].value
                  );
                  model.execute(edit);
                }
                if (this.graph.isAutoSizeCell(cell2)) {
                  this.graph.updateCellSize(cell2);
                }
              } finally {
                model.endUpdate();
              }
            });
            var cancelFunction = mxUtils.bind(this, function() {
              this.hideProperties();
            });
            form.addButtons(okFunction, cancelFunction);
            return form.table;
          }
          return null;
        };
        mxEditor.prototype.hideProperties = function() {
          if (this.properties != null) {
            this.properties.destroy();
            this.properties = null;
          }
        };
        mxEditor.prototype.showTasks = function() {
          if (this.tasks == null) {
            var div = document.createElement("div");
            div.style.padding = "4px";
            div.style.paddingLeft = "20px";
            var w2 = document.body.clientWidth;
            var wnd = new mxWindow(
              mxResources.get(this.tasksResource) || this.tasksResource,
              div,
              w2 - 220,
              this.tasksTop,
              200
            );
            wnd.setClosable(true);
            wnd.destroyOnClose = false;
            var funct = mxUtils.bind(this, function(sender) {
              mxEvent.release(div);
              div.innerHTML = "";
              this.createTasks(div);
            });
            this.graph.getModel().addListener(mxEvent.CHANGE, funct);
            this.graph.getSelectionModel().addListener(mxEvent.CHANGE, funct);
            this.graph.addListener(mxEvent.ROOT, funct);
            if (this.tasksWindowImage != null) {
              wnd.setImage(this.tasksWindowImage);
            }
            this.tasks = wnd;
            this.createTasks(div);
          }
          this.tasks.setVisible(true);
        };
        mxEditor.prototype.refreshTasks = function(div) {
          if (this.tasks != null) {
            var div = this.tasks.content;
            mxEvent.release(div);
            div.innerHTML = "";
            this.createTasks(div);
          }
        };
        mxEditor.prototype.createTasks = function(div) {
        };
        mxEditor.prototype.showHelp = function(tasks) {
          if (this.help == null) {
            var frame = document.createElement("iframe");
            frame.setAttribute("src", mxResources.get("urlHelp") || this.urlHelp);
            frame.setAttribute("height", "100%");
            frame.setAttribute("width", "100%");
            frame.setAttribute("frameBorder", "0");
            frame.style.backgroundColor = "white";
            var w2 = document.body.clientWidth;
            var h2 = document.body.clientHeight || document.documentElement.clientHeight;
            var wnd = new mxWindow(
              mxResources.get(this.helpResource) || this.helpResource,
              frame,
              (w2 - this.helpWidth) / 2,
              (h2 - this.helpHeight) / 3,
              this.helpWidth,
              this.helpHeight
            );
            wnd.setMaximizable(true);
            wnd.setClosable(true);
            wnd.destroyOnClose = false;
            wnd.setResizable(true);
            if (this.helpWindowImage != null) {
              wnd.setImage(this.helpWindowImage);
            }
            if (mxClient.IS_NS) {
              var handler = function(sender) {
                var h3 = wnd.div.offsetHeight;
                frame.setAttribute("height", h3 - 26 + "px");
              };
              wnd.addListener(mxEvent.RESIZE_END, handler);
              wnd.addListener(mxEvent.MAXIMIZE, handler);
              wnd.addListener(mxEvent.NORMALIZE, handler);
              wnd.addListener(mxEvent.SHOW, handler);
            }
            this.help = wnd;
          }
          this.help.setVisible(true);
        };
        mxEditor.prototype.showOutline = function() {
          var create = this.outline == null;
          if (create) {
            var div = document.createElement("div");
            div.style.overflow = "hidden";
            div.style.position = "relative";
            div.style.width = "100%";
            div.style.height = "100%";
            div.style.background = "white";
            div.style.cursor = "move";
            if (document.documentMode == 8) {
              div.style.filter = "progid:DXImageTransform.Microsoft.alpha(opacity=100)";
            }
            var wnd = new mxWindow(
              mxResources.get(this.outlineResource) || this.outlineResource,
              div,
              600,
              480,
              200,
              200,
              false
            );
            var outline = new mxOutline(this.graph, div);
            wnd.setClosable(true);
            wnd.setResizable(true);
            wnd.destroyOnClose = false;
            wnd.addListener(mxEvent.RESIZE_END, function() {
              outline.update();
            });
            this.outline = wnd;
            this.outline.outline = outline;
          }
          this.outline.setVisible(true);
          this.outline.outline.update(true);
        };
        mxEditor.prototype.setMode = function(modename) {
          if (modename == "select") {
            this.graph.panningHandler.useLeftButtonForPanning = false;
            this.graph.setConnectable(false);
          } else if (modename == "connect") {
            this.graph.panningHandler.useLeftButtonForPanning = false;
            this.graph.setConnectable(true);
          } else if (modename == "pan") {
            this.graph.panningHandler.useLeftButtonForPanning = true;
            this.graph.setConnectable(false);
          }
        };
        mxEditor.prototype.createPopupMenu = function(menu, cell2, evt) {
          this.popupHandler.createMenu(this, menu, cell2, evt);
        };
        mxEditor.prototype.createEdge = function(source, target) {
          var e = null;
          if (this.defaultEdge != null) {
            var model = this.graph.getModel();
            e = model.cloneCell(this.defaultEdge);
          } else {
            e = new mxCell("");
            e.setEdge(true);
            var geo = new mxGeometry();
            geo.relative = true;
            e.setGeometry(geo);
          }
          var style = this.getEdgeStyle();
          if (style != null) {
            e.setStyle(style);
          }
          return e;
        };
        mxEditor.prototype.getEdgeStyle = function() {
          return this.defaultEdgeStyle;
        };
        mxEditor.prototype.consumeCycleAttribute = function(cell2) {
          return this.cycleAttributeValues != null && this.cycleAttributeValues.length > 0 && this.graph.isSwimlane(cell2) ? this.cycleAttributeValues[this.cycleAttributeIndex++ % this.cycleAttributeValues.length] : null;
        };
        mxEditor.prototype.cycleAttribute = function(cell2) {
          if (this.cycleAttributeName != null) {
            var value = this.consumeCycleAttribute(cell2);
            if (value != null) {
              cell2.setStyle(cell2.getStyle() + ";" + this.cycleAttributeName + "=" + value);
            }
          }
        };
        mxEditor.prototype.addVertex = function(parent, vertex, x, y) {
          var model = this.graph.getModel();
          while (parent != null && !this.graph.isValidDropTarget(parent)) {
            parent = model.getParent(parent);
          }
          parent = parent != null ? parent : this.graph.getSwimlaneAt(x, y);
          var scale = this.graph.getView().scale;
          var geo = model.getGeometry(vertex);
          var pgeo = model.getGeometry(parent);
          if (this.graph.isSwimlane(vertex) && !this.graph.swimlaneNesting) {
            parent = null;
          } else if (parent == null && this.swimlaneRequired) {
            return null;
          } else if (parent != null && pgeo != null) {
            var state = this.graph.getView().getState(parent);
            if (state != null) {
              x -= state.origin.x * scale;
              y -= state.origin.y * scale;
              if (this.graph.isConstrainedMoving) {
                var width = geo.width;
                var height = geo.height;
                var tmp = state.x + state.width;
                if (x + width > tmp) {
                  x -= x + width - tmp;
                }
                tmp = state.y + state.height;
                if (y + height > tmp) {
                  y -= y + height - tmp;
                }
              }
            } else if (pgeo != null) {
              x -= pgeo.x * scale;
              y -= pgeo.y * scale;
            }
          }
          geo = geo.clone();
          geo.x = this.graph.snap(x / scale - this.graph.getView().translate.x - this.graph.gridSize / 2);
          geo.y = this.graph.snap(y / scale - this.graph.getView().translate.y - this.graph.gridSize / 2);
          vertex.setGeometry(geo);
          if (parent == null) {
            parent = this.graph.getDefaultParent();
          }
          this.cycleAttribute(vertex);
          this.fireEvent(new mxEventObject(
            mxEvent.BEFORE_ADD_VERTEX,
            "vertex",
            vertex,
            "parent",
            parent
          ));
          model.beginUpdate();
          try {
            vertex = this.graph.addCell(vertex, parent);
            if (vertex != null) {
              this.graph.constrainChild(vertex);
              this.fireEvent(new mxEventObject(mxEvent.ADD_VERTEX, "vertex", vertex));
            }
          } finally {
            model.endUpdate();
          }
          if (vertex != null) {
            this.graph.setSelectionCell(vertex);
            this.graph.scrollCellToVisible(vertex);
            this.fireEvent(new mxEventObject(mxEvent.AFTER_ADD_VERTEX, "vertex", vertex));
          }
          return vertex;
        };
        mxEditor.prototype.destroy = function() {
          if (!this.destroyed) {
            this.destroyed = true;
            if (this.tasks != null) {
              this.tasks.destroy();
            }
            if (this.outline != null) {
              this.outline.destroy();
            }
            if (this.properties != null) {
              this.properties.destroy();
            }
            if (this.keyHandler != null) {
              this.keyHandler.destroy();
            }
            if (this.rubberband != null) {
              this.rubberband.destroy();
            }
            if (this.toolbar != null) {
              this.toolbar.destroy();
            }
            if (this.graph != null) {
              this.graph.destroy();
            }
            this.status = null;
            this.templates = null;
          }
        };
        __mxOutput.mxEditor = typeof mxEditor !== "undefined" ? mxEditor : void 0;
        var mxCodecRegistry = {
          /**
           * Class: mxCodecRegistry
           *
           * Singleton class that acts as a global registry for codecs.
           *
           * Adding an <mxCodec>:
           *
           * 1. Define a default codec with a new instance of the 
           * object to be handled.
           *
           * (code)
           * var codec = new mxObjectCodec(new mxGraphModel());
           * (end)
           *
           * 2. Define the functions required for encoding and decoding
           * objects.
           *
           * (code)
           * codec.encode = function(enc, obj) { ... }
           * codec.decode = function(dec, node, into) { ... }
           * (end)
           *
           * 3. Register the codec in the <mxCodecRegistry>.
           *
           * (code)
           * mxCodecRegistry.register(codec);
           * (end)
           *
           * <mxObjectCodec.decode> may be used to either create a new 
           * instance of an object or to configure an existing instance, 
           * in which case the into argument points to the existing
           * object. In this case, we say the codec "configures" the
           * object.
           * 
           * Variable: codecs
           *
           * Maps from constructor names to codecs.
           */
          codecs: [],
          /**
           * Variable: aliases
           *
           * Maps from classnames to codecnames.
           */
          aliases: [],
          /**
           * Function: register
           *
           * Registers a new codec and associates the name of the template
           * constructor in the codec with the codec object.
           *
           * Parameters:
           *
           * codec - <mxObjectCodec> to be registered.
           */
          register: function(codec) {
            if (codec != null) {
              var name2 = codec.getName();
              mxCodecRegistry.codecs[name2] = codec;
              var classname = mxUtils.getFunctionName(codec.template.constructor);
              if (classname != name2) {
                mxCodecRegistry.addAlias(classname, name2);
              }
            }
            return codec;
          },
          /**
           * Function: addAlias
           *
           * Adds an alias for mapping a classname to a codecname.
           */
          addAlias: function(classname, codecname) {
            mxCodecRegistry.aliases[classname] = codecname;
          },
          /**
           * Function: getCodec
           *
           * Returns a codec that handles objects that are constructed
           * using the given constructor.
           *
           * Parameters:
           *
           * ctor - JavaScript constructor function. 
           */
          getCodec: function(ctor) {
            var codec = null;
            if (ctor != null) {
              var name2 = mxUtils.getFunctionName(ctor);
              var tmp = mxCodecRegistry.aliases[name2];
              if (tmp != null) {
                name2 = tmp;
              }
              codec = mxCodecRegistry.codecs[name2];
              if (codec == null) {
                try {
                  codec = new mxObjectCodec(new ctor());
                  mxCodecRegistry.register(codec);
                } catch (e) {
                }
              }
            }
            return codec;
          }
        };
        __mxOutput.mxCodecRegistry = typeof mxCodecRegistry !== "undefined" ? mxCodecRegistry : void 0;
        function mxCodec(document2) {
          this.document = document2 || mxUtils.createXmlDocument();
          this.objects = [];
        }
        ;
        mxCodec.prototype.document = null;
        mxCodec.prototype.objects = null;
        mxCodec.prototype.elements = null;
        mxCodec.prototype.encodeDefaults = false;
        mxCodec.prototype.putObject = function(id, obj) {
          this.objects[id] = obj;
          return obj;
        };
        mxCodec.prototype.getObject = function(id) {
          var obj = null;
          if (id != null) {
            obj = this.objects[id];
            if (obj == null) {
              obj = this.lookup(id);
              if (obj == null) {
                var node = this.getElementById(id);
                if (node != null) {
                  obj = this.decode(node);
                }
              }
            }
          }
          return obj;
        };
        mxCodec.prototype.lookup = function(id) {
          return null;
        };
        mxCodec.prototype.getElementById = function(id) {
          this.updateElements();
          return this.elements[id];
        };
        mxCodec.prototype.updateElements = function() {
          if (this.elements == null) {
            this.elements = new Object();
            if (this.document.documentElement != null) {
              this.addElement(this.document.documentElement);
            }
          }
        };
        mxCodec.prototype.addElement = function(node) {
          if (node.nodeType == mxConstants.NODETYPE_ELEMENT) {
            var id = node.getAttribute("id");
            if (id != null) {
              if (this.elements[id] == null) {
                this.elements[id] = node;
              } else if (this.elements[id] != node) {
                throw new Error(id + ": Duplicate ID");
              }
            }
          }
          node = node.firstChild;
          while (node != null) {
            this.addElement(node);
            node = node.nextSibling;
          }
        };
        mxCodec.prototype.getId = function(obj) {
          var id = null;
          if (obj != null) {
            id = this.reference(obj);
            if (id == null && obj instanceof mxCell) {
              id = obj.getId();
              if (id == null) {
                id = mxCellPath.create(obj);
                if (id.length == 0) {
                  id = "root";
                }
              }
            }
          }
          return id;
        };
        mxCodec.prototype.reference = function(obj) {
          return null;
        };
        mxCodec.prototype.encode = function(obj) {
          var node = null;
          if (obj != null && obj.constructor != null) {
            var enc = mxCodecRegistry.getCodec(obj.constructor);
            if (enc != null) {
              node = enc.encode(this, obj);
            } else {
              if (mxUtils.isNode(obj)) {
                node = mxUtils.importNode(this.document, obj, true);
              } else {
                mxLog.warn("mxCodec.encode: No codec for " + mxUtils.getFunctionName(obj.constructor));
              }
            }
          }
          return node;
        };
        mxCodec.prototype.decode = function(node, into) {
          this.updateElements();
          var obj = null;
          if (node != null && node.nodeType == mxConstants.NODETYPE_ELEMENT) {
            var ctor = null;
            try {
              ctor = window[node.nodeName];
            } catch (err) {
            }
            var dec = mxCodecRegistry.getCodec(ctor);
            if (dec != null) {
              obj = dec.decode(this, node, into);
            } else {
              obj = node.cloneNode(true);
              obj.removeAttribute("as");
            }
          }
          return obj;
        };
        mxCodec.prototype.encodeCell = function(cell2, node, includeChildren) {
          node.appendChild(this.encode(cell2));
          if (includeChildren == null || includeChildren) {
            var childCount = cell2.getChildCount();
            for (var i = 0; i < childCount; i++) {
              this.encodeCell(cell2.getChildAt(i), node);
            }
          }
        };
        mxCodec.prototype.isCellCodec = function(codec) {
          if (codec != null && typeof codec.isCellCodec == "function") {
            return codec.isCellCodec();
          }
          return false;
        };
        mxCodec.prototype.decodeCell = function(node, restoreStructures) {
          restoreStructures = restoreStructures != null ? restoreStructures : true;
          var cell2 = null;
          if (node != null && node.nodeType == mxConstants.NODETYPE_ELEMENT) {
            var decoder = mxCodecRegistry.getCodec(node.nodeName);
            if (!this.isCellCodec(decoder)) {
              var child = node.firstChild;
              while (child != null && !this.isCellCodec(decoder)) {
                decoder = mxCodecRegistry.getCodec(child.nodeName);
                child = child.nextSibling;
              }
            }
            if (!this.isCellCodec(decoder)) {
              decoder = mxCodecRegistry.getCodec(mxCell);
            }
            cell2 = decoder.decode(this, node);
            if (restoreStructures) {
              this.insertIntoGraph(cell2);
            }
          }
          return cell2;
        };
        mxCodec.prototype.insertIntoGraph = function(cell2) {
          var parent = cell2.parent;
          var source = cell2.getTerminal(true);
          var target = cell2.getTerminal(false);
          cell2.setTerminal(null, false);
          cell2.setTerminal(null, true);
          cell2.parent = null;
          if (parent != null) {
            if (parent == cell2) {
              throw new Error(parent.id + ": Self Reference");
            } else {
              parent.insert(cell2);
            }
          }
          if (source != null) {
            source.insertEdge(cell2, true);
          }
          if (target != null) {
            target.insertEdge(cell2, false);
          }
        };
        mxCodec.prototype.setAttribute = function(node, attribute, value) {
          if (attribute != null && value != null) {
            node.setAttribute(attribute, value);
          }
        };
        __mxOutput.mxCodec = typeof mxCodec !== "undefined" ? mxCodec : void 0;
        function mxObjectCodec(template, exclude, idrefs, mapping) {
          this.template = template;
          this.exclude = exclude != null ? exclude : [];
          this.idrefs = idrefs != null ? idrefs : [];
          this.mapping = mapping != null ? mapping : [];
          this.reverse = new Object();
          for (var i in this.mapping) {
            this.reverse[this.mapping[i]] = i;
          }
        }
        ;
        mxObjectCodec.allowEval = false;
        mxObjectCodec.prototype.template = null;
        mxObjectCodec.prototype.exclude = null;
        mxObjectCodec.prototype.idrefs = null;
        mxObjectCodec.prototype.mapping = null;
        mxObjectCodec.prototype.reverse = null;
        mxObjectCodec.prototype.getName = function() {
          return mxUtils.getFunctionName(this.template.constructor);
        };
        mxObjectCodec.prototype.cloneTemplate = function() {
          return new this.template.constructor();
        };
        mxObjectCodec.prototype.getFieldName = function(attributename) {
          if (attributename != null) {
            var mapped = this.reverse[attributename];
            if (mapped != null) {
              attributename = mapped;
            }
          }
          return attributename;
        };
        mxObjectCodec.prototype.getAttributeName = function(fieldname) {
          if (fieldname != null) {
            var mapped = this.mapping[fieldname];
            if (mapped != null) {
              fieldname = mapped;
            }
          }
          return fieldname;
        };
        mxObjectCodec.prototype.isExcluded = function(obj, attr, value, write) {
          return attr == mxObjectIdentity.FIELD_NAME || mxUtils.indexOf(this.exclude, attr) >= 0;
        };
        mxObjectCodec.prototype.isReference = function(obj, attr, value, write) {
          return mxUtils.indexOf(this.idrefs, attr) >= 0;
        };
        mxObjectCodec.prototype.encode = function(enc, obj) {
          var node = enc.document.createElement(this.getName());
          obj = this.beforeEncode(enc, obj, node);
          this.encodeObject(enc, obj, node);
          return this.afterEncode(enc, obj, node);
        };
        mxObjectCodec.prototype.encodeObject = function(enc, obj, node) {
          enc.setAttribute(node, "id", enc.getId(obj));
          for (var i in obj) {
            var name2 = i;
            var value = obj[name2];
            if (value != null && !this.isExcluded(obj, name2, value, true)) {
              if (mxUtils.isInteger(name2)) {
                name2 = null;
              }
              this.encodeValue(enc, obj, name2, value, node);
            }
          }
        };
        mxObjectCodec.prototype.encodeValue = function(enc, obj, name2, value, node) {
          if (value != null) {
            if (this.isReference(obj, name2, value, true)) {
              var tmp = enc.getId(value);
              if (tmp == null) {
                mxLog.warn("mxObjectCodec.encode: No ID for " + this.getName() + "." + name2 + "=" + value);
                return;
              }
              value = tmp;
            }
            var defaultValue = this.template[name2];
            if (name2 == null || enc.encodeDefaults || defaultValue != value) {
              name2 = this.getAttributeName(name2);
              this.writeAttribute(enc, obj, name2, value, node);
            }
          }
        };
        mxObjectCodec.prototype.writeAttribute = function(enc, obj, name2, value, node) {
          if (typeof value != "object") {
            this.writePrimitiveAttribute(enc, obj, name2, value, node);
          } else {
            this.writeComplexAttribute(enc, obj, name2, value, node);
          }
        };
        mxObjectCodec.prototype.writePrimitiveAttribute = function(enc, obj, name2, value, node) {
          value = this.convertAttributeToXml(enc, obj, name2, value, node);
          if (name2 == null) {
            var child = enc.document.createElement("add");
            if (typeof value == "function") {
              child.appendChild(enc.document.createTextNode(value));
            } else {
              enc.setAttribute(child, "value", value);
            }
            node.appendChild(child);
          } else if (typeof value != "function") {
            enc.setAttribute(node, name2, value);
          }
        };
        mxObjectCodec.prototype.writeComplexAttribute = function(enc, obj, name2, value, node) {
          var child = enc.encode(value);
          if (child != null) {
            if (name2 != null) {
              child.setAttribute("as", name2);
            }
            node.appendChild(child);
          } else {
            mxLog.warn("mxObjectCodec.encode: No node for " + this.getName() + "." + name2 + ": " + value);
          }
        };
        mxObjectCodec.prototype.convertAttributeToXml = function(enc, obj, name2, value) {
          if (this.isBooleanAttribute(enc, obj, name2, value)) {
            value = value == true ? "1" : "0";
          }
          return value;
        };
        mxObjectCodec.prototype.isBooleanAttribute = function(enc, obj, name2, value) {
          return typeof value.length == "undefined" && (value == true || value == false);
        };
        mxObjectCodec.prototype.convertAttributeFromXml = function(dec, attr, obj) {
          var value = attr.value;
          if (this.isNumericAttribute(dec, attr, obj)) {
            value = parseFloat(value);
            if (isNaN(value) || !isFinite(value)) {
              value = 0;
            }
          }
          return value;
        };
        mxObjectCodec.prototype.isNumericAttribute = function(dec, attr, obj) {
          var result2 = obj.constructor == mxGeometry && (attr.name == "x" || attr.name == "y" || attr.name == "width" || attr.name == "height") || obj.constructor == mxPoint && (attr.name == "x" || attr.name == "y") || mxUtils.isNumeric(attr.value);
          return result2;
        };
        mxObjectCodec.prototype.beforeEncode = function(enc, obj, node) {
          return obj;
        };
        mxObjectCodec.prototype.afterEncode = function(enc, obj, node) {
          return node;
        };
        mxObjectCodec.prototype.decode = function(dec, node, into) {
          var id = node.getAttribute("id");
          var obj = dec.objects[id];
          if (obj == null) {
            obj = into || this.cloneTemplate();
            if (id != null) {
              dec.putObject(id, obj);
            }
          }
          node = this.beforeDecode(dec, node, obj);
          this.decodeNode(dec, node, obj);
          return this.afterDecode(dec, node, obj);
        };
        mxObjectCodec.prototype.decodeNode = function(dec, node, obj) {
          if (node != null) {
            this.decodeAttributes(dec, node, obj);
            this.decodeChildren(dec, node, obj);
          }
        };
        mxObjectCodec.prototype.decodeAttributes = function(dec, node, obj) {
          var attrs = node.attributes;
          if (attrs != null) {
            for (var i = 0; i < attrs.length; i++) {
              this.decodeAttribute(dec, attrs[i], obj);
            }
          }
        };
        mxObjectCodec.prototype.isIgnoredAttribute = function(dec, attr, obj) {
          return attr.nodeName == "as" || attr.nodeName == "id";
        };
        mxObjectCodec.prototype.decodeAttribute = function(dec, attr, obj) {
          if (!this.isIgnoredAttribute(dec, attr, obj)) {
            var name2 = attr.nodeName;
            var value = this.convertAttributeFromXml(dec, attr, obj);
            var fieldname = this.getFieldName(name2);
            if (this.isReference(obj, fieldname, value, false)) {
              var tmp = dec.getObject(value);
              if (tmp == null) {
                mxLog.warn("mxObjectCodec.decode: No object for " + this.getName() + "." + name2 + "=" + value);
                return;
              }
              value = tmp;
            }
            if (!this.isExcluded(obj, name2, value, false)) {
              obj[name2] = value;
            }
          }
        };
        mxObjectCodec.prototype.decodeChildren = function(dec, node, obj) {
          var child = node.firstChild;
          while (child != null) {
            var tmp = child.nextSibling;
            if (child.nodeType == mxConstants.NODETYPE_ELEMENT && !this.processInclude(dec, child, obj)) {
              this.decodeChild(dec, child, obj);
            }
            child = tmp;
          }
        };
        mxObjectCodec.prototype.decodeChild = function(dec, child, obj) {
          var fieldname = this.getFieldName(child.getAttribute("as"));
          if (fieldname == null || !this.isExcluded(obj, fieldname, child, false)) {
            var template = this.getFieldTemplate(obj, fieldname, child);
            var value = null;
            if (child.nodeName == "add") {
              value = child.getAttribute("value");
              if (value == null && mxObjectCodec.allowEval) {
                value = mxUtils.eval(mxUtils.getTextContent(child));
              }
            } else {
              value = dec.decode(child, template);
            }
            try {
              this.addObjectValue(obj, fieldname, value, template);
            } catch (e) {
              throw new Error(e.message + " for " + child.nodeName);
            }
          }
        };
        mxObjectCodec.prototype.getFieldTemplate = function(obj, fieldname, child) {
          var template = obj[fieldname];
          if (template instanceof Array && template.length > 0) {
            template = null;
          }
          return template;
        };
        mxObjectCodec.prototype.addObjectValue = function(obj, fieldname, value, template) {
          if (value != null && value != template) {
            if (fieldname != null && fieldname.length > 0) {
              obj[fieldname] = value;
            } else {
              obj.push(value);
            }
          }
        };
        mxObjectCodec.prototype.processInclude = function(dec, node, into) {
          if (node.nodeName == "include") {
            var name2 = node.getAttribute("name");
            if (name2 != null) {
              try {
                var xml = mxUtils.load(name2).getDocumentElement();
                if (xml != null) {
                  dec.decode(xml, into);
                }
              } catch (e) {
              }
            }
            return true;
          }
          return false;
        };
        mxObjectCodec.prototype.beforeDecode = function(dec, node, obj) {
          return node;
        };
        mxObjectCodec.prototype.afterDecode = function(dec, node, obj) {
          return obj;
        };
        __mxOutput.mxObjectCodec = typeof mxObjectCodec !== "undefined" ? mxObjectCodec : void 0;
        mxCodecRegistry.register(function() {
          var codec = new mxObjectCodec(
            new mxCell(),
            ["children", "edges", "overlays", "mxTransient"],
            ["parent", "source", "target"]
          );
          codec.isCellCodec = function() {
            return true;
          };
          codec.isNumericAttribute = function(dec, attr, obj) {
            return attr.nodeName !== "value" && mxObjectCodec.prototype.isNumericAttribute.apply(this, arguments);
          };
          codec.isExcluded = function(obj, attr, value, isWrite) {
            return mxObjectCodec.prototype.isExcluded.apply(this, arguments) || isWrite && attr == "value" && value.nodeType == mxConstants.NODETYPE_ELEMENT;
          };
          codec.afterEncode = function(enc, obj, node) {
            if (obj.value != null && obj.value.nodeType == mxConstants.NODETYPE_ELEMENT) {
              var tmp = node;
              node = mxUtils.importNode(enc.document, obj.value, true);
              node.appendChild(tmp);
              var id = tmp.getAttribute("id");
              node.setAttribute("id", id);
              tmp.removeAttribute("id");
            }
            return node;
          };
          codec.beforeDecode = function(dec, node, obj) {
            var inner = node.cloneNode(true);
            var classname = this.getName();
            if (node.nodeName != classname) {
              var tmp = node.getElementsByTagName(classname)[0];
              if (tmp != null && tmp.parentNode == node) {
                mxUtils.removeWhitespace(tmp, true);
                mxUtils.removeWhitespace(tmp, false);
                tmp.parentNode.removeChild(tmp);
                inner = tmp;
              } else {
                inner = null;
              }
              obj.value = node.cloneNode(true);
              var id = obj.value.getAttribute("id");
              if (id != null) {
                obj.setId(id);
                obj.value.removeAttribute("id");
              }
            } else {
              obj.setId(node.getAttribute("id"));
            }
            if (inner != null) {
              for (var i = 0; i < this.idrefs.length; i++) {
                var attr = this.idrefs[i];
                var ref = inner.getAttribute(attr);
                if (ref != null) {
                  inner.removeAttribute(attr);
                  var object = dec.objects[ref] || dec.lookup(ref);
                  if (object == null) {
                    var element = dec.getElementById(ref);
                    if (element != null) {
                      var decoder = mxCodecRegistry.codecs[element.nodeName] || this;
                      object = decoder.decode(dec, element);
                    }
                  }
                  obj[attr] = object;
                }
              }
            }
            return inner;
          };
          return codec;
        }());
        __mxOutput.mxCellCodec = typeof mxCellCodec !== "undefined" ? mxCellCodec : void 0;
        mxCodecRegistry.register(function() {
          var codec = new mxObjectCodec(new mxGraphModel());
          codec.encodeObject = function(enc, obj, node) {
            var rootNode = enc.document.createElement("root");
            enc.encodeCell(obj.getRoot(), rootNode);
            node.appendChild(rootNode);
          };
          codec.decodeChild = function(dec, child, obj) {
            if (child.nodeName == "root") {
              this.decodeRoot(dec, child, obj);
            } else {
              mxObjectCodec.prototype.decodeChild.apply(this, arguments);
            }
          };
          codec.decodeRoot = function(dec, root, model) {
            var rootCell = null;
            var tmp = root.firstChild;
            while (tmp != null) {
              var cell2 = dec.decodeCell(tmp);
              if (cell2 != null && cell2.getParent() == null) {
                rootCell = cell2;
              }
              tmp = tmp.nextSibling;
            }
            if (rootCell != null) {
              model.setRoot(rootCell);
            }
          };
          return codec;
        }());
        __mxOutput.mxModelCodec = typeof mxModelCodec !== "undefined" ? mxModelCodec : void 0;
        mxCodecRegistry.register(function() {
          var codec = new mxObjectCodec(
            new mxRootChange(),
            ["model", "previous", "root"]
          );
          codec.afterEncode = function(enc, obj, node) {
            enc.encodeCell(obj.root, node);
            return node;
          };
          codec.beforeDecode = function(dec, node, obj) {
            if (node.firstChild != null && node.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT) {
              node = node.cloneNode(true);
              var tmp = node.firstChild;
              obj.root = dec.decodeCell(tmp, false);
              var tmp2 = tmp.nextSibling;
              tmp.parentNode.removeChild(tmp);
              tmp = tmp2;
              while (tmp != null) {
                tmp2 = tmp.nextSibling;
                dec.decodeCell(tmp);
                tmp.parentNode.removeChild(tmp);
                tmp = tmp2;
              }
            }
            return node;
          };
          codec.afterDecode = function(dec, node, obj) {
            obj.previous = obj.root;
            return obj;
          };
          return codec;
        }());
        __mxOutput.mxRootChangeCodec = typeof mxRootChangeCodec !== "undefined" ? mxRootChangeCodec : void 0;
        mxCodecRegistry.register(function() {
          var codec = new mxObjectCodec(
            new mxChildChange(),
            ["model", "child", "previousIndex"],
            ["parent", "previous"]
          );
          codec.isReference = function(obj, attr, value, isWrite) {
            if (attr == "child" && (!isWrite || obj.model.contains(obj.previous))) {
              return true;
            }
            return mxUtils.indexOf(this.idrefs, attr) >= 0;
          };
          codec.isExcluded = function(obj, attr, value, write) {
            return mxObjectCodec.prototype.isExcluded.apply(this, arguments) || write && value != null && (attr == "previous" || attr == "parent") && !obj.model.contains(value);
          };
          codec.afterEncode = function(enc, obj, node) {
            if (this.isReference(obj, "child", obj.child, true)) {
              node.setAttribute("child", enc.getId(obj.child));
            } else {
              enc.encodeCell(obj.child, node);
            }
            return node;
          };
          codec.beforeDecode = function(dec, node, obj) {
            if (node.firstChild != null && node.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT) {
              node = node.cloneNode(true);
              var tmp = node.firstChild;
              obj.child = dec.decodeCell(tmp, false);
              var tmp2 = tmp.nextSibling;
              tmp.parentNode.removeChild(tmp);
              tmp = tmp2;
              while (tmp != null) {
                tmp2 = tmp.nextSibling;
                if (tmp.nodeType == mxConstants.NODETYPE_ELEMENT) {
                  var id = tmp.getAttribute("id");
                  if (dec.lookup(id) == null) {
                    dec.decodeCell(tmp);
                  }
                }
                tmp.parentNode.removeChild(tmp);
                tmp = tmp2;
              }
            } else {
              var childRef = node.getAttribute("child");
              obj.child = dec.getObject(childRef);
            }
            return node;
          };
          codec.afterDecode = function(dec, node, obj) {
            if (obj.child != null) {
              if (obj.child.parent != null && obj.previous != null && obj.child.parent != obj.previous) {
                obj.previous = obj.child.parent;
              }
              obj.child.parent = obj.previous;
              obj.previous = obj.parent;
              obj.previousIndex = obj.index;
            }
            return obj;
          };
          return codec;
        }());
        __mxOutput.mxChildChangeCodec = typeof mxChildChangeCodec !== "undefined" ? mxChildChangeCodec : void 0;
        mxCodecRegistry.register(function() {
          var codec = new mxObjectCodec(
            new mxTerminalChange(),
            ["model", "previous"],
            ["cell", "terminal"]
          );
          codec.afterDecode = function(dec, node, obj) {
            obj.previous = obj.terminal;
            return obj;
          };
          return codec;
        }());
        __mxOutput.mxTerminalChangeCodec = typeof mxTerminalChangeCodec !== "undefined" ? mxTerminalChangeCodec : void 0;
        var mxGenericChangeCodec = function(obj, variable) {
          var codec = new mxObjectCodec(obj, ["model", "previous"], ["cell"]);
          codec.afterDecode = function(dec, node, obj2) {
            if (mxUtils.isNode(obj2.cell)) {
              obj2.cell = dec.decodeCell(obj2.cell, false);
            }
            obj2.previous = obj2[variable];
            return obj2;
          };
          return codec;
        };
        mxCodecRegistry.register(mxGenericChangeCodec(new mxValueChange(), "value"));
        mxCodecRegistry.register(mxGenericChangeCodec(new mxStyleChange(), "style"));
        mxCodecRegistry.register(mxGenericChangeCodec(new mxGeometryChange(), "geometry"));
        mxCodecRegistry.register(mxGenericChangeCodec(new mxCollapseChange(), "collapsed"));
        mxCodecRegistry.register(mxGenericChangeCodec(new mxVisibleChange(), "visible"));
        mxCodecRegistry.register(mxGenericChangeCodec(new mxCellAttributeChange(), "value"));
        __mxOutput.mxGenericChangeCodec = typeof mxGenericChangeCodec !== "undefined" ? mxGenericChangeCodec : void 0;
        mxCodecRegistry.register(function() {
          return new mxObjectCodec(
            new mxGraph(),
            [
              "graphListeners",
              "eventListeners",
              "view",
              "container",
              "cellRenderer",
              "editor",
              "selection"
            ]
          );
        }());
        __mxOutput.mxGraphCodec = typeof mxGraphCodec !== "undefined" ? mxGraphCodec : void 0;
        mxCodecRegistry.register(function() {
          var codec = new mxObjectCodec(new mxGraphView());
          codec.encode = function(enc, view) {
            return this.encodeCell(
              enc,
              view,
              view.graph.getModel().getRoot()
            );
          };
          codec.encodeCell = function(enc, view, cell2) {
            var model = view.graph.getModel();
            var state = view.getState(cell2);
            var parent = model.getParent(cell2);
            if (parent == null || state != null) {
              var childCount = model.getChildCount(cell2);
              var geo = view.graph.getCellGeometry(cell2);
              var name2 = null;
              if (parent == model.getRoot()) {
                name2 = "layer";
              } else if (parent == null) {
                name2 = "graph";
              } else if (model.isEdge(cell2)) {
                name2 = "edge";
              } else if (childCount > 0 && geo != null) {
                name2 = "group";
              } else if (model.isVertex(cell2)) {
                name2 = "vertex";
              }
              if (name2 != null) {
                var node = enc.document.createElement(name2);
                var lab = view.graph.getLabel(cell2);
                if (lab != null) {
                  node.setAttribute("label", view.graph.getLabel(cell2));
                  if (view.graph.isHtmlLabel(cell2)) {
                    node.setAttribute("html", true);
                  }
                }
                if (parent == null) {
                  var bounds = view.getGraphBounds();
                  if (bounds != null) {
                    node.setAttribute("x", Math.round(bounds.x));
                    node.setAttribute("y", Math.round(bounds.y));
                    node.setAttribute("width", Math.round(bounds.width));
                    node.setAttribute("height", Math.round(bounds.height));
                  }
                  node.setAttribute("scale", view.scale);
                } else if (state != null && geo != null) {
                  for (var i in state.style) {
                    var value = state.style[i];
                    if (typeof value == "function" && typeof value == "object") {
                      value = mxStyleRegistry.getName(value);
                    }
                    if (value != null && typeof value != "function" && typeof value != "object") {
                      node.setAttribute(i, value);
                    }
                  }
                  var abs = state.absolutePoints;
                  if (abs != null && abs.length > 0) {
                    var pts = Math.round(abs[0].x) + "," + Math.round(abs[0].y);
                    for (var i = 1; i < abs.length; i++) {
                      pts += " " + Math.round(abs[i].x) + "," + Math.round(abs[i].y);
                    }
                    node.setAttribute("points", pts);
                  } else {
                    node.setAttribute("x", Math.round(state.x));
                    node.setAttribute("y", Math.round(state.y));
                    node.setAttribute("width", Math.round(state.width));
                    node.setAttribute("height", Math.round(state.height));
                  }
                  var offset = state.absoluteOffset;
                  if (offset != null) {
                    if (offset.x != 0) {
                      node.setAttribute("dx", Math.round(offset.x));
                    }
                    if (offset.y != 0) {
                      node.setAttribute("dy", Math.round(offset.y));
                    }
                  }
                }
                for (var i = 0; i < childCount; i++) {
                  var childNode = this.encodeCell(
                    enc,
                    view,
                    model.getChildAt(cell2, i)
                  );
                  if (childNode != null) {
                    node.appendChild(childNode);
                  }
                }
              }
            }
            return node;
          };
          return codec;
        }());
        __mxOutput.mxGraphViewCodec = typeof mxGraphViewCodec !== "undefined" ? mxGraphViewCodec : void 0;
        var mxStylesheetCodec = mxCodecRegistry.register(function() {
          var codec = new mxObjectCodec(new mxStylesheet());
          codec.encode = function(enc, obj) {
            var node = enc.document.createElement(this.getName());
            for (var i in obj.styles) {
              var style = obj.styles[i];
              var styleNode = enc.document.createElement("add");
              if (i != null) {
                styleNode.setAttribute("as", i);
                for (var j in style) {
                  var value = this.getStringValue(j, style[j]);
                  if (value != null) {
                    var entry = enc.document.createElement("add");
                    entry.setAttribute("value", value);
                    entry.setAttribute("as", j);
                    styleNode.appendChild(entry);
                  }
                }
                if (styleNode.childNodes.length > 0) {
                  node.appendChild(styleNode);
                }
              }
            }
            return node;
          };
          codec.getStringValue = function(key, value) {
            var type = typeof value;
            if (type == "function") {
              value = mxStyleRegistry.getName(value);
            } else if (type == "object") {
              value = null;
            }
            return value;
          };
          codec.decode = function(dec, node, into) {
            var obj = into || new this.template.constructor();
            var id = node.getAttribute("id");
            if (id != null) {
              dec.objects[id] = obj;
            }
            node = node.firstChild;
            while (node != null) {
              if (!this.processInclude(dec, node, obj) && node.nodeName == "add") {
                var as = node.getAttribute("as");
                if (as != null) {
                  var extend = node.getAttribute("extend");
                  var style = extend != null ? mxUtils.clone(obj.styles[extend]) : null;
                  if (style == null) {
                    if (extend != null) {
                      mxLog.warn("mxStylesheetCodec.decode: stylesheet " + extend + " not found to extend");
                    }
                    style = new Object();
                  }
                  var entry = node.firstChild;
                  while (entry != null) {
                    if (entry.nodeType == mxConstants.NODETYPE_ELEMENT) {
                      var key = entry.getAttribute("as");
                      if (entry.nodeName == "add") {
                        var text = mxUtils.getTextContent(entry);
                        var value = null;
                        if (text != null && text.length > 0 && mxStylesheetCodec.allowEval) {
                          value = mxUtils.eval(text);
                        } else {
                          value = entry.getAttribute("value");
                          if (mxUtils.isNumeric(value)) {
                            value = parseFloat(value);
                          }
                        }
                        if (value != null) {
                          style[key] = value;
                        }
                      } else if (entry.nodeName == "remove") {
                        delete style[key];
                      }
                    }
                    entry = entry.nextSibling;
                  }
                  obj.putCellStyle(as, style);
                }
              }
              node = node.nextSibling;
            }
            return obj;
          };
          return codec;
        }());
        mxStylesheetCodec.allowEval = true;
        __mxOutput.mxStylesheetCodec = typeof mxStylesheetCodec !== "undefined" ? mxStylesheetCodec : void 0;
        mxCodecRegistry.register(function() {
          var codec = new mxObjectCodec(new mxDefaultKeyHandler());
          codec.encode = function(enc, obj) {
            return null;
          };
          codec.decode = function(dec, node, into) {
            if (into != null) {
              var editor = into.editor;
              node = node.firstChild;
              while (node != null) {
                if (!this.processInclude(dec, node, into) && node.nodeName == "add") {
                  var as = node.getAttribute("as");
                  var action = node.getAttribute("action");
                  var control = node.getAttribute("control");
                  into.bindAction(as, action, control);
                }
                node = node.nextSibling;
              }
            }
            return into;
          };
          return codec;
        }());
        __mxOutput.mxDefaultKeyHandlerCodec = typeof mxDefaultKeyHandlerCodec !== "undefined" ? mxDefaultKeyHandlerCodec : void 0;
        var mxDefaultToolbarCodec = mxCodecRegistry.register(function() {
          var codec = new mxObjectCodec(new mxDefaultToolbar());
          codec.encode = function(enc, obj) {
            return null;
          };
          codec.decode = function(dec, node, into) {
            if (into != null) {
              var editor = into.editor;
              node = node.firstChild;
              while (node != null) {
                if (node.nodeType == mxConstants.NODETYPE_ELEMENT) {
                  if (!this.processInclude(dec, node, into)) {
                    if (node.nodeName == "separator") {
                      into.addSeparator();
                    } else if (node.nodeName == "br") {
                      into.toolbar.addBreak();
                    } else if (node.nodeName == "hr") {
                      into.toolbar.addLine();
                    } else if (node.nodeName == "add") {
                      var as = node.getAttribute("as");
                      as = mxResources.get(as) || as;
                      var icon = node.getAttribute("icon");
                      var pressedIcon = node.getAttribute("pressedIcon");
                      var action = node.getAttribute("action");
                      var mode = node.getAttribute("mode");
                      var template = node.getAttribute("template");
                      var toggle = node.getAttribute("toggle") != "0";
                      var text = mxUtils.getTextContent(node);
                      var elt = null;
                      if (action != null) {
                        elt = into.addItem(as, icon, action, pressedIcon);
                      } else if (mode != null) {
                        var funct = mxDefaultToolbarCodec.allowEval ? mxUtils.eval(text) : null;
                        elt = into.addMode(as, icon, mode, pressedIcon, funct);
                      } else if (template != null || text != null && text.length > 0) {
                        var cell2 = editor.templates[template];
                        var style = node.getAttribute("style");
                        if (cell2 != null && style != null) {
                          cell2 = editor.graph.cloneCell(cell2);
                          cell2.setStyle(style);
                        }
                        var insertFunction = null;
                        if (text != null && text.length > 0 && mxDefaultToolbarCodec.allowEval) {
                          insertFunction = mxUtils.eval(text);
                        }
                        elt = into.addPrototype(as, icon, cell2, pressedIcon, insertFunction, toggle);
                      } else {
                        var children = mxUtils.getChildNodes(node);
                        if (children.length > 0) {
                          if (icon == null) {
                            var combo = into.addActionCombo(as);
                            for (var i = 0; i < children.length; i++) {
                              var child = children[i];
                              if (child.nodeName == "separator") {
                                into.addOption(combo, "---");
                              } else if (child.nodeName == "add") {
                                var lab = child.getAttribute("as");
                                var act = child.getAttribute("action");
                                into.addActionOption(combo, lab, act);
                              }
                            }
                          } else {
                            var select = null;
                            var create = function() {
                              var template2 = editor.templates[select.value];
                              if (template2 != null) {
                                var clone = template2.clone();
                                var style2 = select.options[select.selectedIndex].cellStyle;
                                if (style2 != null) {
                                  clone.setStyle(style2);
                                }
                                return clone;
                              } else {
                                mxLog.warn("Template " + template2 + " not found");
                              }
                              return null;
                            };
                            var img = into.addPrototype(as, icon, create, null, null, toggle);
                            select = into.addCombo();
                            mxEvent.addListener(select, "change", function() {
                              into.toolbar.selectMode(img, function(evt) {
                                var pt = mxUtils.convertPoint(
                                  editor.graph.container,
                                  mxEvent.getClientX(evt),
                                  mxEvent.getClientY(evt)
                                );
                                return editor.addVertex(null, funct(), pt.x, pt.y);
                              });
                              into.toolbar.noReset = false;
                            });
                            for (var i = 0; i < children.length; i++) {
                              var child = children[i];
                              if (child.nodeName == "separator") {
                                into.addOption(select, "---");
                              } else if (child.nodeName == "add") {
                                var lab = child.getAttribute("as");
                                var tmp = child.getAttribute("template");
                                var option = into.addOption(select, lab, tmp || template);
                                option.cellStyle = child.getAttribute("style");
                              }
                            }
                          }
                        }
                      }
                      if (elt != null) {
                        var id = node.getAttribute("id");
                        if (id != null && id.length > 0) {
                          elt.setAttribute("id", id);
                        }
                      }
                    }
                  }
                }
                node = node.nextSibling;
              }
            }
            return into;
          };
          return codec;
        }());
        mxDefaultToolbarCodec.allowEval = true;
        __mxOutput.mxDefaultToolbarCodec = typeof mxDefaultToolbarCodec !== "undefined" ? mxDefaultToolbarCodec : void 0;
        mxCodecRegistry.register(function() {
          var codec = new mxObjectCodec(new mxDefaultPopupMenu());
          codec.encode = function(enc, obj) {
            return null;
          };
          codec.decode = function(dec, node, into) {
            var inc = node.getElementsByTagName("include")[0];
            if (inc != null) {
              this.processInclude(dec, inc, into);
            } else if (into != null) {
              into.config = node;
            }
            return into;
          };
          return codec;
        }());
        __mxOutput.mxDefaultPopupMenuCodec = typeof mxDefaultPopupMenuCodec !== "undefined" ? mxDefaultPopupMenuCodec : void 0;
        mxCodecRegistry.register(function() {
          var codec = new mxObjectCodec(
            new mxEditor(),
            [
              "modified",
              "lastSnapshot",
              "ignoredChanges",
              "undoManager",
              "graphContainer",
              "toolbarContainer"
            ]
          );
          codec.afterDecode = function(dec, node, obj) {
            var defaultEdge = node.getAttribute("defaultEdge");
            if (defaultEdge != null) {
              node.removeAttribute("defaultEdge");
              obj.defaultEdge = obj.templates[defaultEdge];
            }
            var defaultGroup = node.getAttribute("defaultGroup");
            if (defaultGroup != null) {
              node.removeAttribute("defaultGroup");
              obj.defaultGroup = obj.templates[defaultGroup];
            }
            return obj;
          };
          codec.decodeChild = function(dec, child, obj) {
            if (child.nodeName == "Array") {
              var role = child.getAttribute("as");
              if (role == "templates") {
                this.decodeTemplates(dec, child, obj);
                return;
              }
            } else if (child.nodeName == "ui") {
              this.decodeUi(dec, child, obj);
              return;
            }
            mxObjectCodec.prototype.decodeChild.apply(this, arguments);
          };
          codec.decodeUi = function(dec, node, editor) {
            var tmp = node.firstChild;
            while (tmp != null) {
              if (tmp.nodeName == "add") {
                var as = tmp.getAttribute("as");
                var elt = tmp.getAttribute("element");
                var style = tmp.getAttribute("style");
                var element = null;
                if (elt != null) {
                  element = document.getElementById(elt);
                  if (element != null && style != null) {
                    element.style.cssText += ";" + style;
                  }
                } else {
                  var x = parseInt(tmp.getAttribute("x"));
                  var y = parseInt(tmp.getAttribute("y"));
                  var width = tmp.getAttribute("width");
                  var height = tmp.getAttribute("height");
                  element = document.createElement("div");
                  element.style.cssText = style;
                  var wnd = new mxWindow(
                    mxResources.get(as) || as,
                    element,
                    x,
                    y,
                    width,
                    height,
                    false,
                    true
                  );
                  wnd.setVisible(true);
                }
                if (as == "graph") {
                  editor.setGraphContainer(element);
                } else if (as == "toolbar") {
                  editor.setToolbarContainer(element);
                } else if (as == "title") {
                  editor.setTitleContainer(element);
                } else if (as == "status") {
                  editor.setStatusContainer(element);
                } else if (as == "map") {
                  editor.setMapContainer(element);
                }
              } else if (tmp.nodeName == "resource") {
                mxResources.add(tmp.getAttribute("basename"));
              } else if (tmp.nodeName == "stylesheet") {
                mxClient.link("stylesheet", tmp.getAttribute("name"));
              }
              tmp = tmp.nextSibling;
            }
          };
          codec.decodeTemplates = function(dec, node, editor) {
            if (editor.templates == null) {
              editor.templates = [];
            }
            var children = mxUtils.getChildNodes(node);
            for (var j = 0; j < children.length; j++) {
              var name2 = children[j].getAttribute("as");
              var child = children[j].firstChild;
              while (child != null && child.nodeType != 1) {
                child = child.nextSibling;
              }
              if (child != null) {
                editor.templates[name2] = dec.decodeCell(child);
              }
            }
          };
          return codec;
        }());
        __mxOutput.mxEditorCodec = typeof mxEditorCodec !== "undefined" ? mxEditorCodec : void 0;
        const GRAPH_PADDING_RIGHT = 40;
        const GRAPH_PADDING_TOP = 0;
        const GRAPH_PADDING_BOTTOM = 80;
        const GRAPH_PADDING_LEFT = 40;
        const CELL_WIDTH = 80;
        const CELL_HEIGHT = 80;
        const STANDARD_NODE_DISTANCE = 173;
        const IDEAL_LONG_LABEL_NODE_DISTANCE = 240;
        const CELL_ICON_HEIGHT = 30;
        const CELL_COST_HEIGHT = 15;
        const MAX_ALLOWED_NODE_WIDTH = 200;
        const MIN_ALLOWED_NODE_WIDTH = 80;
        const LABEL_LENGTH_LIMIT = 38;
        const NODE_HEIGHT = 105;
        const NODE_WIDTH = 100;
        class PolygonRoot {
          constructor(cell2, fillColor, strokeColor, strokeWidth) {
            this.cell = cell2;
            this.fillColor = fillColor;
            this.strokeColor = strokeColor;
            this.strokeWidth = strokeWidth;
          }
        }
        class Point {
          constructor(x, y) {
            this.x = x;
            this.y = y;
          }
        }
        class GraphNodeLayoutHelper {
          constructor() {
            this.layoutPoints = [];
          }
          checkInvariant() {
            var last = new Point(0, 0);
            for (var i = 0; i < this.layoutPoints.length; i++) {
              if (last.x > this.layoutPoints[i].x || last.Y > this.layoutPoints[i].y) {
                console.log("Graph layout failed.");
              }
              last = this.layoutPoints[i];
            }
          }
          /**
           * Updated node layout to prevent overlapping nodes
           * @param {*} nodeLevel: depth of the node from the root of the tree. 0 is the root node.
           * @param {*} yPosition: y position of the node.
           * @returns 
           */
          updateNodeLayout(nodeLevel, yPosition) {
            this.checkInvariant();
            if (this.layoutPoints.length === 0) {
              this.layoutPoints.push(new Point(nodeLevel, yPosition));
              return;
            }
            if (this.layoutPoints.length === 1) {
              if (nodeLevel < this.layoutPoints[0].x) {
                this.layoutPoints.unshift(new Point(nodeLevel, yPosition));
              } else if (nodeLevel === this.layoutPoints[0].x) {
                this.layoutPoints[0] = new Point(this.layoutPoints[0].x, Math.max(this.layoutPoints[0].y, yPosition));
              } else {
                this.layoutPoints.push(new Point(nodeLevel, yPosition));
              }
              return;
            }
            if (nodeLevel < this.layoutPoints[0].x && yPosition < this.layoutPoints[0].y) {
              this.layoutPoints.unshift(new Point(nodeLevel, yPosition));
              return;
            }
            if (this.layoutPoints[this.layoutPoints.length - 1].x < nodeLevel && this.layoutPoints[this.layoutPoints.length - 1].y < yPosition) {
              this.layoutPoints.push(new Point(nodeLevel, yPosition));
              return;
            }
            if (this.layoutPoints[this.layoutPoints.length - 1].x === nodeLevel) {
              this.layoutPoints[this.layoutPoints.length - 1] = new Point(nodeLevel, Math.max(this.layoutPoints[this.layoutPoints.length - 1].y, yPosition));
              return;
            }
            var insertIndex = 0;
            for (var i = 0; i < this.layoutPoints.length; i++) {
              if (nodeLevel <= this.layoutPoints[i].x) {
                insertIndex = i;
                break;
              }
            }
            if (nodeLevel === this.layoutPoints[insertIndex].x) {
              this.layoutPoints[insertIndex] = new Point(nodeLevel, Math.max(this.layoutPoints[insertIndex].y, yPosition));
            } else {
              this.layoutPoints.splice(insertIndex, 0, new Point(nodeLevel, yPosition));
            }
            var lastIndex = insertIndex;
            while (lastIndex < this.layoutPoints.length) {
              if (this.layoutPoints[lastIndex].y > yPosition) {
                this.layoutPoints.splice(insertIndex + 1, lastIndex - insertIndex - 1);
                return;
              }
              ++lastIndex;
            }
            this.layoutPoints.splice(insertIndex + 1, this.layoutPoints.length - insertIndex - 1);
          }
          getYPositionForXPosition(rowX) {
            this.checkInvariant();
            var yPosition = 0;
            for (var i = 0; i < this.layoutPoints.length; i++) {
              if (rowX < this.layoutPoints[i].x) {
                break;
              }
              yPosition = Math.max(this.layoutPoints[i].y, yPosition);
            }
            return yPosition;
          }
        }
        function azdataQueryPlan(queryPlanConfiguration) {
          this.queryPlanGraph = queryPlanConfiguration.queryPlanGraph;
          if (queryPlanConfiguration.container != null && queryPlanConfiguration.iconPaths != null) {
            this.init(queryPlanConfiguration);
          }
        }
        azdataQueryPlan.prototype.init = function(queryPlanConfiguration) {
          const { container, iconPaths, badgeIconPaths, expandCollapsePaths, showTooltipOnClick } = queryPlanConfiguration;
          this.container = container;
          this.polygonRoots = [];
          this.drawnPolygons = [];
          this.badges = [];
          mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
            this.destroy();
          }));
          mxEvent.disableContextMenu(container);
          var graph = new azdataGraph(container);
          this.graph = graph;
          this.graph.firstLoad = true;
          this.rubberband = new mxRubberband(graph);
          this.keyHandler = new mxKeyHandler(graph);
          const arrowRightKey = 39;
          const selectNext = (evt) => {
            graph.tooltipHandler.hide();
            let currentCell = this.graph.getSelectionCell();
            if (currentCell.collapsed) {
              return;
            }
            if (currentCell && currentCell.vertex) {
              if (currentCell.edges.length === 1) {
                if (currentCell.edges[0].target !== currentCell) {
                  this.graph.setSelectionCell(currentCell.edges[0].target);
                }
              } else if (currentCell.edges.length > 1) {
                this.graph.setSelectionCell(currentCell.edges[1].target);
              }
            } else if (currentCell && currentCell.edge) {
              this.graph.setSelectionCell(currentCell.target);
            }
          };
          this.keyHandler.bindKey(arrowRightKey, selectNext);
          const arrowLeftKey = 37;
          const selectPrevious = (evt) => {
            graph.tooltipHandler.hide();
            let currentCell = this.graph.getSelectionCell();
            if (currentCell && currentCell.vertex) {
              if (currentCell.edges.length === 1) {
                if (currentCell.edges[0].source !== currentCell) {
                  this.graph.setSelectionCell(currentCell.edges[0].source);
                }
              } else if (currentCell.edges.length > 1) {
                this.graph.setSelectionCell(currentCell.edges[0].source);
              }
            } else if (currentCell && currentCell.edge) {
              this.graph.setSelectionCell(currentCell.source);
            }
          };
          this.keyHandler.bindKey(arrowLeftKey, selectPrevious);
          const arrowUpKey = 38;
          const selectTop = (evt) => {
            graph.tooltipHandler.hide();
            let currentCell = this.graph.getSelectionCell();
            if (currentCell && currentCell.edge) {
              let source = currentCell.source;
              let edgeIndex = 0;
              while (edgeIndex <= source.edges.length) {
                if (source.edges[edgeIndex] === currentCell) {
                  break;
                }
                ++edgeIndex;
              }
              --edgeIndex;
              if (edgeIndex >= 1) {
                this.graph.setSelectionCell(source.edges[edgeIndex]);
              }
            } else if (currentCell && currentCell.vertex) {
              let source = currentCell.edges[0].source;
              let edgeIndex = 1;
              while (edgeIndex <= source.edges.length - 1) {
                if (source.edges[edgeIndex].target === currentCell) {
                  break;
                }
                ++edgeIndex;
              }
              --edgeIndex;
              if (edgeIndex >= 1) {
                let edge2 = source.edges[edgeIndex];
                this.graph.setSelectionCell(edge2.target);
              }
            }
          };
          this.keyHandler.bindKey(arrowUpKey, selectTop);
          const arrowDownKey = 40;
          const selectBottom = (evt) => {
            graph.tooltipHandler.hide();
            let currentCell = this.graph.getSelectionCell();
            if (currentCell && currentCell.edge) {
              let source = currentCell.source;
              let edgeIndex = 1;
              while (edgeIndex <= source.edges.length - 1) {
                if (source.edges[edgeIndex] === currentCell) {
                  break;
                }
                ++edgeIndex;
              }
              ++edgeIndex;
              if (edgeIndex <= source.edges.length - 1) {
                this.graph.setSelectionCell(source.edges[edgeIndex]);
              }
            } else if (currentCell && currentCell.vertex) {
              let source = currentCell.edges[0].source;
              let edgeIndex = 1;
              while (edgeIndex <= source.edges.length - 1) {
                if (source.edges[edgeIndex].target === currentCell) {
                  break;
                }
                ++edgeIndex;
              }
              ++edgeIndex;
              if (edgeIndex <= source.edges.length - 1) {
                let edge2 = source.edges[edgeIndex];
                this.graph.setSelectionCell(edge2.target);
              }
            }
          };
          this.keyHandler.bindKey(arrowDownKey, selectBottom);
          var style = graph.getStylesheet().getDefaultEdgeStyle();
          style[mxConstants.STYLE_EDGE] = mxEdgeStyle.ElbowConnector;
          graph.keepEdgesInBackground = true;
          graph.centerZoom = false;
          this.enablePanning(true);
          graph.setTooltips(true);
          graph.setEnabled(true);
          graph.setPanning(true);
          graph.panningHandler.useLeftButtonForPanning = true;
          graph.centerZoom = false;
          graph.resizeContainer = false;
          graph.autoSizeCellsOnAdd = true;
          graph.autoExtend = false;
          graph.getSelectionModel().setSingleSelection(true);
          graph.cellsResizable = false;
          graph.cellsMovable = false;
          graph.edgeMovable = false;
          graph.setHtmlLabels(true);
          graph.container.firstChild.setAttribute("role", "group");
          graph.addListener(mxEvent.CLICK, function(sender, evt) {
            var cell2 = evt.getProperty("cell");
            if (cell2 != null && cell2.edge && this.showTooltipOnClick && this.showTooltip) {
              const tooltip = this.getTooltipForCell(cell2);
              if (tooltip) {
                this.tooltipHandler.show(tooltip, evt.properties.event.clientX, evt.properties.event.clientY, cell2);
              }
              evt.consume();
            }
          });
          if (showTooltipOnClick) {
            this.graph.showTooltipOnClick = showTooltipOnClick;
            graph.tooltipHandler.setEnabled(false);
          }
          graph.showTooltip = true;
          graph.isCellSelectable = (cell2) => {
            if (cell2?.isEdge()) {
              return false;
            }
            return true;
          };
          graph.getSelectionModel().addListener(mxEvent.CHANGE, function(sender, evt) {
            if (graph.getSelectionCount() === 1) {
              const cell2 = graph.getSelectionCell();
              if (evt?.properties?.added) {
                evt.properties.added.forEach((cell3) => {
                  if (cell3?.cellDivs?.body) {
                    if (cell3.edge) {
                      const edgeElement = document.getElementById(cell3.id);
                      edgeElement.tabIndex = -1;
                    } else {
                      cell3.cellDivs.body.tabIndex = -1;
                      cell3.cellDivs.body.ariaSelected = false;
                      if (cell3.cellDivs.expandCollapse) {
                        cell3.cellDivs.expandCollapse.tabIndex = -1;
                      }
                    }
                  }
                });
              }
              if (evt?.properties?.removed) {
                evt.properties.removed.forEach((cell3) => {
                  if (cell3?.cellDivs?.body) {
                    if (cell3.edge) {
                      const edgeElement = document.getElementById(cell3.id);
                      edgeElement.tabIndex = 0;
                      edgeElement.focus();
                    } else {
                      cell3.cellDivs.body.tabIndex = 0;
                      cell3.cellDivs.body.ariaSelected = true;
                      if (cell3.cellDivs.expandCollapse) {
                        cell3.cellDivs.expandCollapse.tabIndex = 0;
                      }
                      cell3.cellDivs.body.focus();
                    }
                  }
                });
              }
            }
          });
          let self = this;
          graph.convertValueToString = function(cell2) {
            if (cell2?.value != null && cell2?.value?.label != null) {
              const cellDivs = new Object();
              const oldTabIndex = cell2?.cellDivs?.body?.tabIndex ?? -1;
              cell2.cellDivs = cellDivs;
              const cellContainer = document.createElement("div");
              cellDivs.container = cellContainer;
              cellContainer.setAttribute("class", "graph-cell");
              const cellBodyContainer = document.createElement("div");
              cellDivs.body = cellBodyContainer;
              cellBodyContainer.setAttribute("class", "graph-cell-body");
              cellBodyContainer.setAttribute("role", "treeitem");
              if (cell2.isVertex() && cell2?.value?.children?.length > 0) {
                cellBodyContainer.setAttribute("aria-expanded", !cell2.collapsed);
              }
              cellBodyContainer.setAttribute("aria-level", cell2.value.depth);
              cellBodyContainer.setAttribute("aria-posinset", cell2.value.posInSet);
              cellBodyContainer.setAttribute("aria-setsize", cell2.value.setSize);
              if (cell2.value.ariaLabel) {
                cellBodyContainer.setAttribute("aria-label", cell2.value.ariaLabel);
              }
              cellContainer.appendChild(cellBodyContainer);
              mxEvent.addListener(cellBodyContainer, "focus", (evt) => {
                this.setSelectionCell(cell2);
                if (cell2.highlightShape) {
                  cell2.highlightShape.isDashed = false;
                  cell2.highlightShape.redraw();
                  cell2.highlightShape.updateBoundingBox();
                }
              });
              mxEvent.addListener(cellBodyContainer, "blur", (evt) => {
                if (cell2.highlightShape) {
                  cell2.highlightShape.isDashed = true;
                  cell2.highlightShape.redraw();
                  cell2.highlightShape.updateBoundingBox();
                }
                if (this.tooltipHandler.isVisible) {
                  this.tooltipHandler.hide();
                }
              });
              mxEvent.addListener(cellContainer, "click", (evt) => {
                if (this.showTooltipOnClick && this.showTooltip) {
                  const cell3 = this.getSelectionCell();
                  const tooltip = this.getTooltipForCell(cell3);
                  if (cell3?.geometry) {
                    const cellContainerRect = cellBodyContainer.getBoundingClientRect();
                    this.tooltipHandler.show(tooltip, cellContainerRect.x + cellContainerRect.width, cellContainerRect.y + cellContainerRect.height, cell3);
                  }
                }
              });
              mxEvent.addListener(cellBodyContainer, "keydown", (evt) => {
                if (this.showTooltipOnClick && this.showTooltip) {
                  if (evt.keyCode === 13) {
                    if (this.tooltipHandler.isVisible) {
                      this.tooltipHandler.hide();
                    } else {
                      const cell3 = this.getSelectionCell();
                      if (cell3?.geometry) {
                        const cellContainerRect = cellBodyContainer.getBoundingClientRect();
                        this.tooltipHandler.show(this.getTooltipForCell(cell3), cellContainerRect.x + cellContainerRect.width, cellContainerRect.y + cellContainerRect.height, cell3);
                      }
                    }
                    evt.preventDefault();
                    evt.stopPropagation();
                  } else if (evt.key === "Escape") {
                    this.tooltipHandler.hide();
                    evt.preventDefault();
                    evt.stopPropagation();
                  }
                }
              });
              if (cell2.edge) {
                cellBodyContainer.id = cell2.id;
                return cellContainer;
              }
              const costContainer = document.createElement("div");
              costContainer.setAttribute("class", "graph-cell-cost");
              costContainer.innerHTML = cell2.value.costDisplayString;
              cellBodyContainer.appendChild(costContainer);
              const iconContainer = document.createElement("div");
              iconContainer.setAttribute("class", "graph-cell-icon");
              iconContainer.style.backgroundImage = "url(" + iconPaths[cell2.value.icon] + ")";
              cellBodyContainer.appendChild(iconContainer);
              if (cell2.value.badges) {
                cell2.value.badges.forEach((b) => {
                  const badgeIconPath = badgeIconPaths[b.type];
                  const badgeIcon = document.createElement("div");
                  badgeIcon.setAttribute("class", "graph-icon-badge");
                  badgeIcon.style.backgroundImage = "url(" + badgeIconPath + ")";
                  iconContainer.appendChild(badgeIcon);
                });
              }
              let expandCollapse;
              if (cell2.value.children && cell2.value.children.length > 0) {
                expandCollapse = document.createElement("a");
                expandCollapse.setAttribute("class", "graph-icon-badge-expand");
                expandCollapse.setAttribute("role", "button");
                expandCollapse.ariaLabel = (cell2.collapsed ? "Expand node" : "Collapse node ") + cell2.value.label;
                const icon = cell2.collapsed ? expandCollapsePaths.expand : expandCollapsePaths.collapse;
                expandCollapse.setAttribute("class", cell2.collapsed ? "graph-icon-badge-expand expanded" : "graph-icon-badge-expand collapsed");
                cellContainer.appendChild(expandCollapse);
                mxEvent.addListener(expandCollapse, "click", (evt) => {
                  const currentCell = cell2;
                  const collapse = !currentCell.collapsed;
                  const icon2 = collapse ? expandCollapsePaths.expand : expandCollapsePaths.collapse;
                  expandCollapse.setAttribute("class", cell2.collapsed ? "graph-icon-badge-expand expanded" : "graph-icon-badge-expand collapsed");
                  expandCollapse.ariaLabel = (cell2.collapsed ? "Expand node" : "Collapse node ") + cell2.value.label;
                  this.foldCells(collapse, void 0, [currentCell]);
                  currentCell.cellDivs.expandCollapse.focus();
                  if (!collapse) {
                    self.redrawExpensiveOperatorHighlighting();
                  }
                  expandCollapse.focus();
                  cell2.highlightShape.isDashed = true;
                  cell2.highlightShape.redraw();
                  cell2.highlightShape.updateBoundingBox();
                });
                mxEvent.addListener(expandCollapse, "keydown", (evt) => {
                  if (evt.keyCode === 13 || evt.keyCode === 32) {
                    const currentCell = cell2;
                    const collapse = !currentCell.collapsed;
                    const icon2 = collapse ? expandCollapsePaths.expand : expandCollapsePaths.collapse;
                    expandCollapse.ariaLabel = (cell2.collapsed ? "Expand node" : "Collapse node ") + cell2.value.label;
                    expandCollapse.style.backgroundImage = "url(" + icon2 + ")";
                    this.foldCells(collapse, void 0, [currentCell]);
                    currentCell.cellDivs.expandCollapse.focus();
                    if (!collapse) {
                      self.redrawExpensiveOperatorHighlighting();
                    }
                    evt.stopPropagation();
                    evt.preventDefault();
                    expandCollapse.focus();
                    cell2.highlightShape.isDashed = true;
                    cell2.highlightShape.redraw();
                    cell2.highlightShape.updateBoundingBox();
                  }
                });
                cellDivs.expandCollapse = expandCollapse;
                cellDivs.expandCollapse.tabIndex = oldTabIndex;
              }
              const label = document.createElement("div");
              label.innerText = cell2.value.label;
              cellBodyContainer.appendChild(label);
              const rows = document.createElement("div");
              rows.setAttribute("class", "graph-cell-row-count");
              rows.innerText = cell2.value.rowCountDisplayString;
              cellContainer.appendChild(rows);
              mxEvent.addListener(cellContainer, "click", (evt) => {
                cellBodyContainer.focus();
              });
              cellDivs.body.tabIndex = oldTabIndex;
              if (this.firstLoad && cell2.value.isRoot) {
                this.firstLoad = false;
                if (cellDivs.body) {
                  cellDivs.body.tabIndex = 0;
                  cellDivs.body.ariaSelected = true;
                }
                if (cellDivs.expandCollapse) {
                  cellDivs.expandCollapse.tabIndex = 0;
                }
              }
              return cellContainer;
            }
            if (cell2?.value != null && cell2?.value?.label != null) {
              let hasWindowsEOL = cell2.value.label.includes("\r\n");
              const joinStrings = (strArray) => {
                if (hasWindowsEOL) {
                  return strArray.join("\r\n");
                } else {
                  return strArray.join("\n");
                }
              };
              let splitLabel = cell2.value.label.split(/\r\n|\n/);
              let cellLabel = splitLabel.map((str, index) => {
                let label = "";
                if (index === 0 && !cell2.value.icon?.includes("columnstore")) {
                  label += str.replace(/\(([^)]+)\)/g, "");
                } else if (index === 1 && splitLabel.length >= 3 && str.includes(".")) {
                  let splitStr = str.split(" ");
                  splitStr = splitStr.map((str2) => {
                    if (str2.length >= LABEL_LENGTH_LIMIT) {
                      return str2.substring(0, LABEL_LENGTH_LIMIT - 3) + "...";
                    } else {
                      return str2;
                    }
                  });
                  label += joinStrings(splitStr);
                } else {
                  label += str;
                }
                return label;
              });
              cellLabel = joinStrings(cellLabel);
              return cellLabel;
            }
            return azdataGraph.prototype.convertValueToString.apply(this, arguments);
          };
          graph.isHtmlLabel = function(cell2) {
            return false;
          };
          graph.isCellEditable = function(cell2) {
            return false;
          };
          graph.cellRenderer.getControlBounds = function(state) {
            if (state.control != null) {
              let controlScale = state.control.scale;
              let boundWidth = state.control.bounds.width / controlScale;
              let boundHeight = state.control.bounds.height / controlScale;
              let scale = self.graph.view.getScale();
              return new mxRectangle(
                state.x + state.width - 20 * scale,
                state.cell.geometry.y * scale,
                boundWidth * scale,
                boundHeight * scale
              );
            }
            return null;
          };
          graph.foldCells = function(collapse, recurse, cells) {
            if (cells[0].isVertex() && cells[0]?.value?.children?.length > 0) {
              cells[0].cellDivs.body.setAttribute("aria-expanded", !collapse);
            }
            this.model.beginUpdate();
            try {
              toggleSubtree(this, cells[0], !collapse);
              this.model.setCollapsed(cells[0], collapse);
              self.renderPolygons();
            } finally {
              this.model.endUpdate();
            }
          };
          graph.getTooltipForCell = azdataGraph.prototype.getStyledTooltipForCell;
          var parent = graph.getDefaultParent();
          var layout = new mxHierarchicalLayout(graph, mxConstants.DIRECTION_WEST);
          layout.disableEdgeStyle = false;
          var style = new Object();
          style = mxUtils.clone(style);
          style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_LABEL;
          style[mxConstants.STYLE_STROKECOLOR] = "transparent";
          style[mxConstants.STYLE_FILLCOLOR] = "transparent";
          style[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
          style[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_TOP;
          style[mxConstants.STYLE_IMAGE_ALIGN] = mxConstants.ALIGN_CENTER;
          style[mxConstants.STYLE_IMAGE_VERTICAL_ALIGN] = mxConstants.ALIGN_TOP;
          style[mxConstants.STYLE_IMAGE_WIDTH] = "32";
          style[mxConstants.STYLE_IMAGE_HEIGHT] = "32";
          style[mxConstants.STYLE_SPACING_TOP] = "43";
          style[mxConstants.STYLE_SPACING] = "8";
          style[mxConstants.STYLE_CELL_HIGHLIGHT_DASHED] = false;
          var icons = new Array();
          for (const iconName2 in iconPaths) {
            style = mxUtils.clone(style);
            style[mxConstants.STYLE_IMAGE] = iconPaths[iconName2];
            graph.getStylesheet().putCellStyle("azdataQueryplan-" + iconName2, style);
            icons.push(iconName2);
          }
          graph.getModel().beginUpdate();
          try {
            this.placeGraphNodes();
            var rand = Math.floor(Math.random() * icons.length);
            var iconName = void 0;
            if (this.queryPlanGraph.icon) {
              iconName = "azdataQueryplan-" + this.queryPlanGraph.icon;
            } else {
              iconName = "azdataQueryplan-" + icons[rand];
            }
            var cellStyle = new Object();
            cellStyle[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
            cellStyle[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;
            cellStyle[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;
            cellStyle[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
            cellStyle[mxConstants.STYLE_FILLCOLOR] = "transparent";
            cellStyle[mxConstants.STYLE_STROKECOLOR] = "transparent";
            cellStyle[mxConstants.STYLE_CELL_HIGHLIGHT_DASHED] = false;
            cellStyle[mxConstants.STYLE_CELL_HIGHLIGHT_STROKE_WIDTH] = "3";
            cellStyle[mxConstants.STYLE_CELL_HIGHLIGHT_COLOR] = "#4AA564";
            graph.getStylesheet().putDefaultVertexStyle(cellStyle);
            var maxX = this.queryPlanGraph.position.x;
            var maxY = this.queryPlanGraph.position.y;
            var vertex = graph.insertVertex(parent, this.queryPlanGraph.id, this.queryPlanGraph, this.queryPlanGraph.position.x, this.queryPlanGraph.position.y, CELL_WIDTH, CELL_HEIGHT);
            this.queryPlanGraph.depth = 1;
            this.queryPlanGraph.posInSet = 1;
            this.queryPlanGraph.setSize = 1;
            this.queryPlanGraph.isRoot = true;
            var stack = [
              {
                vertex,
                node: this.queryPlanGraph
              }
            ];
            while (stack.length > 0) {
              var entry = stack.pop();
              if (entry.node.children) {
                for (var i = 0; i < entry.node.children.length; ++i) {
                  var node = entry.node.children[i];
                  if (node.icon) {
                    iconName = "azdataQueryplan-" + node.icon;
                  } else {
                    rand = Math.floor(Math.random() * icons.length);
                    iconName = "azdataQueryplan-" + icons[rand];
                  }
                  if (node.position.x > maxX) {
                    maxX = node.position.x;
                  }
                  if (node.position.y > maxY) {
                    maxY = node.position.y;
                  }
                  vertex = graph.insertVertex(parent, node.id, node, node.position.x, node.position.y, CELL_WIDTH, CELL_HEIGHT);
                  var edge = entry.node.edges[i];
                  graph.insertWeightedInvertedEdge(parent, edge.id, edge, entry.vertex, vertex);
                  node.depth = entry.node.depth + 1;
                  node.posInSet = i + 1;
                  node.setSize = entry.node.children.length;
                  stack.push(
                    {
                      vertex,
                      node
                    }
                  );
                }
              }
            }
            vertex = graph.insertVertex(parent, "paddingVertex", void 0, maxX + CELL_WIDTH + GRAPH_PADDING_LEFT, maxY + CELL_HEIGHT + GRAPH_PADDING_BOTTOM, 1e-4, 1e-4, "");
          } finally {
            graph.getModel().endUpdate();
          }
        };
        azdataQueryPlan.prototype.placeGraphNodes = function() {
          this.spacingY = NODE_HEIGHT;
          this.paddingX = GRAPH_PADDING_RIGHT;
          this.paddingY = GRAPH_PADDING_TOP;
          var startX = (this.paddingX + 10) / 2;
          var startY = (this.paddingY + 10) / 2;
          this.setNodePositionRecursive(this.queryPlanGraph, startX, startY);
        };
        azdataQueryPlan.prototype.disableNodeCollapse = function(disableCollapse) {
          const allVertices = this.graph.model.getChildCells(this.graph.getDefaultParent()).filter((v) => v?.vertex);
          allVertices.forEach((v) => {
            let state = this.graph.view.getState(v);
            if (!state.control || !state.control.node) {
              return;
            }
            if (disableCollapse) {
              state.control.node.style.visibility = "hidden";
            } else if (this.graph.model.getOutgoingEdges(v).length > 0) {
              state.control.node.style.visibility = "visible";
            }
          });
        };
        azdataQueryPlan.prototype.setNodePositionRecursive = function(node, x, y) {
          this.setNodeXPositionRecursive(node, x, 0);
          var layoutHelper = new GraphNodeLayoutHelper();
          this.setNodeYPositionRecursive(node, layoutHelper, y);
        };
        azdataQueryPlan.prototype.isParentHierarchyTreeStructure = function(node) {
          while (node != null) {
            if (node.children.length >= 2) {
              return true;
            }
            node = node.parent;
          }
          return false;
        };
        azdataQueryPlan.prototype.getCleanedNodeLabel = function(node) {
          return node.label.replace(/\n|\r\n/g, "<br>");
        };
        azdataQueryPlan.prototype.getNodeLabelLength = function(node) {
          this.canvas = this.canvas || document.createElement("canvas");
          const context = this.canvas.getContext("2d");
          const metrics = context.measureText(node.label);
          return metrics.width;
        };
        azdataQueryPlan.prototype.getRecommendedNodeXSpacing = function(node) {
          const currentNodeSize = this.getNodeLabelLength(node);
          let maxNodeToWidth = 0;
          node.children.forEach((c) => {
            maxNodeToWidth = Math.max(maxNodeToWidth, this.getNodeLabelLength(c));
          });
          let recommendedSpacing = currentNodeSize / 2 + maxNodeToWidth / 2;
          if (node.children.length > 1) {
            if (this.isParentHierarchyTreeStructure(node)) {
              recommendedSpacing += Math.max(maxNodeToWidth - MAX_ALLOWED_NODE_WIDTH, 0);
            }
          }
          return recommendedSpacing < MIN_ALLOWED_NODE_WIDTH ? MIN_ALLOWED_NODE_WIDTH : recommendedSpacing;
        };
        azdataQueryPlan.prototype.getNodeHeight = function(node) {
          const iconHeight = CELL_ICON_HEIGHT;
          const costHeight = CELL_COST_HEIGHT;
          const cellSubtextLineCount = node.label.split(/\r\n|\r|\n/).length;
          const nodeHeight = iconHeight + costHeight + cellSubtextLineCount * 10;
          return nodeHeight;
        };
        azdataQueryPlan.prototype.updateSpacingY = function(node) {
          this.spacingY = Math.max(this.spacingY, this.getNodeHeight(node));
        };
        azdataQueryPlan.prototype.setNodeXPositionRecursive = function(node, x, level) {
          node.position = new Point(x, 0);
          node.level = level;
          this.updateSpacingY(node);
          var recommendedMinimumSpacing = this.getRecommendedNodeXSpacing(node);
          var spacingX = recommendedMinimumSpacing + this.paddingX;
          x += spacingX;
          node.maxChildrenXPosition = node.level;
          node.children.forEach((childNode) => {
            childNode.parent = node;
            this.setNodeXPositionRecursive(childNode, x, level + 1);
            node.maxChildrenXPosition = Math.max(node.maxChildrenXPosition, childNode.maxChildrenXPosition);
          });
        };
        azdataQueryPlan.prototype.getYMidPoint = function(fromNode, toNode) {
          var edgeMidpoint = (fromNode.position.x + this.getNodeLabelLength(fromNode) + toNode.position.x) / 2;
          for (let i = 0; i < fromNode.children.length; i++) {
            if (fromNode.children[i] === toNode.id) {
              break;
            }
            const minMidPointSpaceFromNodeBoundingRect = 6;
            edgeMidpoint = Math.min(edgeMidpoint, fromNode.children[i].position.x - minMidPointSpaceFromNodeBoundingRect);
          }
          return edgeMidpoint;
        };
        azdataQueryPlan.prototype.setNodeYPositionRecursive = function(node, layoutHelper, y) {
          var newY = Math.max(y, layoutHelper.getYPositionForXPosition(node.maxChildrenXPosition));
          node.position.y = newY;
          var yToUpdate = newY + this.spacingY;
          node.children.forEach((n) => {
            this.setNodeYPositionRecursive(n, layoutHelper, newY);
            newY += this.spacingY;
          });
          layoutHelper.updateNodeLayout(node.level, yToUpdate);
        };
        azdataQueryPlan.prototype.shiftParentAndChildNodePositionsHorizontally = function(parent, shiftAmount) {
          let stack = [...parent.children];
          while (stack.length !== 0) {
            let currentNode = stack.pop();
            let currentNodeParent = currentNode.parent;
            if (currentNode.position.x - currentNodeParent.position.x < IDEAL_LONG_LABEL_NODE_DISTANCE) {
              currentNode.position.x += shiftAmount;
            }
            for (let childIndex = 0; childIndex < currentNode.children.length; ++childIndex) {
              stack.push(currentNode.children[childIndex]);
            }
          }
        };
        azdataQueryPlan.prototype.getNodesByHorizontalLevel = function(node) {
          let table = {};
          let stack = [node];
          while (stack.length !== 0) {
            let entry = stack.pop();
            if (entry.position.y in table) {
              table[entry.position.y].push(entry);
            } else {
              table[entry.position.y] = [];
              table[entry.position.y].push(entry);
            }
            for (let i = 0; i < entry.children.length; ++i) {
              stack.push(entry.children[i]);
            }
          }
          return table;
        };
        azdataQueryPlan.prototype.zoomIn = function() {
          if (this.graph.view.getScale() * this.graph.zoomFactor <= 2) {
            this.graph.zoomIn();
          } else {
            this.graph.zoomTo(2);
          }
          this.renderPolygons();
        };
        azdataQueryPlan.prototype.zoomOut = function() {
          this.graph.zoomOut();
          this.renderPolygons();
        };
        azdataQueryPlan.prototype.zoomToFit = function() {
          this.graph.fit(void 0, true, 20);
          this.renderPolygons();
        };
        azdataQueryPlan.prototype.registerGraphCallback = function(eventType, callback) {
          this.graph.addListener(eventType, (sender, event) => {
            this.graph.graphEventHandler(sender, event, callback);
          });
        };
        azdataQueryPlan.prototype.getZoomLevelPercentage = function() {
          return this.graph.view.scale * 100;
        };
        azdataQueryPlan.prototype.zoomTo = function(zoomPercentage) {
          const ZOOM_PERCENTAGE_MINIMUM = 1;
          const ZOOM_PERCENTAGE_MAXIMUM = 200;
          let parsedZoomLevel = parseInt(zoomPercentage);
          if (isNaN(parsedZoomLevel)) {
            return;
          }
          if (parsedZoomLevel < ZOOM_PERCENTAGE_MINIMUM) {
            parsedZoomLevel = ZOOM_PERCENTAGE_MINIMUM;
          }
          if (parsedZoomLevel > ZOOM_PERCENTAGE_MAXIMUM) {
            parsedZoomLevel = ZOOM_PERCENTAGE_MAXIMUM;
          }
          let zoomScale = parsedZoomLevel / 100;
          this.graph.zoomTo(zoomScale);
          this.renderPolygons();
        };
        azdataQueryPlan.prototype.addZoomInRectListener = function() {
          let self = this;
          mxRubberband.prototype.mouseUp = function(sender, event) {
            let execute = self.container && this.width !== void 0 && this.height !== void 0;
            this.reset();
            if (execute) {
              let rect = new mxRectangle(this.x, this.y, this.width, this.height);
              self.graph.zoomToRect(rect);
              event.consume();
            }
          };
        };
        azdataQueryPlan.prototype.enablePanning = function(panning) {
          this.graph.panningHandler.useLeftButtonForPanning = panning;
          this.graph.setPanning(panning);
        };
        azdataQueryPlan.prototype.setIconBackgroundColor = function(color) {
          const allVertices = this.graph.model.getChildCells(this.graph.getDefaultParent());
          this.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, color, allVertices);
          this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, color, allVertices);
        };
        azdataQueryPlan.prototype.setTextFontColor = function(color) {
          this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, color, this.graph.model.getChildCells(this.graph.getDefaultParent()));
        };
        azdataQueryPlan.prototype.setEdgeColor = function(color) {
          this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, color, this.graph.model.getChildEdges(this.graph.getDefaultParent()));
        };
        azdataQueryPlan.prototype.setCellHighLightColor = function(color) {
          this.graph.setCellStyles(mxConstants.STYLE_CELL_HIGHLIGHT_COLOR, color, this.graph.model.getChildCells(this.graph.getDefaultParent()));
        };
        azdataQueryPlan.prototype.destroy = function() {
          if (!this.destroyed) {
            this.destroyed = true;
            this.container = null;
          }
        };
        azdataQueryPlan.prototype.setShowTooltipOnClick = function(showTooltipOnClick) {
          this.graph.showTooltipOnClick = showTooltipOnClick;
        };
        azdataQueryPlan.prototype.showTooltip = function(showTooltip) {
          this.graph.showTooltip = showTooltip;
          if (!this.graph.showTooltipOnClick) {
            this.graph.tooltipHandler.setEnabled(showTooltip);
          }
        };
        azdataQueryPlan.prototype.drawPolygon = function(cell2, fillColor, strokeColor, strokeWidth) {
          if (!this.polygonModels) {
            this.polygonModels = [];
          }
          this.polygonModels.push({
            root: cell2,
            fillColor,
            strokeColor,
            strokWidth: strokeWidth
          });
          this.renderPolygons();
        };
        azdataQueryPlan.prototype.removeDrawnPolygons = function() {
          this.drawnPolygons.forEach((polygon) => {
            polygon.destroy();
          });
          this.drawnPolygons = [];
          this.polygonModels = [];
        };
        azdataQueryPlan.prototype.renderPolygons = function() {
          if (this.drawnPolygons?.length > 0) {
            this.drawnPolygons.forEach((polygon) => {
              polygon.destroy();
            });
          }
          this.drawnPolygons = [];
          if (this.polygonModels) {
            this.polygonModels.forEach((p) => {
              const points = this.getPolygonPerimeter(p.root);
              const scale = this.graph.view.getScale();
              var polygon = new mxPolygon(
                points.map((point) => new mxPoint(point.x * scale, point.y * scale)),
                p.fillColor,
                p.strokeColor,
                p.strokeWidth
              );
              this.drawnPolygons.push(polygon);
              polygon.init(this.graph.getView().getBackgroundPane());
              polygon.isDashed = true;
              polygon.redraw();
            });
          }
        };
        azdataQueryPlan.prototype.getPolygonPerimeter = function(cell2) {
          if (!cell2.isVisible()) {
            return [];
          }
          let points = [];
          points = points.concat(this.getLeftSidePoints(cell2));
          let rightSidePoints = this.getRightSidePoints(cell2);
          points = points.concat(this.getBottomSidePoints(cell2, rightSidePoints[0].x));
          points = points.concat(rightSidePoints);
          return points;
        };
        azdataQueryPlan.prototype.getLeftSidePoints = function(cell2) {
          let points = [];
          let additionalLeftSideSpacing = this.calcAdditionalSpacingForNode(cell2);
          let xPosition = cell2.geometry.x - 15;
          points.push({ x: xPosition - additionalLeftSideSpacing, y: cell2.geometry.y });
          points.push({ x: xPosition - additionalLeftSideSpacing, y: cell2.geometry.y + NODE_HEIGHT });
          return points;
        };
        azdataQueryPlan.prototype.getBottomSidePoints = function(cell2, polygonRightSideConstraint) {
          let points = [];
          let bottomSideNodes = this.getBottomSideNodes(cell2, polygonRightSideConstraint);
          bottomSideNodes.forEach((node) => {
            let lastPoint = points.length > 0 ? points[points.length - 1] : null;
            let newPoint = { x: node.geometry.x, y: node.geometry.y + NODE_HEIGHT };
            if (lastPoint && newPoint.y !== lastPoint.y) {
              let auxiliaryPoint = { x: lastPoint.x, y: newPoint.y };
              points.push(auxiliaryPoint);
            }
            let cell3 = this.graph.model.getCell(node.id);
            let additionalSpacing = Math.max(...cell3.value.label.split(/\r\n|\n/).map((str) => str.length)) > 20 ? this.calcAdditionalSpacingForNode(cell3) : 0;
            points.push({ x: node.geometry.x, y: node.geometry.y + NODE_HEIGHT });
            points.push({ x: node.geometry.x + NODE_WIDTH + additionalSpacing, y: node.geometry.y + NODE_HEIGHT });
          });
          return points;
        };
        azdataQueryPlan.prototype.getBottomSideNodes = function(cell2, polygonRightSideConstraint) {
          let queue = [cell2];
          let nodes = [];
          while (queue.length !== 0) {
            let levelNodeCount = queue.length;
            for (let nodeIndex = 0; nodeIndex < levelNodeCount; ++nodeIndex) {
              let entry = queue.shift();
              if (nodeIndex === levelNodeCount - 1 && entry.geometry.x < polygonRightSideConstraint) {
                nodes.push(entry);
              }
              for (let childIndex = 0; childIndex < entry.value.children.length; ++childIndex) {
                if (entry.geometry.x < polygonRightSideConstraint) {
                  queue.push(this.graph.model.getCell(entry.value.children[childIndex].id));
                }
              }
            }
          }
          return nodes;
        };
        azdataQueryPlan.prototype.getRightSidePoints = function(cell2) {
          let points = [];
          let leafNodes = this.getLeafNodes(cell2);
          for (let leafIndex = 0; leafIndex < leafNodes.length; ++leafIndex) {
            let leaf = leafNodes[leafIndex];
            let additionalRightSideSpacing = this.calcAdditionalSpacingForNode(leaf);
            let lastLeaf = void 0;
            if (leafIndex > 0) {
              lastLeaf = leafNodes[leafIndex - 1];
            }
            let nextLeaf = void 0;
            if (leafIndex + 1 < leafNodes.length) {
              nextLeaf = leafNodes[leafIndex + 1];
            }
            let lastLeafPositionX = -1;
            if (lastLeaf) {
              lastLeafPositionX = lastLeaf.geometry.x;
            }
            let nextLeafPositionX = -1;
            if (nextLeaf) {
              nextLeafPositionX = nextLeaf.geometry.x;
            }
            let leafPositionX = Math.min(Math.max(lastLeafPositionX, leaf.geometry.x), Math.max(nextLeafPositionX, leaf.geometry.x));
            points.push({ x: leafPositionX + NODE_WIDTH + additionalRightSideSpacing, y: leaf.geometry.y + NODE_HEIGHT });
            points.push({ x: leafPositionX + NODE_WIDTH + additionalRightSideSpacing, y: leaf.geometry.y });
          }
          return points;
        };
        azdataQueryPlan.prototype.calcAdditionalSpacingForNode = function(cell2) {
          let longestSubLabel = Math.max(...cell2.value.label.split(/\r\n|\n/).map((str) => str.length));
          if (longestSubLabel > LABEL_LENGTH_LIMIT) {
            longestSubLabel = LABEL_LENGTH_LIMIT;
          }
          return longestSubLabel / 10 * 15;
        };
        azdataQueryPlan.prototype.getLeafNodes = function(cell2) {
          let leafNodeTable = {};
          let stack = [cell2];
          while (stack.length !== 0) {
            let entry = stack.pop();
            if (entry.value.children.length === 0 || !this.isChildCellVisible(entry)) {
              if (entry.geometry.y in leafNodeTable) {
                let previouslyCachedEntry = leafNodeTable[entry.geometry.y];
                if (entry.geometry.x > previouslyCachedEntry.geometry.x) {
                  leafNodeTable[entry.geometry.y] = entry;
                }
              } else {
                leafNodeTable[entry.geometry.y] = entry;
              }
            }
            for (let nodeIndex = 0; nodeIndex < entry.value.children.length && this.isChildCellVisible(entry); ++nodeIndex) {
              let childCell = this.graph.model.getCell(entry.value.children[nodeIndex].id);
              stack.push(childCell);
            }
          }
          let leafNodes = Object.keys(leafNodeTable).map((key) => leafNodeTable[key]).reverse();
          return leafNodes;
        };
        azdataQueryPlan.prototype.isChildCellVisible = function(vertex) {
          if (vertex.value.children.length === 0) {
            return false;
          }
          let childCell = this.graph.model.getCell(vertex.value.children[0].id);
          return childCell.isVisible();
        };
        azdataQueryPlan.prototype.clearExpensiveOperatorHighlighting = function() {
          if (this.expensiveCellHighlighter) {
            this.expensiveCellHighlighter.destroy();
          }
          this.expensiveCell = void 0;
          this.expensiveCellHighlighter = void 0;
        };
        azdataQueryPlan.prototype.redrawExpensiveOperatorHighlighting = function() {
          if (this.expensiveCell && this.expensiveCellHighlighter) {
            this.expensiveCellHighlighter.highlight(this.graph.view.getState(this.expensiveCell));
          }
        };
        azdataQueryPlan.prototype.highlightExpensiveOperator = function(getExpenseMetricValue) {
          const HIGHLIGHTER_COLOR = "#CD2026";
          const STROKE_WIDTH = 1;
          const expensiveNode = this.findExpensiveOperator(getExpenseMetricValue);
          if (!expensiveNode) {
            return void 0;
          }
          this.expensiveCell = this.graph.model.getCell(expensiveNode.id);
          this.expensiveCellHighlighter = new mxCellHighlight(this.graph, HIGHLIGHTER_COLOR, STROKE_WIDTH);
          this.expensiveCellHighlighter.highlight(this.graph.view.getState(this.expensiveCell));
          return expensiveNode.id;
        };
        azdataQueryPlan.prototype.findExpensiveOperator = function(getExpenseMetricValue) {
          const expensiveOperators = [];
          const expensiveCostValues = [];
          const stack = [this.queryPlanGraph];
          while (stack.length > 0) {
            const node = stack.pop();
            const costValue = getExpenseMetricValue(node);
            if (costValue !== void 0 && costValue >= 0) {
              expensiveOperators.push(node);
              expensiveCostValues.push(costValue);
            }
            for (let childIndex = 0; childIndex < node.children.length; ++childIndex) {
              stack.push(node.children[childIndex]);
            }
          }
          if (expensiveCostValues.length === 0) {
            return void 0;
          }
          const maxCostValue = Math.max(...expensiveCostValues);
          const maxCostValueIndex = expensiveCostValues.findIndex((c) => c === maxCostValue);
          return expensiveOperators[maxCostValueIndex];
        };
        function toggleSubtree(graph, cell2, show) {
          show = show != null ? show : true;
          var cells = [];
          graph.traverse(cell2, true, function(vertex) {
            if (vertex != cell2) {
              cells.push(vertex);
            }
            return vertex === cell2 || !graph.isCellCollapsed(vertex);
          });
          graph.toggleCells(show, cells, true);
        }
        __mxOutput.azdataQueryPlan = typeof azdataQueryPlan !== "undefined" ? azdataQueryPlan : void 0;
        return __mxOutput;
      };
    });
  }
});

// node_modules/@dagrejs/graphlib/lib/graph.js
var require_graph = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/graph.js"(exports2, module2) {
    "use strict";
    var DEFAULT_EDGE_NAME = "\0";
    var GRAPH_NODE = "\0";
    var EDGE_KEY_DELIM = "";
    var Graph = class {
      _isDirected = true;
      _isMultigraph = false;
      _isCompound = false;
      // Label for the graph itself
      _label;
      // Defaults to be set when creating a new node
      _defaultNodeLabelFn = () => void 0;
      // Defaults to be set when creating a new edge
      _defaultEdgeLabelFn = () => void 0;
      // v -> label
      _nodes = {};
      // v -> edgeObj
      _in = {};
      // u -> v -> Number
      _preds = {};
      // v -> edgeObj
      _out = {};
      // v -> w -> Number
      _sucs = {};
      // e -> edgeObj
      _edgeObjs = {};
      // e -> label
      _edgeLabels = {};
      /* Number of nodes in the graph. Should only be changed by the implementation. */
      _nodeCount = 0;
      /* Number of edges in the graph. Should only be changed by the implementation. */
      _edgeCount = 0;
      _parent;
      _children;
      constructor(opts2) {
        if (opts2) {
          this._isDirected = Object.hasOwn(opts2, "directed") ? opts2.directed : true;
          this._isMultigraph = Object.hasOwn(opts2, "multigraph") ? opts2.multigraph : false;
          this._isCompound = Object.hasOwn(opts2, "compound") ? opts2.compound : false;
        }
        if (this._isCompound) {
          this._parent = {};
          this._children = {};
          this._children[GRAPH_NODE] = {};
        }
      }
      /* === Graph functions ========= */
      /**
       * Whether graph was created with 'directed' flag set to true or not.
       */
      isDirected() {
        return this._isDirected;
      }
      /**
       * Whether graph was created with 'multigraph' flag set to true or not.
       */
      isMultigraph() {
        return this._isMultigraph;
      }
      /**
       * Whether graph was created with 'compound' flag set to true or not.
       */
      isCompound() {
        return this._isCompound;
      }
      /**
       * Sets the label of the graph.
       */
      setGraph(label) {
        this._label = label;
        return this;
      }
      /**
       * Gets the graph label.
       */
      graph() {
        return this._label;
      }
      /* === Node functions ========== */
      /**
       * Sets the default node label. If newDefault is a function, it will be
       * invoked ach time when setting a label for a node. Otherwise, this label
       * will be assigned as default label in case if no label was specified while
       * setting a node.
       * Complexity: O(1).
       */
      setDefaultNodeLabel(newDefault) {
        this._defaultNodeLabelFn = newDefault;
        if (typeof newDefault !== "function") {
          this._defaultNodeLabelFn = () => newDefault;
        }
        return this;
      }
      /**
       * Gets the number of nodes in the graph.
       * Complexity: O(1).
       */
      nodeCount() {
        return this._nodeCount;
      }
      /**
       * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
       * not included in list.
       * Complexity: O(1).
       */
      nodes() {
        return Object.keys(this._nodes);
      }
      /**
       * Gets list of nodes without in-edges.
       * Complexity: O(|V|).
       */
      sources() {
        var self = this;
        return this.nodes().filter((v) => Object.keys(self._in[v]).length === 0);
      }
      /**
       * Gets list of nodes without out-edges.
       * Complexity: O(|V|).
       */
      sinks() {
        var self = this;
        return this.nodes().filter((v) => Object.keys(self._out[v]).length === 0);
      }
      /**
       * Invokes setNode method for each node in names list.
       * Complexity: O(|names|).
       */
      setNodes(vs, value) {
        var args = arguments;
        var self = this;
        vs.forEach(function(v) {
          if (args.length > 1) {
            self.setNode(v, value);
          } else {
            self.setNode(v);
          }
        });
        return this;
      }
      /**
       * Creates or updates the value for the node v in the graph. If label is supplied
       * it is set as the value for the node. If label is not supplied and the node was
       * created by this call then the default node label will be assigned.
       * Complexity: O(1).
       */
      setNode(v, value) {
        if (Object.hasOwn(this._nodes, v)) {
          if (arguments.length > 1) {
            this._nodes[v] = value;
          }
          return this;
        }
        this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
        if (this._isCompound) {
          this._parent[v] = GRAPH_NODE;
          this._children[v] = {};
          this._children[GRAPH_NODE][v] = true;
        }
        this._in[v] = {};
        this._preds[v] = {};
        this._out[v] = {};
        this._sucs[v] = {};
        ++this._nodeCount;
        return this;
      }
      /**
       * Gets the label of node with specified name.
       * Complexity: O(|V|).
       */
      node(v) {
        return this._nodes[v];
      }
      /**
       * Detects whether graph has a node with specified name or not.
       */
      hasNode(v) {
        return Object.hasOwn(this._nodes, v);
      }
      /**
       * Remove the node with the name from the graph or do nothing if the node is not in
       * the graph. If the node was removed this function also removes any incident
       * edges.
       * Complexity: O(1).
       */
      removeNode(v) {
        var self = this;
        if (Object.hasOwn(this._nodes, v)) {
          var removeEdge = (e) => self.removeEdge(self._edgeObjs[e]);
          delete this._nodes[v];
          if (this._isCompound) {
            this._removeFromParentsChildList(v);
            delete this._parent[v];
            this.children(v).forEach(function(child) {
              self.setParent(child);
            });
            delete this._children[v];
          }
          Object.keys(this._in[v]).forEach(removeEdge);
          delete this._in[v];
          delete this._preds[v];
          Object.keys(this._out[v]).forEach(removeEdge);
          delete this._out[v];
          delete this._sucs[v];
          --this._nodeCount;
        }
        return this;
      }
      /**
       * Sets node p as a parent for node v if it is defined, or removes the
       * parent for v if p is undefined. Method throws an exception in case of
       * invoking it in context of noncompound graph.
       * Average-case complexity: O(1).
       */
      setParent(v, parent) {
        if (!this._isCompound) {
          throw new Error("Cannot set parent in a non-compound graph");
        }
        if (parent === void 0) {
          parent = GRAPH_NODE;
        } else {
          parent += "";
          for (var ancestor = parent; ancestor !== void 0; ancestor = this.parent(ancestor)) {
            if (ancestor === v) {
              throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
            }
          }
          this.setNode(parent);
        }
        this.setNode(v);
        this._removeFromParentsChildList(v);
        this._parent[v] = parent;
        this._children[parent][v] = true;
        return this;
      }
      _removeFromParentsChildList(v) {
        delete this._children[this._parent[v]][v];
      }
      /**
       * Gets parent node for node v.
       * Complexity: O(1).
       */
      parent(v) {
        if (this._isCompound) {
          var parent = this._parent[v];
          if (parent !== GRAPH_NODE) {
            return parent;
          }
        }
      }
      /**
       * Gets list of direct children of node v.
       * Complexity: O(1).
       */
      children(v = GRAPH_NODE) {
        if (this._isCompound) {
          var children = this._children[v];
          if (children) {
            return Object.keys(children);
          }
        } else if (v === GRAPH_NODE) {
          return this.nodes();
        } else if (this.hasNode(v)) {
          return [];
        }
      }
      /**
       * Return all nodes that are predecessors of the specified node or undefined if node v is not in
       * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
       * Complexity: O(|V|).
       */
      predecessors(v) {
        var predsV = this._preds[v];
        if (predsV) {
          return Object.keys(predsV);
        }
      }
      /**
       * Return all nodes that are successors of the specified node or undefined if node v is not in
       * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
       * Complexity: O(|V|).
       */
      successors(v) {
        var sucsV = this._sucs[v];
        if (sucsV) {
          return Object.keys(sucsV);
        }
      }
      /**
       * Return all nodes that are predecessors or successors of the specified node or undefined if
       * node v is not in the graph.
       * Complexity: O(|V|).
       */
      neighbors(v) {
        var preds = this.predecessors(v);
        if (preds) {
          const union = new Set(preds);
          for (var succ of this.successors(v)) {
            union.add(succ);
          }
          return Array.from(union.values());
        }
      }
      isLeaf(v) {
        var neighbors;
        if (this.isDirected()) {
          neighbors = this.successors(v);
        } else {
          neighbors = this.neighbors(v);
        }
        return neighbors.length === 0;
      }
      /**
       * Creates new graph with nodes filtered via filter. Edges incident to rejected node
       * are also removed. In case of compound graph, if parent is rejected by filter,
       * than all its children are rejected too.
       * Average-case complexity: O(|E|+|V|).
       */
      filterNodes(filter) {
        var copy = new this.constructor({
          directed: this._isDirected,
          multigraph: this._isMultigraph,
          compound: this._isCompound
        });
        copy.setGraph(this.graph());
        var self = this;
        Object.entries(this._nodes).forEach(function([v, value]) {
          if (filter(v)) {
            copy.setNode(v, value);
          }
        });
        Object.values(this._edgeObjs).forEach(function(e) {
          if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
            copy.setEdge(e, self.edge(e));
          }
        });
        var parents = {};
        function findParent(v) {
          var parent = self.parent(v);
          if (parent === void 0 || copy.hasNode(parent)) {
            parents[v] = parent;
            return parent;
          } else if (parent in parents) {
            return parents[parent];
          } else {
            return findParent(parent);
          }
        }
        if (this._isCompound) {
          copy.nodes().forEach((v) => copy.setParent(v, findParent(v)));
        }
        return copy;
      }
      /* === Edge functions ========== */
      /**
       * Sets the default edge label or factory function. This label will be
       * assigned as default label in case if no label was specified while setting
       * an edge or this function will be invoked each time when setting an edge
       * with no label specified and returned value * will be used as a label for edge.
       * Complexity: O(1).
       */
      setDefaultEdgeLabel(newDefault) {
        this._defaultEdgeLabelFn = newDefault;
        if (typeof newDefault !== "function") {
          this._defaultEdgeLabelFn = () => newDefault;
        }
        return this;
      }
      /**
       * Gets the number of edges in the graph.
       * Complexity: O(1).
       */
      edgeCount() {
        return this._edgeCount;
      }
      /**
       * Gets edges of the graph. In case of compound graph subgraphs are not considered.
       * Complexity: O(|E|).
       */
      edges() {
        return Object.values(this._edgeObjs);
      }
      /**
       * Establish an edges path over the nodes in nodes list. If some edge is already
       * exists, it will update its label, otherwise it will create an edge between pair
       * of nodes with label provided or default label if no label provided.
       * Complexity: O(|nodes|).
       */
      setPath(vs, value) {
        var self = this;
        var args = arguments;
        vs.reduce(function(v, w2) {
          if (args.length > 1) {
            self.setEdge(v, w2, value);
          } else {
            self.setEdge(v, w2);
          }
          return w2;
        });
        return this;
      }
      /**
       * Creates or updates the label for the edge (v, w) with the optionally supplied
       * name. If label is supplied it is set as the value for the edge. If label is not
       * supplied and the edge was created by this call then the default edge label will
       * be assigned. The name parameter is only useful with multigraphs.
       */
      setEdge() {
        var v, w2, name2, value;
        var valueSpecified = false;
        var arg0 = arguments[0];
        if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
          v = arg0.v;
          w2 = arg0.w;
          name2 = arg0.name;
          if (arguments.length === 2) {
            value = arguments[1];
            valueSpecified = true;
          }
        } else {
          v = arg0;
          w2 = arguments[1];
          name2 = arguments[3];
          if (arguments.length > 2) {
            value = arguments[2];
            valueSpecified = true;
          }
        }
        v = "" + v;
        w2 = "" + w2;
        if (name2 !== void 0) {
          name2 = "" + name2;
        }
        var e = edgeArgsToId(this._isDirected, v, w2, name2);
        if (Object.hasOwn(this._edgeLabels, e)) {
          if (valueSpecified) {
            this._edgeLabels[e] = value;
          }
          return this;
        }
        if (name2 !== void 0 && !this._isMultigraph) {
          throw new Error("Cannot set a named edge when isMultigraph = false");
        }
        this.setNode(v);
        this.setNode(w2);
        this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w2, name2);
        var edgeObj = edgeArgsToObj(this._isDirected, v, w2, name2);
        v = edgeObj.v;
        w2 = edgeObj.w;
        Object.freeze(edgeObj);
        this._edgeObjs[e] = edgeObj;
        incrementOrInitEntry(this._preds[w2], v);
        incrementOrInitEntry(this._sucs[v], w2);
        this._in[w2][e] = edgeObj;
        this._out[v][e] = edgeObj;
        this._edgeCount++;
        return this;
      }
      /**
       * Gets the label for the specified edge.
       * Complexity: O(1).
       */
      edge(v, w2, name2) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w2, name2);
        return this._edgeLabels[e];
      }
      /**
       * Gets the label for the specified edge and converts it to an object.
       * Complexity: O(1)
       */
      edgeAsObj() {
        const edge = this.edge(...arguments);
        if (typeof edge !== "object") {
          return { label: edge };
        }
        return edge;
      }
      /**
       * Detects whether the graph contains specified edge or not. No subgraphs are considered.
       * Complexity: O(1).
       */
      hasEdge(v, w2, name2) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w2, name2);
        return Object.hasOwn(this._edgeLabels, e);
      }
      /**
       * Removes the specified edge from the graph. No subgraphs are considered.
       * Complexity: O(1).
       */
      removeEdge(v, w2, name2) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w2, name2);
        var edge = this._edgeObjs[e];
        if (edge) {
          v = edge.v;
          w2 = edge.w;
          delete this._edgeLabels[e];
          delete this._edgeObjs[e];
          decrementOrRemoveEntry(this._preds[w2], v);
          decrementOrRemoveEntry(this._sucs[v], w2);
          delete this._in[w2][e];
          delete this._out[v][e];
          this._edgeCount--;
        }
        return this;
      }
      /**
       * Return all edges that point to the node v. Optionally filters those edges down to just those
       * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
       * Complexity: O(|E|).
       */
      inEdges(v, u) {
        var inV = this._in[v];
        if (inV) {
          var edges = Object.values(inV);
          if (!u) {
            return edges;
          }
          return edges.filter((edge) => edge.v === u);
        }
      }
      /**
       * Return all edges that are pointed at by node v. Optionally filters those edges down to just
       * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
       * Complexity: O(|E|).
       */
      outEdges(v, w2) {
        var outV = this._out[v];
        if (outV) {
          var edges = Object.values(outV);
          if (!w2) {
            return edges;
          }
          return edges.filter((edge) => edge.w === w2);
        }
      }
      /**
       * Returns all edges to or from node v regardless of direction. Optionally filters those edges
       * down to just those between nodes v and w regardless of direction.
       * Complexity: O(|E|).
       */
      nodeEdges(v, w2) {
        var inEdges = this.inEdges(v, w2);
        if (inEdges) {
          return inEdges.concat(this.outEdges(v, w2));
        }
      }
    };
    function incrementOrInitEntry(map, k) {
      if (map[k]) {
        map[k]++;
      } else {
        map[k] = 1;
      }
    }
    function decrementOrRemoveEntry(map, k) {
      if (!--map[k]) {
        delete map[k];
      }
    }
    function edgeArgsToId(isDirected, v_, w_, name2) {
      var v = "" + v_;
      var w2 = "" + w_;
      if (!isDirected && v > w2) {
        var tmp = v;
        v = w2;
        w2 = tmp;
      }
      return v + EDGE_KEY_DELIM + w2 + EDGE_KEY_DELIM + (name2 === void 0 ? DEFAULT_EDGE_NAME : name2);
    }
    function edgeArgsToObj(isDirected, v_, w_, name2) {
      var v = "" + v_;
      var w2 = "" + w_;
      if (!isDirected && v > w2) {
        var tmp = v;
        v = w2;
        w2 = tmp;
      }
      var edgeObj = { v, w: w2 };
      if (name2) {
        edgeObj.name = name2;
      }
      return edgeObj;
    }
    function edgeObjToId(isDirected, edgeObj) {
      return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
    }
    module2.exports = Graph;
  }
});

// node_modules/@dagrejs/graphlib/lib/version.js
var require_version = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/version.js"(exports2, module2) {
    module2.exports = "2.2.4";
  }
});

// node_modules/@dagrejs/graphlib/lib/index.js
var require_lib = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/index.js"(exports2, module2) {
    module2.exports = {
      Graph: require_graph(),
      version: require_version()
    };
  }
});

// node_modules/@dagrejs/graphlib/lib/json.js
var require_json = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/json.js"(exports2, module2) {
    var Graph = require_graph();
    module2.exports = {
      write,
      read
    };
    function write(g) {
      var json = {
        options: {
          directed: g.isDirected(),
          multigraph: g.isMultigraph(),
          compound: g.isCompound()
        },
        nodes: writeNodes(g),
        edges: writeEdges(g)
      };
      if (g.graph() !== void 0) {
        json.value = structuredClone(g.graph());
      }
      return json;
    }
    function writeNodes(g) {
      return g.nodes().map(function(v) {
        var nodeValue = g.node(v);
        var parent = g.parent(v);
        var node = { v };
        if (nodeValue !== void 0) {
          node.value = nodeValue;
        }
        if (parent !== void 0) {
          node.parent = parent;
        }
        return node;
      });
    }
    function writeEdges(g) {
      return g.edges().map(function(e) {
        var edgeValue = g.edge(e);
        var edge = { v: e.v, w: e.w };
        if (e.name !== void 0) {
          edge.name = e.name;
        }
        if (edgeValue !== void 0) {
          edge.value = edgeValue;
        }
        return edge;
      });
    }
    function read(json) {
      var g = new Graph(json.options).setGraph(json.value);
      json.nodes.forEach(function(entry) {
        g.setNode(entry.v, entry.value);
        if (entry.parent) {
          g.setParent(entry.v, entry.parent);
        }
      });
      json.edges.forEach(function(entry) {
        g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
      });
      return g;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/components.js
var require_components = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/components.js"(exports2, module2) {
    module2.exports = components;
    function components(g) {
      var visited = {};
      var cmpts = [];
      var cmpt;
      function dfs(v) {
        if (Object.hasOwn(visited, v)) return;
        visited[v] = true;
        cmpt.push(v);
        g.successors(v).forEach(dfs);
        g.predecessors(v).forEach(dfs);
      }
      g.nodes().forEach(function(v) {
        cmpt = [];
        dfs(v);
        if (cmpt.length) {
          cmpts.push(cmpt);
        }
      });
      return cmpts;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/data/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/data/priority-queue.js"(exports2, module2) {
    var PriorityQueue = class {
      _arr = [];
      _keyIndices = {};
      /**
       * Returns the number of elements in the queue. Takes `O(1)` time.
       */
      size() {
        return this._arr.length;
      }
      /**
       * Returns the keys that are in the queue. Takes `O(n)` time.
       */
      keys() {
        return this._arr.map(function(x) {
          return x.key;
        });
      }
      /**
       * Returns `true` if **key** is in the queue and `false` if not.
       */
      has(key) {
        return Object.hasOwn(this._keyIndices, key);
      }
      /**
       * Returns the priority for **key**. If **key** is not present in the queue
       * then this function returns `undefined`. Takes `O(1)` time.
       *
       * @param {Object} key
       */
      priority(key) {
        var index = this._keyIndices[key];
        if (index !== void 0) {
          return this._arr[index].priority;
        }
      }
      /**
       * Returns the key for the minimum element in this queue. If the queue is
       * empty this function throws an Error. Takes `O(1)` time.
       */
      min() {
        if (this.size() === 0) {
          throw new Error("Queue underflow");
        }
        return this._arr[0].key;
      }
      /**
       * Inserts a new key into the priority queue. If the key already exists in
       * the queue this function returns `false`; otherwise it will return `true`.
       * Takes `O(n)` time.
       *
       * @param {Object} key the key to add
       * @param {Number} priority the initial priority for the key
       */
      add(key, priority) {
        var keyIndices = this._keyIndices;
        key = String(key);
        if (!Object.hasOwn(keyIndices, key)) {
          var arr = this._arr;
          var index = arr.length;
          keyIndices[key] = index;
          arr.push({ key, priority });
          this._decrease(index);
          return true;
        }
        return false;
      }
      /**
       * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
       */
      removeMin() {
        this._swap(0, this._arr.length - 1);
        var min = this._arr.pop();
        delete this._keyIndices[min.key];
        this._heapify(0);
        return min.key;
      }
      /**
       * Decreases the priority for **key** to **priority**. If the new priority is
       * greater than the previous priority, this function will throw an Error.
       *
       * @param {Object} key the key for which to raise priority
       * @param {Number} priority the new priority for the key
       */
      decrease(key, priority) {
        var index = this._keyIndices[key];
        if (priority > this._arr[index].priority) {
          throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
        }
        this._arr[index].priority = priority;
        this._decrease(index);
      }
      _heapify(i) {
        var arr = this._arr;
        var l = 2 * i;
        var r = l + 1;
        var largest = i;
        if (l < arr.length) {
          largest = arr[l].priority < arr[largest].priority ? l : largest;
          if (r < arr.length) {
            largest = arr[r].priority < arr[largest].priority ? r : largest;
          }
          if (largest !== i) {
            this._swap(i, largest);
            this._heapify(largest);
          }
        }
      }
      _decrease(index) {
        var arr = this._arr;
        var priority = arr[index].priority;
        var parent;
        while (index !== 0) {
          parent = index >> 1;
          if (arr[parent].priority < priority) {
            break;
          }
          this._swap(index, parent);
          index = parent;
        }
      }
      _swap(i, j) {
        var arr = this._arr;
        var keyIndices = this._keyIndices;
        var origArrI = arr[i];
        var origArrJ = arr[j];
        arr[i] = origArrJ;
        arr[j] = origArrI;
        keyIndices[origArrJ.key] = i;
        keyIndices[origArrI.key] = j;
      }
    };
    module2.exports = PriorityQueue;
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/dijkstra.js"(exports2, module2) {
    var PriorityQueue = require_priority_queue();
    module2.exports = dijkstra;
    var DEFAULT_WEIGHT_FUNC = () => 1;
    function dijkstra(g, source, weightFn, edgeFn) {
      return runDijkstra(
        g,
        String(source),
        weightFn || DEFAULT_WEIGHT_FUNC,
        edgeFn || function(v) {
          return g.outEdges(v);
        }
      );
    }
    function runDijkstra(g, source, weightFn, edgeFn) {
      var results = {};
      var pq = new PriorityQueue();
      var v, vEntry;
      var updateNeighbors = function(edge) {
        var w2 = edge.v !== v ? edge.v : edge.w;
        var wEntry = results[w2];
        var weight = weightFn(edge);
        var distance = vEntry.distance + weight;
        if (weight < 0) {
          throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
        }
        if (distance < wEntry.distance) {
          wEntry.distance = distance;
          wEntry.predecessor = v;
          pq.decrease(w2, distance);
        }
      };
      g.nodes().forEach(function(v2) {
        var distance = v2 === source ? 0 : Number.POSITIVE_INFINITY;
        results[v2] = { distance };
        pq.add(v2, distance);
      });
      while (pq.size() > 0) {
        v = pq.removeMin();
        vEntry = results[v];
        if (vEntry.distance === Number.POSITIVE_INFINITY) {
          break;
        }
        edgeFn(v).forEach(updateNeighbors);
      }
      return results;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/dijkstra-all.js
var require_dijkstra_all = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/dijkstra-all.js"(exports2, module2) {
    var dijkstra = require_dijkstra();
    module2.exports = dijkstraAll;
    function dijkstraAll(g, weightFunc, edgeFunc) {
      return g.nodes().reduce(function(acc, v) {
        acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
        return acc;
      }, {});
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/tarjan.js
var require_tarjan = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/tarjan.js"(exports2, module2) {
    module2.exports = tarjan;
    function tarjan(g) {
      var index = 0;
      var stack = [];
      var visited = {};
      var results = [];
      function dfs(v) {
        var entry = visited[v] = {
          onStack: true,
          lowlink: index,
          index: index++
        };
        stack.push(v);
        g.successors(v).forEach(function(w3) {
          if (!Object.hasOwn(visited, w3)) {
            dfs(w3);
            entry.lowlink = Math.min(entry.lowlink, visited[w3].lowlink);
          } else if (visited[w3].onStack) {
            entry.lowlink = Math.min(entry.lowlink, visited[w3].index);
          }
        });
        if (entry.lowlink === entry.index) {
          var cmpt = [];
          var w2;
          do {
            w2 = stack.pop();
            visited[w2].onStack = false;
            cmpt.push(w2);
          } while (v !== w2);
          results.push(cmpt);
        }
      }
      g.nodes().forEach(function(v) {
        if (!Object.hasOwn(visited, v)) {
          dfs(v);
        }
      });
      return results;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/find-cycles.js
var require_find_cycles = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/find-cycles.js"(exports2, module2) {
    var tarjan = require_tarjan();
    module2.exports = findCycles;
    function findCycles(g) {
      return tarjan(g).filter(function(cmpt) {
        return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
      });
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/floyd-warshall.js
var require_floyd_warshall = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/floyd-warshall.js"(exports2, module2) {
    module2.exports = floydWarshall;
    var DEFAULT_WEIGHT_FUNC = () => 1;
    function floydWarshall(g, weightFn, edgeFn) {
      return runFloydWarshall(
        g,
        weightFn || DEFAULT_WEIGHT_FUNC,
        edgeFn || function(v) {
          return g.outEdges(v);
        }
      );
    }
    function runFloydWarshall(g, weightFn, edgeFn) {
      var results = {};
      var nodes = g.nodes();
      nodes.forEach(function(v) {
        results[v] = {};
        results[v][v] = { distance: 0 };
        nodes.forEach(function(w2) {
          if (v !== w2) {
            results[v][w2] = { distance: Number.POSITIVE_INFINITY };
          }
        });
        edgeFn(v).forEach(function(edge) {
          var w2 = edge.v === v ? edge.w : edge.v;
          var d = weightFn(edge);
          results[v][w2] = { distance: d, predecessor: v };
        });
      });
      nodes.forEach(function(k) {
        var rowK = results[k];
        nodes.forEach(function(i) {
          var rowI = results[i];
          nodes.forEach(function(j) {
            var ik = rowI[k];
            var kj = rowK[j];
            var ij = rowI[j];
            var altDistance = ik.distance + kj.distance;
            if (altDistance < ij.distance) {
              ij.distance = altDistance;
              ij.predecessor = kj.predecessor;
            }
          });
        });
      });
      return results;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/topsort.js
var require_topsort = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/topsort.js"(exports2, module2) {
    function topsort(g) {
      var visited = {};
      var stack = {};
      var results = [];
      function visit(node) {
        if (Object.hasOwn(stack, node)) {
          throw new CycleException();
        }
        if (!Object.hasOwn(visited, node)) {
          stack[node] = true;
          visited[node] = true;
          g.predecessors(node).forEach(visit);
          delete stack[node];
          results.push(node);
        }
      }
      g.sinks().forEach(visit);
      if (Object.keys(visited).length !== g.nodeCount()) {
        throw new CycleException();
      }
      return results;
    }
    var CycleException = class extends Error {
      constructor() {
        super(...arguments);
      }
    };
    module2.exports = topsort;
    topsort.CycleException = CycleException;
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/is-acyclic.js
var require_is_acyclic = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/is-acyclic.js"(exports2, module2) {
    var topsort = require_topsort();
    module2.exports = isAcyclic;
    function isAcyclic(g) {
      try {
        topsort(g);
      } catch (e) {
        if (e instanceof topsort.CycleException) {
          return false;
        }
        throw e;
      }
      return true;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/dfs.js
var require_dfs = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/dfs.js"(exports2, module2) {
    module2.exports = dfs;
    function dfs(g, vs, order) {
      if (!Array.isArray(vs)) {
        vs = [vs];
      }
      var navigation = g.isDirected() ? (v) => g.successors(v) : (v) => g.neighbors(v);
      var orderFunc = order === "post" ? postOrderDfs : preOrderDfs;
      var acc = [];
      var visited = {};
      vs.forEach((v) => {
        if (!g.hasNode(v)) {
          throw new Error("Graph does not have node: " + v);
        }
        orderFunc(v, navigation, visited, acc);
      });
      return acc;
    }
    function postOrderDfs(v, navigation, visited, acc) {
      var stack = [[v, false]];
      while (stack.length > 0) {
        var curr = stack.pop();
        if (curr[1]) {
          acc.push(curr[0]);
        } else {
          if (!Object.hasOwn(visited, curr[0])) {
            visited[curr[0]] = true;
            stack.push([curr[0], true]);
            forEachRight(navigation(curr[0]), (w2) => stack.push([w2, false]));
          }
        }
      }
    }
    function preOrderDfs(v, navigation, visited, acc) {
      var stack = [v];
      while (stack.length > 0) {
        var curr = stack.pop();
        if (!Object.hasOwn(visited, curr)) {
          visited[curr] = true;
          acc.push(curr);
          forEachRight(navigation(curr), (w2) => stack.push(w2));
        }
      }
    }
    function forEachRight(array, iteratee) {
      var length = array.length;
      while (length--) {
        iteratee(array[length], length, array);
      }
      return array;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/postorder.js
var require_postorder = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/postorder.js"(exports2, module2) {
    var dfs = require_dfs();
    module2.exports = postorder;
    function postorder(g, vs) {
      return dfs(g, vs, "post");
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/preorder.js
var require_preorder = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/preorder.js"(exports2, module2) {
    var dfs = require_dfs();
    module2.exports = preorder;
    function preorder(g, vs) {
      return dfs(g, vs, "pre");
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/prim.js
var require_prim = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/prim.js"(exports2, module2) {
    var Graph = require_graph();
    var PriorityQueue = require_priority_queue();
    module2.exports = prim;
    function prim(g, weightFunc) {
      var result2 = new Graph();
      var parents = {};
      var pq = new PriorityQueue();
      var v;
      function updateNeighbors(edge) {
        var w2 = edge.v === v ? edge.w : edge.v;
        var pri = pq.priority(w2);
        if (pri !== void 0) {
          var edgeWeight = weightFunc(edge);
          if (edgeWeight < pri) {
            parents[w2] = v;
            pq.decrease(w2, edgeWeight);
          }
        }
      }
      if (g.nodeCount() === 0) {
        return result2;
      }
      g.nodes().forEach(function(v2) {
        pq.add(v2, Number.POSITIVE_INFINITY);
        result2.setNode(v2);
      });
      pq.decrease(g.nodes()[0], 0);
      var init = false;
      while (pq.size() > 0) {
        v = pq.removeMin();
        if (Object.hasOwn(parents, v)) {
          result2.setEdge(v, parents[v]);
        } else if (init) {
          throw new Error("Input graph is not connected: " + g);
        } else {
          init = true;
        }
        g.nodeEdges(v).forEach(updateNeighbors);
      }
      return result2;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/index.js
var require_alg = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/index.js"(exports2, module2) {
    module2.exports = {
      components: require_components(),
      dijkstra: require_dijkstra(),
      dijkstraAll: require_dijkstra_all(),
      findCycles: require_find_cycles(),
      floydWarshall: require_floyd_warshall(),
      isAcyclic: require_is_acyclic(),
      postorder: require_postorder(),
      preorder: require_preorder(),
      prim: require_prim(),
      tarjan: require_tarjan(),
      topsort: require_topsort()
    };
  }
});

// node_modules/@dagrejs/graphlib/index.js
var require_graphlib = __commonJS({
  "node_modules/@dagrejs/graphlib/index.js"(exports2, module2) {
    var lib = require_lib();
    module2.exports = {
      Graph: lib.Graph,
      json: require_json(),
      alg: require_alg(),
      version: lib.version
    };
  }
});

// node_modules/@dagrejs/dagre/lib/data/list.js
var require_list = __commonJS({
  "node_modules/@dagrejs/dagre/lib/data/list.js"(exports2, module2) {
    var List = class {
      constructor() {
        let sentinel = {};
        sentinel._next = sentinel._prev = sentinel;
        this._sentinel = sentinel;
      }
      dequeue() {
        let sentinel = this._sentinel;
        let entry = sentinel._prev;
        if (entry !== sentinel) {
          unlink(entry);
          return entry;
        }
      }
      enqueue(entry) {
        let sentinel = this._sentinel;
        if (entry._prev && entry._next) {
          unlink(entry);
        }
        entry._next = sentinel._next;
        sentinel._next._prev = entry;
        sentinel._next = entry;
        entry._prev = sentinel;
      }
      toString() {
        let strs = [];
        let sentinel = this._sentinel;
        let curr = sentinel._prev;
        while (curr !== sentinel) {
          strs.push(JSON.stringify(curr, filterOutLinks));
          curr = curr._prev;
        }
        return "[" + strs.join(", ") + "]";
      }
    };
    function unlink(entry) {
      entry._prev._next = entry._next;
      entry._next._prev = entry._prev;
      delete entry._next;
      delete entry._prev;
    }
    function filterOutLinks(k, v) {
      if (k !== "_next" && k !== "_prev") {
        return v;
      }
    }
    module2.exports = List;
  }
});

// node_modules/@dagrejs/dagre/lib/greedy-fas.js
var require_greedy_fas = __commonJS({
  "node_modules/@dagrejs/dagre/lib/greedy-fas.js"(exports2, module2) {
    var Graph = require_graphlib().Graph;
    var List = require_list();
    module2.exports = greedyFAS;
    var DEFAULT_WEIGHT_FN = () => 1;
    function greedyFAS(g, weightFn) {
      if (g.nodeCount() <= 1) {
        return [];
      }
      let state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
      let results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
      return results.flatMap((e) => g.outEdges(e.v, e.w));
    }
    function doGreedyFAS(g, buckets, zeroIdx) {
      let results = [];
      let sources = buckets[buckets.length - 1];
      let sinks = buckets[0];
      let entry;
      while (g.nodeCount()) {
        while (entry = sinks.dequeue()) {
          removeNode(g, buckets, zeroIdx, entry);
        }
        while (entry = sources.dequeue()) {
          removeNode(g, buckets, zeroIdx, entry);
        }
        if (g.nodeCount()) {
          for (let i = buckets.length - 2; i > 0; --i) {
            entry = buckets[i].dequeue();
            if (entry) {
              results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
              break;
            }
          }
        }
      }
      return results;
    }
    function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
      let results = collectPredecessors ? [] : void 0;
      g.inEdges(entry.v).forEach((edge) => {
        let weight = g.edge(edge);
        let uEntry = g.node(edge.v);
        if (collectPredecessors) {
          results.push({ v: edge.v, w: edge.w });
        }
        uEntry.out -= weight;
        assignBucket(buckets, zeroIdx, uEntry);
      });
      g.outEdges(entry.v).forEach((edge) => {
        let weight = g.edge(edge);
        let w2 = edge.w;
        let wEntry = g.node(w2);
        wEntry["in"] -= weight;
        assignBucket(buckets, zeroIdx, wEntry);
      });
      g.removeNode(entry.v);
      return results;
    }
    function buildState(g, weightFn) {
      let fasGraph = new Graph();
      let maxIn = 0;
      let maxOut = 0;
      g.nodes().forEach((v) => {
        fasGraph.setNode(v, { v, "in": 0, out: 0 });
      });
      g.edges().forEach((e) => {
        let prevWeight = fasGraph.edge(e.v, e.w) || 0;
        let weight = weightFn(e);
        let edgeWeight = prevWeight + weight;
        fasGraph.setEdge(e.v, e.w, edgeWeight);
        maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
        maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
      });
      let buckets = range(maxOut + maxIn + 3).map(() => new List());
      let zeroIdx = maxIn + 1;
      fasGraph.nodes().forEach((v) => {
        assignBucket(buckets, zeroIdx, fasGraph.node(v));
      });
      return { graph: fasGraph, buckets, zeroIdx };
    }
    function assignBucket(buckets, zeroIdx, entry) {
      if (!entry.out) {
        buckets[0].enqueue(entry);
      } else if (!entry["in"]) {
        buckets[buckets.length - 1].enqueue(entry);
      } else {
        buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
      }
    }
    function range(limit) {
      const range2 = [];
      for (let i = 0; i < limit; i++) {
        range2.push(i);
      }
      return range2;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/util.js
var require_util = __commonJS({
  "node_modules/@dagrejs/dagre/lib/util.js"(exports2, module2) {
    "use strict";
    var Graph = require_graphlib().Graph;
    module2.exports = {
      addBorderNode,
      addDummyNode,
      applyWithChunking,
      asNonCompoundGraph,
      buildLayerMatrix,
      intersectRect,
      mapValues,
      maxRank,
      normalizeRanks,
      notime,
      partition,
      pick,
      predecessorWeights,
      range,
      removeEmptyRanks,
      simplify,
      successorWeights,
      time,
      uniqueId,
      zipObject
    };
    function addDummyNode(g, type, attrs, name2) {
      let v;
      do {
        v = uniqueId(name2);
      } while (g.hasNode(v));
      attrs.dummy = type;
      g.setNode(v, attrs);
      return v;
    }
    function simplify(g) {
      let simplified = new Graph().setGraph(g.graph());
      g.nodes().forEach((v) => simplified.setNode(v, g.node(v)));
      g.edges().forEach((e) => {
        let simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
        let label = g.edge(e);
        simplified.setEdge(e.v, e.w, {
          weight: simpleLabel.weight + label.weight,
          minlen: Math.max(simpleLabel.minlen, label.minlen)
        });
      });
      return simplified;
    }
    function asNonCompoundGraph(g) {
      let simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
      g.nodes().forEach((v) => {
        if (!g.children(v).length) {
          simplified.setNode(v, g.node(v));
        }
      });
      g.edges().forEach((e) => {
        simplified.setEdge(e, g.edge(e));
      });
      return simplified;
    }
    function successorWeights(g) {
      let weightMap = g.nodes().map((v) => {
        let sucs = {};
        g.outEdges(v).forEach((e) => {
          sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
        });
        return sucs;
      });
      return zipObject(g.nodes(), weightMap);
    }
    function predecessorWeights(g) {
      let weightMap = g.nodes().map((v) => {
        let preds = {};
        g.inEdges(v).forEach((e) => {
          preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
        });
        return preds;
      });
      return zipObject(g.nodes(), weightMap);
    }
    function intersectRect(rect, point) {
      let x = rect.x;
      let y = rect.y;
      let dx = point.x - x;
      let dy = point.y - y;
      let w2 = rect.width / 2;
      let h2 = rect.height / 2;
      if (!dx && !dy) {
        throw new Error("Not possible to find intersection inside of the rectangle");
      }
      let sx, sy;
      if (Math.abs(dy) * w2 > Math.abs(dx) * h2) {
        if (dy < 0) {
          h2 = -h2;
        }
        sx = h2 * dx / dy;
        sy = h2;
      } else {
        if (dx < 0) {
          w2 = -w2;
        }
        sx = w2;
        sy = w2 * dy / dx;
      }
      return { x: x + sx, y: y + sy };
    }
    function buildLayerMatrix(g) {
      let layering = range(maxRank(g) + 1).map(() => []);
      g.nodes().forEach((v) => {
        let node = g.node(v);
        let rank = node.rank;
        if (rank !== void 0) {
          layering[rank][node.order] = v;
        }
      });
      return layering;
    }
    function normalizeRanks(g) {
      let nodeRanks = g.nodes().map((v) => {
        let rank = g.node(v).rank;
        if (rank === void 0) {
          return Number.MAX_VALUE;
        }
        return rank;
      });
      let min = applyWithChunking(Math.min, nodeRanks);
      g.nodes().forEach((v) => {
        let node = g.node(v);
        if (Object.hasOwn(node, "rank")) {
          node.rank -= min;
        }
      });
    }
    function removeEmptyRanks(g) {
      let nodeRanks = g.nodes().map((v) => g.node(v).rank);
      let offset = applyWithChunking(Math.min, nodeRanks);
      let layers = [];
      g.nodes().forEach((v) => {
        let rank = g.node(v).rank - offset;
        if (!layers[rank]) {
          layers[rank] = [];
        }
        layers[rank].push(v);
      });
      let delta = 0;
      let nodeRankFactor = g.graph().nodeRankFactor;
      Array.from(layers).forEach((vs, i) => {
        if (vs === void 0 && i % nodeRankFactor !== 0) {
          --delta;
        } else if (vs !== void 0 && delta) {
          vs.forEach((v) => g.node(v).rank += delta);
        }
      });
    }
    function addBorderNode(g, prefix, rank, order) {
      let node = {
        width: 0,
        height: 0
      };
      if (arguments.length >= 4) {
        node.rank = rank;
        node.order = order;
      }
      return addDummyNode(g, "border", node, prefix);
    }
    function splitToChunks(array, chunkSize = CHUNKING_THRESHOLD) {
      const chunks = [];
      for (let i = 0; i < array.length; i += chunkSize) {
        const chunk = array.slice(i, i + chunkSize);
        chunks.push(chunk);
      }
      return chunks;
    }
    var CHUNKING_THRESHOLD = 65535;
    function applyWithChunking(fn, argsArray) {
      if (argsArray.length > CHUNKING_THRESHOLD) {
        const chunks = splitToChunks(argsArray);
        return fn.apply(null, chunks.map((chunk) => fn.apply(null, chunk)));
      } else {
        return fn.apply(null, argsArray);
      }
    }
    function maxRank(g) {
      const nodes = g.nodes();
      const nodeRanks = nodes.map((v) => {
        let rank = g.node(v).rank;
        if (rank === void 0) {
          return Number.MIN_VALUE;
        }
        return rank;
      });
      return applyWithChunking(Math.max, nodeRanks);
    }
    function partition(collection, fn) {
      let result2 = { lhs: [], rhs: [] };
      collection.forEach((value) => {
        if (fn(value)) {
          result2.lhs.push(value);
        } else {
          result2.rhs.push(value);
        }
      });
      return result2;
    }
    function time(name2, fn) {
      let start = Date.now();
      try {
        return fn();
      } finally {
        console.log(name2 + " time: " + (Date.now() - start) + "ms");
      }
    }
    function notime(name2, fn) {
      return fn();
    }
    var idCounter = 0;
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }
    function range(start, limit, step = 1) {
      if (limit == null) {
        limit = start;
        start = 0;
      }
      let endCon = (i) => i < limit;
      if (step < 0) {
        endCon = (i) => limit < i;
      }
      const range2 = [];
      for (let i = start; endCon(i); i += step) {
        range2.push(i);
      }
      return range2;
    }
    function pick(source, keys) {
      const dest = {};
      for (const key of keys) {
        if (source[key] !== void 0) {
          dest[key] = source[key];
        }
      }
      return dest;
    }
    function mapValues(obj, funcOrProp) {
      let func = funcOrProp;
      if (typeof funcOrProp === "string") {
        func = (val) => val[funcOrProp];
      }
      return Object.entries(obj).reduce((acc, [k, v]) => {
        acc[k] = func(v, k);
        return acc;
      }, {});
    }
    function zipObject(props, values) {
      return props.reduce((acc, key, i) => {
        acc[key] = values[i];
        return acc;
      }, {});
    }
  }
});

// node_modules/@dagrejs/dagre/lib/acyclic.js
var require_acyclic = __commonJS({
  "node_modules/@dagrejs/dagre/lib/acyclic.js"(exports2, module2) {
    "use strict";
    var greedyFAS = require_greedy_fas();
    var uniqueId = require_util().uniqueId;
    module2.exports = {
      run,
      undo
    };
    function run(g) {
      let fas = g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g);
      fas.forEach((e) => {
        let label = g.edge(e);
        g.removeEdge(e);
        label.forwardName = e.name;
        label.reversed = true;
        g.setEdge(e.w, e.v, label, uniqueId("rev"));
      });
      function weightFn(g2) {
        return (e) => {
          return g2.edge(e).weight;
        };
      }
    }
    function dfsFAS(g) {
      let fas = [];
      let stack = {};
      let visited = {};
      function dfs(v) {
        if (Object.hasOwn(visited, v)) {
          return;
        }
        visited[v] = true;
        stack[v] = true;
        g.outEdges(v).forEach((e) => {
          if (Object.hasOwn(stack, e.w)) {
            fas.push(e);
          } else {
            dfs(e.w);
          }
        });
        delete stack[v];
      }
      g.nodes().forEach(dfs);
      return fas;
    }
    function undo(g) {
      g.edges().forEach((e) => {
        let label = g.edge(e);
        if (label.reversed) {
          g.removeEdge(e);
          let forwardName = label.forwardName;
          delete label.reversed;
          delete label.forwardName;
          g.setEdge(e.w, e.v, label, forwardName);
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/normalize.js
var require_normalize = __commonJS({
  "node_modules/@dagrejs/dagre/lib/normalize.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    module2.exports = {
      run,
      undo
    };
    function run(g) {
      g.graph().dummyChains = [];
      g.edges().forEach((edge) => normalizeEdge(g, edge));
    }
    function normalizeEdge(g, e) {
      let v = e.v;
      let vRank = g.node(v).rank;
      let w2 = e.w;
      let wRank = g.node(w2).rank;
      let name2 = e.name;
      let edgeLabel = g.edge(e);
      let labelRank = edgeLabel.labelRank;
      if (wRank === vRank + 1) return;
      g.removeEdge(e);
      let dummy, attrs, i;
      for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
        edgeLabel.points = [];
        attrs = {
          width: 0,
          height: 0,
          edgeLabel,
          edgeObj: e,
          rank: vRank
        };
        dummy = util.addDummyNode(g, "edge", attrs, "_d");
        if (vRank === labelRank) {
          attrs.width = edgeLabel.width;
          attrs.height = edgeLabel.height;
          attrs.dummy = "edge-label";
          attrs.labelpos = edgeLabel.labelpos;
        }
        g.setEdge(v, dummy, { weight: edgeLabel.weight }, name2);
        if (i === 0) {
          g.graph().dummyChains.push(dummy);
        }
        v = dummy;
      }
      g.setEdge(v, w2, { weight: edgeLabel.weight }, name2);
    }
    function undo(g) {
      g.graph().dummyChains.forEach((v) => {
        let node = g.node(v);
        let origLabel = node.edgeLabel;
        let w2;
        g.setEdge(node.edgeObj, origLabel);
        while (node.dummy) {
          w2 = g.successors(v)[0];
          g.removeNode(v);
          origLabel.points.push({ x: node.x, y: node.y });
          if (node.dummy === "edge-label") {
            origLabel.x = node.x;
            origLabel.y = node.y;
            origLabel.width = node.width;
            origLabel.height = node.height;
          }
          v = w2;
          node = g.node(v);
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/util.js
var require_util2 = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/util.js"(exports2, module2) {
    "use strict";
    var { applyWithChunking } = require_util();
    module2.exports = {
      longestPath,
      slack
    };
    function longestPath(g) {
      var visited = {};
      function dfs(v) {
        var label = g.node(v);
        if (Object.hasOwn(visited, v)) {
          return label.rank;
        }
        visited[v] = true;
        let outEdgesMinLens = g.outEdges(v).map((e) => {
          if (e == null) {
            return Number.POSITIVE_INFINITY;
          }
          return dfs(e.w) - g.edge(e).minlen;
        });
        var rank = applyWithChunking(Math.min, outEdgesMinLens);
        if (rank === Number.POSITIVE_INFINITY) {
          rank = 0;
        }
        return label.rank = rank;
      }
      g.sources().forEach(dfs);
    }
    function slack(g, e) {
      return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/feasible-tree.js
var require_feasible_tree = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/feasible-tree.js"(exports2, module2) {
    "use strict";
    var Graph = require_graphlib().Graph;
    var slack = require_util2().slack;
    module2.exports = feasibleTree;
    function feasibleTree(g) {
      var t = new Graph({ directed: false });
      var start = g.nodes()[0];
      var size = g.nodeCount();
      t.setNode(start, {});
      var edge, delta;
      while (tightTree(t, g) < size) {
        edge = findMinSlackEdge(t, g);
        delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
        shiftRanks(t, g, delta);
      }
      return t;
    }
    function tightTree(t, g) {
      function dfs(v) {
        g.nodeEdges(v).forEach((e) => {
          var edgeV = e.v, w2 = v === edgeV ? e.w : edgeV;
          if (!t.hasNode(w2) && !slack(g, e)) {
            t.setNode(w2, {});
            t.setEdge(v, w2, {});
            dfs(w2);
          }
        });
      }
      t.nodes().forEach(dfs);
      return t.nodeCount();
    }
    function findMinSlackEdge(t, g) {
      const edges = g.edges();
      return edges.reduce((acc, edge) => {
        let edgeSlack = Number.POSITIVE_INFINITY;
        if (t.hasNode(edge.v) !== t.hasNode(edge.w)) {
          edgeSlack = slack(g, edge);
        }
        if (edgeSlack < acc[0]) {
          return [edgeSlack, edge];
        }
        return acc;
      }, [Number.POSITIVE_INFINITY, null])[1];
    }
    function shiftRanks(t, g, delta) {
      t.nodes().forEach((v) => g.node(v).rank += delta);
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/network-simplex.js
var require_network_simplex = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/network-simplex.js"(exports2, module2) {
    "use strict";
    var feasibleTree = require_feasible_tree();
    var slack = require_util2().slack;
    var initRank = require_util2().longestPath;
    var preorder = require_graphlib().alg.preorder;
    var postorder = require_graphlib().alg.postorder;
    var simplify = require_util().simplify;
    module2.exports = networkSimplex;
    networkSimplex.initLowLimValues = initLowLimValues;
    networkSimplex.initCutValues = initCutValues;
    networkSimplex.calcCutValue = calcCutValue;
    networkSimplex.leaveEdge = leaveEdge;
    networkSimplex.enterEdge = enterEdge;
    networkSimplex.exchangeEdges = exchangeEdges;
    function networkSimplex(g) {
      g = simplify(g);
      initRank(g);
      var t = feasibleTree(g);
      initLowLimValues(t);
      initCutValues(t, g);
      var e, f;
      while (e = leaveEdge(t)) {
        f = enterEdge(t, g, e);
        exchangeEdges(t, g, e, f);
      }
    }
    function initCutValues(t, g) {
      var vs = postorder(t, t.nodes());
      vs = vs.slice(0, vs.length - 1);
      vs.forEach((v) => assignCutValue(t, g, v));
    }
    function assignCutValue(t, g, child) {
      var childLab = t.node(child);
      var parent = childLab.parent;
      t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
    }
    function calcCutValue(t, g, child) {
      var childLab = t.node(child);
      var parent = childLab.parent;
      var childIsTail = true;
      var graphEdge = g.edge(child, parent);
      var cutValue = 0;
      if (!graphEdge) {
        childIsTail = false;
        graphEdge = g.edge(parent, child);
      }
      cutValue = graphEdge.weight;
      g.nodeEdges(child).forEach((e) => {
        var isOutEdge = e.v === child, other = isOutEdge ? e.w : e.v;
        if (other !== parent) {
          var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e).weight;
          cutValue += pointsToHead ? otherWeight : -otherWeight;
          if (isTreeEdge(t, child, other)) {
            var otherCutValue = t.edge(child, other).cutvalue;
            cutValue += pointsToHead ? -otherCutValue : otherCutValue;
          }
        }
      });
      return cutValue;
    }
    function initLowLimValues(tree, root) {
      if (arguments.length < 2) {
        root = tree.nodes()[0];
      }
      dfsAssignLowLim(tree, {}, 1, root);
    }
    function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
      var low = nextLim;
      var label = tree.node(v);
      visited[v] = true;
      tree.neighbors(v).forEach((w2) => {
        if (!Object.hasOwn(visited, w2)) {
          nextLim = dfsAssignLowLim(tree, visited, nextLim, w2, v);
        }
      });
      label.low = low;
      label.lim = nextLim++;
      if (parent) {
        label.parent = parent;
      } else {
        delete label.parent;
      }
      return nextLim;
    }
    function leaveEdge(tree) {
      return tree.edges().find((e) => tree.edge(e).cutvalue < 0);
    }
    function enterEdge(t, g, edge) {
      var v = edge.v;
      var w2 = edge.w;
      if (!g.hasEdge(v, w2)) {
        v = edge.w;
        w2 = edge.v;
      }
      var vLabel = t.node(v);
      var wLabel = t.node(w2);
      var tailLabel = vLabel;
      var flip = false;
      if (vLabel.lim > wLabel.lim) {
        tailLabel = wLabel;
        flip = true;
      }
      var candidates = g.edges().filter((edge2) => {
        return flip === isDescendant(t, t.node(edge2.v), tailLabel) && flip !== isDescendant(t, t.node(edge2.w), tailLabel);
      });
      return candidates.reduce((acc, edge2) => {
        if (slack(g, edge2) < slack(g, acc)) {
          return edge2;
        }
        return acc;
      });
    }
    function exchangeEdges(t, g, e, f) {
      var v = e.v;
      var w2 = e.w;
      t.removeEdge(v, w2);
      t.setEdge(f.v, f.w, {});
      initLowLimValues(t);
      initCutValues(t, g);
      updateRanks(t, g);
    }
    function updateRanks(t, g) {
      var root = t.nodes().find((v) => !g.node(v).parent);
      var vs = preorder(t, root);
      vs = vs.slice(1);
      vs.forEach((v) => {
        var parent = t.node(v).parent, edge = g.edge(v, parent), flipped = false;
        if (!edge) {
          edge = g.edge(parent, v);
          flipped = true;
        }
        g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
      });
    }
    function isTreeEdge(tree, u, v) {
      return tree.hasEdge(u, v);
    }
    function isDescendant(tree, vLabel, rootLabel) {
      return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/index.js
var require_rank = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/index.js"(exports2, module2) {
    "use strict";
    var rankUtil = require_util2();
    var longestPath = rankUtil.longestPath;
    var feasibleTree = require_feasible_tree();
    var networkSimplex = require_network_simplex();
    module2.exports = rank;
    function rank(g) {
      switch (g.graph().ranker) {
        case "network-simplex":
          networkSimplexRanker(g);
          break;
        case "tight-tree":
          tightTreeRanker(g);
          break;
        case "longest-path":
          longestPathRanker(g);
          break;
        default:
          networkSimplexRanker(g);
      }
    }
    var longestPathRanker = longestPath;
    function tightTreeRanker(g) {
      longestPath(g);
      feasibleTree(g);
    }
    function networkSimplexRanker(g) {
      networkSimplex(g);
    }
  }
});

// node_modules/@dagrejs/dagre/lib/parent-dummy-chains.js
var require_parent_dummy_chains = __commonJS({
  "node_modules/@dagrejs/dagre/lib/parent-dummy-chains.js"(exports2, module2) {
    module2.exports = parentDummyChains;
    function parentDummyChains(g) {
      let postorderNums = postorder(g);
      g.graph().dummyChains.forEach((v) => {
        let node = g.node(v);
        let edgeObj = node.edgeObj;
        let pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
        let path = pathData.path;
        let lca = pathData.lca;
        let pathIdx = 0;
        let pathV = path[pathIdx];
        let ascending = true;
        while (v !== edgeObj.w) {
          node = g.node(v);
          if (ascending) {
            while ((pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank) {
              pathIdx++;
            }
            if (pathV === lca) {
              ascending = false;
            }
          }
          if (!ascending) {
            while (pathIdx < path.length - 1 && g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
              pathIdx++;
            }
            pathV = path[pathIdx];
          }
          g.setParent(v, pathV);
          v = g.successors(v)[0];
        }
      });
    }
    function findPath(g, postorderNums, v, w2) {
      let vPath = [];
      let wPath = [];
      let low = Math.min(postorderNums[v].low, postorderNums[w2].low);
      let lim = Math.max(postorderNums[v].lim, postorderNums[w2].lim);
      let parent;
      let lca;
      parent = v;
      do {
        parent = g.parent(parent);
        vPath.push(parent);
      } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
      lca = parent;
      parent = w2;
      while ((parent = g.parent(parent)) !== lca) {
        wPath.push(parent);
      }
      return { path: vPath.concat(wPath.reverse()), lca };
    }
    function postorder(g) {
      let result2 = {};
      let lim = 0;
      function dfs(v) {
        let low = lim;
        g.children(v).forEach(dfs);
        result2[v] = { low, lim: lim++ };
      }
      g.children().forEach(dfs);
      return result2;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/nesting-graph.js
var require_nesting_graph = __commonJS({
  "node_modules/@dagrejs/dagre/lib/nesting-graph.js"(exports2, module2) {
    var util = require_util();
    module2.exports = {
      run,
      cleanup
    };
    function run(g) {
      let root = util.addDummyNode(g, "root", {}, "_root");
      let depths = treeDepths(g);
      let depthsArr = Object.values(depths);
      let height = util.applyWithChunking(Math.max, depthsArr) - 1;
      let nodeSep = 2 * height + 1;
      g.graph().nestingRoot = root;
      g.edges().forEach((e) => g.edge(e).minlen *= nodeSep);
      let weight = sumWeights(g) + 1;
      g.children().forEach((child) => dfs(g, root, nodeSep, weight, height, depths, child));
      g.graph().nodeRankFactor = nodeSep;
    }
    function dfs(g, root, nodeSep, weight, height, depths, v) {
      let children = g.children(v);
      if (!children.length) {
        if (v !== root) {
          g.setEdge(root, v, { weight: 0, minlen: nodeSep });
        }
        return;
      }
      let top = util.addBorderNode(g, "_bt");
      let bottom = util.addBorderNode(g, "_bb");
      let label = g.node(v);
      g.setParent(top, v);
      label.borderTop = top;
      g.setParent(bottom, v);
      label.borderBottom = bottom;
      children.forEach((child) => {
        dfs(g, root, nodeSep, weight, height, depths, child);
        let childNode = g.node(child);
        let childTop = childNode.borderTop ? childNode.borderTop : child;
        let childBottom = childNode.borderBottom ? childNode.borderBottom : child;
        let thisWeight = childNode.borderTop ? weight : 2 * weight;
        let minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
        g.setEdge(top, childTop, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
        g.setEdge(childBottom, bottom, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
      });
      if (!g.parent(v)) {
        g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });
      }
    }
    function treeDepths(g) {
      var depths = {};
      function dfs2(v, depth) {
        var children = g.children(v);
        if (children && children.length) {
          children.forEach((child) => dfs2(child, depth + 1));
        }
        depths[v] = depth;
      }
      g.children().forEach((v) => dfs2(v, 1));
      return depths;
    }
    function sumWeights(g) {
      return g.edges().reduce((acc, e) => acc + g.edge(e).weight, 0);
    }
    function cleanup(g) {
      var graphLabel = g.graph();
      g.removeNode(graphLabel.nestingRoot);
      delete graphLabel.nestingRoot;
      g.edges().forEach((e) => {
        var edge = g.edge(e);
        if (edge.nestingEdge) {
          g.removeEdge(e);
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/add-border-segments.js
var require_add_border_segments = __commonJS({
  "node_modules/@dagrejs/dagre/lib/add-border-segments.js"(exports2, module2) {
    var util = require_util();
    module2.exports = addBorderSegments;
    function addBorderSegments(g) {
      function dfs(v) {
        let children = g.children(v);
        let node = g.node(v);
        if (children.length) {
          children.forEach(dfs);
        }
        if (Object.hasOwn(node, "minRank")) {
          node.borderLeft = [];
          node.borderRight = [];
          for (let rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; ++rank) {
            addBorderNode(g, "borderLeft", "_bl", v, node, rank);
            addBorderNode(g, "borderRight", "_br", v, node, rank);
          }
        }
      }
      g.children().forEach(dfs);
    }
    function addBorderNode(g, prop, prefix, sg, sgNode, rank) {
      let label = { width: 0, height: 0, rank, borderType: prop };
      let prev = sgNode[prop][rank - 1];
      let curr = util.addDummyNode(g, "border", label, prefix);
      sgNode[prop][rank] = curr;
      g.setParent(curr, sg);
      if (prev) {
        g.setEdge(prev, curr, { weight: 1 });
      }
    }
  }
});

// node_modules/@dagrejs/dagre/lib/coordinate-system.js
var require_coordinate_system = __commonJS({
  "node_modules/@dagrejs/dagre/lib/coordinate-system.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      adjust,
      undo
    };
    function adjust(g) {
      let rankDir = g.graph().rankdir.toLowerCase();
      if (rankDir === "lr" || rankDir === "rl") {
        swapWidthHeight(g);
      }
    }
    function undo(g) {
      let rankDir = g.graph().rankdir.toLowerCase();
      if (rankDir === "bt" || rankDir === "rl") {
        reverseY(g);
      }
      if (rankDir === "lr" || rankDir === "rl") {
        swapXY(g);
        swapWidthHeight(g);
      }
    }
    function swapWidthHeight(g) {
      g.nodes().forEach((v) => swapWidthHeightOne(g.node(v)));
      g.edges().forEach((e) => swapWidthHeightOne(g.edge(e)));
    }
    function swapWidthHeightOne(attrs) {
      let w2 = attrs.width;
      attrs.width = attrs.height;
      attrs.height = w2;
    }
    function reverseY(g) {
      g.nodes().forEach((v) => reverseYOne(g.node(v)));
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        edge.points.forEach(reverseYOne);
        if (Object.hasOwn(edge, "y")) {
          reverseYOne(edge);
        }
      });
    }
    function reverseYOne(attrs) {
      attrs.y = -attrs.y;
    }
    function swapXY(g) {
      g.nodes().forEach((v) => swapXYOne(g.node(v)));
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        edge.points.forEach(swapXYOne);
        if (Object.hasOwn(edge, "x")) {
          swapXYOne(edge);
        }
      });
    }
    function swapXYOne(attrs) {
      let x = attrs.x;
      attrs.x = attrs.y;
      attrs.y = x;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/init-order.js
var require_init_order = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/init-order.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    module2.exports = initOrder;
    function initOrder(g) {
      let visited = {};
      let simpleNodes = g.nodes().filter((v) => !g.children(v).length);
      let simpleNodesRanks = simpleNodes.map((v) => g.node(v).rank);
      let maxRank = util.applyWithChunking(Math.max, simpleNodesRanks);
      let layers = util.range(maxRank + 1).map(() => []);
      function dfs(v) {
        if (visited[v]) return;
        visited[v] = true;
        let node = g.node(v);
        layers[node.rank].push(v);
        g.successors(v).forEach(dfs);
      }
      let orderedVs = simpleNodes.sort((a, b) => g.node(a).rank - g.node(b).rank);
      orderedVs.forEach(dfs);
      return layers;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/cross-count.js
var require_cross_count = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/cross-count.js"(exports2, module2) {
    "use strict";
    var zipObject = require_util().zipObject;
    module2.exports = crossCount;
    function crossCount(g, layering) {
      let cc = 0;
      for (let i = 1; i < layering.length; ++i) {
        cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);
      }
      return cc;
    }
    function twoLayerCrossCount(g, northLayer, southLayer) {
      let southPos = zipObject(southLayer, southLayer.map((v, i) => i));
      let southEntries = northLayer.flatMap((v) => {
        return g.outEdges(v).map((e) => {
          return { pos: southPos[e.w], weight: g.edge(e).weight };
        }).sort((a, b) => a.pos - b.pos);
      });
      let firstIndex = 1;
      while (firstIndex < southLayer.length) firstIndex <<= 1;
      let treeSize = 2 * firstIndex - 1;
      firstIndex -= 1;
      let tree = new Array(treeSize).fill(0);
      let cc = 0;
      southEntries.forEach((entry) => {
        let index = entry.pos + firstIndex;
        tree[index] += entry.weight;
        let weightSum = 0;
        while (index > 0) {
          if (index % 2) {
            weightSum += tree[index + 1];
          }
          index = index - 1 >> 1;
          tree[index] += entry.weight;
        }
        cc += entry.weight * weightSum;
      });
      return cc;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/barycenter.js
var require_barycenter = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/barycenter.js"(exports2, module2) {
    module2.exports = barycenter;
    function barycenter(g, movable = []) {
      return movable.map((v) => {
        let inV = g.inEdges(v);
        if (!inV.length) {
          return { v };
        } else {
          let result2 = inV.reduce((acc, e) => {
            let edge = g.edge(e), nodeU = g.node(e.v);
            return {
              sum: acc.sum + edge.weight * nodeU.order,
              weight: acc.weight + edge.weight
            };
          }, { sum: 0, weight: 0 });
          return {
            v,
            barycenter: result2.sum / result2.weight,
            weight: result2.weight
          };
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/resolve-conflicts.js
var require_resolve_conflicts = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/resolve-conflicts.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    module2.exports = resolveConflicts;
    function resolveConflicts(entries, cg) {
      let mappedEntries = {};
      entries.forEach((entry, i) => {
        let tmp = mappedEntries[entry.v] = {
          indegree: 0,
          "in": [],
          out: [],
          vs: [entry.v],
          i
        };
        if (entry.barycenter !== void 0) {
          tmp.barycenter = entry.barycenter;
          tmp.weight = entry.weight;
        }
      });
      cg.edges().forEach((e) => {
        let entryV = mappedEntries[e.v];
        let entryW = mappedEntries[e.w];
        if (entryV !== void 0 && entryW !== void 0) {
          entryW.indegree++;
          entryV.out.push(mappedEntries[e.w]);
        }
      });
      let sourceSet = Object.values(mappedEntries).filter((entry) => !entry.indegree);
      return doResolveConflicts(sourceSet);
    }
    function doResolveConflicts(sourceSet) {
      let entries = [];
      function handleIn(vEntry) {
        return (uEntry) => {
          if (uEntry.merged) {
            return;
          }
          if (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) {
            mergeEntries(vEntry, uEntry);
          }
        };
      }
      function handleOut(vEntry) {
        return (wEntry) => {
          wEntry["in"].push(vEntry);
          if (--wEntry.indegree === 0) {
            sourceSet.push(wEntry);
          }
        };
      }
      while (sourceSet.length) {
        let entry = sourceSet.pop();
        entries.push(entry);
        entry["in"].reverse().forEach(handleIn(entry));
        entry.out.forEach(handleOut(entry));
      }
      return entries.filter((entry) => !entry.merged).map((entry) => {
        return util.pick(entry, ["vs", "i", "barycenter", "weight"]);
      });
    }
    function mergeEntries(target, source) {
      let sum = 0;
      let weight = 0;
      if (target.weight) {
        sum += target.barycenter * target.weight;
        weight += target.weight;
      }
      if (source.weight) {
        sum += source.barycenter * source.weight;
        weight += source.weight;
      }
      target.vs = source.vs.concat(target.vs);
      target.barycenter = sum / weight;
      target.weight = weight;
      target.i = Math.min(source.i, target.i);
      source.merged = true;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/sort.js
var require_sort = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/sort.js"(exports2, module2) {
    var util = require_util();
    module2.exports = sort;
    function sort(entries, biasRight) {
      let parts = util.partition(entries, (entry) => {
        return Object.hasOwn(entry, "barycenter");
      });
      let sortable = parts.lhs, unsortable = parts.rhs.sort((a, b) => b.i - a.i), vs = [], sum = 0, weight = 0, vsIndex = 0;
      sortable.sort(compareWithBias(!!biasRight));
      vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      sortable.forEach((entry) => {
        vsIndex += entry.vs.length;
        vs.push(entry.vs);
        sum += entry.barycenter * entry.weight;
        weight += entry.weight;
        vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      });
      let result2 = { vs: vs.flat(true) };
      if (weight) {
        result2.barycenter = sum / weight;
        result2.weight = weight;
      }
      return result2;
    }
    function consumeUnsortable(vs, unsortable, index) {
      let last;
      while (unsortable.length && (last = unsortable[unsortable.length - 1]).i <= index) {
        unsortable.pop();
        vs.push(last.vs);
        index++;
      }
      return index;
    }
    function compareWithBias(bias) {
      return (entryV, entryW) => {
        if (entryV.barycenter < entryW.barycenter) {
          return -1;
        } else if (entryV.barycenter > entryW.barycenter) {
          return 1;
        }
        return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
      };
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/sort-subgraph.js
var require_sort_subgraph = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/sort-subgraph.js"(exports2, module2) {
    var barycenter = require_barycenter();
    var resolveConflicts = require_resolve_conflicts();
    var sort = require_sort();
    module2.exports = sortSubgraph;
    function sortSubgraph(g, v, cg, biasRight) {
      let movable = g.children(v);
      let node = g.node(v);
      let bl = node ? node.borderLeft : void 0;
      let br = node ? node.borderRight : void 0;
      let subgraphs = {};
      if (bl) {
        movable = movable.filter((w2) => w2 !== bl && w2 !== br);
      }
      let barycenters = barycenter(g, movable);
      barycenters.forEach((entry) => {
        if (g.children(entry.v).length) {
          let subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
          subgraphs[entry.v] = subgraphResult;
          if (Object.hasOwn(subgraphResult, "barycenter")) {
            mergeBarycenters(entry, subgraphResult);
          }
        }
      });
      let entries = resolveConflicts(barycenters, cg);
      expandSubgraphs(entries, subgraphs);
      let result2 = sort(entries, biasRight);
      if (bl) {
        result2.vs = [bl, result2.vs, br].flat(true);
        if (g.predecessors(bl).length) {
          let blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
          if (!Object.hasOwn(result2, "barycenter")) {
            result2.barycenter = 0;
            result2.weight = 0;
          }
          result2.barycenter = (result2.barycenter * result2.weight + blPred.order + brPred.order) / (result2.weight + 2);
          result2.weight += 2;
        }
      }
      return result2;
    }
    function expandSubgraphs(entries, subgraphs) {
      entries.forEach((entry) => {
        entry.vs = entry.vs.flatMap((v) => {
          if (subgraphs[v]) {
            return subgraphs[v].vs;
          }
          return v;
        });
      });
    }
    function mergeBarycenters(target, other) {
      if (target.barycenter !== void 0) {
        target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
        target.weight += other.weight;
      } else {
        target.barycenter = other.barycenter;
        target.weight = other.weight;
      }
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/build-layer-graph.js
var require_build_layer_graph = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/build-layer-graph.js"(exports2, module2) {
    var Graph = require_graphlib().Graph;
    var util = require_util();
    module2.exports = buildLayerGraph;
    function buildLayerGraph(g, rank, relationship) {
      let root = createRootNode(g), result2 = new Graph({ compound: true }).setGraph({ root }).setDefaultNodeLabel((v) => g.node(v));
      g.nodes().forEach((v) => {
        let node = g.node(v), parent = g.parent(v);
        if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
          result2.setNode(v);
          result2.setParent(v, parent || root);
          g[relationship](v).forEach((e) => {
            let u = e.v === v ? e.w : e.v, edge = result2.edge(u, v), weight = edge !== void 0 ? edge.weight : 0;
            result2.setEdge(u, v, { weight: g.edge(e).weight + weight });
          });
          if (Object.hasOwn(node, "minRank")) {
            result2.setNode(v, {
              borderLeft: node.borderLeft[rank],
              borderRight: node.borderRight[rank]
            });
          }
        }
      });
      return result2;
    }
    function createRootNode(g) {
      var v;
      while (g.hasNode(v = util.uniqueId("_root"))) ;
      return v;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/add-subgraph-constraints.js
var require_add_subgraph_constraints = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/add-subgraph-constraints.js"(exports2, module2) {
    module2.exports = addSubgraphConstraints;
    function addSubgraphConstraints(g, cg, vs) {
      let prev = {}, rootPrev;
      vs.forEach((v) => {
        let child = g.parent(v), parent, prevChild;
        while (child) {
          parent = g.parent(child);
          if (parent) {
            prevChild = prev[parent];
            prev[parent] = child;
          } else {
            prevChild = rootPrev;
            rootPrev = child;
          }
          if (prevChild && prevChild !== child) {
            cg.setEdge(prevChild, child);
            return;
          }
          child = parent;
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/index.js
var require_order = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/index.js"(exports2, module2) {
    "use strict";
    var initOrder = require_init_order();
    var crossCount = require_cross_count();
    var sortSubgraph = require_sort_subgraph();
    var buildLayerGraph = require_build_layer_graph();
    var addSubgraphConstraints = require_add_subgraph_constraints();
    var Graph = require_graphlib().Graph;
    var util = require_util();
    module2.exports = order;
    function order(g, opts2) {
      if (opts2 && typeof opts2.customOrder === "function") {
        opts2.customOrder(g, order);
        return;
      }
      let maxRank = util.maxRank(g), downLayerGraphs = buildLayerGraphs(g, util.range(1, maxRank + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g, util.range(maxRank - 1, -1, -1), "outEdges");
      let layering = initOrder(g);
      assignOrder(g, layering);
      if (opts2 && opts2.disableOptimalOrderHeuristic) {
        return;
      }
      let bestCC = Number.POSITIVE_INFINITY, best;
      for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
        sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
        layering = util.buildLayerMatrix(g);
        let cc = crossCount(g, layering);
        if (cc < bestCC) {
          lastBest = 0;
          best = Object.assign({}, layering);
          bestCC = cc;
        }
      }
      assignOrder(g, best);
    }
    function buildLayerGraphs(g, ranks, relationship) {
      return ranks.map(function(rank) {
        return buildLayerGraph(g, rank, relationship);
      });
    }
    function sweepLayerGraphs(layerGraphs, biasRight) {
      let cg = new Graph();
      layerGraphs.forEach(function(lg) {
        let root = lg.graph().root;
        let sorted = sortSubgraph(lg, root, cg, biasRight);
        sorted.vs.forEach((v, i) => lg.node(v).order = i);
        addSubgraphConstraints(lg, cg, sorted.vs);
      });
    }
    function assignOrder(g, layering) {
      Object.values(layering).forEach((layer) => layer.forEach((v, i) => g.node(v).order = i));
    }
  }
});

// node_modules/@dagrejs/dagre/lib/position/bk.js
var require_bk = __commonJS({
  "node_modules/@dagrejs/dagre/lib/position/bk.js"(exports2, module2) {
    "use strict";
    var Graph = require_graphlib().Graph;
    var util = require_util();
    module2.exports = {
      positionX,
      findType1Conflicts,
      findType2Conflicts,
      addConflict,
      hasConflict,
      verticalAlignment,
      horizontalCompaction,
      alignCoordinates,
      findSmallestWidthAlignment,
      balance
    };
    function findType1Conflicts(g, layering) {
      let conflicts = {};
      function visitLayer(prevLayer, layer) {
        let k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = layer[layer.length - 1];
        layer.forEach((v, i) => {
          let w2 = findOtherInnerSegmentNode(g, v), k1 = w2 ? g.node(w2).order : prevLayerLength;
          if (w2 || v === lastNode) {
            layer.slice(scanPos, i + 1).forEach((scanNode) => {
              g.predecessors(scanNode).forEach((u) => {
                let uLabel = g.node(u), uPos = uLabel.order;
                if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {
                  addConflict(conflicts, u, scanNode);
                }
              });
            });
            scanPos = i + 1;
            k0 = k1;
          }
        });
        return layer;
      }
      layering.length && layering.reduce(visitLayer);
      return conflicts;
    }
    function findType2Conflicts(g, layering) {
      let conflicts = {};
      function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
        let v;
        util.range(southPos, southEnd).forEach((i) => {
          v = south[i];
          if (g.node(v).dummy) {
            g.predecessors(v).forEach((u) => {
              let uNode = g.node(u);
              if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
                addConflict(conflicts, u, v);
              }
            });
          }
        });
      }
      function visitLayer(north, south) {
        let prevNorthPos = -1, nextNorthPos, southPos = 0;
        south.forEach((v, southLookahead) => {
          if (g.node(v).dummy === "border") {
            let predecessors = g.predecessors(v);
            if (predecessors.length) {
              nextNorthPos = g.node(predecessors[0]).order;
              scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
              southPos = southLookahead;
              prevNorthPos = nextNorthPos;
            }
          }
          scan(south, southPos, south.length, nextNorthPos, north.length);
        });
        return south;
      }
      layering.length && layering.reduce(visitLayer);
      return conflicts;
    }
    function findOtherInnerSegmentNode(g, v) {
      if (g.node(v).dummy) {
        return g.predecessors(v).find((u) => g.node(u).dummy);
      }
    }
    function addConflict(conflicts, v, w2) {
      if (v > w2) {
        let tmp = v;
        v = w2;
        w2 = tmp;
      }
      let conflictsV = conflicts[v];
      if (!conflictsV) {
        conflicts[v] = conflictsV = {};
      }
      conflictsV[w2] = true;
    }
    function hasConflict(conflicts, v, w2) {
      if (v > w2) {
        let tmp = v;
        v = w2;
        w2 = tmp;
      }
      return !!conflicts[v] && Object.hasOwn(conflicts[v], w2);
    }
    function verticalAlignment(g, layering, conflicts, neighborFn) {
      let root = {}, align = {}, pos = {};
      layering.forEach((layer) => {
        layer.forEach((v, order) => {
          root[v] = v;
          align[v] = v;
          pos[v] = order;
        });
      });
      layering.forEach((layer) => {
        let prevIdx = -1;
        layer.forEach((v) => {
          let ws = neighborFn(v);
          if (ws.length) {
            ws = ws.sort((a, b) => pos[a] - pos[b]);
            let mp = (ws.length - 1) / 2;
            for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
              let w2 = ws[i];
              if (align[v] === v && prevIdx < pos[w2] && !hasConflict(conflicts, v, w2)) {
                align[w2] = v;
                align[v] = root[v] = root[w2];
                prevIdx = pos[w2];
              }
            }
          }
        });
      });
      return { root, align };
    }
    function horizontalCompaction(g, layering, root, align, reverseSep) {
      let xs = {}, blockG = buildBlockGraph(g, layering, root, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
      function iterate(setXsFunc, nextNodesFunc) {
        let stack = blockG.nodes();
        let elem = stack.pop();
        let visited = {};
        while (elem) {
          if (visited[elem]) {
            setXsFunc(elem);
          } else {
            visited[elem] = true;
            stack.push(elem);
            stack = stack.concat(nextNodesFunc(elem));
          }
          elem = stack.pop();
        }
      }
      function pass1(elem) {
        xs[elem] = blockG.inEdges(elem).reduce((acc, e) => {
          return Math.max(acc, xs[e.v] + blockG.edge(e));
        }, 0);
      }
      function pass2(elem) {
        let min = blockG.outEdges(elem).reduce((acc, e) => {
          return Math.min(acc, xs[e.w] - blockG.edge(e));
        }, Number.POSITIVE_INFINITY);
        let node = g.node(elem);
        if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
          xs[elem] = Math.max(xs[elem], min);
        }
      }
      iterate(pass1, blockG.predecessors.bind(blockG));
      iterate(pass2, blockG.successors.bind(blockG));
      Object.keys(align).forEach((v) => xs[v] = xs[root[v]]);
      return xs;
    }
    function buildBlockGraph(g, layering, root, reverseSep) {
      let blockGraph = new Graph(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
      layering.forEach((layer) => {
        let u;
        layer.forEach((v) => {
          let vRoot = root[v];
          blockGraph.setNode(vRoot);
          if (u) {
            var uRoot = root[u], prevMax = blockGraph.edge(uRoot, vRoot);
            blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
          }
          u = v;
        });
      });
      return blockGraph;
    }
    function findSmallestWidthAlignment(g, xss) {
      return Object.values(xss).reduce((currentMinAndXs, xs) => {
        let max = Number.NEGATIVE_INFINITY;
        let min = Number.POSITIVE_INFINITY;
        Object.entries(xs).forEach(([v, x]) => {
          let halfWidth = width(g, v) / 2;
          max = Math.max(x + halfWidth, max);
          min = Math.min(x - halfWidth, min);
        });
        const newMin = max - min;
        if (newMin < currentMinAndXs[0]) {
          currentMinAndXs = [newMin, xs];
        }
        return currentMinAndXs;
      }, [Number.POSITIVE_INFINITY, null])[1];
    }
    function alignCoordinates(xss, alignTo) {
      let alignToVals = Object.values(alignTo), alignToMin = util.applyWithChunking(Math.min, alignToVals), alignToMax = util.applyWithChunking(Math.max, alignToVals);
      ["u", "d"].forEach((vert) => {
        ["l", "r"].forEach((horiz) => {
          let alignment = vert + horiz, xs = xss[alignment];
          if (xs === alignTo) return;
          let xsVals = Object.values(xs);
          let delta = alignToMin - util.applyWithChunking(Math.min, xsVals);
          if (horiz !== "l") {
            delta = alignToMax - util.applyWithChunking(Math.max, xsVals);
          }
          if (delta) {
            xss[alignment] = util.mapValues(xs, (x) => x + delta);
          }
        });
      });
    }
    function balance(xss, align) {
      return util.mapValues(xss.ul, (num, v) => {
        if (align) {
          return xss[align.toLowerCase()][v];
        } else {
          let xs = Object.values(xss).map((xs2) => xs2[v]).sort((a, b) => a - b);
          return (xs[1] + xs[2]) / 2;
        }
      });
    }
    function positionX(g) {
      let layering = util.buildLayerMatrix(g);
      let conflicts = Object.assign(
        findType1Conflicts(g, layering),
        findType2Conflicts(g, layering)
      );
      let xss = {};
      let adjustedLayering;
      ["u", "d"].forEach((vert) => {
        adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
        ["l", "r"].forEach((horiz) => {
          if (horiz === "r") {
            adjustedLayering = adjustedLayering.map((inner) => {
              return Object.values(inner).reverse();
            });
          }
          let neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
          let align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
          let xs = horizontalCompaction(
            g,
            adjustedLayering,
            align.root,
            align.align,
            horiz === "r"
          );
          if (horiz === "r") {
            xs = util.mapValues(xs, (x) => -x);
          }
          xss[vert + horiz] = xs;
        });
      });
      let smallestWidth = findSmallestWidthAlignment(g, xss);
      alignCoordinates(xss, smallestWidth);
      return balance(xss, g.graph().align);
    }
    function sep(nodeSep, edgeSep, reverseSep) {
      return (g, v, w2) => {
        let vLabel = g.node(v);
        let wLabel = g.node(w2);
        let sum = 0;
        let delta;
        sum += vLabel.width / 2;
        if (Object.hasOwn(vLabel, "labelpos")) {
          switch (vLabel.labelpos.toLowerCase()) {
            case "l":
              delta = -vLabel.width / 2;
              break;
            case "r":
              delta = vLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += wLabel.width / 2;
        if (Object.hasOwn(wLabel, "labelpos")) {
          switch (wLabel.labelpos.toLowerCase()) {
            case "l":
              delta = wLabel.width / 2;
              break;
            case "r":
              delta = -wLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        return sum;
      };
    }
    function width(g, v) {
      return g.node(v).width;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/position/index.js
var require_position = __commonJS({
  "node_modules/@dagrejs/dagre/lib/position/index.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var positionX = require_bk().positionX;
    module2.exports = position;
    function position(g) {
      g = util.asNonCompoundGraph(g);
      positionY(g);
      Object.entries(positionX(g)).forEach(([v, x]) => g.node(v).x = x);
    }
    function positionY(g) {
      let layering = util.buildLayerMatrix(g);
      let rankSep = g.graph().ranksep;
      let prevY = 0;
      layering.forEach((layer) => {
        const maxHeight = layer.reduce((acc, v) => {
          const height = g.node(v).height;
          if (acc > height) {
            return acc;
          } else {
            return height;
          }
        }, 0);
        layer.forEach((v) => g.node(v).y = prevY + maxHeight / 2);
        prevY += maxHeight + rankSep;
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/layout.js
var require_layout = __commonJS({
  "node_modules/@dagrejs/dagre/lib/layout.js"(exports2, module2) {
    "use strict";
    var acyclic = require_acyclic();
    var normalize = require_normalize();
    var rank = require_rank();
    var normalizeRanks = require_util().normalizeRanks;
    var parentDummyChains = require_parent_dummy_chains();
    var removeEmptyRanks = require_util().removeEmptyRanks;
    var nestingGraph = require_nesting_graph();
    var addBorderSegments = require_add_border_segments();
    var coordinateSystem = require_coordinate_system();
    var order = require_order();
    var position = require_position();
    var util = require_util();
    var Graph = require_graphlib().Graph;
    module2.exports = layout;
    function layout(g, opts2) {
      let time = opts2 && opts2.debugTiming ? util.time : util.notime;
      time("layout", () => {
        let layoutGraph = time("  buildLayoutGraph", () => buildLayoutGraph(g));
        time("  runLayout", () => runLayout(layoutGraph, time, opts2));
        time("  updateInputGraph", () => updateInputGraph(g, layoutGraph));
      });
    }
    function runLayout(g, time, opts2) {
      time("    makeSpaceForEdgeLabels", () => makeSpaceForEdgeLabels(g));
      time("    removeSelfEdges", () => removeSelfEdges(g));
      time("    acyclic", () => acyclic.run(g));
      time("    nestingGraph.run", () => nestingGraph.run(g));
      time("    rank", () => rank(util.asNonCompoundGraph(g)));
      time("    injectEdgeLabelProxies", () => injectEdgeLabelProxies(g));
      time("    removeEmptyRanks", () => removeEmptyRanks(g));
      time("    nestingGraph.cleanup", () => nestingGraph.cleanup(g));
      time("    normalizeRanks", () => normalizeRanks(g));
      time("    assignRankMinMax", () => assignRankMinMax(g));
      time("    removeEdgeLabelProxies", () => removeEdgeLabelProxies(g));
      time("    normalize.run", () => normalize.run(g));
      time("    parentDummyChains", () => parentDummyChains(g));
      time("    addBorderSegments", () => addBorderSegments(g));
      time("    order", () => order(g, opts2));
      time("    insertSelfEdges", () => insertSelfEdges(g));
      time("    adjustCoordinateSystem", () => coordinateSystem.adjust(g));
      time("    position", () => position(g));
      time("    positionSelfEdges", () => positionSelfEdges(g));
      time("    removeBorderNodes", () => removeBorderNodes(g));
      time("    normalize.undo", () => normalize.undo(g));
      time("    fixupEdgeLabelCoords", () => fixupEdgeLabelCoords(g));
      time("    undoCoordinateSystem", () => coordinateSystem.undo(g));
      time("    translateGraph", () => translateGraph(g));
      time("    assignNodeIntersects", () => assignNodeIntersects(g));
      time("    reversePoints", () => reversePointsForReversedEdges(g));
      time("    acyclic.undo", () => acyclic.undo(g));
    }
    function updateInputGraph(inputGraph, layoutGraph) {
      inputGraph.nodes().forEach((v) => {
        let inputLabel = inputGraph.node(v);
        let layoutLabel = layoutGraph.node(v);
        if (inputLabel) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
          inputLabel.rank = layoutLabel.rank;
          if (layoutGraph.children(v).length) {
            inputLabel.width = layoutLabel.width;
            inputLabel.height = layoutLabel.height;
          }
        }
      });
      inputGraph.edges().forEach((e) => {
        let inputLabel = inputGraph.edge(e);
        let layoutLabel = layoutGraph.edge(e);
        inputLabel.points = layoutLabel.points;
        if (Object.hasOwn(layoutLabel, "x")) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
        }
      });
      inputGraph.graph().width = layoutGraph.graph().width;
      inputGraph.graph().height = layoutGraph.graph().height;
    }
    var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
    var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
    var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
    var nodeNumAttrs = ["width", "height"];
    var nodeDefaults = { width: 0, height: 0 };
    var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
    var edgeDefaults = {
      minlen: 1,
      weight: 1,
      width: 0,
      height: 0,
      labeloffset: 10,
      labelpos: "r"
    };
    var edgeAttrs = ["labelpos"];
    function buildLayoutGraph(inputGraph) {
      let g = new Graph({ multigraph: true, compound: true });
      let graph = canonicalize(inputGraph.graph());
      g.setGraph(Object.assign(
        {},
        graphDefaults,
        selectNumberAttrs(graph, graphNumAttrs),
        util.pick(graph, graphAttrs)
      ));
      inputGraph.nodes().forEach((v) => {
        let node = canonicalize(inputGraph.node(v));
        const newNode = selectNumberAttrs(node, nodeNumAttrs);
        Object.keys(nodeDefaults).forEach((k) => {
          if (newNode[k] === void 0) {
            newNode[k] = nodeDefaults[k];
          }
        });
        g.setNode(v, newNode);
        g.setParent(v, inputGraph.parent(v));
      });
      inputGraph.edges().forEach((e) => {
        let edge = canonicalize(inputGraph.edge(e));
        g.setEdge(e, Object.assign(
          {},
          edgeDefaults,
          selectNumberAttrs(edge, edgeNumAttrs),
          util.pick(edge, edgeAttrs)
        ));
      });
      return g;
    }
    function makeSpaceForEdgeLabels(g) {
      let graph = g.graph();
      graph.ranksep /= 2;
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        edge.minlen *= 2;
        if (edge.labelpos.toLowerCase() !== "c") {
          if (graph.rankdir === "TB" || graph.rankdir === "BT") {
            edge.width += edge.labeloffset;
          } else {
            edge.height += edge.labeloffset;
          }
        }
      });
    }
    function injectEdgeLabelProxies(g) {
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        if (edge.width && edge.height) {
          let v = g.node(e.v);
          let w2 = g.node(e.w);
          let label = { rank: (w2.rank - v.rank) / 2 + v.rank, e };
          util.addDummyNode(g, "edge-proxy", label, "_ep");
        }
      });
    }
    function assignRankMinMax(g) {
      let maxRank = 0;
      g.nodes().forEach((v) => {
        let node = g.node(v);
        if (node.borderTop) {
          node.minRank = g.node(node.borderTop).rank;
          node.maxRank = g.node(node.borderBottom).rank;
          maxRank = Math.max(maxRank, node.maxRank);
        }
      });
      g.graph().maxRank = maxRank;
    }
    function removeEdgeLabelProxies(g) {
      g.nodes().forEach((v) => {
        let node = g.node(v);
        if (node.dummy === "edge-proxy") {
          g.edge(node.e).labelRank = node.rank;
          g.removeNode(v);
        }
      });
    }
    function translateGraph(g) {
      let minX = Number.POSITIVE_INFINITY;
      let maxX = 0;
      let minY = Number.POSITIVE_INFINITY;
      let maxY = 0;
      let graphLabel = g.graph();
      let marginX = graphLabel.marginx || 0;
      let marginY = graphLabel.marginy || 0;
      function getExtremes(attrs) {
        let x = attrs.x;
        let y = attrs.y;
        let w2 = attrs.width;
        let h2 = attrs.height;
        minX = Math.min(minX, x - w2 / 2);
        maxX = Math.max(maxX, x + w2 / 2);
        minY = Math.min(minY, y - h2 / 2);
        maxY = Math.max(maxY, y + h2 / 2);
      }
      g.nodes().forEach((v) => getExtremes(g.node(v)));
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        if (Object.hasOwn(edge, "x")) {
          getExtremes(edge);
        }
      });
      minX -= marginX;
      minY -= marginY;
      g.nodes().forEach((v) => {
        let node = g.node(v);
        node.x -= minX;
        node.y -= minY;
      });
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        edge.points.forEach((p) => {
          p.x -= minX;
          p.y -= minY;
        });
        if (Object.hasOwn(edge, "x")) {
          edge.x -= minX;
        }
        if (Object.hasOwn(edge, "y")) {
          edge.y -= minY;
        }
      });
      graphLabel.width = maxX - minX + marginX;
      graphLabel.height = maxY - minY + marginY;
    }
    function assignNodeIntersects(g) {
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        let nodeV = g.node(e.v);
        let nodeW = g.node(e.w);
        let p1, p2;
        if (!edge.points) {
          edge.points = [];
          p1 = nodeW;
          p2 = nodeV;
        } else {
          p1 = edge.points[0];
          p2 = edge.points[edge.points.length - 1];
        }
        edge.points.unshift(util.intersectRect(nodeV, p1));
        edge.points.push(util.intersectRect(nodeW, p2));
      });
    }
    function fixupEdgeLabelCoords(g) {
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        if (Object.hasOwn(edge, "x")) {
          if (edge.labelpos === "l" || edge.labelpos === "r") {
            edge.width -= edge.labeloffset;
          }
          switch (edge.labelpos) {
            case "l":
              edge.x -= edge.width / 2 + edge.labeloffset;
              break;
            case "r":
              edge.x += edge.width / 2 + edge.labeloffset;
              break;
          }
        }
      });
    }
    function reversePointsForReversedEdges(g) {
      g.edges().forEach((e) => {
        let edge = g.edge(e);
        if (edge.reversed) {
          edge.points.reverse();
        }
      });
    }
    function removeBorderNodes(g) {
      g.nodes().forEach((v) => {
        if (g.children(v).length) {
          let node = g.node(v);
          let t = g.node(node.borderTop);
          let b = g.node(node.borderBottom);
          let l = g.node(node.borderLeft[node.borderLeft.length - 1]);
          let r = g.node(node.borderRight[node.borderRight.length - 1]);
          node.width = Math.abs(r.x - l.x);
          node.height = Math.abs(b.y - t.y);
          node.x = l.x + node.width / 2;
          node.y = t.y + node.height / 2;
        }
      });
      g.nodes().forEach((v) => {
        if (g.node(v).dummy === "border") {
          g.removeNode(v);
        }
      });
    }
    function removeSelfEdges(g) {
      g.edges().forEach((e) => {
        if (e.v === e.w) {
          var node = g.node(e.v);
          if (!node.selfEdges) {
            node.selfEdges = [];
          }
          node.selfEdges.push({ e, label: g.edge(e) });
          g.removeEdge(e);
        }
      });
    }
    function insertSelfEdges(g) {
      var layers = util.buildLayerMatrix(g);
      layers.forEach((layer) => {
        var orderShift = 0;
        layer.forEach((v, i) => {
          var node = g.node(v);
          node.order = i + orderShift;
          (node.selfEdges || []).forEach((selfEdge) => {
            util.addDummyNode(g, "selfedge", {
              width: selfEdge.label.width,
              height: selfEdge.label.height,
              rank: node.rank,
              order: i + ++orderShift,
              e: selfEdge.e,
              label: selfEdge.label
            }, "_se");
          });
          delete node.selfEdges;
        });
      });
    }
    function positionSelfEdges(g) {
      g.nodes().forEach((v) => {
        var node = g.node(v);
        if (node.dummy === "selfedge") {
          var selfNode = g.node(node.e.v);
          var x = selfNode.x + selfNode.width / 2;
          var y = selfNode.y;
          var dx = node.x - x;
          var dy = selfNode.height / 2;
          g.setEdge(node.e, node.label);
          g.removeNode(v);
          node.label.points = [
            { x: x + 2 * dx / 3, y: y - dy },
            { x: x + 5 * dx / 6, y: y - dy },
            { x: x + dx, y },
            { x: x + 5 * dx / 6, y: y + dy },
            { x: x + 2 * dx / 3, y: y + dy }
          ];
          node.label.x = node.x;
          node.label.y = node.y;
        }
      });
    }
    function selectNumberAttrs(obj, attrs) {
      return util.mapValues(util.pick(obj, attrs), Number);
    }
    function canonicalize(attrs) {
      var newAttrs = {};
      if (attrs) {
        Object.entries(attrs).forEach(([k, v]) => {
          if (typeof k === "string") {
            k = k.toLowerCase();
          }
          newAttrs[k] = v;
        });
      }
      return newAttrs;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/debug.js
var require_debug = __commonJS({
  "node_modules/@dagrejs/dagre/lib/debug.js"(exports2, module2) {
    var util = require_util();
    var Graph = require_graphlib().Graph;
    module2.exports = {
      debugOrdering
    };
    function debugOrdering(g) {
      let layerMatrix = util.buildLayerMatrix(g);
      let h2 = new Graph({ compound: true, multigraph: true }).setGraph({});
      g.nodes().forEach((v) => {
        h2.setNode(v, { label: v });
        h2.setParent(v, "layer" + g.node(v).rank);
      });
      g.edges().forEach((e) => h2.setEdge(e.v, e.w, {}, e.name));
      layerMatrix.forEach((layer, i) => {
        let layerV = "layer" + i;
        h2.setNode(layerV, { rank: "same" });
        layer.reduce((u, v) => {
          h2.setEdge(u, v, { style: "invis" });
          return v;
        });
      });
      return h2;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/version.js
var require_version2 = __commonJS({
  "node_modules/@dagrejs/dagre/lib/version.js"(exports2, module2) {
    module2.exports = "1.1.4";
  }
});

// node_modules/@dagrejs/dagre/index.js
var require_dagre = __commonJS({
  "node_modules/@dagrejs/dagre/index.js"(exports2, module2) {
    module2.exports = {
      graphlib: require_graphlib(),
      layout: require_layout(),
      debug: require_debug(),
      util: {
        time: require_util().time,
        notime: require_util().notime
      },
      version: require_version2()
    };
  }
});

// src/ts/index.ts
var ts_exports = {};
__export(ts_exports, {
  OnAction: () => OnAction,
  SchemaDesigner: () => SchemaDesigner,
  SchemaDesignerTable: () => SchemaDesignerTable,
  SchemaDesignerToolbar: () => SchemaDesignerToolbar,
  extendedConnectionHandler: () => extendedConnectionHandler,
  mx: () => import_mxgraph2.default,
  mxGraphFactory: () => mxGraphFactory
});
var import_mxgraph2 = __toESM(require_build());

// src/ts/mx.ts
var import_mxgraph = __toESM(require_build());
window.mxLoadResources = false;
window.mxForceIncludes = false;
window.mxLoadStylesheets = false;
window.mxResourceExtension = ".txt";
var mxGraphFactory = (0, import_mxgraph.default)({});

// src/ts/index.ts
__reExport(ts_exports, __toESM(require_build()));

// src/ts/schemaDesigner/schemaDesignerInterfaces.ts
var OnAction = /* @__PURE__ */ ((OnAction2) => {
  OnAction2["CASCADE"] = "0";
  OnAction2["NO_ACTION"] = "1";
  OnAction2["SET_NULL"] = "2";
  OnAction2["SET_DEFAULT"] = "3";
  return OnAction2;
})(OnAction || {});
var extendedConnectionHandler = class extends mxGraphFactory.mxConnectionHandler {
  constructor() {
    super(...arguments);
    this.currentRow = 0;
  }
};

// src/ts/schemaDesigner/schemaDesignerToolbar.ts
var SchemaDesignerToolbar = class {
  constructor(_container, _graph, _config) {
    this._container = _container;
    this._graph = _graph;
    this._config = _config;
    this.buttons = /* @__PURE__ */ new Map();
    this._toolbarDiv = document.createElement("div");
    this._container.appendChild(this._toolbarDiv);
    this._toolbarDiv.classList.add("sd-toolbar");
    this._toolbarDiv.style.color = this._config.colors.toolbarForeground;
  }
  addButton(icon, title, callback, onDragEndCallback) {
    const button = document.createElement("div");
    this._toolbarDiv.appendChild(button);
    button.classList.add("sd-toolbar-button");
    button.innerHTML = icon;
    button.onclick = () => {
      if (!this.isButtonDisabled(title)) {
        callback();
      }
    };
    button.title = title;
    if (onDragEndCallback) {
      const dragImage = button.cloneNode(true);
      dragImage.style.backgroundColor = this._config.colors.toolbarBackground;
      const ds = mxGraphFactory.mxUtils.makeDraggable(
        button,
        this._graph,
        onDragEndCallback,
        dragImage
      );
      ds.highlightDropTargets = true;
    }
    this.buttons.set(title, button);
  }
  disableButton(title) {
    this.buttons.get(title)?.classList.add("sd-toolbar-button-disabled");
  }
  enableButton(title) {
    this.buttons.get(title)?.classList.remove("sd-toolbar-button-disabled");
  }
  isButtonDisabled(title) {
    return this.buttons.get(title)?.classList.contains("sd-toolbar-button-disabled");
  }
  addDivider() {
    const divider = document.createElement("div");
    this._toolbarDiv.appendChild(divider);
    divider.classList.add("sd-toolbar-divider");
  }
};

// src/ts/schemaDesigner/utils.ts
function getRowY(state, column) {
  const s = state.view.scale;
  if (!column) {
    return state.y;
  }
  const div = column.parentNode;
  let y = state.y + (column.offsetTop - div.scrollTop + column.offsetHeight / 2) * s;
  if (div.scrollTop > column.offsetTop) {
    y = state.y + (div.offsetTop - 15) * s;
  }
  if (y > state.y + div.offsetTop * s + div.clientHeight * s) {
    y = state.y + (div.offsetTop + div.clientHeight - 5) * s;
  }
  return y;
}

// src/ts/schemaDesigner/schemaDesignerEntity.ts
var SchemaDesignerTable = class {
  /**
   * Creates a new instance of the SchemaDesignerEntity class
   * @param entity entity to be rendered
   * @param config schema designer configuration
   * @param mxGraph mxGraph instance
   * @param schemaDesigner schema designer instance
   */
  constructor(entity, schemaDesigner) {
    this.schemaDesigner = schemaDesigner;
    this.eventListeners = [];
    /**
     * The foreign keys of the table
     */
    this.foreignKeys = [];
    /**
     * Opacity of the table
     * @default 1
     */
    this.opacity = 1;
    /**
     * Indicates if the table is visible
     */
    this.isVisible = true;
    this.id = entity.id;
    this.name = entity.name;
    this.schema = entity.schema;
    this.columns = entity.columns;
    this.foreignKeys = [];
    this.editor = false;
  }
  /**
   * Renders the entity
   * @returns the rendered entity
   */
  render() {
    this.removeEventListeners();
    return this.renderTableDiv();
  }
  /**
   * Sets up the entity DOM
   * @param parentNode node to be set up
   * @param state state of the node
   */
  setupEntityDOM(parentNode, state) {
    const columnsDiv = parentNode.getElementsByClassName("sd-table-columns")[0];
    if (columnsDiv !== void 0 && columnsDiv !== null) {
      if (columnsDiv.getAttribute("scrollHandler") === null) {
        columnsDiv.setAttribute("scrollHandler", "true");
        const updateEdges = mxGraphFactory.mxUtils.bind(this, () => {
          this.mxGraph.clearSelection();
          const edgeCount = this.mxModel.getEdgeCount(state.cell);
          for (let i = 0; i < edgeCount; i++) {
            const edge = this.mxModel.getEdgeAt(state.cell, i);
            this.mxGraph.view.invalidate(edge, true, false);
            this.mxGraph.view.validate(edge);
          }
        });
        mxGraphFactory.mxEvent.addListener(columnsDiv, "scroll", () => {
          state.cell.value.scrollTop = columnsDiv.scrollTop;
          updateEdges();
        });
        mxGraphFactory.mxEvent.addListener(columnsDiv, "mouseup", updateEdges);
      }
    }
    const editButton = parentNode.getElementsByClassName("sd-table-edit-button")[0];
    if (editButton !== void 0 && editButton !== null) {
      if (editButton.getAttribute("clickHandler") !== null) {
        return;
      }
      editButton.setAttribute("clickHandler", "true");
      this.addEventListeners(editButton, "click", async () => {
        this.editTable(state);
      });
    }
  }
  /**
   * Edits the table
   * @param state state of the entity
   */
  async editTable(state) {
    this.schemaDesigner.activeCellState = state;
    this.editor = true;
    const mxCellTableValue = state.cell.value;
    const table = {
      id: mxCellTableValue.id,
      name: mxCellTableValue.name,
      schema: mxCellTableValue.schema,
      columns: JSON.parse(JSON.stringify(mxCellTableValue.columns)),
      // clone the columns
      foreignKeys: JSON.parse(JSON.stringify(mxCellTableValue.schemaDesigner.getForeignKeysForTable(state.cell)))
    };
    await this.schemaDesigner.config.editTable(table, state.cell, state.x, state.y, this.mxGraph.view.scale, this.schemaDesigner.schema);
  }
  /**
   * Adds event listeners to the entity
   */
  addEventListeners(div, type, callback) {
    this.eventListeners.push({
      target: div,
      eventName: type,
      callback
    });
    div.addEventListener(type, callback);
  }
  /**
   * Removes event listeners from the entity
   */
  removeEventListeners() {
    this.eventListeners.forEach((listener) => {
      listener.target.removeEventListener(listener.eventName, listener.callback);
    });
  }
  /**
   * Gets the mxGraph model
   */
  get mxModel() {
    return this.schemaDesigner.mxGraph.getModel();
  }
  /**
   * Gets the mxGraph instance
   */
  get mxGraph() {
    return this.schemaDesigner.mxGraph;
  }
  /**
   * Gets the schema designer configuration
   */
  get schemaDesignerConfig() {
    return this.schemaDesigner.config;
  }
  /**
   * Renders the table div
   * @returns the table div
   */
  renderTableDiv() {
    const FONT_SIZE = "13px";
    const LINE_HEIGHT = "18px";
    const FONT_WEIGHT = "400";
    if (this.parentDiv) {
      this.removeEventListeners();
      this.parentDiv.remove();
    }
    const parent = document.createElement("div");
    this.parentDiv = parent;
    parent.classList.add("sd-table");
    parent.style.width = "250px";
    parent.style.height = "100%";
    parent.style.borderRadius = "2px";
    parent.style.color = "var(--sd-cell-html-foreground)";
    parent.style.boxShadow = "0px 3px 8px rgba(0, 0, 0, 0.35), 0px 1px 3px rgba(0, 0, 0, 0.5), inset 0px 0.5px 0px rgba(255, 255, 255, 0.08), inset 0px 0px 0.5px rgba(255, 255, 255, 0.3)";
    parent.style.border = "1px solid var(--sd-cell-divider-color)";
    parent.style.display = "flex";
    parent.style.flexDirection = "column";
    parent.style.opacity = this.opacity.toString();
    parent.style.backgroundColor = "var(--sd-graph-background-color)";
    const header = document.createElement("div");
    header.classList.add("sd-table-header");
    header.style.display = "flex";
    header.style.gap = "10px";
    header.style.height = "44px";
    header.style.borderBottom = "1px solid var(--sd-cell-divider-color)";
    const headerIcon = document.createElement("div");
    headerIcon.innerHTML = this.schemaDesignerConfig.icons.entityIcon;
    headerIcon.classList.add("sd-table-header-icon");
    headerIcon.style.width = "24px";
    headerIcon.style.height = "100%";
    headerIcon.style.backgroundSize = "16px 16px";
    headerIcon.style.backgroundRepeat = "no-repeat";
    headerIcon.style.backgroundPosition = "center";
    headerIcon.style.marginLeft = "10px";
    headerIcon.style.display = "flex";
    headerIcon.style.justifyContent = "center";
    headerIcon.style.alignItems = "center";
    headerIcon.style.color = "var(--sd-cell-html-foreground)";
    headerIcon.innerHTML = this.schemaDesignerConfig.icons.entityIcon;
    header.appendChild(headerIcon);
    const headerText = document.createElement("div");
    headerText.classList.add("sd-table-header-text");
    headerText.style.fontSize = "14px";
    headerText.style.fontWeight = "500";
    headerText.style.alignSelf = "center";
    headerText.style.textAlign = "left";
    headerText.style.flex = "1";
    headerText.style.userSelect = "none";
    headerText.style.textOverflow = "ellipsis";
    headerText.style.overflow = "hidden";
    const tableTitle = `${this.schema}.${this.name}`;
    headerText.innerText = tableTitle;
    headerText.title = tableTitle;
    header.appendChild(headerText);
    if (this.schemaDesignerConfig.isEditable) {
      const button = document.createElement("button");
      button.type = "button";
      button.classList.add("sd-table-button", "sd-table-edit-button");
      button.title = "Edit";
      button.innerHTML = this.schemaDesignerConfig.icons.editIcon;
      header.appendChild(button);
    }
    parent.appendChild(header);
    const columns = document.createElement("div");
    columns.classList.add("sd-table-columns");
    columns.style.display = "flex";
    columns.style.flexDirection = "column";
    columns.style.maxHeight = "280px";
    columns.style.overflowY = "auto";
    columns.style.marginTop = "5px";
    columns.style.padding = "0";
    columns.style.boxSizing = "border-box";
    this.columns.forEach((column, index) => {
      const columnDiv = document.createElement("div");
      columnDiv.classList.add("sd-table-column");
      columnDiv.style.display = "flex";
      columnDiv.style.gap = "10px";
      columnDiv.style.height = "28px";
      columnDiv.style.minHeight = "28px";
      columnDiv.style.boxSizing = "border-box";
      columnDiv.addEventListener("mouseenter", () => {
        columnDiv.style.backgroundColor = "var(--sd-cell-html-hover-column-background);";
      });
      columnDiv.addEventListener("mouseleave", () => {
        columnDiv.style.backgroundColor = "transparent";
      });
      const keyIcon = document.createElement("div");
      keyIcon.classList.add("sd-table-column-icon");
      keyIcon.style.width = "18px";
      keyIcon.style.height = "18px";
      keyIcon.style.height = "100%";
      keyIcon.style.backgroundSize = "16px 16px";
      keyIcon.style.backgroundRepeat = "no-repeat";
      keyIcon.style.backgroundPosition = "center";
      keyIcon.style.marginLeft = "10px";
      keyIcon.style.display = "flex";
      keyIcon.style.justifyContent = "center";
      keyIcon.style.alignItems = "center";
      if (column.isPrimaryKey) {
        keyIcon.innerHTML = this.schemaDesignerConfig.icons.primaryKeyIcon;
        keyIcon.title = "Primary key";
      }
      if (this.hasForeignKey(index)) {
        keyIcon.innerHTML = this.schemaDesignerConfig.icons.foreignKeyIcon;
        keyIcon.title = "Foreign key";
      }
      columnDiv.appendChild(keyIcon);
      const columnNameDiv = document.createElement("div");
      columnNameDiv.classList.add("sd-table-column-text");
      columnNameDiv.style.fontSize = FONT_SIZE;
      columnNameDiv.style.lineHeight = LINE_HEIGHT;
      columnNameDiv.style.fontWeight = FONT_WEIGHT;
      columnNameDiv.style.alignSelf = "center";
      columnNameDiv.style.textAlign = "left";
      columnNameDiv.style.userSelect = "none";
      columnNameDiv.style.flex = "1";
      columnNameDiv.style.overflow = "hidden";
      columnNameDiv.style.textOverflow = "ellipsis";
      columnNameDiv.title = column.name;
      columnNameDiv.innerText = column.name;
      columnNameDiv.title = this.getColumnTooltip(index);
      columnDiv.appendChild(columnNameDiv);
      const columnDataTypeDiv = document.createElement("div");
      columnDataTypeDiv.classList.add("sd-table-column-datatype-text");
      columnDataTypeDiv.style.fontSize = FONT_SIZE;
      columnDataTypeDiv.style.lineHeight = LINE_HEIGHT;
      columnDataTypeDiv.style.fontWeight = FONT_WEIGHT;
      columnDataTypeDiv.style.alignSelf = "center";
      columnDataTypeDiv.style.textAlign = "left";
      columnDataTypeDiv.style.marginRight = "10px";
      columnDataTypeDiv.style.userSelect = "none";
      columnDataTypeDiv.innerText = column.dataType;
      columnDiv.appendChild(columnDataTypeDiv);
      columnDiv.setAttribute("column-id", index.toString());
      columns.appendChild(columnDiv);
    });
    parent.appendChild(columns);
    return parent;
  }
  /**
   * Checks if the columns has a foreign key dependency
   * @param index index of the column
   * @returns true if the column has a foreign key dependency
   */
  hasForeignKey(index) {
    const cells = this.mxGraph.getChildCells(this.mxGraph.getDefaultParent());
    const vertex = cells.find((cell2) => cell2.vertex && cell2.value.name === this.name && cell2.value.schema === this.schema);
    if (vertex) {
      const edges = this.mxGraph.getEdges(vertex);
      const outgoingEdges = edges.filter((edge) => edge.source === vertex);
      for (const edge of outgoingEdges) {
        if (edge.value.sourceRow - 1 === index) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Gets the column title for the tooltip
   * @param index index of the column
   * @returns column title
   */
  getColumnTooltip(index) {
    const column = this.columns[index];
    let columnTitle = `${column.name}`;
    if (column.isPrimaryKey) {
      columnTitle += ` Primary key`;
    }
    const cells = this.mxGraph.getChildCells(this.mxGraph.getDefaultParent());
    const vertex = cells.find((cell2) => cell2.vertex && cell2.value.name === this.name && cell2.value.schema === this.schema);
    if (vertex) {
      const edges = this.mxGraph.getEdges(vertex);
      const outgoingEdges = edges.filter((edge) => edge.source === vertex);
      for (const edge of outgoingEdges) {
        if (edge.value.sourceRow - 1 === index) {
          return columnTitle + ` Foreign key`;
        }
      }
    }
    return columnTitle;
  }
  get width() {
    return 250;
  }
  get height() {
    return Math.min(330, 52 + this.columns.length * 28);
  }
};

// src/ts/schemaDesigner/schemaDesignerLayout.ts
var import_dagre = __toESM(require_dagre());
var SchemaDesignerLayout = class extends mxGraphFactory.mxGraphLayout {
  constructor(graph) {
    super(graph);
    this.isEdgeIgnored = (_edge) => {
      console.log("edge ignored", _edge.value);
      return true;
    };
  }
  execute(parent) {
    const selectedCell = this.graph.getSelectionCell();
    this.graph.getModel().beginUpdate();
    const g = new import_dagre.default.graphlib.Graph({
      directed: true,
      multigraph: true
    }).setDefaultEdgeLabel(() => ({}));
    g.setGraph({
      rankdir: "LR",
      align: "UL",
      marginx: 50,
      marginy: 50,
      nodesep: 50,
      ranksep: 50
    });
    const dagCells = this.graph.getModel().getChildCells(parent);
    for (let i = 0; i < dagCells.length; i++) {
      const currentCell = dagCells[i];
      if (!currentCell.edge) {
        const value = currentCell.value;
        if (!value.isVisible) {
          continue;
        }
        g.setNode(
          currentCell.id,
          {
            label: currentCell.id,
            width: value.width + 20,
            height: value.height
          }
        );
      }
    }
    for (let i = 0; i < dagCells.length; i++) {
      const currentCell = dagCells[i];
      if (currentCell.edge) {
        g.setEdge(currentCell.source.id, currentCell.target.id, {}, currentCell.id);
      }
    }
    import_dagre.default.layout(g);
    for (let i = 0; i < dagCells.length; i++) {
      const currentCell = dagCells[i];
      if (!currentCell.edge) {
        if (!currentCell.value.isVisible) {
          continue;
        }
        const computedNode = g.node(currentCell.id);
        currentCell.geometry.x = computedNode.x - (currentCell.value.width + 20) / 2;
        currentCell.geometry.y = computedNode.y - currentCell.value.height / 2;
      }
    }
    this.graph.refresh();
    if (selectedCell) {
      this.graph.setSelectionCell(selectedCell);
      this.graph.scrollCellToVisible(selectedCell);
    }
    this.graph.getModel().endUpdate();
  }
};

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/html-to-image/es/util.js
function resolveUrl(url, baseUrl) {
  if (url.match(/^[a-z]+:\/\//i)) {
    return url;
  }
  if (url.match(/^\/\//)) {
    return window.location.protocol + url;
  }
  if (url.match(/^[a-z]+:/i)) {
    return url;
  }
  const doc = document.implementation.createHTMLDocument();
  const base = doc.createElement("base");
  const a = doc.createElement("a");
  doc.head.appendChild(base);
  doc.body.appendChild(a);
  if (baseUrl) {
    base.href = baseUrl;
  }
  a.href = url;
  return a.href;
}
var uuid = /* @__PURE__ */ (() => {
  let counter = 0;
  const random = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => {
    counter += 1;
    return `u${random()}${counter}`;
  };
})();
function toArray(arrayLike) {
  const arr = [];
  for (let i = 0, l = arrayLike.length; i < l; i++) {
    arr.push(arrayLike[i]);
  }
  return arr;
}
var styleProps = null;
function getStyleProperties(options = {}) {
  if (styleProps) {
    return styleProps;
  }
  if (options.includeStyleProperties) {
    styleProps = options.includeStyleProperties;
    return styleProps;
  }
  styleProps = toArray(window.getComputedStyle(document.documentElement));
  return styleProps;
}
function px(node, styleProperty) {
  const win = node.ownerDocument.defaultView || window;
  const val = win.getComputedStyle(node).getPropertyValue(styleProperty);
  return val ? parseFloat(val.replace("px", "")) : 0;
}
function getNodeWidth(node) {
  const leftBorder = px(node, "border-left-width");
  const rightBorder = px(node, "border-right-width");
  return node.clientWidth + leftBorder + rightBorder;
}
function getNodeHeight(node) {
  const topBorder = px(node, "border-top-width");
  const bottomBorder = px(node, "border-bottom-width");
  return node.clientHeight + topBorder + bottomBorder;
}
function getImageSize(targetNode, options = {}) {
  const width = options.width || getNodeWidth(targetNode);
  const height = options.height || getNodeHeight(targetNode);
  return { width, height };
}
function getPixelRatio() {
  let ratio;
  let FINAL_PROCESS;
  try {
    FINAL_PROCESS = process;
  } catch (e) {
  }
  const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;
  if (val) {
    ratio = parseInt(val, 10);
    if (Number.isNaN(ratio)) {
      ratio = 1;
    }
  }
  return ratio || window.devicePixelRatio || 1;
}
var canvasDimensionLimit = 16384;
function checkCanvasDimensions(canvas) {
  if (canvas.width > canvasDimensionLimit || canvas.height > canvasDimensionLimit) {
    if (canvas.width > canvasDimensionLimit && canvas.height > canvasDimensionLimit) {
      if (canvas.width > canvas.height) {
        canvas.height *= canvasDimensionLimit / canvas.width;
        canvas.width = canvasDimensionLimit;
      } else {
        canvas.width *= canvasDimensionLimit / canvas.height;
        canvas.height = canvasDimensionLimit;
      }
    } else if (canvas.width > canvasDimensionLimit) {
      canvas.height *= canvasDimensionLimit / canvas.width;
      canvas.width = canvasDimensionLimit;
    } else {
      canvas.width *= canvasDimensionLimit / canvas.height;
      canvas.height = canvasDimensionLimit;
    }
  }
}
function createImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      img.decode().then(() => {
        requestAnimationFrame(() => resolve(img));
      });
    };
    img.onerror = reject;
    img.crossOrigin = "anonymous";
    img.decoding = "async";
    img.src = url;
  });
}
async function svgToDataURL(svg) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then((html) => `data:image/svg+xml;charset=utf-8,${html}`);
}
async function nodeToDataURL(node, width, height) {
  const xmlns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(xmlns, "svg");
  const foreignObject = document.createElementNS(xmlns, "foreignObject");
  svg.setAttribute("width", `${width}`);
  svg.setAttribute("height", `${height}`);
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  foreignObject.setAttribute("width", "100%");
  foreignObject.setAttribute("height", "100%");
  foreignObject.setAttribute("x", "0");
  foreignObject.setAttribute("y", "0");
  foreignObject.setAttribute("externalResourcesRequired", "true");
  svg.appendChild(foreignObject);
  foreignObject.appendChild(node);
  return svgToDataURL(svg);
}
var isInstanceOfElement = (node, instance) => {
  if (node instanceof instance)
    return true;
  const nodePrototype = Object.getPrototypeOf(node);
  if (nodePrototype === null)
    return false;
  return nodePrototype.constructor.name === instance.name || isInstanceOfElement(nodePrototype, instance);
};

// node_modules/html-to-image/es/clone-pseudos.js
function formatCSSText(style) {
  const content = style.getPropertyValue("content");
  return `${style.cssText} content: '${content.replace(/'|"/g, "")}';`;
}
function formatCSSProperties(style, options) {
  return getStyleProperties(options).map((name2) => {
    const value = style.getPropertyValue(name2);
    const priority = style.getPropertyPriority(name2);
    return `${name2}: ${value}${priority ? " !important" : ""};`;
  }).join(" ");
}
function getPseudoElementStyle(className, pseudo, style, options) {
  const selector = `.${className}:${pseudo}`;
  const cssText = style.cssText ? formatCSSText(style) : formatCSSProperties(style, options);
  return document.createTextNode(`${selector}{${cssText}}`);
}
function clonePseudoElement(nativeNode, clonedNode, pseudo, options) {
  const style = window.getComputedStyle(nativeNode, pseudo);
  const content = style.getPropertyValue("content");
  if (content === "" || content === "none") {
    return;
  }
  const className = uuid();
  try {
    clonedNode.className = `${clonedNode.className} ${className}`;
  } catch (err) {
    return;
  }
  const styleElement = document.createElement("style");
  styleElement.appendChild(getPseudoElementStyle(className, pseudo, style, options));
  clonedNode.appendChild(styleElement);
}
function clonePseudoElements(nativeNode, clonedNode, options) {
  clonePseudoElement(nativeNode, clonedNode, ":before", options);
  clonePseudoElement(nativeNode, clonedNode, ":after", options);
}

// node_modules/html-to-image/es/mimes.js
var WOFF = "application/font-woff";
var JPEG = "image/jpeg";
var mimes = {
  woff: WOFF,
  woff2: WOFF,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: JPEG,
  jpeg: JPEG,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function getExtension(url) {
  const match = /\.([^./]*?)$/g.exec(url);
  return match ? match[1] : "";
}
function getMimeType(url) {
  const extension = getExtension(url).toLowerCase();
  return mimes[extension] || "";
}

// node_modules/html-to-image/es/dataurl.js
function getContentFromDataUrl(dataURL) {
  return dataURL.split(/,/)[1];
}
function isDataUrl(url) {
  return url.search(/^(data:)/) !== -1;
}
function makeDataUrl(content, mimeType) {
  return `data:${mimeType};base64,${content}`;
}
async function fetchAsDataURL(url, init, process2) {
  const res = await fetch(url, init);
  if (res.status === 404) {
    throw new Error(`Resource "${res.url}" not found`);
  }
  const blob = await res.blob();
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onloadend = () => {
      try {
        resolve(process2({ res, result: reader.result }));
      } catch (error) {
        reject(error);
      }
    };
    reader.readAsDataURL(blob);
  });
}
var cache = {};
function getCacheKey(url, contentType, includeQueryParams) {
  let key = url.replace(/\?.*/, "");
  if (includeQueryParams) {
    key = url;
  }
  if (/ttf|otf|eot|woff2?/i.test(key)) {
    key = key.replace(/.*\//, "");
  }
  return contentType ? `[${contentType}]${key}` : key;
}
async function resourceToDataURL(resourceUrl, contentType, options) {
  const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);
  if (cache[cacheKey] != null) {
    return cache[cacheKey];
  }
  if (options.cacheBust) {
    resourceUrl += (/\?/.test(resourceUrl) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
  }
  let dataURL;
  try {
    const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result: result2 }) => {
      if (!contentType) {
        contentType = res.headers.get("Content-Type") || "";
      }
      return getContentFromDataUrl(result2);
    });
    dataURL = makeDataUrl(content, contentType);
  } catch (error) {
    dataURL = options.imagePlaceholder || "";
    let msg = `Failed to fetch resource: ${resourceUrl}`;
    if (error) {
      msg = typeof error === "string" ? error : error.message;
    }
    if (msg) {
      console.warn(msg);
    }
  }
  cache[cacheKey] = dataURL;
  return dataURL;
}

// node_modules/html-to-image/es/clone-node.js
async function cloneCanvasElement(canvas) {
  const dataURL = canvas.toDataURL();
  if (dataURL === "data:,") {
    return canvas.cloneNode(false);
  }
  return createImage(dataURL);
}
async function cloneVideoElement(video, options) {
  if (video.currentSrc) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = video.clientWidth;
    canvas.height = video.clientHeight;
    ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const dataURL2 = canvas.toDataURL();
    return createImage(dataURL2);
  }
  const poster = video.poster;
  const contentType = getMimeType(poster);
  const dataURL = await resourceToDataURL(poster, contentType, options);
  return createImage(dataURL);
}
async function cloneIFrameElement(iframe, options) {
  var _a;
  try {
    if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) {
      return await cloneNode(iframe.contentDocument.body, options, true);
    }
  } catch (_b) {
  }
  return iframe.cloneNode(false);
}
async function cloneSingleNode(node, options) {
  if (isInstanceOfElement(node, HTMLCanvasElement)) {
    return cloneCanvasElement(node);
  }
  if (isInstanceOfElement(node, HTMLVideoElement)) {
    return cloneVideoElement(node, options);
  }
  if (isInstanceOfElement(node, HTMLIFrameElement)) {
    return cloneIFrameElement(node, options);
  }
  return node.cloneNode(isSVGElement(node));
}
var isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === "SLOT";
var isSVGElement = (node) => node.tagName != null && node.tagName.toUpperCase() === "SVG";
async function cloneChildren(nativeNode, clonedNode, options) {
  var _a, _b;
  if (isSVGElement(clonedNode)) {
    return clonedNode;
  }
  let children = [];
  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {
    children = toArray(nativeNode.assignedNodes());
  } else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {
    children = toArray(nativeNode.contentDocument.body.childNodes);
  } else {
    children = toArray(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);
  }
  if (children.length === 0 || isInstanceOfElement(nativeNode, HTMLVideoElement)) {
    return clonedNode;
  }
  await children.reduce((deferred, child) => deferred.then(() => cloneNode(child, options)).then((clonedChild) => {
    if (clonedChild) {
      clonedNode.appendChild(clonedChild);
    }
  }), Promise.resolve());
  return clonedNode;
}
function cloneCSSStyle(nativeNode, clonedNode, options) {
  const targetStyle = clonedNode.style;
  if (!targetStyle) {
    return;
  }
  const sourceStyle = window.getComputedStyle(nativeNode);
  if (sourceStyle.cssText) {
    targetStyle.cssText = sourceStyle.cssText;
    targetStyle.transformOrigin = sourceStyle.transformOrigin;
  } else {
    getStyleProperties(options).forEach((name2) => {
      let value = sourceStyle.getPropertyValue(name2);
      if (name2 === "font-size" && value.endsWith("px")) {
        const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;
        value = `${reducedFont}px`;
      }
      if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && name2 === "display" && value === "inline") {
        value = "block";
      }
      if (name2 === "d" && clonedNode.getAttribute("d")) {
        value = `path(${clonedNode.getAttribute("d")})`;
      }
      targetStyle.setProperty(name2, value, sourceStyle.getPropertyPriority(name2));
    });
  }
}
function cloneInputValue(nativeNode, clonedNode) {
  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {
    clonedNode.innerHTML = nativeNode.value;
  }
  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {
    clonedNode.setAttribute("value", nativeNode.value);
  }
}
function cloneSelectValue(nativeNode, clonedNode) {
  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {
    const clonedSelect = clonedNode;
    const selectedOption = Array.from(clonedSelect.children).find((child) => nativeNode.value === child.getAttribute("value"));
    if (selectedOption) {
      selectedOption.setAttribute("selected", "");
    }
  }
}
function decorate(nativeNode, clonedNode, options) {
  if (isInstanceOfElement(clonedNode, Element)) {
    cloneCSSStyle(nativeNode, clonedNode, options);
    clonePseudoElements(nativeNode, clonedNode, options);
    cloneInputValue(nativeNode, clonedNode);
    cloneSelectValue(nativeNode, clonedNode);
  }
  return clonedNode;
}
async function ensureSVGSymbols(clone, options) {
  const uses = clone.querySelectorAll ? clone.querySelectorAll("use") : [];
  if (uses.length === 0) {
    return clone;
  }
  const processedDefs = {};
  for (let i = 0; i < uses.length; i++) {
    const use = uses[i];
    const id = use.getAttribute("xlink:href");
    if (id) {
      const exist = clone.querySelector(id);
      const definition = document.querySelector(id);
      if (!exist && definition && !processedDefs[id]) {
        processedDefs[id] = await cloneNode(definition, options, true);
      }
    }
  }
  const nodes = Object.values(processedDefs);
  if (nodes.length) {
    const ns = "http://www.w3.org/1999/xhtml";
    const svg = document.createElementNS(ns, "svg");
    svg.setAttribute("xmlns", ns);
    svg.style.position = "absolute";
    svg.style.width = "0";
    svg.style.height = "0";
    svg.style.overflow = "hidden";
    svg.style.display = "none";
    const defs = document.createElementNS(ns, "defs");
    svg.appendChild(defs);
    for (let i = 0; i < nodes.length; i++) {
      defs.appendChild(nodes[i]);
    }
    clone.appendChild(svg);
  }
  return clone;
}
async function cloneNode(node, options, isRoot) {
  if (!isRoot && options.filter && !options.filter(node)) {
    return null;
  }
  return Promise.resolve(node).then((clonedNode) => cloneSingleNode(clonedNode, options)).then((clonedNode) => cloneChildren(node, clonedNode, options)).then((clonedNode) => decorate(node, clonedNode, options)).then((clonedNode) => ensureSVGSymbols(clonedNode, options));
}

// node_modules/html-to-image/es/embed-resources.js
var URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
var URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g;
var FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function toRegex(url) {
  const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, "g");
}
function parseURLs(cssText) {
  const urls = [];
  cssText.replace(URL_REGEX, (raw, quotation, url) => {
    urls.push(url);
    return raw;
  });
  return urls.filter((url) => !isDataUrl(url));
}
async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {
  try {
    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;
    const contentType = getMimeType(resourceURL);
    let dataURL;
    if (getContentFromUrl) {
      const content = await getContentFromUrl(resolvedURL);
      dataURL = makeDataUrl(content, contentType);
    } else {
      dataURL = await resourceToDataURL(resolvedURL, contentType, options);
    }
    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);
  } catch (error) {
  }
  return cssText;
}
function filterPreferredFontFormat(str, { preferredFontFormat }) {
  return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, (match) => {
    while (true) {
      const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];
      if (!format) {
        return "";
      }
      if (format === preferredFontFormat) {
        return `src: ${src};`;
      }
    }
  });
}
function shouldEmbed(url) {
  return url.search(URL_REGEX) !== -1;
}
async function embedResources(cssText, baseUrl, options) {
  if (!shouldEmbed(cssText)) {
    return cssText;
  }
  const filteredCSSText = filterPreferredFontFormat(cssText, options);
  const urls = parseURLs(filteredCSSText);
  return urls.reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));
}

// node_modules/html-to-image/es/embed-images.js
async function embedProp(propName, node, options) {
  var _a;
  const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);
  if (propValue) {
    const cssString = await embedResources(propValue, null, options);
    node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));
    return true;
  }
  return false;
}
async function embedBackground(clonedNode, options) {
  ;
  await embedProp("background", clonedNode, options) || await embedProp("background-image", clonedNode, options);
  await embedProp("mask", clonedNode, options) || await embedProp("-webkit-mask", clonedNode, options) || await embedProp("mask-image", clonedNode, options) || await embedProp("-webkit-mask-image", clonedNode, options);
}
async function embedImageNode(clonedNode, options) {
  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);
  if (!(isImageElement && !isDataUrl(clonedNode.src)) && !(isInstanceOfElement(clonedNode, SVGImageElement) && !isDataUrl(clonedNode.href.baseVal))) {
    return;
  }
  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;
  const dataURL = await resourceToDataURL(url, getMimeType(url), options);
  await new Promise((resolve, reject) => {
    clonedNode.onload = resolve;
    clonedNode.onerror = options.onImageErrorHandler ? (...attributes) => {
      try {
        resolve(options.onImageErrorHandler(...attributes));
      } catch (error) {
        reject(error);
      }
    } : reject;
    const image = clonedNode;
    if (image.decode) {
      image.decode = resolve;
    }
    if (image.loading === "lazy") {
      image.loading = "eager";
    }
    if (isImageElement) {
      clonedNode.srcset = "";
      clonedNode.src = dataURL;
    } else {
      clonedNode.href.baseVal = dataURL;
    }
  });
}
async function embedChildren(clonedNode, options) {
  const children = toArray(clonedNode.childNodes);
  const deferreds = children.map((child) => embedImages(child, options));
  await Promise.all(deferreds).then(() => clonedNode);
}
async function embedImages(clonedNode, options) {
  if (isInstanceOfElement(clonedNode, Element)) {
    await embedBackground(clonedNode, options);
    await embedImageNode(clonedNode, options);
    await embedChildren(clonedNode, options);
  }
}

// node_modules/html-to-image/es/apply-style.js
function applyStyle(node, options) {
  const { style } = node;
  if (options.backgroundColor) {
    style.backgroundColor = options.backgroundColor;
  }
  if (options.width) {
    style.width = `${options.width}px`;
  }
  if (options.height) {
    style.height = `${options.height}px`;
  }
  const manual = options.style;
  if (manual != null) {
    Object.keys(manual).forEach((key) => {
      style[key] = manual[key];
    });
  }
  return node;
}

// node_modules/html-to-image/es/embed-webfonts.js
var cssFetchCache = {};
async function fetchCSS(url) {
  let cache2 = cssFetchCache[url];
  if (cache2 != null) {
    return cache2;
  }
  const res = await fetch(url);
  const cssText = await res.text();
  cache2 = { url, cssText };
  cssFetchCache[url] = cache2;
  return cache2;
}
async function embedFonts(data, options) {
  let cssText = data.cssText;
  const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
  const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
  const loadFonts = fontLocs.map(async (loc) => {
    let url = loc.replace(regexUrl, "$1");
    if (!url.startsWith("https://")) {
      url = new URL(url, data.url).href;
    }
    return fetchAsDataURL(url, options.fetchRequestInit, ({ result: result2 }) => {
      cssText = cssText.replace(loc, `url(${result2})`);
      return [loc, result2];
    });
  });
  return Promise.all(loadFonts).then(() => cssText);
}
function parseCSS(source) {
  if (source == null) {
    return [];
  }
  const result2 = [];
  const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
  let cssText = source.replace(commentsRegex, "");
  const keyframesRegex = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  while (true) {
    const matches = keyframesRegex.exec(cssText);
    if (matches === null) {
      break;
    }
    result2.push(matches[0]);
  }
  cssText = cssText.replace(keyframesRegex, "");
  const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
  const combinedCSSRegex = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})";
  const unifiedRegex = new RegExp(combinedCSSRegex, "gi");
  while (true) {
    let matches = importRegex.exec(cssText);
    if (matches === null) {
      matches = unifiedRegex.exec(cssText);
      if (matches === null) {
        break;
      } else {
        importRegex.lastIndex = unifiedRegex.lastIndex;
      }
    } else {
      unifiedRegex.lastIndex = importRegex.lastIndex;
    }
    result2.push(matches[0]);
  }
  return result2;
}
async function getCSSRules(styleSheets, options) {
  const ret = [];
  const deferreds = [];
  styleSheets.forEach((sheet) => {
    if ("cssRules" in sheet) {
      try {
        toArray(sheet.cssRules || []).forEach((item, index) => {
          if (item.type === CSSRule.IMPORT_RULE) {
            let importIndex = index + 1;
            const url = item.href;
            const deferred = fetchCSS(url).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
              try {
                sheet.insertRule(rule, rule.startsWith("@import") ? importIndex += 1 : sheet.cssRules.length);
              } catch (error) {
                console.error("Error inserting rule from remote css", {
                  rule,
                  error
                });
              }
            })).catch((e) => {
              console.error("Error loading remote css", e.toString());
            });
            deferreds.push(deferred);
          }
        });
      } catch (e) {
        const inline = styleSheets.find((a) => a.href == null) || document.styleSheets[0];
        if (sheet.href != null) {
          deferreds.push(fetchCSS(sheet.href).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
            inline.insertRule(rule, inline.cssRules.length);
          })).catch((err) => {
            console.error("Error loading remote stylesheet", err);
          }));
        }
        console.error("Error inlining remote css file", e);
      }
    }
  });
  return Promise.all(deferreds).then(() => {
    styleSheets.forEach((sheet) => {
      if ("cssRules" in sheet) {
        try {
          toArray(sheet.cssRules || []).forEach((item) => {
            ret.push(item);
          });
        } catch (e) {
          console.error(`Error while reading CSS rules from ${sheet.href}`, e);
        }
      }
    });
    return ret;
  });
}
function getWebFontRules(cssRules) {
  return cssRules.filter((rule) => rule.type === CSSRule.FONT_FACE_RULE).filter((rule) => shouldEmbed(rule.style.getPropertyValue("src")));
}
async function parseWebFontRules(node, options) {
  if (node.ownerDocument == null) {
    throw new Error("Provided element is not within a Document");
  }
  const styleSheets = toArray(node.ownerDocument.styleSheets);
  const cssRules = await getCSSRules(styleSheets, options);
  return getWebFontRules(cssRules);
}
function normalizeFontFamily(font) {
  return font.trim().replace(/["']/g, "");
}
function getUsedFonts(node) {
  const fonts = /* @__PURE__ */ new Set();
  function traverse(node2) {
    const fontFamily = node2.style.fontFamily || getComputedStyle(node2).fontFamily;
    fontFamily.split(",").forEach((font) => {
      fonts.add(normalizeFontFamily(font));
    });
    Array.from(node2.children).forEach((child) => {
      if (child instanceof HTMLElement) {
        traverse(child);
      }
    });
  }
  traverse(node);
  return fonts;
}
async function getWebFontCSS(node, options) {
  const rules = await parseWebFontRules(node, options);
  const usedFonts = getUsedFonts(node);
  const cssTexts = await Promise.all(rules.filter((rule) => usedFonts.has(normalizeFontFamily(rule.style.fontFamily))).map((rule) => {
    const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;
    return embedResources(rule.cssText, baseUrl, options);
  }));
  return cssTexts.join("\n");
}
async function embedWebFonts(clonedNode, options) {
  const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : await getWebFontCSS(clonedNode, options);
  if (cssText) {
    const styleNode = document.createElement("style");
    const sytleContent = document.createTextNode(cssText);
    styleNode.appendChild(sytleContent);
    if (clonedNode.firstChild) {
      clonedNode.insertBefore(styleNode, clonedNode.firstChild);
    } else {
      clonedNode.appendChild(styleNode);
    }
  }
}

// node_modules/html-to-image/es/index.js
async function toSvg(node, options = {}) {
  const { width, height } = getImageSize(node, options);
  const clonedNode = await cloneNode(node, options, true);
  await embedWebFonts(clonedNode, options);
  await embedImages(clonedNode, options);
  applyStyle(clonedNode, options);
  const datauri = await nodeToDataURL(clonedNode, width, height);
  return datauri;
}
async function toCanvas(node, options = {}) {
  const { width, height } = getImageSize(node, options);
  const svg = await toSvg(node, options);
  const img = await createImage(svg);
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  const ratio = options.pixelRatio || getPixelRatio();
  const canvasWidth = options.canvasWidth || width;
  const canvasHeight = options.canvasHeight || height;
  canvas.width = canvasWidth * ratio;
  canvas.height = canvasHeight * ratio;
  if (!options.skipAutoScale) {
    checkCanvasDimensions(canvas);
  }
  canvas.style.width = `${canvasWidth}`;
  canvas.style.height = `${canvasHeight}`;
  if (options.backgroundColor) {
    context.fillStyle = options.backgroundColor;
    context.fillRect(0, 0, canvas.width, canvas.height);
  }
  context.drawImage(img, 0, 0, canvas.width, canvas.height);
  return canvas;
}
async function toPng(node, options = {}) {
  const canvas = await toCanvas(node, options);
  return canvas.toDataURL();
}
async function toJpeg(node, options = {}) {
  const canvas = await toCanvas(node, options);
  return canvas.toDataURL("image/jpeg", options.quality || 1);
}

// src/ts/schemaDesigner/schemaDesigner.ts
var SchemaDesigner = class {
  constructor(container, config) {
    this.container = container;
    this.config = config;
    /**
     * Array of registered listeners for cell clicks
     */
    this.cellClickListeners = [];
    this.filteredCellIds = [];
    this.initializeGraph();
  }
  /**
   * Sets up the mxGraph instance for the schema designer
   */
  initializeGraph() {
    this.overwriteMxGraphDefaults();
    this.configureEdgeTerminals();
    this.mxEditor = new mxGraphFactory.mxEditor();
    this.mxEditor.setGraphContainer(this.container);
    this.mxGraph = this.mxEditor.graph;
    this.mxModel = this.mxGraph.getModel();
    this.configureMxEditor();
    this.configureMxGraph();
    this.applyColors(this.config.colors);
    this.configureMxOutline();
    this.initializeToolbar();
  }
  /**
   * Applies the colors from the config to the schema designer
   */
  applyColors(colors) {
    const body = document.getElementsByTagName("body")[0];
    body.style.setProperty("--sd-toolbar-background-color", colors.toolbarBackground);
    body.style.setProperty("--sd-toolbar-foreground-color", colors.toolbarForeground);
    body.style.setProperty("--sd-toolbar-hover-background-color", colors.toolbarHoverBackground);
    body.style.setProperty("--sd-toolbar-divider-background-color", colors.toolbarDividerBackground);
    body.style.setProperty("--sd-graph-background-color", colors.graphBackground);
    body.style.setProperty("--sd-graph-grid-color", colors.graphGrid);
    body.style.setProperty("--sd-border-color", colors.cellBorder);
    body.style.setProperty("--sd-cell-html-foreground", colors.cellForeground);
    body.style.setProperty("--sd-cell-html-hover-column-background", colors.cellColumnHover);
    body.style.setProperty("--sd-cell-divider-color", colors.cellDivider);
    body.style.setProperty("--sd-graph-background-color", colors.cellBackground);
    this.mxGraph.getStylesheet().getDefaultVertexStyle()[mxGraphFactory.mxConstants.STYLE_FILLCOLOR] = colors.cellBackground;
    this.mxGraph.getStylesheet().getDefaultVertexStyle()["cellHighlightColor"] = colors.cellHighlight;
    this.mxGraph.getStylesheet().getDefaultVertexStyle()["cellHighlightStrokeWidth"] = 3;
    this.mxGraph.getStylesheet().getDefaultEdgeStyle()["cellHighlightColor"] = colors.cellHighlight;
    this.mxGraph.getStylesheet().getDefaultEdgeStyle()["strokeColor"] = colors.edge;
    mxGraphFactory.mxConstants.OUTLINE_HANDLE_FILLCOLOR = colors.outlineHandleFill;
    mxGraphFactory.mxConstants.OUTLINE_HANDLE_STROKECOLOR = colors.outlineHandleFill;
    mxGraphFactory.mxConstants.OUTLINE_COLOR = colors.outline;
    this.mxGraph.graphHandler.previewColor = colors.graphHandlePreview;
    this.mxGraph.refresh();
    this.mxGraph.view.refresh();
  }
  /**
   * Overwrites the default mxGraph settings
   */
  overwriteMxGraphDefaults() {
    mxGraphFactory.mxClient.NO_FO = true;
    mxGraphFactory.mxEvent.disableContextMenu(this.container);
  }
  /**
   * Configures the edge terminals for the schema designer for different cardinalities
   */
  configureEdgeTerminals() {
    mxGraphFactory.mxMarker.addMarker("one", (canvas, _shape, _type, pe, unitX, unitY, size, _source, _sw, _filled) => {
      return () => {
        const endX = pe.x - unitX * size;
        const endY = pe.y - unitY * size;
        const midX = endX - unitY * size;
        const midY = endY + unitX * size;
        const startX = endX + unitY * size;
        const startY = endY - unitX * size;
        canvas.begin();
        canvas.moveTo(startX, startY);
        canvas.lineTo(midX, midY);
        canvas.stroke();
      };
    });
    mxGraphFactory.mxMarker.addMarker("many", (canvas, _shape, _type, pe, unitX, unitY, size, _source, _sw, _filled) => {
      return () => {
        const arrowSize = 1.5;
        const startX = pe.x - unitX * size * arrowSize;
        const startY = pe.y - unitY * size * arrowSize;
        const Y1 = pe.y + unitX * size * arrowSize;
        const X1 = pe.x;
        const Y2 = pe.y - unitX * size * arrowSize;
        const X2 = pe.x;
        canvas.begin();
        canvas.moveTo(startX, startY);
        canvas.lineTo(X1, Y1);
        canvas.stroke();
        canvas.begin();
        canvas.moveTo(startX, startY);
        canvas.lineTo(X2, Y2);
        canvas.stroke();
      };
    });
  }
  /**
   * Configures the mxEditor instance for the schema designer
   */
  configureMxEditor() {
    this.mxEditor.layoutSwimlanes = true;
  }
  /**
   * Configures the mxGraph instance for the schema designer
   */
  configureMxGraph() {
    this.mxGraph.tooltipHandler.setEnabled(false);
    this.mxGraph.setConnectable(this.config.isEditable);
    this.mxGraph.setAllowDanglingEdges(false);
    this.mxGraph.setHtmlLabels(true);
    this.mxGraph.connectionHandler.enabled = this.config.isEditable;
    this.mxGraph.connectionHandler.movePreviewAway = false;
    this.mxGraph.connectionHandler.moveIconFront = true;
    this.mxGraph.connectionHandler.connectImage = new mxGraphFactory.mxImage(
      this.config.icons.connectorIcon,
      24,
      24
    );
    this.mxGraph.connectionHandler.factoryMethod = null;
    this.mxLayout = new SchemaDesignerLayout(this.mxGraph);
    this.mxGraph.setCellsDisconnectable(false);
    this.mxGraph.autoSizeCellsOnAdd = true;
    this.mxGraph.getSelectionModel().setSingleSelection(true);
    this.mxGraph.setPanning(true);
    this.mxGraph.panningHandler.useLeftButtonForPanning = true;
    this.mxGraph.view.updateFloatingTerminalPoint = function(edge, start, end, source) {
      const next = this.getNextPoint(edge, end, source);
      const div = start.text.node.getElementsByClassName("sd-table-columns")[0];
      let x = start.x;
      let y = start.getCenterY();
      if (next.x > x + start.width / 2) {
        x += start.width;
      }
      if (div !== null) {
        y = start.getCenterY() - div.scrollTop;
        const edgeCellValue = edge.cell.value;
        if (edgeCellValue !== void 0) {
          const row = source ? edgeCellValue.sourceRow : edgeCellValue.targetRow;
          const columns = div.getElementsByClassName("sd-table-column");
          const column = columns[Math.min(columns.length - 1, row - 1)];
          if (column !== null) {
            y = getRowY(start, column);
          }
        }
        y = Math.min(start.y + start.height, Math.max(start.y, y));
        if (edge !== null && edge.absolutePoints !== null) {
          next.y = y;
        }
      }
      edge.setAbsoluteTerminalPoint(new mxGraphFactory.mxPoint(x, y), source);
    };
    this.mxGraph.getLabel = (cell2) => {
      if (cell2?.value?.render !== void 0) {
        return cell2.value.render();
      }
      return document.createElement("div");
    };
    this.mxGraph.isHtmlLabel = (cell2) => {
      return !this.mxModel.isEdge(cell2);
    };
    this.mxGraph.isCellEditable = (_cell) => {
      return false;
    };
    this.mxGraph.isCellMovable = (cell2) => {
      return this.config.isEditable && !this.mxModel.isEdge(cell2);
    };
    this.mxGraph.isCellResizable = (_cell) => {
      return false;
    };
    this.mxGraph.isCellFoldable = (_cell) => {
      return false;
    };
    const oldCellIsVisible = this.mxGraph.isCellVisible;
    this.mxGraph.isCellVisible = (cell2) => {
      const result2 = oldCellIsVisible.apply(this.mxGraph, [cell2]);
      if (cell2.vertex) {
        const cellValue = cell2.value;
        return result2 && cellValue.isVisible;
      } else if (cell2.edge) {
        const cellValue = cell2.value;
        return result2 && cellValue.isVisible;
      }
      return result2;
    };
    this.mxGraph.convertValueToString = function(cell2) {
      if (cell2?.value?.entity?.name !== void 0) {
        return cell2.value.entity.name;
      }
      return mxGraphFactory.mxGraph.prototype.convertValueToString.apply(this, [cell2]);
    };
    this.mxGraph.model.valueForCellChanged = function(cell2, value) {
      const old = {
        id: cell2.value.id,
        name: cell2.value.name,
        schema: cell2.value.schema,
        columns: cell2.value.columns
      };
      cell2.value.id = value.id;
      cell2.value.name = value.name;
      cell2.value.schema = value.schema;
      cell2.value.columns = value.columns;
      return old;
    };
    const oldRedrawLabel = this.mxGraph.cellRenderer.redrawLabel;
    this.mxGraph.cellRenderer.redrawLabel = function(state) {
      oldRedrawLabel.apply(this, arguments);
      const graph = state.view.graph;
      const model = graph.model;
      if (model.isVertex(state.cell) && state.text !== null) {
        const value = state.cell.value;
        if (value.setupEntityDOM !== void 0) {
          value.setupEntityDOM(state.text.node, state);
        }
      }
    };
    this.mxGraph.connectionHandler.updateRow = function(target) {
      if (target === null) {
        return target;
      }
      const column = target.closest(".sd-table-column");
      if (column !== null) {
        this.currentRow = parseInt(column.getAttribute("column-id")) + 1;
        return column;
      }
      return null;
    };
    this.mxGraph.connectionHandler.updateIcons = function(state, icons, me) {
      const targetNode = me.getSource();
      const columnDiv = this.updateRow(targetNode);
      if (columnDiv !== null && this.currentRow !== void 0) {
        const columnsDiv = columnDiv.parentElement;
        const s = state.view.scale;
        icons[0].node.style.userSelect = "none";
        icons[0].node.style.visibility = "visible";
        icons[0].bounds.width = s * 24;
        icons[0].bounds.height = s * 24;
        icons[0].bounds.x = state.x + columnDiv.offsetWidth * s;
        icons[0].bounds.y = state.y + columnDiv.offsetTop * s + -columnsDiv.scrollTop + columnDiv.offsetHeight * s / 2 - icons[0].bounds.height / 2;
        if (icons[0].node.getAttribute("cell-id") === state.cell.id && icons[0].node.getAttribute("row-id") === this.currentRow.toString()) {
          return;
        }
        icons[0].node.setAttribute("cell-id", state.cell.id);
        icons[0].node.setAttribute("row-id", this.currentRow.toString());
        icons[0].redraw();
        this.currentRowNode = columnDiv;
      } else {
        icons[0].node.style.visibility = "hidden";
      }
    };
    const oldMouseMove = this.mxGraph.connectionHandler.mouseMove;
    this.mxGraph.connectionHandler.mouseMove = function(_sender, me) {
      if (this.edgeState !== null) {
        this.currentRowNode = this.updateRow(me.getSource());
        const cellValue = this.edgeState.cell.value;
        const sourceTableValue = this.previous.cell.value;
        if (this.currentRow !== null && this.currentRow !== void 0) {
          const targetCellState = this.currentState;
          if (targetCellState?.cell?.value) {
            const targetCellValue = targetCellState.cell.value;
            if (cellValue) {
              const targetColumnName = targetCellValue.columns[this.currentRow - 1].name;
              cellValue.targetRow = this.currentRow;
              cellValue.referencedColumns = [targetColumnName];
              cellValue.referencedSchemaName = targetCellValue.schema;
              cellValue.referencedTableName = targetCellValue.name;
              cellValue.name = `FK_${sourceTableValue.name}_${cellValue.referencedTableName}`;
            }
          }
        } else {
          cellValue.targetRow = 0;
        }
      }
      oldMouseMove.apply(this, arguments);
    };
    this.mxGraph.connectionHandler.createEdgeState = function(_me) {
      const sourceCellState = this.currentState;
      const sourceCellValue = sourceCellState.cell.value;
      const targetColumnName = sourceCellValue.columns[this.currentRow ? this.currentRow - 1 : 0].name;
      const foreignKey = {
        sourceRow: this.currentRow || 0,
        targetRow: 0,
        id: v4_default(),
        name: "",
        columns: [targetColumnName],
        referencedSchemaName: "",
        referencedTableName: "",
        referencedColumns: [],
        onDeleteAction: "0" /* CASCADE */,
        onUpdateAction: "0" /* CASCADE */,
        isVisible: true
      };
      const edge = this.createEdge(foreignKey);
      const style = this.graph.getCellStyle(edge);
      const state = new mxGraphFactory.mxCellState(this.graph.view, edge, style);
      this.sourceRowNode = this.currentRowNode;
      return state;
    };
    this.mxGraph.connectionHandler.isValidTarget = function(_cell) {
      return this.currentRowNode !== null;
    };
    this.mxGraph.connectionHandler.validateConnection = function(source, target) {
      if (this.edgeState === null) {
        return null;
      }
      if (this.currentRowNode === null) {
        return "";
      }
      if (this.graph.model.isEdge(target)) {
        return "";
      }
      if (source === target) {
        return "";
      }
      const edgeState = this.edgeState;
      const edgeStateValue = edgeState.cell.value;
      const edgeBetweenSourceAndTarget = this.graph.model.getEdgesBetween(source, target);
      for (let i = 0; i < edgeBetweenSourceAndTarget.length; i++) {
        const edge = edgeBetweenSourceAndTarget[i];
        const edgeValue = edge.value;
        if (edgeValue.sourceRow === edgeStateValue.sourceRow && edgeValue.targetRow === edgeStateValue.targetRow && edge.source === source && edge.target === target) {
          return "";
        }
        if (
          // edgeValue.sourceRow === edgeStateValue.targetRow &&
          // edgeValue.targetRow === edgeStateValue.sourceRow &&
          edge.source === target && edge.target === source
        ) {
          return "";
        }
      }
      return null;
    };
    this.mxGraph.connectionHandler.getTargetPerimeterPoint = function(state, me) {
      let y = me.getY();
      if (this.currentRowNode !== null) {
        y = getRowY(state, this.currentRowNode);
      }
      let x = state.x;
      if (this.getEventSource().getCenterX() > state.getCenterX()) {
        x += state.width;
      }
      return new mxGraphFactory.mxPoint(x, y);
    };
    this.mxGraph.connectionHandler.getSourcePerimeterPoint = function(state, next, me) {
      let y = me.getY();
      if (this.sourceRowNode !== null) {
        y = getRowY(state, this.sourceRowNode);
      }
      let x = state.x;
      if (next.x > state.getCenterX()) {
        x += state.width;
      }
      return new mxGraphFactory.mxPoint(x, y);
    };
    this.mxGraph.connectionHandler.addListener(mxGraphFactory.mxEvent.CONNECT, (_sender, evt) => {
      const edge = evt.getProperty("cell");
      const source = this.mxGraph.getModel().getTerminal(edge, true);
      this.mxGraph.view.invalidate(source, false, false);
      this.mxGraph.view.validate(source);
    });
    this.mxGraph.addListener(mxGraphFactory.mxEvent.REMOVE_CELLS, (_sender, evt) => {
      const removedCell = evt.properties.cells[0];
      if (removedCell !== void 0 && removedCell.edge) {
        const source = this.mxGraph.getModel().getTerminal(removedCell, true);
        this.mxGraph.view.invalidate(source, false, false);
        this.mxGraph.view.validate(source);
      }
    });
    this.mxGraph.addListener(mxGraphFactory.mxEvent.DOUBLE_CLICK, (_sender, _evt) => {
      const cell2 = this.mxGraph.getSelectionCell();
      if (cell2 !== void 0) {
        this.cellClickListeners.forEach((listener) => listener(cell2));
      }
    });
    this.mxGraph.getStylesheet().getDefaultEdgeStyle()["edgeStyle"] = mxGraphFactory.mxEdgeStyle.EntityRelationPerpendicular;
  }
  /**
   * Configures the mxGraph outline for the schema designer
   */
  configureMxOutline() {
    this._outlineContainer = document.createElement("div");
    this._outlineContainer.classList.add("sd-outline");
    this.container.parentElement.appendChild(this._outlineContainer);
    this.mxOutline = new mxGraphFactory.mxOutline(this.mxGraph, this._outlineContainer);
  }
  /**
   * Initializes the toolbar for the schema designer
   */
  initializeToolbar() {
    const toolbarBelt = document.createElement("div");
    toolbarBelt.classList.add("sd-toolbar-belt");
    this.toolbar = new SchemaDesignerToolbar(toolbarBelt, this.mxGraph, this.config);
    if (this.config.isEditable) {
      this.toolbar.addButton(
        this.config.icons.addTableIcon,
        "Add Table",
        () => {
          this.addNewTable();
        },
        (_graph, evt, _cell) => {
          this.mxGraph.stopEditing(false);
          const pt = this.mxGraph.getPointForEvent(evt, true);
          const entity = this.createTable();
          const cell2 = this.renderTable(entity, pt.x, pt.y);
          const state = this.mxGraph.view.getState(cell2);
          if (state !== void 0) {
            cell2.value.editTable(state);
          }
        }
      );
      this.toolbar.addDivider();
      this.toolbar.addButton(
        this.config.icons.undoIcon,
        "Undo",
        () => {
          this.mxEditor.execute("undo");
        }
      );
      this.toolbar.addButton(
        this.config.icons.redoIcon,
        "Redo",
        () => {
          this.mxEditor.execute("redo");
        }
      );
      this.toolbar.addDivider();
    }
    this.toolbar.addButton(
      this.config.icons.zoomInIcon,
      "Zoom In",
      () => {
        this.zoomIn();
      }
    );
    this.toolbar.addButton(
      this.config.icons.zoomOutIcon,
      "Zoom Out",
      () => {
        this.zoomOut();
      }
    );
    this.toolbar.addButton(
      this.config.icons.zoomFitIcon,
      "Fit",
      () => {
        this.zoomToFit();
      }
    );
    this.toolbar.addDivider();
    this.toolbar.addButton(
      this.config.icons.autoArrangeCellsIcon,
      "Auto Arrange",
      () => {
        this.autoLayout();
      }
    );
    if (this.config.isEditable) {
      this.toolbar.addDivider();
      this.toolbar.addButton(
        this.config.icons.deleteIcon,
        "Delete",
        () => {
          const cell2 = this.mxGraph.getSelectionCell();
          if (cell2 !== void 0) {
            this.mxEditor.execute("delete", cell2);
          }
        }
      );
      this.toolbar.addDivider();
      this.toolbar.addButton(
        this.config.icons.exportIcon,
        "Export",
        () => {
          const schema = this.schema;
          this.config.publish(schema);
        }
      );
      this.toolbar.addButton(
        this.config.icons.editIcon,
        "filter",
        () => {
          const cells = this.mxModel.getChildCells(this.mxGraph.getDefaultParent());
          const filteredCells = cells.filter((cell2) => {
            if (cell2.vertex) {
              return Math.random() > 0.3;
            } else {
              return false;
            }
          }).map(
            (cell2) => {
              return cell2.value.id;
            }
          );
          this.filterCells(filteredCells);
        }
      );
    }
    if (this.config.showToolbar === false) {
      toolbarBelt.style.display = "none";
    } else {
      this.container.parentElement.appendChild(toolbarBelt);
    }
  }
  /**
   * Zoom in the schema designer
   */
  zoomIn() {
    this.mxEditor.execute("zoomIn");
    this.redrawEdges();
    this.updateEditorPosition();
  }
  /**
   * Zoom out the schema designer
   */
  zoomOut() {
    this.mxEditor.execute("zoomOut");
    this.redrawEdges();
    this.updateEditorPosition();
  }
  /**
   * Zoom to fit the schema designer
   */
  zoomToFit() {
    this.mxGraph.view.rendering = false;
    while (true) {
      this.mxGraph.fit(null);
      if (this.mxGraph.view.scale < 1) {
        break;
      }
    }
    this.mxGraph.view.rendering = true;
    this.autoLayout();
    this.updateEditorPosition();
  }
  /**
   * Adds a drag and drop listener for the table
   * @param element The element to make draggable
   */
  addTableDragAndDropListener(element) {
    this.makeElementDraggable(element, (_graph, evt, _cell) => {
      this.mxGraph.stopEditing(false);
      const pt = this.mxGraph.getPointForEvent(evt, true);
      const entity = this.createTable();
      const cell2 = this.renderTable(entity, pt.x, pt.y);
      const state = this.mxGraph.view.getState(cell2);
      if (state !== void 0) {
        cell2.value.editTable(state);
      }
    });
  }
  /**
   * Redraws the edges in the schema designer
   */
  redrawEdges() {
    const cells = this.mxModel.getChildCells(this.mxGraph.getDefaultParent());
    for (let i = 0; i < cells.length; i++) {
      if (!cells[i].edge) {
        continue;
      }
      const edge = cells[i];
      this.mxGraph.view.invalidate(edge, true, false);
      this.mxGraph.view.validate(edge);
    }
  }
  get activeCellState() {
    return this._activeCellState;
  }
  /**
   * Sets the current cell under edit
   */
  set activeCellState(value) {
    if (this._activeCellState !== void 0 && value.cell.id !== this._activeCellState.cell.id) {
      this._activeCellState.cell.value.editor = false;
    }
    this._activeCellState = value;
  }
  /**
   * Renders the schema in the schema designer
   * @param schema The schema to render
   * @param cleanUndoManager Whether to clean the undo manager so that the user can't undo the rendering
   */
  renderSchema(schema, cleanUndoManager = false) {
    const parent = this.mxGraph.getDefaultParent();
    this.mxModel.beginUpdate();
    try {
      this.mxGraph.removeCells(this.mxModel.getChildCells(parent));
      const tables = schema.tables;
      for (let i = 0; i < tables.length; i++) {
        const table = tables[i];
        this.renderTable(table, 100 + i * 50, 100 + i * 50);
      }
      for (let i = 0; i < tables.length; i++) {
        const table = tables[i];
        for (let j = 0; j < table.foreignKeys.length; j++) {
          const foreignKey = table.foreignKeys[j];
          this.renderForeignKey(foreignKey, table);
        }
      }
    } finally {
      this.mxModel.endUpdate();
      this.mxGraph.view.refresh();
      const parentCells = [];
      for (let i = 0; i < this.mxModel.cells.length; i++) {
        if (this.mxModel.cells[i].vertex) {
          if (this.mxModel.getIncomingEdges(this.mxModel.cells[i]).length === 0) {
            parentCells.push(this.mxModel.cells[i]);
          }
        }
      }
      const cells = this.mxModel.getChildCells(this.mxGraph.getDefaultParent());
      let max = 0;
      let cell2 = cells[0];
      for (let i = 0; i < cells.length; i++) {
        const edges = this.mxModel.getEdges(cells[i]);
        if (edges.length > max) {
          max = edges.length;
          cell2 = cells[i];
        }
      }
      this.mxGraph.setSelectionCell(cell2);
      this.autoLayout();
      if (cleanUndoManager) {
        this.mxEditor.undoManager.clear();
      }
    }
  }
  /**
   * Renders an entity in the schema designer
   * @param entity The entity to render
   * @param x the x position to render the entity at
   * @param y the y position to render the entity at
   * @returns The cell that was rendered
   */
  renderTable(entity, x, y) {
    const entityValue = new SchemaDesignerTable(entity, this);
    const entityCell = new mxGraphFactory.mxCell(
      entityValue,
      new mxGraphFactory.mxGeometry(
        0,
        0,
        entityValue.width,
        entityValue.height
      )
    );
    entityCell.setVertex(true);
    this.mxModel.beginUpdate();
    try {
      entityCell.geometry.x = x;
      entityCell.geometry.y = y;
      entityCell.geometry.alternateBounds = new mxGraphFactory.mxRectangle(0, 0, entityCell.geometry.width, entityCell.geometry.height);
      this.mxGraph.addCell(entityCell, this.mxGraph.getDefaultParent());
    } finally {
      this.mxModel.endUpdate();
    }
    this.mxGraph.setSelectionCell(entityCell);
    return entityCell;
  }
  /**
   * Renders a relationship in the schema designer
   * @param relationship The relationship to render
   * @returns The edge that was rendered
   */
  renderForeignKey(foreignKey, sourceTable) {
    const cells = this.mxModel.getChildCells(this.mxGraph.getDefaultParent());
    const source = cells.find((cell2) => {
      const value = cell2.value;
      return value.name === sourceTable.name && value.schema === sourceTable.schema;
    });
    const target = cells.find((cell2) => {
      const value = cell2.value;
      return value.name === foreignKey.referencedTableName && value.schema === foreignKey.referencedSchemaName;
    });
    if (source === void 0 || target === void 0) {
      return;
    }
    const sourceValue = source.value;
    const targetValue = target.value;
    for (let i = 0; i < foreignKey.columns.length; i++) {
      const sourceRowIndex = sourceValue.columns.findIndex((column) => column.name === foreignKey.columns[i]) + 1;
      const targetRowIndex = targetValue.columns.findIndex((column) => column.name === foreignKey.referencedColumns[i]) + 1;
      const edgeValue = {
        sourceRow: sourceRowIndex,
        targetRow: targetRowIndex,
        columns: [foreignKey.columns[i]],
        name: foreignKey.name,
        onDeleteAction: foreignKey.onDeleteAction,
        onUpdateAction: foreignKey.onUpdateAction,
        referencedTableName: targetValue.name,
        referencedColumns: [foreignKey.referencedColumns[i]],
        referencedSchemaName: targetValue.schema,
        id: foreignKey.id,
        isVisible: true
      };
      this.mxGraph.insertEdge(this.mxGraph.getDefaultParent(), null, edgeValue, source, target);
    }
    this.mxGraph.view.invalidate(source, false, false);
    this.mxGraph.view.validate(source);
    this.mxGraph.view.invalidate(target, false, false);
    this.mxGraph.view.validate(target);
  }
  /**
   * Gets the current schema from the schema designer
   */
  get schema() {
    const schema = {
      tables: []
    };
    const cells = this.mxModel.getChildCells(this.mxGraph.getDefaultParent());
    for (let i = 0; i < cells.length; i++) {
      const cell2 = cells[i];
      if (cell2.vertex) {
        const table = {
          columns: cell2.value.columns,
          name: cell2.value.name,
          schema: cell2.value.schema,
          foreignKeys: [],
          id: cell2.value.id
        };
        schema.tables.push(table);
        table.foreignKeys = this.getForeignKeysForTable(cell2);
      }
    }
    return schema;
  }
  /**
   * Automatically arranges the cells in the schema designer
   */
  autoLayout() {
    this.mxModel.beginUpdate();
    this.mxLayout.execute(this.mxGraph.getDefaultParent());
    this.mxModel.endUpdate();
  }
  /**
   * Registers a listener for cell clicks
   * @param listener The listener to register
   */
  addCellClickListener(listener) {
    this.cellClickListeners.push(listener);
  }
  /**
   * Scrolls to a cell in the schema designer
   * @param cell The cell to scroll to
   */
  scrollToCell(cell2) {
    this.mxGraph.scrollCellToVisible(cell2, true);
  }
  /**
   * Updates the position of the editor in the schema designer. This is called
   * when the graph scales or when the graph is moved
   */
  updateEditorPosition() {
    if (this.activeCellState !== void 0) {
      this.config.updateEditorPosition(this._activeCellState.x, this._activeCellState.y, this.mxGraph.view.scale);
    }
  }
  /**
   * Gets the relationships of an entity
   * @param entityCellState The cell state of the entity
   * @returns The relationships of the entity
   */
  getTableRelationships(entityCellState) {
    const outgoing = [];
    const incoming = [];
    const cells = this.mxModel.getChildCells(this.mxGraph.getDefaultParent());
    for (let i = 0; i < cells.length; i++) {
      const cell2 = cells[i];
      if (cell2.edge) {
        if (cell2.source.id === entityCellState.cell.id) {
          outgoing.push(cell2);
        } else if (cell2.target.id === entityCellState.cell.id) {
          incoming.push(cell2);
        }
      }
    }
    return {
      outgoing,
      incoming
    };
  }
  addNewTable() {
    this.mxModel.beginUpdate();
    this.mxGraph.stopEditing(false);
    const entity = this.createTable();
    const cell2 = this.renderTable(entity, 100, 100);
    this.autoLayout();
    this.mxGraph.setSelectionCell(cell2);
    this.mxGraph.scrollCellToVisible(cell2, true);
    const state = this.mxGraph.view.getState(cell2);
    if (state !== void 0) {
      cell2.value.editTable(state);
    }
    this.mxModel.endUpdate();
  }
  /**
   * Creates a new entity
   * @returns The new entity
   */
  createTable() {
    let index = 1;
    let name2 = `Table${index}`;
    for (this.schema.tables.length; this.schema.tables.find((tables) => tables.name === name2); index++) {
      name2 = `Table${index}`;
    }
    const schemas = new Set(this.schema.tables.map((tables) => tables.schema));
    return {
      id: v4_default(),
      name: name2,
      schema: schemas.size > 0 ? Array.from(schemas)[0] : "dbo",
      columns: [
        {
          id: v4_default(),
          name: "column_1",
          dataType: "int",
          isPrimaryKey: true,
          isIdentity: true,
          isNullable: false,
          isUnique: false
        }
      ],
      foreignKeys: []
    };
  }
  /**
   * Updates the active cell state entity
   * @param editedTable describes the new entity
   * @param editedOutgoingEdges describes the new relationships
   * @returns void
   */
  updateActiveCellStateTable(editedTable) {
    this.mxGraph.model.beginUpdate();
    const state = this._activeCellState;
    if (state === void 0) {
      return;
    }
    const oldTable = state.cell.value;
    const incomingEdges = this.mxModel.getIncomingEdges(state.cell);
    const incomingEdgesIds = incomingEdges.map((edge) => {
      const edgeValue = edge.value;
      return oldTable.columns[edgeValue.targetRow - 1].id;
    });
    this.mxGraph.labelChanged(state.cell, {
      id: editedTable.id,
      name: editedTable.name,
      schema: editedTable.schema,
      columns: editedTable.columns
    });
    state.cell.value.editor = false;
    this.mxGraph.resizeCell(state.cell, new mxGraphFactory.mxRectangle(state.x, state.y, oldTable.width, oldTable.height), true);
    this.mxGraph.refresh(state.cell);
    const edges = this.mxGraph.getEdges(state.cell);
    edges.forEach((e) => {
      this.mxGraph.getModel().remove(e);
    });
    incomingEdges.forEach((edge, index) => {
      const incomingEdgeId = incomingEdgesIds[index];
      const edgeValue = edge.value;
      edgeValue.referencedTableName = editedTable.name;
      edgeValue.referencedSchemaName = editedTable.schema;
      const column = editedTable.columns.find((column2) => column2.id === incomingEdgeId);
      if (column !== void 0) {
        edgeValue.referencedColumns = [column.name];
        this.renderForeignKey(edgeValue, edge.source.value);
      }
    });
    editedTable.foreignKeys.forEach((foreignKey) => {
      this.renderForeignKey(foreignKey, editedTable);
    });
    this.mxGraph.scrollCellToVisible(state.cell, true);
    this.mxGraph.model.endUpdate();
  }
  // Gets the foreign keys for a table
  getForeignKeysForTable(tableCell) {
    const outgoingEdges = this.mxModel.getOutgoingEdges(tableCell);
    const foreignKeyMap = outgoingEdges.reduce((map, edge) => {
      const edgeValue = edge.value;
      if (map.has(edgeValue.id)) {
        const existingForeignKey = map.get(edgeValue.id);
        existingForeignKey.columns.push(...edgeValue.columns.slice());
        existingForeignKey.referencedColumns.push(...edgeValue.referencedColumns.slice());
      } else {
        map.set(edgeValue.id, {
          id: edgeValue.id,
          name: edgeValue.name,
          columns: edgeValue.columns.slice(),
          referencedSchemaName: edgeValue.referencedSchemaName,
          referencedTableName: edgeValue.referencedTableName,
          referencedColumns: edgeValue.referencedColumns.slice(),
          onDeleteAction: edgeValue.onDeleteAction,
          onUpdateAction: edgeValue.onUpdateAction
        });
      }
      return map;
    }, /* @__PURE__ */ new Map());
    return Array.from(foreignKeyMap.values());
  }
  makeElementDraggable(element, onDragEndCallback) {
    if (onDragEndCallback) {
      const dragImage = element.cloneNode(true);
      dragImage.style.backgroundColor = this.config.colors.toolbarBackground;
      const ds = mxGraphFactory.mxUtils.makeDraggable(
        element,
        this.mxGraph,
        onDragEndCallback,
        dragImage
      );
      ds.highlightDropTargets = true;
    }
  }
  async exportImage(format) {
    const selectedCells = this.mxGraph.getSelectionCells();
    this.mxGraph.setSelectionCells([]);
    const width = this.mxGraph.getGraphBounds().width + 300;
    const height = this.mxGraph.getGraphBounds().height + 300;
    this._outlineContainer.style.visibility = "hidden";
    const fileContentPromise = new Promise((resolve) => {
      switch (format) {
        case "png":
          toPng(this.container, {
            width,
            height
          }).then((dataUrl) => {
            resolve(dataUrl);
          });
          break;
        case "jpeg":
          toJpeg(this.container, {
            width,
            height
          }).then((dataUrl) => {
            resolve(dataUrl);
          });
          break;
        case "svg":
          toSvg(this.container, {
            width,
            height
          }).then((dataUrl) => {
            resolve(dataUrl);
          });
          break;
        default:
          throw new Error("Invalid format");
      }
    });
    const fileContent = await fileContentPromise;
    this.mxGraph.setSelectionCells(selectedCells);
    this._outlineContainer.style.visibility = "visible";
    return {
      fileContent,
      format,
      width,
      height
    };
  }
  filterCells(tableIds) {
    const cells = this.mxModel.getChildCells(this.mxGraph.getDefaultParent());
    if (tableIds === void 0 || tableIds.length === 0) {
      for (let i = 0; i < cells.length; i++) {
        const cell2 = cells[i];
        cell2.value.isVisible = true;
        cell2.value.opacity = 1;
      }
      return;
    }
    const visibleCells = [];
    let partiallyVisibleCells = [];
    const visibleEdges = [];
    let hiddenCells = [];
    for (let i = 0; i < cells.length; i++) {
      const cell2 = cells[i];
      if (cell2.vertex) {
        const tableValue = cell2.value;
        if (tableIds.includes(tableValue.id)) {
          visibleCells.push(cell2);
        } else {
          hiddenCells.push(cell2);
        }
      }
      if (cell2.edge) {
        if (cell2.source && cell2.target) {
          const sourceTableValue = cell2.source.value;
          const targetTableValue = cell2.target.value;
          if (tableIds.includes(sourceTableValue.id)) {
            visibleEdges.push(cell2);
            partiallyVisibleCells.push(cell2.target);
          }
          if (tableIds.includes(targetTableValue.id)) {
            visibleEdges.push(cell2);
            partiallyVisibleCells.push(cell2.source);
          }
        }
      }
    }
    hiddenCells = hiddenCells.filter((cell2) => {
      return !visibleCells.includes(cell2) && !partiallyVisibleCells.includes(cell2);
    });
    partiallyVisibleCells = partiallyVisibleCells.filter((cell2) => {
      return !visibleCells.includes(cell2);
    });
    for (let i = 0; i < visibleCells.length; i++) {
      const cell2 = visibleCells[i];
      cell2.value.isVisible = true;
      cell2.value.opacity = 1;
    }
    for (let i = 0; i < partiallyVisibleCells.length; i++) {
      const cell2 = partiallyVisibleCells[i];
      cell2.value.isVisible = true;
      cell2.value.opacity = 0.5;
    }
    for (let i = 0; i < hiddenCells.length; i++) {
      const cell2 = hiddenCells[i];
      cell2.value.isVisible = false;
    }
    for (let i = 0; i < visibleEdges.length; i++) {
      const cell2 = visibleEdges[i];
      cell2.value.isVisible = true;
    }
    this.autoLayout();
    this.mxGraph.refresh();
  }
};
var export_mx = import_mxgraph2.default;
export {
  OnAction,
  SchemaDesigner,
  SchemaDesignerTable,
  SchemaDesignerToolbar,
  extendedConnectionHandler,
  export_mx as mx,
  mxGraphFactory
};
//# sourceMappingURL=index.js.map
